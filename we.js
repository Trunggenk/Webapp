// --------------------------------------
//
//    _  _ _/ .  _  _/ /_ _  _  _
//   /_|/_ / /|//_  / / //_ /_// /_/
//   https://activetheory.net    _/
//
// --------------------------------------
//   12/19/23 9:16a
// --------------------------------------

"undefined" == typeof console && (window.console = {},
        console.log = console.error = console.info = console.debug = console.warn = console.trace = function() {}
),
    window.performance = window.performance && window.performance.now ? window.performance : Date,
    Date.now = Date.now || function() {
        return +new Date
    }
    ,
window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function() {
    const start = Date.now();
    return function(callback) {
        window.setTimeout((()=>callback(Date.now() - start)), 1e3 / 60)
    }
}()),
    window.defer = window.requestAnimationFrame,
    window.clearTimeout = function() {
        const _clearTimeout = window.clearTimeout;
        return function(ref) {
            return window.Timer && Timer.__clearTimeout(ref) || _clearTimeout(ref)
        }
    }(),
    window.requestIdleCallback = function() {
        const _requestIdleCallback = window.requestIdleCallback;
        return function(callback, max) {
            return _requestIdleCallback ? _requestIdleCallback(callback, max ? {
                timeout: max
            } : null) : defer((()=>{
                    callback({
                        didTimeout: !1
                    })
                }
            ), 0)
        }
    }(),
    window.onIdle = window.requestIdleCallback,
"undefined" == typeof Float32Array && (Float32Array = Array),
    Math.sign = function(x) {
        return 0 === (x = +x) || isNaN(x) ? Number(x) : x > 0 ? 1 : -1
    }
    ,
    Math._round = Math.round,
    Math.round = function(value, precision=0) {
        let p = Math.pow(10, precision);
        return Math._round(value * p) / p
    }
    ,
    Math._random = Math.random,
    Math.rand = Math.random = function(min, max, precision=0) {
        return void 0 === min ? Math._random() : min === max ? min : (min = min || 0,
            max = max || 1,
            0 == precision ? Math.floor(Math._random() * (max + 1 - min) + min) : Math.round(min + Math._random() * (max - min), precision))
    }
    ,
    Math.degrees = function(radians) {
        return radians * (180 / Math.PI)
    }
    ,
    Math.radians = function(degrees) {
        return degrees * (Math.PI / 180)
    }
    ,
    Math.clamp = function(value, min=0, max=1) {
        return Math.min(Math.max(value, Math.min(min, max)), Math.max(min, max))
    }
    ,
    Math.map = Math.range = function(value, oldMin=-1, oldMax=1, newMin=0, newMax=1, isClamp) {
        const newValue = (value - oldMin) * (newMax - newMin) / (oldMax - oldMin) + newMin;
        return isClamp ? Math.clamp(newValue, Math.min(newMin, newMax), Math.max(newMin, newMax)) : newValue
    }
    ,
    Math.mix = function(a, b, alpha) {
        return a * (1 - alpha) + b * alpha
    }
    ,
    Math.step = function(edge, value) {
        return value < edge ? 0 : 1
    }
    ,
    Math.smoothStep = function(min, max, value) {
        const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
        return x * x * (3 - 2 * x)
    }
    ,
    Math.fract = function(value) {
        return value - Math.floor(value)
    }
    ,
    Math.lerp = function(target, value, alpha) {
        return Math.mix(value, target, alpha * Render.HZ_MULTIPLIER)
    }
    ,
    Math.mod = function(value, n) {
        return (value % n + n) % n
    }
    ,
    Array.prototype.shuffle = function() {
        let temp, r, i = this.length - 1;
        for (; i > 0; )
            r = Math.random(0, i, 0),
                i -= 1,
                temp = this[i],
                this[i] = this[r],
                this[r] = temp;
        return this
    }
    ,
    Array.storeRandom = function(arr) {
        arr.randomStore = []
    }
    ,
    Array.prototype.random = function(range) {
        let value = Math.random(0, this.length - 1);
        if (arguments.length && !this.randomStore && Array.storeRandom(this),
            !this.randomStore)
            return this[value];
        if (range > this.length - 1 && (range = this.length),
        range > 1) {
            for (; ~this.randomStore.indexOf(value); )
                (value += 1) > this.length - 1 && (value = 0);
            this.randomStore.push(value),
            this.randomStore.length >= range && this.randomStore.shift()
        }
        return this[value]
    }
    ,
    Array.prototype.remove = function(element) {
        if (!this.indexOf)
            return;
        const index = this.indexOf(element);
        return ~index ? this.splice(index, 1) : void 0
    }
    ,
    Array.prototype.last = function() {
        return this[this.length - 1]
    }
    ,
    window.Promise = window.Promise || {},
Array.prototype.flat || Object.defineProperty(Array.prototype, "flat", {
    configurable: !0,
    value: function flat() {
        var depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
        return depth ? Array.prototype.reduce.call(this, (function(acc, cur) {
                return Array.isArray(cur) ? acc.push.apply(acc, flat.call(cur, depth - 1)) : acc.push(cur),
                    acc
            }
        ), []) : Array.prototype.slice.call(this)
    },
    writable: !0
}),
    Promise.create = function() {
        const promise = new Promise(((resolve,reject)=>{
                this.temp_resolve = resolve,
                    this.temp_reject = reject
            }
        ));
        return promise.resolve = this.temp_resolve,
            promise.reject = this.temp_reject,
            delete this.temp_resolve,
            delete this.temp_reject,
            promise
    }
    ,
    Promise.catchAll = function(array) {
        let promises = [];
        return array.forEach((promise=>{
                let p = Promise.create();
                promises.push(p),
                    promise.then((d=>p.resolve(d))).catch((e=>p.reject(e)))
            }
        )),
            Promise.all(promises)
    }
    ,
    String.prototype.includes = function(str) {
        if (!Array.isArray(str))
            return !!~this.indexOf(str);
        for (let i = str.length - 1; i >= 0; i--)
            if (~this.indexOf(str[i]))
                return !0;
        return !1
    }
    ,
    String.prototype.equals = function(str) {
        let compare = String(this);
        if (!Array.isArray(str))
            return str === compare;
        for (let i = str.length - 1; i >= 0; i--)
            if (str[i] === compare)
                return !0;
        return !1
    }
    ,
    String.prototype.strpos = function(str) {
        return console.warn("strpos deprecated: use .includes()"),
            this.includes(str)
    }
    ,
    String.prototype.clip = function(num, end="") {
        return this.length > num ? this.slice(0, Math.max(0, num - end.length)).trim() + end : this.slice()
    }
    ,
    String.prototype.capitalize = function() {
        return this.charAt(0).toUpperCase() + this.slice(1)
    }
    ,
    String.prototype.replaceAll = function(find, replace) {
        return this.split(find).join(replace)
    }
    ,
    String.prototype.replaceAt = function(index, replacement) {
        return this.substr(0, index) + replacement + this.substr(index + replacement.length)
    }
    ,
window.fetch || (window.fetch = function(url, options) {
        options = options || {};
        const promise = Promise.create()
            , request = new XMLHttpRequest;
        request.open(options.method || "get", url);
        for (let i in options.headers)
            request.setRequestHeader(i, options.headers[i]);
        function response() {
            let header, keys = [], all = [], headers = {};
            return request.getAllResponseHeaders().replace(/^(.*?):\s*([\s\S]*?)$/gm, ((m,key,value)=>{
                    keys.push(key = key.toLowerCase()),
                        all.push([key, value]),
                        header = headers[key],
                        headers[key] = header ? `${header},${value}` : value
                }
            )),
                {
                    ok: 1 == (request.status / 200 | 0),
                    status: request.status,
                    statusText: request.statusText,
                    url: request.responseURL,
                    clone: response,
                    text: ()=>Promise.resolve(request.responseText),
                    json: ()=>Promise.resolve(request.responseText).then(JSON.parse),
                    xml: ()=>Promise.resolve(request.responseXML),
                    blob: ()=>Promise.resolve(new Blob([request.response])),
                    headers: {
                        keys: ()=>keys,
                        entries: ()=>all,
                        get: n=>headers[n.toLowerCase()],
                        has: n=>n.toLowerCase()in headers
                    }
                }
        }
        return request.onload = ()=>{
            promise.resolve(response())
        }
            ,
            request.onerror = promise.reject,
            request.send(options.body),
            promise
    }
),
    window.get = function(url, options={
        credentials: "same-origin"
    }) {
        let promise = Promise.create();
        return options.method = "GET",
            fetch(url, options).then((function handleResponse(e) {
                    if (!e.ok)
                        return promise.reject(e);
                    e.text().then((text=>{
                            if (text.charAt(0).includes(["[", "{"]))
                                try {
                                    promise.resolve(JSON.parse(text))
                                } catch (err) {
                                    promise.resolve(text)
                                }
                            else
                                promise.resolve(text)
                        }
                    ))
                }
            )).catch(promise.reject),
            promise
    }
    ,
    window.post = function(url, body, options={}) {
        let promise = Promise.create();
        return options.method = "POST",
        body && (options.body = "object" == typeof body || Array.isArray(body) ? JSON.stringify(body) : body),
            fetch(url, options).then((function handleResponse(e) {
                    if (!e.ok)
                        return promise.reject(e);
                    e.text().then((text=>{
                            if (text.charAt(0).includes(["[", "{"]))
                                try {
                                    promise.resolve(JSON.parse(text))
                                } catch (err) {
                                    promise.resolve(text)
                                }
                            else
                                promise.resolve(text)
                        }
                    ))
                }
            )).catch(promise.reject),
            promise
    }
    ,
    window.put = function(url, body, options={}) {
        let promise = Promise.create();
        return options.method = "PUT",
        body && (options.body = "object" == typeof body || Array.isArray(body) ? JSON.stringify(body) : body),
            fetch(url, options).then((function handleResponse(e) {
                    if (!e.ok)
                        return promise.reject(e);
                    e.text().then((text=>{
                            if (text.charAt(0).includes(["[", "{"]))
                                try {
                                    promise.resolve(JSON.parse(text))
                                } catch (err) {
                                    promise.resolve(text)
                                }
                            else
                                promise.resolve(text)
                        }
                    ))
                }
            )).catch(promise.reject),
            promise
    }
    ,
    window.Class = function(_class, _type, _static) {
        const _this = this || window
            , _name = _class.name || _class.toString().match(/function ?([^\(]+)/)[1];
        "function" == typeof _type && (_static = _type,
            _type = null),
            (_type = (_type || "").toLowerCase()) ? "static" == _type ? _this[_name] = new _class : "singleton" == _type && (_this[_name] = _class,
                function() {
                    let _instance;
                    _this[_name].instance = function(a, b, c) {
                        return _instance || (_instance = new _class(a,b,c)),
                            _instance
                    }
                }(),
            _static && _static()) : (_this[_name] = _class,
            _static && _static()),
        this && this !== window && (this[_name]._namespace = this.__namespace)
    }
    ,
    window.Inherit = function(child, parent) {
        const args = [].slice.call(arguments, 2);
        parent.apply(child, args);
        const save = {};
        for (let method in child)
            save[method] = child[method];
        defer((()=>{
                for (let method in child)
                    if (save[method] && child[method] !== save[method]) {
                        if ("destroy" == method && child.destroy && !child.__element)
                            throw "Do not override destroy directly, use onDestroy :: " + child.constructor.toString();
                        child["_" + method] = save[method]
                    }
            }
        ))
    }
    ,
    window.Namespace = function(obj) {
        "string" == typeof obj ? window[obj] || (window[obj] = {
            Class: Class,
            __namespace: obj
        }) : (obj.Class = Class,
            obj.__namespace = obj.constructor.name || obj.constructor.toString().match(/function ([^\(]+)/)[1])
    }
    ,
    window.Global = {},
    window.THREAD = !1,
    Class((function Hydra() {
            const _this = this
                , _readyPromise = Promise.create();
            var _base, _callbacks = [];
            function initLoad() {
                return document && window ? window._NODE_ ? setTimeout(loaded, 1) : window._AURA_ ? window.Main ? setTimeout(loaded, 1) : setTimeout(initLoad, 1) : void window.addEventListener("load", loaded, !1) : setTimeout(initLoad, 1)
            }
            function loaded() {
                window.removeEventListener("load", loaded, !1),
                    _this.LOCAL = !window._BUILT_ && (location.hostname.indexOf("local") > -1 || "10" == location.hostname.split(".")[0] || "192" == location.hostname.split(".")[0]) && "" == location.port,
                    _callbacks.forEach((cb=>cb())),
                    _callbacks = null,
                    _readyPromise.resolve(),
                window.Main && _readyPromise.then((()=>Hydra.Main = new window.Main))
            }
            this.HASH = window.location.hash.slice(1),
                this.LOCAL = !window._BUILT_ && (location.hostname.indexOf("local") > -1 || "10" == location.hostname.split(".")[0] || "192" == location.hostname.split(".")[0]) && "" == location.port,
                initLoad(),
                this.__triggerReady = function() {
                    loaded()
                }
                ,
                this.ready = function(callback) {
                    if (!callback)
                        return _readyPromise;
                    _callbacks ? _callbacks.push(callback) : callback()
                }
                ,
                this.absolutePath = function(path) {
                    if (window.AURA)
                        return path;
                    let base = _base;
                    if (void 0 === base)
                        try {
                            if (document.getElementsByTagName("base").length > 0) {
                                var a = document.createElement("a");
                                a.href = document.getElementsByTagName("base")[0].href,
                                    base = a.pathname,
                                    _base = base
                            }
                        } catch (e) {
                            _base = null
                        }
                    let pathname = base || location.pathname;
                    pathname.includes("/index.html") && (pathname = pathname.replace("/index.html", ""));
                    let port = Number(location.port) > 1e3 ? `:${location.port}` : "";
                    return path.includes("http") ? path : (location.protocol.length ? location.protocol + "//" : "") + (location.hostname + port + pathname + "/" + path).replace("//", "/")
                }
        }
    ), "Static"),
    Class((function Utils() {
            var _queries = {};
            this.query = function(key) {
                if (!Hydra.LOCAL)
                    return !1;
                if (void 0 !== _queries[key])
                    return _queries[key];
                const str = decodeURI(window.location.search.replace(new RegExp("^(?:.*[&\\?]" + encodeURI(key).replace(/[\.\+\*]/g, "\\$&") + "(?:\\=([^&]*))?)?.*$","i"), "$1"));
                return "0" == str ? (_queries[key] = 0,
                    0) : str.length && "false" != str ? (_queries[key] = str,
                    str) : (_queries[key] = location.search.includes(key),
                    _queries[key])
            }
                ,
                this.getConstructorName = function(obj) {
                    return obj ? obj.constructor.name || obj.constructor.toString().match(/function ([^\(]+)/)[1] : obj
                }
                ,
                this.nullObject = function(object) {
                    if (object && (object.destroy || object.div))
                        for (var key in object)
                            void 0 !== object[key] && (object[key] = null);
                    return null
                }
                ,
                this.cloneObject = function(obj) {
                    return JSON.parse(JSON.stringify(obj))
                }
                ,
                this.headsTails = function(n0, n1) {
                    return Math.random(0, 1) ? n1 : n0
                }
                ,
                this.mergeObject = function() {
                    for (var obj = {}, i = 0; i < arguments.length; i++) {
                        var o = arguments[i];
                        for (var key in o)
                            obj[key] = o[key]
                    }
                    return obj
                }
                ,
                this.timestamp = function() {
                    return (Date.now() + Math.random(0, 99999, 0)).toString()
                }
                ,
                this.randomColor = function() {
                    var color = "#" + Math.floor(16777215 * Math.random()).toString(16);
                    return color.length < 7 && (color = this.randomColor()),
                        color
                }
                ,
                this.numberWithCommas = function(num) {
                    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")
                }
                ,
                this.padInt = function(num, digits, isLimit) {
                    isLimit && (num = Math.min(num, Math.pow(10, digits) - 1));
                    let str = Math.floor(num).toString();
                    return Math.pow(10, Math.max(0, digits - str.length)).toString().slice(1) + str
                }
                ,
                this.copyToClipboard = function(string) {
                    try {
                        var el = document.createElement("textarea")
                            , range = document.createRange();
                        el.contentEditable = !0,
                            el.readOnly = !0,
                            el.value = string,
                            document.body.appendChild(el),
                            el.select(),
                            range.selectNodeContents(el);
                        var s = window.getSelection();
                        return s.removeAllRanges(),
                            s.addRange(range),
                            el.setSelectionRange(0, string.length),
                            document.execCommand("copy"),
                            document.body.removeChild(el),
                            !0
                    } catch (e) {
                        return !1
                    }
                }
                ,
                this.stringList = function(items=[], limit=0, options={}) {
                    if (0 === items.length)
                        return "";
                    let output = ""
                        , printed = 0;
                    "object" == typeof limit && (options = limit,
                        limit = 0),
                        options.oxford = !0 === options.oxford,
                        options.more = !1 !== options.more && (options.more ? options.more : "more"),
                        options.and = options.and ? options.and : "&",
                        options.comma = options.comma ? options.comma : ",",
                    isNaN(options.limit) || (limit = options.limit),
                    0 === limit && (limit = items.length);
                    do {
                        output = `${output}${items.shift()}${options.comma} `,
                            printed++
                    } while (items.length > 1 && printed + 1 < limit);
                    if (output = output.trim(),
                        output = output.slice(0, output.length - 1),
                    1 === items.length)
                        output = `${output}${options.oxford && printed > 1 ? options.comma : ""} ${options.and} ${items.shift()}`;
                    else if (items.length > 1 && options.more) {
                        let more = `${items.length} ${options.more}`;
                        output = `${output}${options.oxford && printed > 1 ? options.comma : ""} ${options.and} ${more}`
                    }
                    return output
                }
        }
    ), "Static"),
    Class((function Render() {
            const _this = this
                , _render = []
                , _drawFrame = []
                , _multipliers = [];
            var _last = performance.now()
                , _localTSL = 0
                , _sampleRefreshRate = []
                , rAF = requestAnimationFrame;
            function render(tsl) {
                if (_this.timeScaleUniform.value = 1,
                    _multipliers.length)
                    for (let i = 0; i < _multipliers.length; i++) {
                        let obj = _multipliers[i];
                        _this.timeScaleUniform.value *= obj.value
                    }
                _this.DT = tsl - _last;
                let delta = _this.DT * _this.timeScaleUniform.value;
                if (delta = Math.min(200, delta),
                    _last = tsl,
                _this.startFrame && _this.startFrame(tsl, delta),
                    _sampleRefreshRate) {
                    let fps = 1e3 / _this.DT;
                    if (_sampleRefreshRate.push(fps),
                    _sampleRefreshRate.length > 30) {
                        _sampleRefreshRate.sort(((a,b)=>a - b));
                        let rate = _sampleRefreshRate[Math.round(_sampleRefreshRate.length / 2)];
                        rate = _this.REFRESH_TABLE.reduce(((prev,curr)=>Math.abs(curr - rate) < Math.abs(prev - rate) ? curr : prev)),
                            _this.REFRESH_RATE = rate,
                            _this.HZ_MULTIPLIER = 60 / _this.REFRESH_RATE,
                            _sampleRefreshRate = null
                    }
                }
                _this.TIME = tsl,
                    _this.DELTA = delta,
                    _localTSL += delta;
                for (let i = _render.length - 1; i >= 0; i--) {
                    var callback = _render[i];
                    if (callback)
                        if (callback.fps) {
                            if (tsl - callback.last < 1e3 / callback.fps)
                                continue;
                            callback(++callback.frame),
                                callback.last = tsl
                        } else
                            callback(tsl, delta);
                    else
                        _render.remove(callback)
                }
                for (let i = _drawFrame.length - 1; i > -1; i--)
                    _drawFrame[i](tsl, delta);
                _this.drawFrame && _this.drawFrame(tsl, delta),
                _this.endFrame && _this.endFrame(tsl, delta),
                THREAD || _this.isPaused || rAF(render)
            }
            this.timeScaleUniform = {
                value: 1,
                type: "f",
                ignoreUIL: !0
            },
                this.REFRESH_TABLE = [30, 60, 72, 90, 100, 120, 144, 240],
                this.REFRESH_RATE = 60,
                this.HZ_MULTIPLIER = 1,
            THREAD || (rAF(render),
                setInterval((_=>_sampleRefreshRate = []), 3e3)),
                this.now = function() {
                    return _localTSL
                }
                ,
                this.start = function(callback, fps) {
                    fps && (callback.fps = fps,
                        callback.last = -1 / 0,
                        callback.frame = -1),
                    ~_render.indexOf(callback) || _render.unshift(callback)
                }
                ,
                this.stop = function(callback) {
                    _render.remove(callback)
                }
                ,
                this.tick = function() {
                    THREAD && (this.TIME = performance.now(),
                        render(this.TIME))
                }
                ,
                this.Worker = function(_callback, _budget=4) {
                    Inherit(this, Component);
                    let _scope = this
                        , _elapsed = 0;
                    function loop() {
                        for (; _elapsed < _budget; ) {
                            if (_scope.dead)
                                return;
                            const start = performance.now();
                            _callback && _callback(),
                                _elapsed += performance.now() - start
                        }
                        _elapsed = 0
                    }
                    this.startRender(loop),
                        this.stop = function() {
                            this.dead = !0,
                                this.stopRender(loop)
                        }
                        ,
                        this.pause = function() {
                            this.stopRender(loop)
                        }
                        ,
                        this.resume = function() {
                            this.startRender(loop)
                        }
                }
                ,
                this.pause = function() {
                    _this.isPaused = !0
                }
                ,
                this.resume = function() {
                    _this.isPaused && (_this.isPaused = !1,
                        rAF(render))
                }
                ,
                this.useRAF = function(raf) {
                    _last = performance.now(),
                        (rAF = raf)(render)
                }
                ,
                this.onDrawFrame = function(cb) {
                    _drawFrame.push(cb)
                }
                ,
                this.setTimeScale = function(v) {
                    _this.timeScaleUniform.value = v
                }
                ,
                this.getTimeScale = function() {
                    return _this.timeScaleUniform.value
                }
                ,
                this.createTimeMultiplier = function() {
                    let obj = {
                        value: 1
                    };
                    return _multipliers.push(obj),
                        obj
                }
                ,
                this.destroyTimeMultiplier = function(obj) {
                    _multipliers.remove(obj)
                }
                ,
                this.tweenTimeScale = function(value, time, ease, delay) {
                    return tween(_this.timeScaleUniform, {
                        value: value
                    }, time, ease, delay, null, null, !0)
                }
        }
    ), "Static"),
    Class((function Timer() {
            const _this = this
                , _callbacks = []
                , _discard = []
                , _deferA = []
                , _deferB = [];
            var _defer = _deferA;
            function loop(t, delta) {
                for (let i = _discard.length - 1; i >= 0; i--) {
                    let obj = _discard[i];
                    obj.callback = null,
                        _callbacks.remove(obj)
                }
                _discard.length && (_discard.length = 0);
                for (let i = _callbacks.length - 1; i >= 0; i--) {
                    let obj = _callbacks[i];
                    obj ? (obj.scaledTime ? obj.current += delta : obj.current += Render.DT,
                    obj.current >= obj.time && (obj.callback && obj.callback(),
                        _discard.push(obj))) : _callbacks.remove(obj)
                }
                for (let i = _defer.length - 1; i > -1; i--)
                    _defer[i]();
                _defer.length = 0,
                    _defer = _defer == _deferA ? _deferB : _deferA
            }
            Render.start(loop),
                this.__clearTimeout = function(ref) {
                    const obj = function find(ref) {
                        for (let i = _callbacks.length - 1; i > -1; i--)
                            if (_callbacks[i].ref == ref)
                                return _callbacks[i]
                    }(ref);
                    return !!obj && (obj.callback = null,
                        _callbacks.remove(obj),
                        !0)
                }
                ,
                this.create = function(callback, time, scaledTime) {
                    if (window._NODE_)
                        return setTimeout(callback, time);
                    const obj = {
                        time: Math.max(1, time || 1),
                        current: 0,
                        ref: Utils.timestamp(),
                        callback: callback,
                        scaledTime: scaledTime
                    };
                    return _callbacks.unshift(obj),
                        obj.ref
                }
                ,
                this.delayedCall = function(time) {
                    let promise = Promise.create();
                    return _this.create(promise.resolve, time),
                        promise
                }
                ,
                window.defer = this.defer = function(callback) {
                    if (!callback) {
                        callback = Promise.create().resolve
                    }
                    (_defer == _deferA ? _deferB : _deferA).unshift(callback)
                }
        }
    ), "static"),
    Class((function Events() {
            this.events = {};
            const _e = {}
                , _linked = [];
            let _emitter;
            this.events.sub = function(obj, evt, callback) {
                if ("object" != typeof obj && (callback = evt,
                    evt = obj,
                    obj = null),
                    !obj)
                    return Events.emitter._addEvent(evt, callback.resolve ? callback.resolve : callback, this),
                        callback;
                let emitter = obj.events.emitter();
                return emitter._addEvent(evt, callback.resolve ? callback.resolve : callback, this),
                    emitter._saveLink(this),
                    _linked.push(emitter),
                    callback
            }
                ,
                this.events.unsub = function(obj, evt, callback) {
                    if ("object" != typeof obj && (callback = evt,
                        evt = obj,
                        obj = null),
                        !obj)
                        return Events.emitter._removeEvent(evt, callback.resolve ? callback.resolve : callback);
                    obj.events.emitter()._removeEvent(evt, callback.resolve ? callback.resolve : callback)
                }
                ,
                this.events.fire = function(evt, obj, isLocalOnly) {
                    (obj = obj || _e).target = this,
                        Events.emitter._check(evt),
                    _emitter && _emitter._fireEvent(evt, obj) || isLocalOnly || Events.emitter._fireEvent(evt, obj)
                }
                ,
                this.events.bubble = function(obj, evt) {
                    let _this = this;
                    _this.sub(obj, evt, (e=>_this.fire(evt, e)))
                }
                ,
                this.events.destroy = function() {
                    return Events.emitter._destroyEvents(this),
                    _linked && _linked.forEach((emitter=>emitter._destroyEvents(this))),
                    _emitter && _emitter.links && _emitter.links.forEach((obj=>obj.events && obj.events._unlink(_emitter))),
                        null
                }
                ,
                this.events.emitter = function() {
                    return _emitter || (_emitter = Events.emitter.createLocalEmitter()),
                        _emitter
                }
                ,
                this.events._unlink = function(emitter) {
                    _linked.remove(emitter)
                }
        }
    ), (()=>{
            Events.emitter = new function Emitter() {
                const prototype = Emitter.prototype;
                if (this.events = [],
                void 0 !== prototype._check)
                    return;
                prototype._check = function(evt) {
                    if (void 0 === evt)
                        throw "Undefined event"
                }
                    ,
                    prototype._addEvent = function(evt, callback, object) {
                        this._check(evt),
                            this.events.push({
                                evt: evt,
                                object: object,
                                callback: callback
                            })
                    }
                    ,
                    prototype._removeEvent = function(eventString, callback) {
                        this._check(eventString);
                        let _this = this
                            , marked = !1;
                        for (let i = this.events.length - 1; i >= 0; i--)
                            this.events[i].evt == eventString && this.events[i].callback == callback && (this.events[i].markedForDeletion = !0,
                                marked = !0);
                        marked && defer((()=>_this._sweepEvents()))
                    }
                    ,
                    prototype._sweepEvents = function() {
                        for (let i = 0; i < this.events.length; i++)
                            this.events[i].markedForDeletion && this.events.remove(this.events[i])
                    }
                    ,
                    prototype._fireEvent = function(eventString, obj) {
                        this._check && this._check(eventString),
                            obj = obj || _e;
                        let called = !1;
                        for (let i = 0; i < this.events.length; i++) {
                            let evt = this.events[i];
                            evt.evt != eventString || evt.markedForDeletion || (evt.callback(obj),
                                called = !0)
                        }
                        return called
                    }
                    ,
                    prototype._destroyEvents = function(object) {
                        for (var i = this.events.length - 1; i >= 0; i--)
                            this.events[i].object == object && (this.events.splice(i, 1)[0] = null)
                    }
                    ,
                    prototype._saveLink = function(obj) {
                        this.links || (this.links = []),
                        ~this.links.indexOf(obj) || this.links.push(obj)
                    }
                    ,
                    prototype.createLocalEmitter = function() {
                        return new Emitter
                    }
            }
                ,
                Events.broadcast = Events.emitter._fireEvent,
                Events.VISIBILITY = "hydra_visibility",
                Events.HASH_UPDATE = "hydra_hash_update",
                Events.COMPLETE = "hydra_complete",
                Events.PROGRESS = "hydra_progress",
                Events.UPDATE = "hydra_update",
                Events.LOADED = "hydra_loaded",
                Events.END = "hydra_end",
                Events.FAIL = "hydra_fail",
                Events.SELECT = "hydra_select",
                Events.ERROR = "hydra_error",
                Events.READY = "hydra_ready",
                Events.RESIZE = "hydra_resize",
                Events.CLICK = "hydra_click",
                Events.HOVER = "hydra_hover",
                Events.MESSAGE = "hydra_message",
                Events.ORIENTATION = "orientation",
                Events.BACKGROUND = "background",
                Events.BACK = "hydra_back",
                Events.PREVIOUS = "hydra_previous",
                Events.NEXT = "hydra_next",
                Events.RELOAD = "hydra_reload",
                Events.UNLOAD = "hydra_unload",
                Events.FULLSCREEN = "hydra_fullscreen";
            const _e = {};
            Hydra.ready((()=>{
                    let timer, timer2;
                    function updateStage() {
                        Stage.width = window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth,
                            Stage.height = window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight
                    }
                    !function() {
                        let _last, _lastTime = performance.now();
                        function onfocus() {
                            "focus" != _last && Events.emitter._fireEvent(Events.VISIBILITY, {
                                type: "focus"
                            }),
                                _last = "focus"
                        }
                        function onblur() {
                            "blur" != _last && Events.emitter._fireEvent(Events.VISIBILITY, {
                                type: "blur"
                            }),
                                _last = "blur"
                        }
                        Timer.create((function addVisibilityHandler() {
                                let hidden, eventName;
                                if ([["msHidden", "msvisibilitychange"], ["webkitHidden", "webkitvisibilitychange"], ["hidden", "visibilitychange"]].forEach((d=>{
                                        void 0 !== document[d[0]] && (hidden = d[0],
                                            eventName = d[1])
                                    }
                                )),
                                    !eventName) {
                                    const root = "ie" == Device.browser ? document : window;
                                    return root.onfocus = onfocus,
                                        void (root.onblur = onblur)
                                }
                                document.addEventListener(eventName, (()=>{
                                        const time = performance.now();
                                        time - _lastTime > 10 && (!1 === document[hidden] ? onfocus() : onblur()),
                                            _lastTime = time
                                    }
                                ))
                            }
                        ), 250),
                            window.onbeforeunload = _=>(Events.emitter._fireEvent(Events.UNLOAD),
                                null)
                    }(),
                        window.Stage = window.Stage || {},
                        updateStage(),
                        window.addEventListener("resize", (function() {
                                clearTimeout(timer),
                                    clearTimeout(timer2),
                                    timer = setTimeout((_=>{
                                            updateStage(),
                                                Events.emitter._fireEvent(Events.RESIZE)
                                        }
                                    ), 16),
                                Device.mobile && "ios" === Device.system.os && (timer2 = setTimeout((_=>{
                                        updateStage(),
                                            Events.emitter._fireEvent(Events.RESIZE),
                                            timer2 = setTimeout((_=>{
                                                    updateStage(),
                                                        Events.emitter._fireEvent(Events.RESIZE)
                                                }
                                            ), 500)
                                    }
                                ), 300))
                            }
                        )),
                        window.onorientationchange = window.onresize,
                        window.forceStage = function() {
                            updateStage(),
                                Events.emitter._fireEvent(Events.RESIZE)
                        }
                        ,
                        defer(window.onresize)
                }
            ))
        }
    )),
    Class((function Device() {
            var vid, _this = this;
            this.agent = navigator.userAgent.toLowerCase(),
                this.detect = function(match) {
                    return this.agent.includes(match)
                }
                ,
                this.touchCapable = !!navigator.maxTouchPoints,
                this.pixelRatio = window.devicePixelRatio,
                this.system = {},
                this.system.retina = window.devicePixelRatio > 1,
                this.system.webworker = void 0 !== window.Worker,
            window._NODE_ || (this.system.geolocation = void 0 !== navigator.geolocation),
            window._NODE_ || (this.system.pushstate = void 0 !== window.history.pushState),
                this.system.webcam = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia),
                this.system.language = window.navigator.userLanguage || window.navigator.language,
                this.system.webaudio = void 0 !== window.AudioContext,
                this.system.xr = navigator.getVRDisplays || navigator.xr,
                this.system.exokit = _this.detect("exokit");
            try {
                this.system.localStorage = void 0 !== window.localStorage
            } catch (e) {
                this.system.localStorage = !1
            }
            this.system.fullscreen = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled,
                this.system.os = _this.detect(["exokit"]) && "linux" == navigator.platform ? "magicleap" : _this.detect(["ipad", "iphone", "ios"]) || _this.detect("mac") && _this.touchCapable && Math.max(screen.width, screen.height) < 1370 ? "ios" : _this.detect(["android", "kindle"]) ? "android" : _this.detect(["blackberry"]) ? "blackberry" : _this.detect(["mac os"]) ? "mac" : _this.detect(["windows", "iemobile"]) ? "windows" : _this.detect(["linux"]) ? "linux" : "unknown",
                this.system.version = function() {
                    try {
                        if ("ios" == _this.system.os) {
                            if (_this.agent.includes("intel mac")) {
                                let split = _this.agent.split("version/")[1].split(" ")[0].split(".");
                                return Number(split[0] + "." + split[1])
                            }
                            var num = _this.agent.split("os ")[1].split("_")
                                , main = num[0]
                                , sub = num[1].split(" ")[0];
                            return Number(main + "." + sub)
                        }
                        if ("android" == _this.system.os) {
                            var version = _this.agent.split("android ")[1].split(";")[0];
                            return version.length > 3 && (version = version.slice(0, -2)),
                            "." == version.charAt(version.length - 1) && (version = version.slice(0, -1)),
                                Number(version)
                        }
                        if ("windows" == _this.system.os)
                            return _this.agent.includes("rv:11") ? 11 : Number(_this.agent.split("windows phone ")[1].split(";")[0])
                    } catch (e) {}
                    return -1
                }(),
                this.system.browser = "ios" == _this.system.os ? _this.detect(["twitter", "fbios"]) ? "social" : _this.detect(["crios"]) ? "chrome" : _this.detect(["safari"]) ? "safari" : "unknown" : "android" == _this.system.os ? _this.detect(["twitter", "fb", "facebook"]) ? "social" : _this.detect(["chrome"]) ? "chrome" : _this.detect(["firefox"]) ? "firefox" : "browser" : _this.detect(["msie"]) || _this.detect(["trident"]) && _this.detect(["rv:"]) || _this.detect(["windows"]) && _this.detect(["edge"]) ? "ie" : _this.detect(["chrome"]) ? "chrome" : _this.detect(["safari"]) ? "safari" : _this.detect(["firefox"]) ? "firefox" : "unknown",
                this.system.browserVersion = function() {
                    try {
                        if ("chrome" == _this.system.browser)
                            return Number(_this.agent.split("chrome/")[1].split(".")[0]);
                        if ("firefox" == _this.system.browser)
                            return Number(_this.agent.split("firefox/")[1].split(".")[0]);
                        if ("safari" == _this.system.browser)
                            return Number(_this.agent.split("version/")[1].split(".")[0].split(".")[0]);
                        if ("ie" == _this.system.browser)
                            return _this.detect(["msie"]) ? Number(_this.agent.split("msie ")[1].split(".")[0]) : _this.detect(["rv:"]) ? Number(_this.agent.split("rv:")[1].split(".")[0]) : Number(_this.agent.split("edge/")[1].split(".")[0])
                    } catch (e) {
                        return -1
                    }
                }(),
                this.mobile = !(window._NODE_ || !("ontouchstart"in window) && !("onpointerdown"in window) || !_this.system.os.includes(["ios", "android", "magicleap"])) && {},
            this.mobile && this.detect(["windows"]) && !this.detect(["touch"]) && (this.mobile = !1),
            this.mobile && (this.mobile.tablet = Math.max(window.screen ? screen.width : window.innerWidth, window.screen ? screen.height : window.innerHeight) > 1e3,
                this.mobile.phone = !this.mobile.tablet,
                this.mobile.pwa = !(!window.matchMedia || !window.matchMedia("(display-mode: standalone)").matches) || !!window.navigator.standalone,
                Hydra.ready((()=>{
                        _this.mobile.native = !(!Mobile.NativeCore || !Mobile.NativeCore.active) || !!window._AURA_
                    }
                ))),
                this.media = {},
                this.media.audio = !!document.createElement("audio").canPlayType && (_this.detect(["firefox", "opera"]) ? "ogg" : "mp3"),
                this.media.video = !!(vid = document.createElement("video")).canPlayType && (vid.canPlayType("video/webm;") ? "webm" : "mp4"),
                this.media.webrtc = !!(window.webkitRTCPeerConnection || window.mozRTCPeerConnection || window.msRTCPeerConnection || window.oRTCPeerConnection || window.RTCPeerConnection),
                this.graphics = {},
                this.graphics.webgl = function() {
                    let DISABLED = !1;
                    Object.defineProperty(_this.graphics, "webgl", {
                        get: ()=>{
                            if (DISABLED)
                                return !1;
                            if (_this.graphics._webglContext)
                                return _this.graphics._webglContext;
                            try {
                                const names = ["webgl2", "webgl", "experimental-webgl"]
                                    , canvas = document.createElement("canvas");
                                let gl;
                                for (let i = 0; i < names.length && (gl = canvas.getContext(names[i]),
                                    !gl); i++)
                                    ;
                                let info = gl.getExtension("WEBGL_debug_renderer_info")
                                    , output = {};
                                if (info) {
                                    let gpu = info.UNMASKED_RENDERER_WEBGL;
                                    output.gpu = gl.getParameter(gpu).toLowerCase()
                                }
                                return output.renderer = gl.getParameter(gl.RENDERER).toLowerCase(),
                                    output.version = gl.getParameter(gl.VERSION).toLowerCase(),
                                    output.glsl = gl.getParameter(gl.SHADING_LANGUAGE_VERSION).toLowerCase(),
                                    output.extensions = gl.getSupportedExtensions(),
                                    output.webgl2 = output.version.includes(["webgl 2", "webgl2"]),
                                    output.canvas = canvas,
                                    output.context = gl,
                                    output.detect = function(matches) {
                                        if (output.gpu && output.gpu.toLowerCase().includes(matches))
                                            return !0;
                                        if (output.version && output.version.toLowerCase().includes(matches))
                                            return !0;
                                        for (let i = 0; i < output.extensions.length; i++)
                                            if (output.extensions[i].toLowerCase().includes(matches))
                                                return !0;
                                        return !1
                                    }
                                    ,
                                    _this.graphics._webglContext = output,
                                    output
                            } catch (e) {
                                return !1
                            }
                        }
                        ,
                        set: v=>{
                            !1 === v && (DISABLED = !0)
                        }
                    })
                }(),
                this.graphics.metal = function() {
                    if (!window.Metal)
                        return !1;
                    let output = {};
                    return output.gpu = Metal.device.getName().toLowerCase(),
                        output.detect = function(matches) {
                            return output.gpu.includes(matches)
                        }
                        ,
                        output
                }(),
                this.graphics.gpu = function() {
                    if (!_this.graphics.webgl && !_this.graphics.metal)
                        return !1;
                    let output = {};
                    return ["metal", "webgl"].forEach((name=>{
                            _this.graphics[name] && !output.identifier && (output.detect = _this.graphics[name].detect,
                                output.identifier = _this.graphics[name].gpu)
                        }
                    )),
                        output
                }(),
                this.graphics.canvas = !!document.createElement("canvas").getContext;
            const checkForStyle = function() {
                let _tagDiv;
                return function(prop) {
                    _tagDiv = _tagDiv || document.createElement("div");
                    const vendors = ["Khtml", "ms", "O", "Moz", "Webkit"];
                    if (prop in _tagDiv.style)
                        return !0;
                    prop = prop.replace(/^[a-z]/, (val=>val.toUpperCase()));
                    for (let i = vendors.length - 1; i >= 0; i--)
                        if (vendors[i] + prop in _tagDiv.style)
                            return !0;
                    return !1
                }
            }();
            this.styles = {},
                this.styles.filter = checkForStyle("filter"),
                this.styles.blendMode = checkForStyle("mix-blend-mode"),
                this.tween = {},
                this.tween.transition = checkForStyle("transition"),
                this.tween.css2d = checkForStyle("transform"),
                this.tween.css3d = checkForStyle("perspective")
        }
    ), "Static"),
    Class((function Component() {
            Inherit(this, Events);
            const _this = this
                , _setters = {}
                , _flags = {}
                , _timers = []
                , _loops = [];
            function defineSetter(_this, prop) {
                _setters[prop] = {},
                    Object.defineProperty(_this, prop, {
                        set: function(v) {
                            _setters[prop] && _setters[prop].s && _setters[prop].s.call(_this, v),
                                v = null
                        },
                        get: function() {
                            if (_setters[prop] && _setters[prop].g)
                                return _setters[prop].g.apply(_this)
                        }
                    })
            }
            this.classes = {},
                this.isPlayground = function() {
                    return Global.PLAYGROUND && Global.PLAYGROUND == Utils.getConstructorName(_this)
                }
                ,
                this.findParent = function(type) {
                    let p = _this.parent;
                    for (; p; ) {
                        if (p._cachedName || (p._cachedName = Utils.getConstructorName(p)),
                        p._cachedName == type)
                            return p;
                        p = p.parent
                    }
                }
                ,
                this.set = function(prop, callback) {
                    _setters[prop] || defineSetter(this, prop),
                        _setters[prop].s = callback
                }
                ,
                this.get = function(prop, callback) {
                    _setters[prop] || defineSetter(this, prop),
                        _setters[prop].g = callback
                }
                ,
                this.initClass = function(clss) {
                    if (!clss)
                        throw "unable to locate class";
                    const args = [].slice.call(arguments, 1)
                        , child = Object.create(clss.prototype);
                    if (child.parent = this,
                        clss.apply(child, args),
                        child.destroy) {
                        const id = Utils.timestamp();
                        this.classes[id] = child,
                            this.classes[id].__id = id
                    }
                    if (child.element) {
                        const last = arguments[arguments.length - 1];
                        Array.isArray(last) && 1 == last.length && last[0]instanceof HydraObject ? last[0].add(child.element) : this.element && null !== last && this.element.add(child.element)
                    }
                    if (child.group) {
                        const last = arguments[arguments.length - 1];
                        this.group && null !== last && this.group.add(child.group)
                    }
                    return child
                }
                ,
                this.delayedCall = function(callback, time, scaledTime) {
                    const timer = Timer.create((()=>{
                            _this && _this.destroy && callback && callback()
                        }
                    ), time, scaledTime);
                    return _timers.push(timer),
                    _timers.length > 50 && _timers.shift(),
                        timer
                }
                ,
                this.clearTimers = function() {
                    for (let i = _timers.length - 1; i >= 0; i--)
                        clearTimeout(_timers[i]);
                    _timers.length = 0
                }
                ,
                this.startRender = function(callback, fps) {
                    for (let i = 0; i < _loops.length; i++)
                        if (_loops[i].callback == callback)
                            return;
                    let flagInvisible = _=>{
                            _this._invisible || (_this._invisible = !0,
                            _this.onInvisible && _this.onInvisible())
                        }
                        , loop = (a,b,c,d)=>{
                            let p = _this;
                            for (; p; ) {
                                if (!1 === p.visible)
                                    return flagInvisible();
                                if (p.group && !1 === p.group.visible)
                                    return flagInvisible();
                                p = p.parent
                            }
                            !1 !== _this._invisible && (_this._invisible = !1,
                            _this.onVisible && _this.onVisible()),
                                callback(a, b, c, d)
                        }
                    ;
                    _loops.push({
                        callback: callback,
                        loop: loop
                    }),
                        Render.start(loop, fps)
                }
                ,
                this.onResize = function(callback) {
                    callback(),
                        this.events.sub(Events.RESIZE, callback)
                }
                ,
                this.stopRender = function(callback) {
                    for (let i = 0; i < _loops.length; i++)
                        _loops[i].callback == callback && (Render.stop(_loops[i].loop),
                            _loops.splice(i, 1))
                }
                ,
                this.clearRenders = function() {
                    for (let i = 0; i < _loops.length; i++)
                        Render.stop(_loops[i].loop);
                    _loops.length = 0
                }
                ,
                this.wait = function(object, key, callback) {
                    const promise = Promise.create();
                    if ("string" == typeof object && (callback = key,
                        key = object,
                        object = _this),
                    "number" == typeof object && !key)
                        return _this.delayedCall(promise.resolve, object),
                            promise;
                    if ("function" == typeof object && "function" != typeof callback) {
                        let _object = object;
                        object = key,
                            key = callback,
                            callback = _object
                    }
                    if (callback = callback || promise.resolve,
                    object[key] || _this.flag(key))
                        callback();
                    else {
                        Render.start((function test() {
                                if (!object || !_this.flag)
                                    return Render.stop(test);
                                (object[key] || _this.flag(key)) && (callback(),
                                    Render.stop(test))
                            }
                        ))
                    }
                    return promise
                }
                ,
                this.flag = function(name, value, time) {
                    if (void 0 === value)
                        return _flags[name];
                    _flags[name] = value,
                    time && (clearTimeout(_flags[name + "_timer"]),
                        _flags[name + "_timer"] = this.delayedCall((()=>{
                                _flags[name] = !_flags[name]
                            }
                        ), time))
                }
                ,
                this.destroy = function() {
                    this.removeDispatch && this.removeDispatch(),
                    this.onDestroy && this.onDestroy(),
                    this.fxDestroy && this.fxDestroy();
                    for (let id in this.classes) {
                        var clss = this.classes[id];
                        clss && clss.destroy && clss.destroy()
                    }
                    return this.classes = null,
                    this.clearRenders && this.clearRenders(),
                    this.clearTimers && this.clearTimers(),
                    this.element && window.GLUI && this.element instanceof GLUIObject && this.element.remove(),
                    this.events && (this.events = this.events.destroy()),
                    this.parent && this.parent.__destroyChild && this.parent.__destroyChild(this.__id),
                    this.group && this.group._parent && this.group._parent.remove(this.group),
                        Utils.nullObject(this)
                }
                ,
                this.__destroyChild = function(name) {
                    delete this.classes[name]
                }
        }
    )),
    Class((function Model() {
            Inherit(this, Component),
                Namespace(this);
            const _this = this
                , _storage = {};
            let _data = 0
                , _triggered = 0;
            this.push = function(name, val) {
                _storage[name] = val
            }
                ,
                this.pull = function(name) {
                    return _storage[name]
                }
                ,
                this.waitForData = this.promiseData = function(num=1) {
                    _data += num
                }
                ,
                this.fulfillData = this.resolveData = function() {
                    _triggered++,
                    _triggered == _data && (_this.dataReady = !0)
                }
                ,
                this.ready = function(callback) {
                    let promise = Promise.create();
                    return callback && promise.then(callback),
                        _this.wait(_this, "dataReady").then(promise.resolve),
                        promise
                }
                ,
                this.initWithData = function(data) {
                    for (var key in _this.STATIC_DATA = data,
                        _this) {
                        var model = _this[key]
                            , init = !1;
                        for (var i in data)
                            i.toLowerCase().replace(/-/g, "") == key.toLowerCase() && (init = !0,
                            model.init && model.init(data[i]));
                        !init && model.init && model.init()
                    }
                    _this.init && _this.init(data)
                }
                ,
                this.loadData = function(url, callback) {
                    let promise = Promise.create();
                    callback || (callback = promise.resolve);
                    var _this = this;
                    return get(url + "?" + Utils.timestamp()).then((d=>{
                            defer((()=>{
                                    _this.initWithData(d),
                                        callback(d)
                                }
                            ))
                        }
                    )),
                        promise
                }
        }
    )),
    Class((function Modules() {
            const _modules = {}
                , _constructors = {};
            function exec() {
                for (let m in _modules)
                    for (let key in _modules[m]) {
                        let module = _modules[m][key];
                        module._ready || (module._ready = !0,
                        module.exec && module.exec())
                    }
            }
            defer(exec),
                this.Module = function(module) {
                    let m = new module
                        , name = module.toString().slice(0, 100).match(/function ([^\(]+)/);
                    name ? (m._ready = !0,
                        name = name[1],
                        _modules[name] = {
                            index: m
                        },
                        _constructors[name] = module) : (_modules[m.module] || (_modules[m.module] = {}),
                        _modules[m.module][m.path] = m)
                }
                ,
                this.require = function(path) {
                    let root;
                    return path.includes("/") ? (root = path.split("/")[0],
                        path = path.replace(root + "/", "")) : (root = path,
                        path = "index"),
                        function requireModule(root, path) {
                            let module = _modules[root];
                            if (!module)
                                throw `Module ${root} not found`;
                            return module = module[path],
                            module._ready || (module._ready = !0,
                            module.exec && module.exec()),
                                module
                        }(root, path).exports
                }
                ,
                this.getConstructor = function(name) {
                    return _constructors[name]
                }
                ,
                window.Module = this.Module,
            window._NODE_ || (window.requireNative = window.require,
                window.require = this.require)
        }
    ), "Static"),
    Class((function LinkedList() {
            var prototype = LinkedList.prototype;
            this.length = 0,
                this.first = null,
                this.last = null,
                this.current = null,
                this.prev = null,
            void 0 === prototype.push && (prototype.push = function(obj) {
                    this.first ? (obj.__next = this.first,
                        obj.__prev = this.last,
                        this.last.__next = obj,
                        this.last = obj) : (this.first = obj,
                        this.last = obj,
                        obj.__prev = obj,
                        obj.__next = obj),
                        this.length++
                }
                    ,
                    prototype.remove = function(obj) {
                        obj && obj.__next && (this.length <= 1 ? this.empty() : (obj == this.first ? (this.first = obj.__next,
                            this.last.__next = this.first,
                            this.first.__prev = this.last) : obj == this.last ? (this.last = obj.__prev,
                            this.last.__next = this.first,
                            this.first.__prev = this.last) : (obj.__prev.__next = obj.__next,
                            obj.__next.__prev = obj.__prev),
                            this.length--),
                            obj.__prev = null,
                            obj.__next = null)
                    }
                    ,
                    prototype.empty = function() {
                        this.first = null,
                            this.last = null,
                            this.current = null,
                            this.prev = null,
                            this.length = 0
                    }
                    ,
                    prototype.start = function() {
                        return this.current = this.first,
                            this.prev = this.current,
                            this.current
                    }
                    ,
                    prototype.next = function() {
                        if (this.current && (this.current = this.current.__next,
                        1 != this.length && this.prev.__next != this.first))
                            return this.prev = this.current,
                                this.current
                    }
                    ,
                    prototype.destroy = function() {
                        return Utils.nullObject(this),
                            null
                    }
            )
        }
    )),
    Class((function ObjectPool(_type, _number=10) {
            var _pool = [];
            this.array = _pool,
                function() {
                    if (_type)
                        for (var i = 0; i < _number; i++)
                            _pool.push(new _type)
                }(),
                this.get = function() {
                    return _pool.shift() || (_type ? new _type : null)
                }
                ,
                this.empty = function() {
                    _pool.length = 0
                }
                ,
                this.put = function(obj) {
                    obj && _pool.push(obj)
                }
                ,
                this.insert = function(array) {
                    void 0 === array.push && (array = [array]);
                    for (var i = 0; i < array.length; i++)
                        _pool.push(array[i])
                }
                ,
                this.length = function() {
                    return _pool.length
                }
                ,
                this.randomize = function() {
                    let array = _pool;
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i],array[j]] = [array[j], array[i]]
                    }
                }
                ,
                this.destroy = function() {
                    for (let i = _pool.length - 1; i >= 0; i--)
                        _pool[i].destroy && _pool[i].destroy();
                    return _pool = null
                }
        }
    )),
    Class((function Gate() {
            var _list = []
                , _map = {};
            this.create = function(name) {
                let promise = Promise.create();
                name ? _map[name] = promise : _list.push(promise)
            }
                ,
                this.open = function(name) {
                    name && (_map[name] || (_map[name] = Promise.create()),
                        _map[name].resolve());
                    let promise = _list.shift();
                    promise && promise.resolve()
                }
                ,
                this.wait = function(name) {
                    return _list.length || name ? name ? (_map[name] || (_map[name] = Promise.create()),
                        _map[name]) : _list[_list.length - 1] || Promise.resolve() : Promise.resolve()
                }
        }
    ), "static"),
    Class((function Assets() {
            const _this = this;
            function AssetList(arr) {
                return arr.__proto__ = AssetList.prototype,
                    arr
            }
            this.__loaded = [],
                this.FLIPY = !0,
                this.CDN = "",
                this.CORS = null,
                this.IMAGES = {},
                this.SDF = {},
                this.JSON = {
                    push: function(prop, value) {
                        this[prop] = value,
                            Object.defineProperty(this, prop, {
                                get: ()=>JSON.parse(JSON.stringify(value))
                            })
                    }
                },
                Object.defineProperty(this.JSON, "push", {
                    enumerable: !1,
                    writable: !0
                }),
                this.SVG = {},
                AssetList.prototype = new Array,
                AssetList.prototype.filter = function(items) {
                    for (let i = this.length - 1; i >= 0; i--)
                        this[i].includes(items) || this.splice(i, 1);
                    return this
                }
                ,
                AssetList.prototype.exclude = function(items) {
                    for (let i = this.length - 1; i >= 0; i--)
                        this[i].includes(items) && this.splice(i, 1);
                    return this
                }
                ,
                AssetList.prototype.prepend = function(prefix) {
                    for (let i = this.length - 1; i >= 0; i--)
                        this[i] = prefix + this[i];
                    return this
                }
                ,
                AssetList.prototype.append = function(suffix) {
                    for (let i = this.length - 1; i >= 0; i--)
                        this[i] = this[i] + suffix;
                    return this
                }
                ,
                this.list = function() {
                    return window.ASSETS || console.warn("ASSETS list not available"),
                        new AssetList(window.ASSETS.slice(0) || [])
                }
                ,
                this.getPath = function(path) {
                    return ~path.indexOf("//") || (path = function parseResolution(path) {
                        if (!window.ASSETS || !ASSETS.RES)
                            return path;
                        var res = ASSETS.RES[path]
                            , ratio = Math.min(Device.pixelRatio, 3);
                        if (!res)
                            return path;
                        if (!res["x" + ratio])
                            return path;
                        var split = path.split("/")
                            , file = split[split.length - 1];
                        return split = file.split("."),
                            path.replace(file, split[0] + "-" + ratio + "x." + split[1])
                    }(path),
                    this.CDN && !~path.indexOf(this.CDN) && (path = this.CDN + path)),
                        path
                }
                ,
                this.loadImage = function(path, isStore) {
                    var img = new Image;
                    return img.crossOrigin = this.CORS,
                        img.src = _this.getPath(path),
                        img.loadPromise = function() {
                            let promise = Promise.create();
                            return img.onload = promise.resolve,
                                promise
                        }
                        ,
                    isStore && (this.IMAGES[path] = img),
                        img
                }
                ,
                this.decodeImage = function(path, params) {
                    let promise = Promise.create()
                        , img = _this.loadImage(path);
                    return img.onload = ()=>promise.resolve(img),
                        img.onerror = ()=>promise.reject(),
                        promise
                }
        }
    ), "static"),
    Class((function AssetLoader(_assets, _callback, ASSETS=Assets) {
            Inherit(this, Events);
            const _this = this;
            let _total = _assets.length
                , _loaded = 0
                , _lastFiredPercent = 0;
            function loadAsset() {
                let path = _assets.splice(_assets.length - 1, 1)[0];
                const name = path.split("assets/").last().split(".")[0]
                    , ext = path.split(".").last().split("?")[0].toLowerCase();
                let timeout = Timer.create(timedOut, AssetLoader.TIMEOUT, path);
                if (!Assets.preventCache && ~Assets.__loaded.indexOf(path))
                    return loaded();
                if (ext.includes(["jpg", "jpeg", "png", "gif"])) {
                    let image = ASSETS.loadImage(path);
                    return image.complete ? loaded() : (image.onload = loaded,
                        void (image.onerror = loaded))
                }
                if (window.AURA && window.AURA.import && "js" == ext)
                    return AURA.import(path),
                        void loaded();
                function loaded() {
                    timeout && clearTimeout(timeout),
                        increment(),
                    _assets.length && loadAsset()
                }
                get(Assets.getPath(path), Assets.HEADERS).then((data=>{
                        Assets.__loaded.push(path),
                        "json" == ext && ASSETS.JSON.push(name, data),
                        "svg" == ext && (ASSETS.SVG[name] = data),
                        "fnt" == ext && (ASSETS.SDF[name.split("/")[1]] = data),
                        "js" == ext && window.eval(data),
                        ext.includes(["fs", "vs", "glsl"]) && window.Shaders && Shaders.parse(data, path),
                            loaded()
                    }
                )).catch((e=>{
                        console.warn(e),
                            loaded()
                    }
                ))
            }
            function increment() {
                let percent = Math.max(_lastFiredPercent, Math.min(1, ++_loaded / _total));
                _this.events.fire(Events.PROGRESS, {
                    percent: percent
                }),
                    _lastFiredPercent = percent,
                _loaded >= _total && defer(complete)
            }
            function complete() {
                _this.completed || (_this.completed = !0,
                    defer((()=>{
                            _callback && _callback(),
                                _this.events.fire(Events.COMPLETE)
                        }
                    )))
            }
            function timedOut(path) {
                console.warn("Asset timed out", path)
            }
            !function() {
                if (!Array.isArray(_assets))
                    throw "AssetLoader requires array of assets to load";
                _assets = _assets.slice(0).reverse(),
                    function init() {
                        if (!_assets.length)
                            return complete();
                        for (let i = 0; i < AssetLoader.SPLIT; i++)
                            _assets.length && loadAsset()
                    }()
            }(),
                this.loadModules = function() {
                    if (!window._BUILT_ || window.AURA)
                        return;
                    this.add(1);
                    let module = window._ES5_ ? "es5-modules" : "modules"
                        , s = document.createElement("script");
                    return s.src = "assets/js/" + module + ".js?" + window._CACHE_,
                        s.async = !0,
                        document.head.appendChild(s),
                        AssetLoader.waitForLib("_MODULES_").then((_=>_this.trigger(1)))
                }
                ,
                this.add = function(num) {
                    _total += num || 1
                }
                ,
                this.trigger = function(num) {
                    for (let i = 0; i < (num || 1); i++)
                        increment()
                }
        }
    ), (()=>{
            AssetLoader.SPLIT = 2,
                AssetLoader.TIMEOUT = 5e3,
                AssetLoader.loadAllAssets = function(callback) {
                    let promise = Promise.create();
                    return callback || (callback = promise.resolve),
                        promise.loader = new AssetLoader(Assets.list(),(()=>{
                                callback && callback(),
                                promise.loader && promise.loader.destroy && (promise.loader = promise.loader.destroy())
                            }
                        )),
                        promise
                }
                ,
                AssetLoader.loadAssets = function(list, callback) {
                    let promise = Promise.create();
                    return callback || (callback = promise.resolve),
                        promise.loader = new AssetLoader(list,(()=>{
                                callback && callback(),
                                promise.loader && promise.loader.destroy && (promise.loader = promise.loader.destroy())
                            }
                        )),
                        promise
                }
                ,
                AssetLoader.waitForLib = function(name, callback) {
                    let promise = Promise.create();
                    return callback || (callback = promise.resolve),
                        Render.start((function check() {
                                window[name] && (Render.stop(check),
                                callback && callback())
                            }
                        )),
                        promise
                }
                ,
                AssetLoader.waitForModules = function() {
                    return AssetLoader.waitForLib(window._BUILT_ ? "_MODULES_" : "zUtils3D")
                }
        }
    )),
    Hydra.ready((function() {
            window.__window = $(window),
                window.__document = $(document),
                window.__body = $(document.getElementsByTagName("body")[0]),
                window.Stage = window.Stage && window.Stage.style ? $(window.Stage) : __body.create("#Stage"),
                Stage.size("100%"),
                Stage.__useFragment = !0,
                Stage.width = window.innerWidth || document.body.clientWidth || document.documentElement.offsetWidth,
                Stage.height = window.innerHeight || document.body.clientHeight || document.documentElement.offsetHeight
        }
    )),
    Class((function CSS() {
            var _obj, _style, _needsUpdate, _this = this;
            function objToCSS(key) {
                var match = key.match(/[A-Z]/)
                    , camelIndex = match ? match.index : null;
                if (camelIndex) {
                    var start = key.slice(0, camelIndex)
                        , end = key.slice(camelIndex);
                    key = start + "-" + end.toLowerCase()
                }
                return key
            }
            function cssToObj(key) {
                var match = key.match(/\-/)
                    , camelIndex = match ? match.index : null;
                if (camelIndex) {
                    var start = key.slice(0, camelIndex)
                        , end = key.slice(camelIndex).slice(1)
                        , letter = end.charAt(0);
                    end = end.slice(1),
                        key = start + (end = letter.toUpperCase() + end)
                }
                return key
            }
            function setHTML() {
                _obj.innerHTML = _style,
                    _needsUpdate = !1
            }
            Hydra.ready((function() {
                    _style = "",
                        (_obj = document.createElement("style")).type = "text/css",
                        document.getElementsByTagName("head")[0].appendChild(_obj)
                }
            )),
                this._read = function() {
                    return _style
                }
                ,
                this._write = function(css) {
                    _style = css,
                    _needsUpdate || (_needsUpdate = !0,
                        defer(setHTML))
                }
                ,
                this.style = function(selector, obj) {
                    var s = selector + " {";
                    for (var key in obj) {
                        var prop = objToCSS(key)
                            , val = obj[key];
                        "string" != typeof val && "opacity" != key && (val += "px"),
                            s += prop + ":" + val + "!important;"
                    }
                    s += "}",
                        _this._write(_style + s)
                }
                ,
                this.get = function(selector, prop) {
                    for (var values = new Object, string = _obj.innerHTML.split(selector + " {"), i = 0; i < string.length; i++) {
                        var str = string[i];
                        if (str.length) {
                            var split = str.split("!important;");
                            for (var j in split)
                                if (split[j].includes(":")) {
                                    var fsplit = split[j].split(":");
                                    "px" == fsplit[1].slice(-2) && (fsplit[1] = Number(fsplit[1].slice(0, -2))),
                                        values[cssToObj(fsplit[0])] = fsplit[1]
                                }
                        }
                    }
                    return prop ? values[prop] : values
                }
                ,
                this.textSize = function($obj) {
                    var $clone = $obj.clone();
                    $clone.css({
                        position: "relative",
                        cssFloat: "left",
                        styleFloat: "left",
                        marginTop: -99999,
                        width: "",
                        height: ""
                    }),
                        __body.addChild($clone);
                    var width = $clone.div.offsetWidth
                        , height = $clone.div.offsetHeight;
                    return $clone.remove(),
                        {
                            width: width,
                            height: height
                        }
                }
                ,
                this.prefix = function(style) {
                    return "" == _this.styles.vendor ? style.charAt(0).toLowerCase() + style.slice(1) : _this.styles.vendor + style
                }
                ,
                this._toCSS = objToCSS
        }
    ), "Static"),
    Class((function HydraObject(_selector, _type, _exists, _useFragment) {
            this._children = new LinkedList,
                this.__useFragment = _useFragment,
                this._initSelector(_selector, _type, _exists)
        }
    ), (()=>{
            var prototype = HydraObject.prototype;
            prototype._initSelector = function(_selector, _type, _exists) {
                if (_selector && "string" != typeof _selector)
                    this.div = _selector;
                else {
                    var first = _selector ? _selector.charAt(0) : null
                        , name = _selector ? _selector.slice(1) : null;
                    if ("." != first && "#" != first && (name = _selector,
                        first = "."),
                        _exists) {
                        if ("#" != first)
                            throw "Hydra Selectors Require #ID";
                        this.div = document.getElementById(name)
                    } else
                        this._type = _type || "div",
                            "svg" == this._type ? (this.div = document.createElementNS("http://www.w3.org/2000/svg", this._type),
                                this.div.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink")) : (this.div = document.createElement(this._type),
                            first && ("#" == first ? this.div.id = name : this.div.className = name))
                }
                this.div.hydraObject = this
            }
                ,
                prototype.add = function(child) {
                    var div = this.div
                        , _this = this
                        , createFrag = function() {
                        _this.__useFragment && (_this._fragment || (_this._fragment = document.createDocumentFragment(),
                            defer((function() {
                                    if (!_this._fragment || !_this.div)
                                        return _this._fragment = null;
                                    _this.div.appendChild(_this._fragment),
                                        _this._fragment = null
                                }
                            ))),
                            div = _this._fragment)
                    };
                    return child.element && child.element instanceof HydraObject ? (createFrag(),
                        div.appendChild(child.element.div),
                        this._children.push(child.element),
                        child.element._parent = this,
                        child.element.div.parentNode = this.div) : child.div ? (createFrag(),
                        div.appendChild(child.div),
                        this._children.push(child),
                        child._parent = this,
                        child.div.parentNode = this.div) : child.nodeName && (createFrag(),
                        div.appendChild(child),
                        child.parentNode = this.div),
                        this
                }
                ,
                prototype.clone = function() {
                    return $(this.div.cloneNode(!0))
                }
                ,
                prototype.create = function(name, type) {
                    var $obj = $(name, type);
                    return this.add($obj),
                        $obj
                }
                ,
                prototype.empty = function() {
                    for (var child = this._children.start(); child; )
                        child && child.remove && child.remove(),
                            child = this._children.next();
                    return this.div.innerHTML = "",
                        this
                }
                ,
                prototype.parent = function() {
                    return this._parent
                }
                ,
                prototype.children = function() {
                    return this.div.children ? this.div.children : this.div.childNodes
                }
                ,
                prototype.removeChild = function(object, keep) {
                    try {
                        object.div.parentNode.removeChild(object.div)
                    } catch (e) {}
                    keep || this._children.remove(object)
                }
                ,
                prototype.remove = prototype.destroy = function() {
                    this.removed = !0;
                    var parent = this._parent;
                    parent && !parent.removed && parent.removeChild && parent.removeChild(this, !0);
                    for (var child = this._children.start(); child; )
                        child && child.remove && child.remove(),
                            child = this._children.next();
                    this._children.destroy(),
                        this.div.hydraObject = null,
                        Utils.nullObject(this)
                }
                ,
                window.$ = function(selector, type, exists) {
                    return new HydraObject(selector,type,exists)
                }
                ,
                $.fn = HydraObject.prototype
        }
    )),
    $.fn.text = function(text) {
        return void 0 !== text ? (this.__cacheText != text && (this.div.textContent = text),
            this.__cacheText = text,
            this) : this.div.textContent
    }
    ,
    $.fn.html = function(text, force) {
        return !text || text.includes("<") || force ? void 0 !== text ? (this.div.innerHTML = text,
            this) : this.div.innerHTML : this.text(text)
    }
    ,
    $.fn.hide = function() {
        return this.div.style.display = "none",
            this
    }
    ,
    $.fn.show = function() {
        return this.div.style.display = "",
            this
    }
    ,
    $.fn.visible = function() {
        return this.div.style.visibility = "visible",
            this
    }
    ,
    $.fn.invisible = function() {
        return this.div.style.visibility = "hidden",
            this
    }
    ,
    $.fn.setZ = function(z) {
        return this.div.style.zIndex = z,
            this
    }
    ,
    $.fn.clearAlpha = function() {
        return this.div.style.opacity = "",
            this
    }
    ,
    $.fn.size = function(w, h, noScale) {
        return "string" == typeof w ? (void 0 === h ? h = "100%" : "string" != typeof h && (h += "px"),
            this.div.style.width = w,
            this.div.style.height = h) : (this.div.style.width = w + "px",
            this.div.style.height = h + "px",
        noScale || (this.div.style.backgroundSize = w + "px " + h + "px")),
            this.width = w,
            this.height = h,
            this
    }
    ,
    $.fn.mouseEnabled = function(bool) {
        return this.div.style.pointerEvents = bool ? "auto" : "none",
            this
    }
    ,
    $.fn.fontStyle = function(family, size, color, style) {
        var font = {};
        return family && (font.fontFamily = family),
        size && (font.fontSize = size),
        color && (font.color = color),
        style && (font.fontStyle = style),
            this.css(font),
            this
    }
    ,
    $.fn.font = function(font) {
        return this.css("font", font),
            this
    }
    ,
    $.fn.bg = function(src, x, y, repeat) {
        return src ? (src.includes(".") && (src = Assets.getPath(src)),
            src.includes(".") ? this.div.style.backgroundImage = "url(" + src + ")" : this.div.style.backgroundColor = src,
        void 0 !== x && (x = "number" == typeof x ? x + "px" : x,
            y = "number" == typeof y ? y + "px" : y,
            this.div.style.backgroundPosition = x + " " + y),
        repeat && (this.div.style.backgroundSize = "",
            this.div.style.backgroundRepeat = repeat),
        "cover" != x && "contain" != x || (this.div.style.backgroundSize = x,
            this.div.style.backgroundPosition = void 0 !== y ? y + " " + repeat : "center"),
            this) : this
    }
    ,
    $.fn.center = function(x, y, noPos) {
        var css = {};
        return void 0 === x ? (css.left = "50%",
            css.top = "50%",
            css.marginLeft = -this.width / 2,
            css.marginTop = -this.height / 2) : (x && (css.left = "50%",
            css.marginLeft = -this.width / 2),
        y && (css.top = "50%",
            css.marginTop = -this.height / 2)),
        noPos && (delete css.left,
            delete css.top),
            this.css(css),
            this
    }
    ,
    $.fn.max = function(width, height) {
        let w, h;
        return void 0 !== width && (w = "number" == typeof width ? width + "px" : width,
            this.div.style.maxWidth = w),
            void 0 !== height ? (h = "number" == typeof height ? height + "px" : height,
                this.div.style.maxHeight = h) : (h = w,
                this.div.style.maxHeight = h),
            this
    }
    ,
    $.fn.min = function(width, height) {
        let w, h;
        return void 0 !== width && (w = "number" == typeof width ? width + "px" : width,
            this.div.style.minWidth = w),
            void 0 !== height ? (h = "number" == typeof height ? height + "px" : height,
                this.div.style.minHeight = h) : (h = w,
                this.div.style.minHeight = h),
            this
    }
    ,
    $.fn.flex = function(inline) {
        return this.div.style.display = inline ? "inline-flex" : "flex",
            this.div.style.justifyContent = "center",
            this.div.style.alignItems = "center",
            this.div.classList.add("relative-children"),
            this
    }
    ,
    $.fn.order = function(opts={}) {
        let s = this.div.style;
        return "none" === opts.flexWrap && (opts.flexWrap = "nowrap"),
        opts.direction && (s.flexDirection = opts.direction),
        opts.wrap && (s.flexWrap = opts.wrap),
        opts.order && (s.order = opts.order),
            this
    }
    ,
    $.fn.align = function(opts={}) {
        let s = this.div.style;
        function flex(str, contentMode=!1) {
            return "start" === str ? "flex-start" : "end" === str ? "flex-end" : "between" === str ? contentMode ? "space-between" : "flex-between" : "around" === str ? contentMode ? "space-around" : "flex-around" : "none" === str ? "nowrap" : str
        }
        return opts.justify && (s.justifyContent = flex(opts.justify)),
        opts.items && (s.alignItems = flex(opts.items)),
        opts.self && (s.alignSelf = flex(opts.self)),
        opts.content && (s.alignContent = flex(opts.content, !0)),
            this
    }
    ,
    $.fn.flexibility = function(opts={}) {
        let s = this.div.style;
        return "undefined" !== opts.grow && (s.flexGrow = opts.grow),
        "undefined" !== opts.shrink && (s.flexGrow = opts.shrink),
        void 0 !== opts.basis && (s.flexBasis = "number" == typeof opts.basis ? opts.basis + "px" : opts.basis),
            this
    }
    ,
    $.fn.mask = function(arg) {
        let maskPrefix = "Moz" === CSS.styles.vendor ? "mask" : CSS.prefix("Mask");
        return this.div.style[maskPrefix] = (arg.includes(".") ? "url(" + arg + ")" : arg) + " no-repeat",
            this.div.style[maskPrefix + "Size"] = "contain",
            this
    }
    ,
    $.fn.blendMode = function(mode, bg) {
        return bg ? this.div.style["background-blend-mode"] = mode : this.div.style["mix-blend-mode"] = mode,
            this
    }
    ,
    $.fn.css = function(obj, value) {
        if ("boolean" == typeof value && (value = null),
        "object" != typeof obj) {
            if (value)
                return this.div.style[obj] = value,
                    this;
            var style = this.div.style[obj];
            if ("number" != typeof style) {
                if (!style)
                    return !1;
                style.includes("px") && (style = Number(style.slice(0, -2))),
                "opacity" == obj && (style = isNaN(Number(this.div.style.opacity)) ? 1 : Number(this.div.style.opacity))
            }
            return style || (style = 0),
                style
        }
        for (var type in TweenManager._clearCSSTween(this),
            obj) {
            var val = obj[type];
            "string" != typeof val && "number" != typeof val || ("string" != typeof val && "opacity" != type && "zIndex" != type && (val += "px"),
                this.div.style[type] = val)
        }
        return this
    }
    ,
    $.fn.transform = function(props) {
        if (!(this.multiTween && this.cssTweens && this._cssTweens.length > 1 && this.__transformTime && Render.TIME - this.__transformTime < 15)) {
            if (this.__transformTime = Render.TIME,
                TweenManager._clearCSSTween(this),
                Device.tween.css2d) {
                if (props)
                    for (var key in props)
                        "number" == typeof props[key] && (this[key] = props[key]);
                else
                    props = this;
                var transformString = TweenManager._parseTransform(props);
                this.__transformCache != transformString && (this.div.style[CSS.styles.vendorTransform] = transformString,
                    this.__transformCache = transformString)
            }
            return this
        }
    }
    ,
    $.fn.willChange = function(props) {
        if ("boolean" == typeof props)
            this._willChangeLock = !0 === props;
        else if (this._willChangeLock)
            return;
        var string = "string" == typeof props;
        this._willChange && !string || "null" == typeof props ? (this._willChange = !1,
            this.div.style["will-change"] = "") : (this._willChange = !0,
            this.div.style["will-change"] = string ? props : CSS.transformProperty + ", opacity")
    }
    ,
    $.fn.backfaceVisibility = function(visible) {
        this.div.style[CSS.prefix("BackfaceVisibility")] = visible ? "visible" : "hidden"
    }
    ,
    $.fn.enable3D = function(perspective, x, y) {
        return Device.tween.css3d ? (this.div.style[CSS.prefix("TransformStyle")] = "preserve-3d",
        perspective && (this.div.style[CSS.prefix("Perspective")] = perspective + "px"),
        void 0 !== x && (x = "number" == typeof x ? x + "px" : x,
            y = "number" == typeof y ? y + "px" : y,
            this.div.style[CSS.prefix("PerspectiveOrigin")] = x + " " + y),
            this) : this
    }
    ,
    $.fn.disable3D = function() {
        return this.div.style[CSS.prefix("TransformStyle")] = "",
            this.div.style[CSS.prefix("Perspective")] = "",
            this
    }
    ,
    $.fn.transformPoint = function(x, y, z) {
        var origin = "";
        return void 0 !== x && (origin += "number" == typeof x ? x + "px " : x + " "),
        void 0 !== y && (origin += "number" == typeof y ? y + "px " : y + " "),
        void 0 !== z && (origin += "number" == typeof z ? z + "px" : z),
            this.div.style[CSS.prefix("TransformOrigin")] = origin,
            this
    }
    ,
    $.fn.tween = function(props, time, ease, delay, callback, manual) {
        "boolean" == typeof delay ? (manual = delay,
            delay = 0,
            callback = null) : "function" == typeof delay && (callback = delay,
            delay = 0),
        "boolean" == typeof callback && (manual = callback,
            callback = null),
        delay || (delay = 0);
        var usePromise = null;
        callback && callback instanceof Promise && (usePromise = callback,
            callback = callback.resolve);
        var tween = TweenManager._detectTween(this, props, time, ease, delay, callback, manual);
        return usePromise || tween
    }
    ,
    $.fn.clearTransform = function() {
        return "number" == typeof this.x && (this.x = 0),
        "number" == typeof this.y && (this.y = 0),
        "number" == typeof this.z && (this.z = 0),
        "number" == typeof this.scale && (this.scale = 1),
        "number" == typeof this.scaleX && (this.scaleX = 1),
        "number" == typeof this.scaleY && (this.scaleY = 1),
        "number" == typeof this.rotation && (this.rotation = 0),
        "number" == typeof this.rotationX && (this.rotationX = 0),
        "number" == typeof this.rotationY && (this.rotationY = 0),
        "number" == typeof this.rotationZ && (this.rotationZ = 0),
        "number" == typeof this.skewX && (this.skewX = 0),
        "number" == typeof this.skewY && (this.skewY = 0),
            this.div.style[CSS.styles.vendorTransform] = "",
            this
    }
    ,
    $.fn.clearTween = function() {
        return this._cssTween && this._cssTween.stop(),
        this._mathTween && this._mathTween.stop(),
            this
    }
    ,
    $.fn.stopTween = function() {
        return console.warn(".stopTween deprecated. use .clearTween instead"),
            this.clearTween()
    }
    ,
    $.fn.keypress = function(callback) {
        this.div.onkeypress = function(e) {
            (e = e || window.event).code = e.keyCode ? e.keyCode : e.charCode,
            callback && callback(e)
        }
    }
    ,
    $.fn.keydown = function(callback) {
        this.div.onkeydown = function(e) {
            (e = e || window.event).code = e.keyCode,
            callback && callback(e)
        }
    }
,
$.fn.keyup = function(callback) {
    this.div.onkeyup = function(e) {
        (e = e || window.event).code = e.keyCode,
        callback && callback(e)
    }
}
,
$.fn.attr = function(attr, value) {
    if (attr && value)
        "" == value ? this.div.removeAttribute(attr) : this.div.setAttribute(attr, value);
    else if (attr)
        return this.div.getAttribute(attr);
    return this
}
,
$.fn.val = function(value) {
    return void 0 === value ? this.div.value : (this.div.value = value,
        this)
}
,
$.fn.change = function(callback) {
    var _this = this;
    "select" == this._type && (this.div.onchange = function() {
            callback({
                object: _this,
                value: _this.div.value || ""
            })
        }
    )
}
,
$.fn.svgSymbol = function(id, width, height) {
    var config = SVG.getSymbolConfig(id)
        , svgHTML = '<svg viewBox="0 0 ' + config.width + " " + config.height + '" width="' + width + '" height="' + height + '"><use xlink:href="#' + config.id + '" x="0" y="0" /></svg>';
    this.html(svgHTML, !0)
}
,
$.fn.overflowScroll = function(dir) {
    var x = !!dir.x
        , y = !!dir.y
        , overflow = {};
    (!x && !y || x && y) && (overflow.overflow = "auto"),
    !x && y && (overflow.overflowY = "auto",
        overflow.overflowX = "hidden"),
    x && !y && (overflow.overflowX = "auto",
        overflow.overflowY = "hidden"),
    Device.mobile && (overflow["-webkit-overflow-scrolling"] = "touch",
        Mobile._addOverflowScroll(this)),
        this.css(overflow)
}
,
$.fn.removeOverflowScroll = function() {
    this.css({
        overflow: "hidden",
        overflowX: "",
        overflowY: "",
        "-webkit-overflow-scrolling": ""
    }),
    Device.mobile && Mobile._removeOverflowScroll(this)
}
,
$.fn.accessible = function(type="label", tabIndex=-1) {
    switch (tabIndex > -1 && this.attr("tabindex", tabIndex),
        type) {
        case "label":
            this.attr("aria-label", this.div.textContent);
            break;
        case "hidden":
            this.attr("aria-hidden", !0)
    }
}
,
$.fn.tabIndex = function(tabIndex) {
    this.attr("tabindex", tabIndex)
}
,
function() {
    var windowsPointer = !!window.MSGesture
        , translateEvent = function(evt) {
        if (windowsPointer)
            switch (evt) {
                case "touchstart":
                    return "pointerdown";
                case "touchmove":
                    return "MSGestureChange";
                case "touchend":
                    return "pointerup"
            }
        return evt
    }
        , convertTouchEvent = function(e) {
        var touchEvent = {
            x: 0,
            y: 0
        };
        if (e.windowsPointer)
            return e;
        if (!e)
            return touchEvent;
        if (e.touches || e.changedTouches ? e.touches.length ? (touchEvent.x = e.touches[0].pageX,
            touchEvent.y = e.touches[0].pageY) : (touchEvent.x = e.changedTouches[0].pageX,
            touchEvent.y = e.changedTouches[0].pageY) : (touchEvent.x = e.pageX,
            touchEvent.y = e.pageY),
        Mobile.ScreenLock && Mobile.ScreenLock.isActive && Mobile.orientationSet && Mobile.orientation !== Mobile.orientationSet) {
            if (90 == window.orientation || 0 === window.orientation) {
                var x = touchEvent.y;
                touchEvent.y = touchEvent.x,
                    touchEvent.x = Stage.width - x
            }
            if (-90 == window.orientation || 180 === window.orientation) {
                var y = touchEvent.x;
                touchEvent.x = touchEvent.y,
                    touchEvent.y = Stage.height - y
            }
        }
        return touchEvent
    };
    $.fn.click = function(callback) {
        var _this = this;
        return this.div.addEventListener(translateEvent("click"), (function click(e) {
                return !!_this.div && (!Mouse._preventClicks && (e.object = "hit" == _this.div.className ? _this.parent() : _this,
                    e.action = "click",
                e.pageX || (e.pageX = e.clientX,
                    e.pageY = e.clientY),
                callback && callback(e),
                    void (Mouse.autoPreventClicks && Mouse.preventClicks())))
            }
        ), !0),
            this.div.style.cursor = "pointer",
            this
    }
        ,
        $.fn.hover = function(callback) {
            var _time, _this = this, _over = !1;
            function hover(e) {
                if (!_this.div)
                    return !1;
                var time = performance.now()
                    , original = e.toElement || e.relatedTarget;
                if (_time && time - _time < 5)
                    return _time = time,
                        !1;
                switch (_time = time,
                    e.object = "hit" == _this.div.className ? _this.parent() : _this,
                    e.type) {
                    case "mouseout":
                    case "mouseleave":
                        e.action = "out";
                        break;
                    default:
                        e.action = "over"
                }
                if (_over) {
                    if (Mouse._preventClicks)
                        return !1;
                    if ("over" == e.action)
                        return !1;
                    if ("out" == e.action && isAChild(_this.div, original))
                        return !1;
                    _over = !1
                } else {
                    if ("out" == e.action)
                        return !1;
                    _over = !0
                }
                e.pageX || (e.pageX = e.clientX,
                    e.pageY = e.clientY),
                callback && callback(e)
            }
            function isAChild(div, object) {
                for (var len = div.children.length - 1, i = len; i > -1; i--)
                    if (object == div.children[i])
                        return !0;
                for (i = len; i > -1; i--)
                    if (isAChild(div.children[i], object))
                        return !0
            }
            return this.div.addEventListener(translateEvent("mouseover"), hover, !0),
                this.div.addEventListener(translateEvent("mouseout"), hover, !0),
                this
        }
        ,
        $.fn.press = function(callback) {
            var _this = this;
            function press(e) {
                if (!_this.div)
                    return !1;
                switch (e.object = "hit" == _this.div.className ? _this.parent() : _this,
                    e.type) {
                    case "mousedown":
                        e.action = "down";
                        break;
                    default:
                        e.action = "up"
                }
                e.pageX || (e.pageX = e.clientX,
                    e.pageY = e.clientY),
                callback && callback(e)
            }
            return this.div.addEventListener(translateEvent("mousedown"), press, !0),
                this.div.addEventListener(translateEvent("mouseup"), press, !0),
                this
        }
        ,
        $.fn.bind = function(evt, callback) {
            if (this._events = this._events || {},
            windowsPointer && this == __window)
                return Stage.bind(evt, callback);
            "touchstart" == evt ? Device.mobile || (Device.touchCapable ? this.bind("mousedown", callback) : evt = "mousedown") : "touchmove" == evt ? (Device.mobile || (Device.touchCapable ? this.bind("mousemove", callback) : evt = "mousemove"),
            windowsPointer && !this.div.msGesture && (this.div.msGesture = new MSGesture,
                this.div.msGesture.target = this.div)) : "touchend" == evt && (Device.mobile || (Device.touchCapable ? this.bind("mouseup", callback) : evt = "mouseup")),
                this._events["bind_" + evt] = this._events["bind_" + evt] || [];
            var _events = this._events["bind_" + evt]
                , e = {}
                , target = this.div;
            function touchEvent(e) {
                windowsPointer && target.msGesture && "touchstart" == evt && target.msGesture.addPointer(e.pointerId),
                Device.mobile || "touchstart" != evt || e.preventDefault();
                var touch = convertTouchEvent(e);
                if (windowsPointer) {
                    var windowsEvt = e;
                    (e = {}).x = Number(windowsEvt.pageX || windowsEvt.clientX),
                        e.y = Number(windowsEvt.pageY || windowsEvt.clientY),
                        e.target = windowsEvt.target,
                        e.currentTarget = windowsEvt.currentTarget,
                        e.path = [];
                    for (var node = e.target; node; )
                        e.path.push(node),
                            node = node.parentElement || null;
                    e.windowsPointer = !0
                } else
                    e.x = touch.x,
                        e.y = touch.y;
                for (var i = 0; i < _events.length; i++) {
                    var ev = _events[i];
                    ev.target == e.currentTarget && ev.callback(e)
                }
            }
            return e.callback = callback,
                e.target = this.div,
                _events.push(e),
            this._events["fn_" + evt] || (this._events["fn_" + evt] = touchEvent,
                this.div.addEventListener(translateEvent(evt), touchEvent, {
                    capture: !0,
                    passive: !1
                })),
                this
        }
        ,
        $.fn.unbind = function(evt, callback) {
            if (this._events = this._events || {},
            windowsPointer && this == __window)
                return Stage.unbind(evt, callback);
            "touchstart" == evt ? Device.mobile || (Device.touchCapable ? this.unbind("mousedown", callback) : evt = "mousedown") : "touchmove" == evt ? Device.mobile || (Device.touchCapable ? this.unbind("mousemove", callback) : evt = "mousemove") : "touchend" == evt && (Device.mobile || (Device.touchCapable ? this.unbind("mouseup", callback) : evt = "mouseup"));
            var _events = this._events["bind_" + evt];
            if (!_events)
                return this;
            for (var i = 0; i < _events.length; i++) {
                _events[i].callback == callback && _events.splice(i, 1)
            }
            return this._events["fn_" + evt] && !_events.length && (this.div.removeEventListener(translateEvent(evt), this._events["fn_" + evt], !Device.mobile || {
                passive: !0
            }),
                this._events["fn_" + evt] = null),
                this
        }
        ,
        $.fn.interact = function(overCallback, clickCallback, seoLink, seoText) {
            this.hit || (this.hit = $(".hit", seoLink ? "a" : void 0),
                this.hit.css({
                    width: "100%",
                    height: "100%",
                    zIndex: 99999,
                    top: 0,
                    left: 0,
                    position: "absolute"
                }),
                this.add(this.hit),
            seoLink && (this.hit.attr("href", Hydra.absolutePath(seoLink)),
                    this.hit.text(seoText || this.div.textContent),
                    this.hit.css({
                        fontSize: 0
                    }),
                    this.hit.accessible(),
                    this.hit.div.onfocus = _=>overCallback({
                        action: "over"
                    }),
                    this.hit.div.onblur = _=>overCallback({
                        action: "out"
                    }),
                    this.hit.div.onclick = e=>{
                        e.preventDefault(),
                            clicked(e)
                    }
            ));
            let time = Render.TIME;
            function clicked(e) {
                clickCallback && Render.TIME - time > 100 && clickCallback(e),
                    time = Render.TIME
            }
            Device.mobile ? this.hit.touchClick(overCallback, clicked).click(clicked) : this.hit.hover(overCallback).click(clicked)
        }
        ,
        $.fn.touchSwipe = function(callback, distance) {
            if (!window.addEventListener)
                return this;
            var _startX, _startY, _this = this, _distance = distance || 75, _moving = !1, _move = {};
            function touchMove(e) {
                if (!_this.div)
                    return !1;
                if (_moving) {
                    var touch = convertTouchEvent(e)
                        , dx = _startX - touch.x
                        , dy = _startY - touch.y;
                    _move.direction = null,
                        _move.moving = null,
                        _move.x = null,
                        _move.y = null,
                        _move.evt = e,
                        Math.abs(dx) >= _distance ? (touchEnd(),
                            _move.direction = dx > 0 ? "left" : "right") : Math.abs(dy) >= _distance ? (touchEnd(),
                            _move.direction = dy > 0 ? "up" : "down") : (_move.moving = !0,
                            _move.x = dx,
                            _move.y = dy),
                    callback && callback(_move, e)
                }
            }
            function touchEnd(e) {
                if (!_this.div)
                    return !1;
                _startX = _startY = _moving = !1,
                    _this.div.removeEventListener(translateEvent("touchmove"), touchMove)
            }
            return console.log(_this.div),
            Device.mobile && (this.div.addEventListener(translateEvent("touchstart"), (function touchStart(e) {
                    var touch = convertTouchEvent(e);
                    if (!_this.div)
                        return !1;
                    1 == e.touches.length && (console.log(e.touches),
                        _startX = touch.x,
                        _startY = touch.y,
                        _moving = !0,
                        _this.div.addEventListener(translateEvent("touchmove"), touchMove, {
                            passive: !0
                        }))
                }
            ), {
                passive: !0
            }),
                this.div.addEventListener(translateEvent("touchend"), touchEnd, {
                    passive: !0
                }),
                this.div.addEventListener(translateEvent("touchcancel"), touchEnd, {
                    passive: !0
                })),
                this
        }
        ,
        $.fn.touchClick = function(hover, click) {
            if (!window.addEventListener)
                return this;
            var _time, _move, _this = this, _start = {}, _touch = {};
            function setTouch(e) {
                var touch = convertTouchEvent(e);
                e.touchX = touch.x,
                    e.touchY = touch.y,
                    _start.x = e.touchX,
                    _start.y = e.touchY
            }
            return Device.mobile && (this.div.addEventListener(translateEvent("touchstart"), (function touchStart(e) {
                    if (!_this.div)
                        return !1;
                    _time = performance.now(),
                        e.action = "over",
                        e.object = "hit" == _this.div.className ? _this.parent() : _this,
                        setTouch(e),
                    hover && !_move && hover(e)
                }
            ), {
                passive: !0
            }),
                this.div.addEventListener(translateEvent("touchend"), (function touchEnd(e) {
                        if (!_this.div)
                            return !1;
                        var time = performance.now();
                        if (_touch = convertTouchEvent(e),
                            _move = function findDistance(p1, p2) {
                                var dx = p2.x - p1.x
                                    , dy = p2.y - p1.y;
                                return Math.sqrt(dx * dx + dy * dy)
                            }(_start, _touch) > 5,
                            e.object = "hit" == _this.div.className ? _this.parent() : _this,
                            setTouch(e),
                        _time && time - _time < 750) {
                            if (Mouse._preventClicks)
                                return !1;
                            click && !_move && (!0,
                                e.action = "click",
                            click && !_move && click(e),
                            Mouse.autoPreventClicks && Mouse.preventClicks())
                        }
                        hover && (e.action = "out",
                        Mouse._preventFire || hover(e));
                        _move = !1
                    }
                ), {
                    passive: !0
                })),
                this
        }
}(),
Class((function Element(type="div") {
        Inherit(this, Component);
        var name = Utils.getConstructorName(this);
        this.__element = !0,
            this.element = $("." + name, type),
            this.element.__useFragment = !0,
            this.destroy = function() {
                this.element && this.element.remove && (this.element = this.element.remove()),
                this._destroy && this._destroy()
            }
    }
)),
Hydra.ready((()=>{
        TweenManager.Transforms = ["scale", "scaleX", "scaleY", "x", "y", "z", "rotation", "rotationX", "rotationY", "rotationZ", "skewX", "skewY", "perspective"],
            TweenManager.CubicEases = [{
                name: "easeOutCubic",
                curve: "cubic-bezier(0.215, 0.610, 0.355, 1.000)"
            }, {
                name: "easeOutQuad",
                curve: "cubic-bezier(0.250, 0.460, 0.450, 0.940)"
            }, {
                name: "easeOutQuart",
                curve: "cubic-bezier(0.165, 0.840, 0.440, 1.000)"
            }, {
                name: "easeOutQuint",
                curve: "cubic-bezier(0.230, 1.000, 0.320, 1.000)"
            }, {
                name: "easeOutSine",
                curve: "cubic-bezier(0.390, 0.575, 0.565, 1.000)"
            }, {
                name: "easeOutExpo",
                curve: "cubic-bezier(0.190, 1.000, 0.220, 1.000)"
            }, {
                name: "easeOutCirc",
                curve: "cubic-bezier(0.075, 0.820, 0.165, 1.000)"
            }, {
                name: "easeOutBack",
                curve: "cubic-bezier(0.175, 0.885, 0.320, 1.275)"
            }, {
                name: "easeInCubic",
                curve: "cubic-bezier(0.550, 0.055, 0.675, 0.190)"
            }, {
                name: "easeInQuad",
                curve: "cubic-bezier(0.550, 0.085, 0.680, 0.530)"
            }, {
                name: "easeInQuart",
                curve: "cubic-bezier(0.895, 0.030, 0.685, 0.220)"
            }, {
                name: "easeInQuint",
                curve: "cubic-bezier(0.755, 0.050, 0.855, 0.060)"
            }, {
                name: "easeInSine",
                curve: "cubic-bezier(0.470, 0.000, 0.745, 0.715)"
            }, {
                name: "easeInCirc",
                curve: "cubic-bezier(0.600, 0.040, 0.980, 0.335)"
            }, {
                name: "easeInBack",
                curve: "cubic-bezier(0.600, -0.280, 0.735, 0.045)"
            }, {
                name: "easeInOutCubic",
                curve: "cubic-bezier(0.645, 0.045, 0.355, 1.000)"
            }, {
                name: "easeInOutQuad",
                curve: "cubic-bezier(0.455, 0.030, 0.515, 0.955)"
            }, {
                name: "easeInOutQuart",
                curve: "cubic-bezier(0.770, 0.000, 0.175, 1.000)"
            }, {
                name: "easeInOutQuint",
                curve: "cubic-bezier(0.860, 0.000, 0.070, 1.000)"
            }, {
                name: "easeInOutSine",
                curve: "cubic-bezier(0.445, 0.050, 0.550, 0.950)"
            }, {
                name: "easeInOutExpo",
                curve: "cubic-bezier(1.000, 0.000, 0.000, 1.000)"
            }, {
                name: "easeInOutCirc",
                curve: "cubic-bezier(0.785, 0.135, 0.150, 0.860)"
            }, {
                name: "easeInOutBack",
                curve: "cubic-bezier(0.680, -0.550, 0.265, 1.550)"
            }, {
                name: "easeInOut",
                curve: "cubic-bezier(.42,0,.58,1)"
            }, {
                name: "linear",
                curve: "linear"
            }],
            TweenManager.useCSSTrans = function(props, ease, object) {
                return !(props.math || "string" == typeof ease && ease.includes(["Elastic", "Bounce"]) || object.multiTween || TweenManager._inspectEase(ease).path || !Device.tween.transition)
            }
            ,
            TweenManager._detectTween = function(object, props, time, ease, delay, callback) {
                return TweenManager.useCSSTrans(props, ease, object) ? new CSSTransition(object,props,time,ease,delay,callback) : new FrameTween(object,props,time,ease,delay,callback)
            }
            ,
            TweenManager._parseTransform = function(props) {
                var transforms = ""
                    , translate = "";
                if (props.perspective > 0 && (transforms += "perspective(" + props.perspective + "px)"),
                void 0 !== props.x || void 0 !== props.y || void 0 !== props.z) {
                    var x = props.x || 0
                        , y = props.y || 0
                        , z = props.z || 0;
                    translate += x + ("string" == typeof props.x && (props.x.includes("%") || props.x.includes("vw") || props.x.includes("vh")) ? "" : "px") + ", ",
                        translate += y + ("string" == typeof props.y && (props.y.includes("%") || props.y.includes("vw") || props.y.includes("vh")) ? "" : "px"),
                        Device.tween.css3d ? transforms += "translate3d(" + (translate += ", " + z + "px") + ")" : transforms += "translate(" + translate + ")"
                }
                return void 0 !== props.scale ? transforms += "scale(" + props.scale + ")" : (void 0 !== props.scaleX && (transforms += "scaleX(" + props.scaleX + ")"),
                void 0 !== props.scaleY && (transforms += "scaleY(" + props.scaleY + ")")),
                void 0 !== props.rotation && (transforms += "rotate(" + props.rotation + "deg)"),
                void 0 !== props.rotationX && (transforms += "rotateX(" + props.rotationX + "deg)"),
                void 0 !== props.rotationY && (transforms += "rotateY(" + props.rotationY + "deg)"),
                void 0 !== props.rotationZ && (transforms += "rotateZ(" + props.rotationZ + "deg)"),
                void 0 !== props.skewX && (transforms += "skewX(" + props.skewX + "deg)"),
                void 0 !== props.skewY && (transforms += "skewY(" + props.skewY + "deg)"),
                    transforms
            }
            ,
            TweenManager._clearCSSTween = function(obj) {
                obj && !obj._cssTween && obj.div._transition && !obj.persistTween && (obj.div.style[CSS.styles.vendorTransition] = "",
                    obj.div._transition = !1,
                    obj._cssTween = null)
            }
            ,
            TweenManager._isTransform = function(key) {
                return TweenManager.Transforms.indexOf(key) > -1
            }
            ,
            TweenManager._getAllTransforms = function(object) {
                for (var obj = {}, i = TweenManager.Transforms.length - 1; i > -1; i--) {
                    var tf = TweenManager.Transforms[i]
                        , val = object[tf];
                    0 !== val && "number" == typeof val && (obj[tf] = val)
                }
                return obj
            }
        ;
        const prefix = function() {
            let pre = ""
                , dom = "";
            try {
                var styles = window.getComputedStyle(document.documentElement, "");
                return pre = (Array.prototype.slice.call(styles).join("").match(/-(moz|webkit|ms)-/) || "" === styles.OLink && ["", "o"])[1],
                    dom = "WebKit|Moz|MS|O".match(new RegExp("(" + pre + ")","i"))[1],
                    {
                        unprefixed: "ie" == Device.system.browser && !Device.detect("msie 9"),
                        dom: dom,
                        lowercase: pre,
                        css: "-" + pre + "-",
                        js: ("ie" == Device.system.browser ? pre[0] : pre[0].toUpperCase()) + pre.substr(1)
                    }
            } catch (e) {
                return {
                    unprefixed: !0,
                    dom: "",
                    lowercase: "",
                    css: "",
                    js: ""
                }
            }
        }();
        CSS.styles = {},
            CSS.styles.vendor = prefix.unprefixed ? "" : prefix.js,
            CSS.styles.vendorTransition = CSS.styles.vendor.length ? CSS.styles.vendor + "Transition" : "transition",
            CSS.styles.vendorTransform = CSS.styles.vendor.length ? CSS.styles.vendor + "Transform" : "transform",
            CSS.vendor = prefix.css,
            CSS.transformProperty = function() {
                switch (prefix.lowercase) {
                    case "moz":
                        return "-moz-transform";
                    case "webkit":
                        return "-webkit-transform";
                    case "o":
                        return "-o-transform";
                    case "ms":
                        return "-ms-transform";
                    default:
                        return "transform"
                }
            }(),
            CSS.tween = {},
            CSS.tween.complete = prefix.unprefixed ? "transitionend" : prefix.lowercase + "TransitionEnd"
    }
)),
Class((function CSSTransition(_object, _props, _time, _ease, _delay, _callback) {
        const _this = this;
        let _transformProps, _transitionProps;
        function killed() {
            return !_this || _this.kill || !_object || !_object.div
        }
        function clearCSSTween() {
            killed() || (_this.playing = !1,
                _object._cssTween = null,
                _object.willChange(null),
                _object = _props = null,
                Utils.nullObject(this))
        }
        this.playing = !0,
            function() {
                if ("number" != typeof _time)
                    throw "CSSTween Requires object, props, time, ease";
                !function initProperties() {
                    var transform = TweenManager._getAllTransforms(_object)
                        , properties = [];
                    for (var key in _props)
                        TweenManager._isTransform(key) ? (transform.use = !0,
                            transform[key] = _props[key],
                            delete _props[key]) : ("number" == typeof _props[key] || key.includes(["-", "color"])) && properties.push(key);
                    transform.use && (properties.push(CSS.transformProperty),
                        delete transform.use);
                    _transformProps = transform,
                        _transitionProps = properties
                }(),
                    async function initCSSTween(values) {
                        if (killed())
                            return;
                        _object._cssTween && (_object._cssTween.kill = !0);
                        _object._cssTween = _this,
                            _object.div._transition = !0;
                        var strings = function buildStrings(time, ease, delay) {
                            for (var props = "", str = "", len = _transitionProps.length, i = 0; i < len; i++) {
                                var transitionProp = _transitionProps[i];
                                props += (props.length ? ", " : "") + transitionProp,
                                    str += (str.length ? ", " : "") + transitionProp + " " + time + "ms " + TweenManager._getEase(ease) + " " + delay + "ms"
                            }
                            return {
                                props: props,
                                transition: str
                            }
                        }(_time, _ease, _delay);
                        _object.willChange(strings.props);
                        var time = values ? values.time : _time
                            , delay = values ? values.delay : _delay
                            , props = values ? values.props : _props
                            , transformProps = values ? values.transform : _transformProps;
                        if (_this.time = _time,
                            _this.delay = _delay,
                            await Timer.delayedCall(32),
                            killed())
                            return;
                        if (_object.div.style[CSS.styles.vendorTransition] = strings.transition,
                            _this.playing = !0,
                        "safari" == Device.system.browser) {
                            if (Device.system.browserVersion < 11 && await Timer.delayedCall(16),
                                killed())
                                return;
                            _object.css(props),
                                _object.transform(transformProps)
                        } else
                            _object.css(props),
                                _object.transform(transformProps);
                        Timer.create((function() {
                                killed() || (clearCSSTween(),
                                _callback && _callback(),
                                _this.completePromise && _this.completePromise.resolve())
                            }
                        ), time + delay)
                    }()
            }(),
            this.stop = function() {
                this.playing && (this.kill = !0,
                    this.playing = !1,
                    _object.div.style[CSS.styles.vendorTransition] = "",
                    _object.div._transition = !1,
                    _object.willChange(null),
                    _object._cssTween = null,
                    Utils.nullObject(this))
            }
            ,
            this.onComplete = function(callback) {
                return _callback = callback,
                    this
            }
            ,
            this.promise = function() {
                return _this.completePromise = Promise.create(),
                    _this.completePromise
            }
    }
)),
Class((function FrameTween(_object, _props, _time, _ease, _delay, _callback, _manual) {
        var _endValues, _transformEnd, _transformStart, _startValues, _isTransform, _isCSS, _transformProps, _cssTween, _transformTween, _this = this;
        function copy(obj) {
            let newObj = {};
            for (let key in obj)
                "number" == typeof obj[key] && (newObj[key] = obj[key]);
            return newObj
        }
        function clear() {
            _object._cssTweens && _object._cssTweens.remove(_this),
                _this.playing = !1,
                _object._cssTween = null,
                _object = _props = null
        }
        function update() {
            if (!function killed() {
                return _this.kill || !_object || !_object.div
            }()) {
                if (_isCSS && _object.css(_props),
                    _isTransform)
                    if (_object.multiTween) {
                        for (var key in _transformProps)
                            "number" == typeof _transformProps[key] && (_object[key] = _transformProps[key]);
                        _object.transform()
                    } else
                        _object.transform(_transformProps);
                undefined
            }
        }
        function tweenComplete() {
            _this.playing && (clear(),
            _callback && _callback(),
            _this.completePromise && _this.completePromise.resolve())
        }
        this.playing = !0,
            _this.object = _object,
            _this.props = _props,
            _this.time = _time,
            _this.ease = _ease,
            _this.delay = _delay,
            defer((function() {
                    if (_this.overrideValues) {
                        let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
                        values && (_this.props = _props = values.props || _props,
                            _this.time = _time = values.time || _time,
                            _this.ease = _ease = values.ease || _ease,
                            _this.delay = _delay = values.delay || _delay)
                    }
                    if ("object" == typeof _ease && (_ease = "easeOutCubic"),
                    _object && _props) {
                        if (_this.object = _object,
                        "number" != typeof _time)
                            throw "FrameTween Requires object, props, time, ease";
                        !function initValues() {
                            _props.math && delete _props.math;
                            Device.tween.transition && _object.div._transition && (_object.div.style[CSS.styles.vendorTransition] = "",
                                _object.div._transition = !1);
                            _this.time = _time,
                                _this.delay = _delay,
                                _endValues = {},
                                _transformEnd = {},
                                _transformStart = {},
                                _startValues = {},
                            _object.multiTween || (void 0 === _props.x && (_props.x = _object.x),
                            void 0 === _props.y && (_props.y = _object.y),
                            void 0 === _props.z && (_props.z = _object.z));
                            for (var key in _props)
                                if (key.includes(["damping", "spring"]))
                                    _endValues[key] = _props[key],
                                        _transformEnd[key] = _props[key];
                                else if (TweenManager._isTransform(key))
                                    _isTransform = !0,
                                        _transformStart[key] = _object[key] || ("scale" == key ? 1 : 0),
                                        _transformEnd[key] = _props[key];
                                else {
                                    _isCSS = !0;
                                    var v = _props[key];
                                    "string" == typeof v ? _object.div.style[key] = v : "number" == typeof v && (_startValues[key] = Number(_object.css(key)),
                                        _endValues[key] = v)
                                }
                        }(),
                            function startTween() {
                                !_object._cssTween || _manual || _object.multiTween || (_object._cssTween.kill = !0);
                                _this.time = _time,
                                    _this.delay = _delay,
                                _object.multiTween && (_object._cssTweens || (_object._cssTweens = []),
                                    _object._cssTweens.push(_this));
                                _object._cssTween = _this,
                                    _this.playing = !0,
                                    _props = copy(_startValues),
                                    _transformProps = copy(_transformStart),
                                _isCSS && (_cssTween = tween(_props, _endValues, _time, _ease, _delay, null, _manual).onUpdate(update).onComplete(tweenComplete));
                                _isTransform && (_transformTween = tween(_transformProps, _transformEnd, _time, _ease, _delay, null, _manual).onComplete(_isCSS ? null : tweenComplete).onUpdate(_isCSS ? null : update))
                            }()
                    }
                }
            )),
            this.stop = function() {
                this.playing && (_cssTween && _cssTween.stop && _cssTween.stop(),
                _transformTween && _transformTween.stop && _transformTween.stop(),
                    clear())
            }
            ,
            this.interpolate = function(elapsed) {
                _cssTween && _cssTween.interpolate(elapsed),
                _transformTween && _transformTween.interpolate(elapsed),
                    update()
            }
            ,
            this.getValues = function() {
                return {
                    start: _startValues,
                    transformStart: _transformStart,
                    end: _endValues,
                    transformEnd: _transformEnd
                }
            }
            ,
            this.setEase = function(ease) {
                _cssTween && _cssTween.setEase(ease),
                _transformTween && _transformTween.setEase(ease)
            }
            ,
            this.onUpdate = function() {
                return this
            }
            ,
            this.onComplete = function(callback) {
                return _callback = callback,
                    this
            }
            ,
            this.promise = function() {
                return _this.completePromise || (_this.completePromise = Promise.create()),
                    _this.completePromise
            }
    }
)),
Class((function Interaction(_object) {
        Inherit(this, Events);
        const _this = this;
        var _velocity = []
            , _moved = 0
            , _time = performance.now();
        function Vec2() {
            this.x = 0,
                this.y = 0,
                this.length = function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
        }
        var _vec2Pool = new ObjectPool(Vec2,10);
        let _distance, _timeDown, _timeMove;
        function loop() {
            _moved++ > 10 && (_this.velocity.x = _this.velocity.y = 0,
                _this.delta.x = _this.delta.y = 0)
        }
        function down(e) {
            _this.isTouching = !0,
            e.touches && "number" == typeof e.touches[0].force && (e.force = e.touches[0].force),
                _this.x = e.x,
                _this.y = e.y,
                _this.hold.x = _this.last.x = e.x,
                _this.hold.y = _this.last.y = e.y,
                _this.delta.x = _this.move.x = _this.velocity.x = 0,
                _this.delta.y = _this.move.y = _this.velocity.y = 0,
                _distance = 0,
                _this.events.fire(Interaction.START, e, !0),
                _timeDown = _timeMove = Render.TIME
        }
        function move(e) {
            let now = performance.now();
            if (now - _time < 16)
                return;
            _time = now,
            _this.isTouching && (_this.move.x = e.x - _this.hold.x,
                _this.move.y = e.y - _this.hold.y),
            e.touches && "number" == typeof e.touches[0].force && (e.force = e.touches[0].force),
                _this.x = e.x,
                _this.y = e.y,
                _this.delta.x = e.x - _this.last.x,
                _this.delta.y = e.y - _this.last.y,
                _this.last.x = e.x,
                _this.last.y = e.y,
                _moved = 0,
                _distance += _this.delta.length();
            let delta = Render.TIME - (_timeMove || Render.TIME);
            if (_timeMove = Render.TIME,
            delta > .01) {
                let velocity = _vec2Pool.get();
                velocity.x = Math.abs(_this.delta.x) / delta,
                    velocity.y = Math.abs(_this.delta.y) / delta,
                    _velocity.push(velocity),
                _velocity.length > 5 && _vec2Pool.put(_velocity.shift())
            }
            _this.velocity.x = _this.velocity.y = 0;
            for (let i = 0; i < _velocity.length; i++)
                _this.velocity.x += _velocity[i].x,
                    _this.velocity.y += _velocity[i].y;
            _this.velocity.x /= _velocity.length,
                _this.velocity.y /= _velocity.length,
                _this.velocity.x = _this.velocity.x || 0,
                _this.velocity.y = _this.velocity.y || 0,
                _this.events.fire(Interaction.MOVE, e, !0),
            _this.isTouching && _this.events.fire(Interaction.DRAG, e, !0)
        }
        function up(e) {
            if (!_this.isTouching)
                return;
            _this.isTouching = !1,
                _this.move.x = 0,
                _this.move.y = 0,
            Math.max(.001, Render.TIME - (_timeMove || Render.TIME)) > 100 && (_this.delta.x = 0,
                _this.delta.y = 0),
            _distance < 20 && Render.TIME - _timeDown < 2e3 && _this.events.fire(Interaction.CLICK, e, !0),
                _this.events.fire(Interaction.END, e, !0),
            Device.mobile && (_this.velocity.x = _this.velocity.y = 0)
        }
        function leave() {
            _this.delta.x = 0,
                _this.delta.y = 0,
                up()
        }
        this.x = 0,
            this.y = 0,
            this.hold = new Vec2,
            this.last = new Vec2,
            this.delta = new Vec2,
            this.move = new Vec2,
            this.velocity = new Vec2,
            function() {
                if (!_object instanceof HydraObject)
                    throw "Interaction.Input requires a HydraObject";
                !function addHandlers() {
                    _object == Stage || _object == __window ? Interaction.bind("touchstart", down) : _object.bind("touchstart", down);
                    Interaction.bind("touchmove", move),
                        Interaction.bind("touchend", up),
                        Interaction.bind("leave", leave)
                }(),
                    Render.start(loop)
            }(),
            this.onDestroy = function() {
                Interaction.unbind("touchstart", down),
                    Interaction.unbind("touchmove", move),
                    Interaction.unbind("touchend", up),
                    Render.stop(loop),
                _object && _object.unbind && _object.unbind("touchstart", down)
            }
    }
), (()=>{
        Namespace(Interaction),
            Interaction.CLICK = "interaction_click",
            Interaction.START = "interaction_start",
            Interaction.MOVE = "interaction_move",
            Interaction.DRAG = "interaction_drag",
            Interaction.END = "interaction_end";
        const _events = {
            touchstart: [],
            touchmove: [],
            touchend: [],
            leave: []
        };
        function touchMove(e) {
            _events.touchmove.forEach((c=>c(e)))
        }
        function touchStart(e) {
            _events.touchstart.forEach((c=>c(e)))
        }
        function touchEnd(e) {
            _events.touchend.forEach((c=>c(e)))
        }
        function leave(e) {
            _events.leave.forEach((c=>c(e)))
        }
        Hydra.ready((async()=>{
                await defer(),
                    __window.bind("touchstart", touchStart),
                    __window.bind("touchmove", touchMove),
                    __window.bind("touchend", touchEnd),
                    __window.bind("touchcancel", touchEnd),
                    __window.bind("contextmenu", touchEnd),
                    __window.bind("mouseleave", leave),
                    __window.bind("mouseout", leave)
            }
        )),
            Interaction.bind = function(evt, callback) {
                _events[evt].push(callback)
            }
            ,
            Interaction.unbind = function(evt, callback) {
                _events[evt].remove(callback)
            }
    }
)),
Class((function Mouse() {
        Inherit(this, Events);
        const _this = this;
        this.x = 0,
            this.y = 0,
            this.normal = {
                x: 0,
                y: 0
            },
            this.tilt = {
                x: 0,
                y: 0
            },
            this.inverseNormal = {
                x: 0,
                y: 0
            },
            this.resetOnRelease = !1;
        const _offset = {
            x: 0,
            y: 0
        };
        function init() {
            defer((_=>{
                    _this.resetOnRelease && Device.mobile && (_this.x = Stage.width / 2,
                        _this.y = Stage.height / 2)
                }
            )),
                _this.input = new Interaction(__window),
                _this.events.sub(_this.input, Interaction.START, update),
                _this.events.sub(_this.input, Interaction.MOVE, update),
                _this.events.sub(_this.input, Interaction.END, end),
                _this.hold = _this.input.hold,
                _this.last = _this.input.last,
                _this.delta = _this.input.delta,
                _this.move = _this.input.move,
                _this.velocity = _this.input.velocity,
                defer((()=>{
                        _this.events.sub(Events.RESIZE, resize),
                            resize()
                    }
                ))
        }
        function update(e) {
            _this.x = e.x,
                _this.y = e.y,
            Stage.width && Stage.height && (_this.normal.x = e.x / Stage.width - _offset.x,
                _this.normal.y = e.y / Stage.height - _offset.y,
                _this.tilt.x = 2 * _this.normal.x - 1,
                _this.tilt.y = 1 - 2 * _this.normal.y,
                _this.inverseNormal.x = _this.normal.x,
                _this.inverseNormal.y = 1 - _this.normal.y)
        }
        function end(e) {
            Device.mobile && _this.resetOnRelease && update({
                x: Stage.width / 2,
                y: Stage.height / 2
            })
        }
        function resize() {
            Stage.css("top") && (_offset.y = Stage.css("top") / Stage.height),
            Stage.css("left") && (_offset.x = Stage.css("left") / Stage.width)
        }
        Hydra.ready(init)
    }
), "Static"),
Class((function Mobile() {
        Inherit(this, Component),
            Namespace(this);
        const _this = this;
        function preventNativeScroll(e) {
            if (_this.isAllowNativeScroll)
                return;
            let target = e.target;
            if ("INPUT" == target.nodeName || "TEXTAREA" == target.nodeName || "SELECT" == target.nodeName || "A" == target.nodeName)
                return;
            let prevent = target.hydraObject;
            for (; target.parentNode && prevent; )
                target._scrollParent && (prevent = !1),
                    target = target.parentNode;
            prevent && e.preventDefault()
        }
        function resize() {
            updateOrientation(),
                checkResizeRefresh(),
            _this.isAllowNativeScroll || (document.body.scrollTop = 0)
        }
        function updateOrientation() {
            _this.orientation = Stage.width > Stage.height ? "landscape" : "portrait",
            _this.orientationSet && (window.Fullscreen.isOpen || Device.mobile.pwa) && window.screen && window.screen.orientation && window.screen.orientation.lock(_this.orientationSet)
        }
        Hydra.ready((()=>{
                Device.mobile && (!function addHandlers() {
                    _this.events.sub(Events.RESIZE, resize),
                    Device.mobile.native || window.addEventListener("touchstart", preventNativeScroll, {
                        passive: !1
                    })
                }(),
                "safari" != Device.system.browser || Device.mobile.native || (__body.css({
                    height: "100%"
                }).div.scrollTop = 0),
                Device.mobile.native && Stage.css({
                    width: "100vw",
                    height: "100vh"
                }))
            }
        ));
        const checkResizeRefresh = function() {
            let _lastWidth;
            return function() {
                _this.isPreventResizeReload || _lastWidth != Stage.width && (_lastWidth = Stage.width,
                "ios" === Device.system.os || "android" == Device.system.os && Device.system.version)
            }
        }();
        this.vibrate = function(duration) {
            navigator.vibrate && navigator.vibrate(duration)
        }
            ,
            this.fullscreen = function() {
                if (Device.mobile && !Device.mobile.native && !Device.mobile.pwa && !Dev.emulator) {
                    if (!window.Fullscreen)
                        throw "Mobile.fullscreen requires Fullscreen module";
                    "android" === Device.system.os && (__window.bind("touchend", (()=>{
                            Fullscreen.open()
                        }
                    )),
                    _this.ScreenLock && _this.ScreenLock.isActive && window.onresize())
                }
            }
            ,
            this.setOrientation = function(orientation, isForce) {
                if (_this.System && _this.NativeCore.active)
                    return _this.System.orientation = _this.System[orientation.toUpperCase()];
                if (_this.orientationSet = orientation,
                    updateOrientation(),
                    isForce) {
                    if (!_this.ScreenLock)
                        throw "Mobile.setOrientation isForce argument requires ScreenLock module";
                    "any" === orientation ? _this.ScreenLock.unlock() : _this.ScreenLock.lock()
                }
            }
            ,
            this.allowNativeScroll = function() {
                _this.isAllowNativeScroll = !0
            }
            ,
            this.preventResizeReload = function() {
                _this.isPreventResizeReload = !0
            }
            ,
            this._addOverflowScroll = function($obj) {
                $obj.div._scrollParent = !0,
                Device.mobile.native || ($obj.div._preventEvent = function(e) {
                    e.stopPropagation()
                }
                    ,
                    $obj.bind("touchmove", $obj.div._preventEvent))
            }
            ,
            this._removeOverflowScroll = function($obj) {
                $obj.unbind("touchmove", $obj.div._preventEvent)
            }
            ,
            this.get("phone", (()=>{
                    throw "Mobile.phone is removed. Use Device.mobile.phone"
                }
            )),
            this.get("tablet", (()=>{
                    throw "Mobile.tablet is removed. Use Device.mobile.tablet"
                }
            )),
            this.get("os", (()=>{
                    throw "Mobile.os is removed. Use Device.system.os"
                }
            ))
    }
), "Static"),
Class((function PushState(_isHash) {
        const _this = this;
        let _store, _root = "";
        function getState() {
            return _isHash ? String(window.location.hash.slice(3)) : ("/" !== _root ? location.pathname.split(_root)[1] : location.pathname.slice(1)) || ""
        }
        function handleStateChange(state, forced) {
            if (state !== _store || forced)
                if (!_this.isLocked || forced)
                    _store = state,
                        _this.events.fire(Events.UPDATE, {
                            value: state,
                            split: state.split("/")
                        });
                else {
                    if (!_store)
                        return;
                    _isHash ? window.location.hash = "!/" + _store : window.history.pushState(null, null, _root + _store)
                }
        }
        "boolean" != typeof _isHash && (_isHash = Hydra.LOCAL || !Device.system.pushstate),
            this.isLocked = !1,
            function addHandlers() {
                if (_isHash)
                    return window.addEventListener("hashchange", (()=>handleStateChange(getState())), !1);
                window.onpopstate = history.onpushstate = ()=>handleStateChange(getState())
            }(),
            _store = getState(),
            this.getState = function() {
                return Device.mobile.native ? Storage.get("app_state") || "" : getState()
            }
            ,
            this.setRoot = function(root) {
                _root = "/" === root.charAt(0) ? root : "/" + root
            }
            ,
            this.setState = function(state, forced) {
                if (Device.mobile.native && Storage.set("app_state", state),
                state !== _store)
                    return _store = state,
                        _isHash ? window.location.hash = "!/" + state : window.history.pushState(null, null, _root + state),
                    PushState.fireChangeWhenSet && handleStateChange(getState(), forced),
                        !0
            }
            ,
            this.replaceState = function(state) {
                state !== _store && (_store = state,
                    _isHash ? window.location.hash = "!/" + state : window.history.replaceState(null, null, _root + state))
            }
            ,
            this.setTitle = function(title) {
                document.title = title
            }
            ,
            this.lock = function() {
                this.isLocked = !0
            }
            ,
            this.unlock = function() {
                this.isLocked = !1
            }
            ,
            this.useHash = function() {
                _isHash = !0
            }
    }
)),
Class((function Dev() {
        var _post, _alert, _inter, _timerName, _this = this, _id = Utils.timestamp();
        function catchErrors() {
            window.onerror = function(message, file, line) {
                var string = message + " ::: " + file + " : " + line;
                _alert && alert(string),
                _post && post(_post + "/api/data/debug", getDebugInfo(string)),
                _this.onError && _this.onError(message, file, line)
            }
        }
        function getDebugInfo(string) {
            var obj = {};
            return obj.time = (new Date).toString(),
                obj.deviceId = _id,
                obj.err = string,
                obj.ua = Device.agent,
                obj.width = Stage.width,
                obj.height = Stage.height,
                obj.screenWidth = screen.width,
                obj.screenHeight = screen.height,
                obj
        }
        this.emulator = Device.mobile && navigator.platform && navigator.platform.toLowerCase().includes(["mac", "windows"]),
            this.alertErrors = function(url) {
                _alert = !0,
                "string" == typeof url && (url = [url]);
                for (var i = 0; i < url.length; i++)
                    if (location.href.includes(url[i]) || location.hash.includes(url[i]))
                        return catchErrors()
            }
            ,
            this.postErrors = function(url, post) {
                _post = post,
                "string" == typeof url && (url = [url]);
                for (var i = 0; i < url.length; i++)
                    if (location.href.includes(url[i]))
                        return catchErrors()
            }
            ,
            this.expose = function(name, val, force) {
                (Hydra.LOCAL || force) && (window[name] = val)
            }
            ,
            this.logServer = function(msg) {
                _post && post(_post + "/api/data/debug", getDebugInfo(msg))
            }
            ,
            this.unsupported = function(needsAlert) {
                needsAlert && alert("Hi! This build is not yet ready for this device, things may not work as expected. Refer to build schedule for when this device will be supported.")
            }
            ,
            this.checkForLeaks = function(flag, array) {
                if (!window.AURA) {
                    var matchArray = function(prop) {
                        if (!array)
                            return !1;
                        for (var i = 0; i < array.length; i++)
                            if (prop.includes(array[i]))
                                return !0;
                        return !1
                    };
                    clearInterval(_inter),
                    flag && (_inter = setInterval((function() {
                            for (var prop in window) {
                                if (!prop.includes("webkit"))
                                    if ("function" != typeof window[prop] && prop.length > 2) {
                                        if (prop.includes("_ga") || prop.includes("_typeface_js") || matchArray(prop))
                                            continue;
                                        var char1 = prop.charAt(0)
                                            , char2 = prop.charAt(1);
                                        if (("_" == char1 || "$" == char1) && char2 !== char2.toUpperCase())
                                            throw console.log(window[prop]),
                                            "Hydra Warning:: " + prop + " leaking into global scope"
                                    }
                            }
                        }
                    ), 1e3))
                }
            }
            ,
            this.startTimer = function(name) {
                _timerName = name || "Timer",
                    console.time && !window._NODE_ ? console.time(_timerName) : _timer = performance.now()
            }
            ,
            this.stopTimer = function() {
                console.time && !window._NODE_ ? console.timeEnd(_timerName) : console.log("Render " + _timerName + ": " + (performance.now() - _timer))
            }
            ,
            this.writeFile = function(file, data) {
                if (!Hydra.LOCAL)
                    return;
                let url = location.protocol + "//" + location.hostname + ":8017" + location.pathname + file;
                post(url, data).then((e=>{
                        "OK" != e && console.warn(`Unable to write to ${file}`)
                    }
                ))
            }
            ,
            this.execUILScript = async function(name, data) {
                if (!Hydra.LOCAL)
                    return;
                let url = location.protocol + "//" + location.hostname + ":8017" + location.pathname + "/uil/" + name
                    , response = await post(url, data);
                if ("ERROR" == response)
                    throw response;
                return response
            }
            ,
        Hydra.LOCAL && _this.checkForLeaks(!0)
    }
), "Static"),
Class((function Service() {
        Inherit(this, Component);
        var _sw, _this = this;
        function getSWAssets() {
            if (!window.ASSETS.SW || _this.cached)
                return [];
            var assets = window.ASSETS.SW;
            return assets.forEach(((asset,i)=>{
                    asset.includes(".js") && (asset = assets[i].replace(".js", ".js?" + window._CACHE_))
                }
            )),
                assets
        }
        function handleRegistration(e) {}
        function handleReady(e) {
            _this.isReady = !0,
                _this.events.fire(Events.READY, e, !0),
                _sw = navigator.serviceWorker.controller,
                function checkCache() {
                    Storage.get("service_cache") != window._CACHE_ && _this.post("clearCache")
                }()
        }
        function handleError(e) {
            e && (_this.events.fire(Events.ERROR, e, !0),
                _this.active = !1)
        }
        function handleMessage(e) {
            var data = e.data;
            data.evt && _this.events.fire(data.evt, data)
        }
        this.active = !1,
            this.ready = !1,
            this.cached = !1,
            this.offline = !1,
            this.disabled = !1,
            this.ready = function() {
                return this.wait(this, "isReady")
            }
            ,
            this.init = function() {
                Hydra.ready((()=>{
                        !("serviceWorker"in navigator) || Hydra.LOCAL && "" == location.port || window.process || _this.disabled || function initWorker() {
                            _this.active = !0,
                                navigator.serviceWorker.register("sw.js").then(handleRegistration).then(handleReady).then(handleError)
                        }()
                    }
                ))
            }
            ,
            this.cache = function(assets=[]) {
                assets = Array.from(assets);
                _this.active && _this.wait(_this, "ready", (function() {
                        _this.post("upload", {
                            assets: assets,
                            cdn: Assets.CDN,
                            hostname: location.hostname,
                            sw: getSWAssets(),
                            offline: _this.offline
                        }),
                            Storage.set("service_cache", window._CACHE_),
                            _this.cached = !0
                    }
                ))
            }
            ,
            this.post = function(fn, data={}) {
                if (!_this.active)
                    return;
                _this.wait(_this, "ready", (function() {
                        let mc = new MessageChannel;
                        mc.port1.onmessage = handleMessage,
                            data.fn = fn,
                        _sw && _sw.postMessage(data, [mc.port2])
                    }
                ))
            }
    }
), "static"),
Class((function Storage() {
        var _storage;
        function cookie(key, value, expires) {
            var options;
            if (arguments.length > 1 && (null === value || "object" != typeof value)) {
                if ((options = {}).path = "/",
                    options.expires = expires || 1,
                null === value && (options.expires = -1),
                "number" == typeof options.expires) {
                    var days = options.expires
                        , t = options.expires = new Date;
                    t.setDate(t.getDate() + days)
                }
                return document.cookie = [encodeURIComponent(key), "=", options.raw ? String(value) : encodeURIComponent(String(value)), options.expires ? "; expires=" + options.expires.toUTCString() : "", options.path ? "; path=" + options.path : "", options.domain ? "; domain=" + options.domain : "", options.secure ? "; secure" : ""].join("")
            }
            var result, decode = (options = value || {}).raw ? function(s) {
                    return s
                }
                : decodeURIComponent;
            return (result = new RegExp("(?:^|; )" + encodeURIComponent(key) + "=([^;]*)").exec(document.cookie)) ? decode(result[1]) : null
        }
        !function testStorage() {
            try {
                if (window.localStorage)
                    try {
                        window.localStorage.test = 1,
                            window.localStorage.removeItem("test"),
                            _storage = !0
                    } catch (e) {
                        _storage = !1
                    }
                else
                    _storage = !1
            } catch (e) {
                _storage = !1
            }
        }(),
            this.setCookie = function(key, value, expires) {
                cookie(key, value, expires)
            }
            ,
            this.getCookie = function(key) {
                return cookie(key)
            }
            ,
            this.set = function(key, value) {
                null != value && "object" == typeof value && (value = JSON.stringify(value)),
                    _storage ? null === value ? window.localStorage.removeItem(key) : window.localStorage[key] = value : cookie(key, value, 365)
            }
            ,
            this.get = function(key) {
                var val, char0;
                (val = _storage ? window.localStorage[key] : cookie(key)) && (val.charAt && (char0 = val.charAt(0)),
                "{" != char0 && "[" != char0 || (val = JSON.parse(val)),
                "true" != val && "false" != val || (val = "true" == val));
                return val
            }
    }
), "Static"),
Class((function Thread(_class) {
        Inherit(this, Component);
        var _this = this, _worker, _callbacks, _path, _mvc, _msg = {};
        function init() {
            let file = window._ES5_ ? "assets/js/hydra/hydra-thread-es5.js" : "assets/js/hydra/hydra-thread.js";
            _callbacks = {},
                _worker = new Worker(Thread.PATH + file)
        }
        function importClasses() {
            importClass(Utils),
                importClass(Component),
                importClass(Events),
                importClass(_class, !0)
        }
        function importClass(_class, scoped) {
            if (_class) {
                var code;
                if (scoped) {
                    code = (code = _class.toString().replace("{", "!!!")).split("!!!")[1];
                    for (var splitChar = window._MINIFIED_ ? "=" : " "; code.includes("this"); ) {
                        var name = code.slice(code.indexOf("this.")).split("this.")[1].split(splitChar)[0];
                        code = code.replace("this", "self"),
                            createMethod(name)
                    }
                    code = (code = code.slice(0, -1)).replace(/_self/g, "_this")
                } else if ("function" != typeof _class) {
                    if ((code = _class.constructor.toString()).includes("[native"))
                        return;
                    code = (_class.constructor._namespace ? _class.constructor._namespace + "." : "") + "Class(" + code + ', "static");'
                } else
                    code = (_class._namespace ? _class._namespace + "." : "") + "Class(" + _class.toString() + ");";
                _worker.postMessage({
                    code: code
                })
            }
        }
        function createMethod(name) {
            _this[name] = function(message={}, callback, buffer) {
                let promise;
                return Array.isArray(callback) && (buffer = callback,
                    callback = void 0),
                Array.isArray(buffer) && ((message = {
                    msg: message,
                    transfer: !0
                }).buffer = buffer),
                void 0 === callback && (promise = Promise.create(),
                    callback = promise.resolve),
                    _this.send(name, message, callback),
                    promise
            }
        }
        function addListeners() {
            _worker.addEventListener("message", workerMessage)
        }
        function workerMessage(e) {
            if (e.data.console)
                console.log(e.data.message);
            else if (e.data.id) {
                (callback = _callbacks[e.data.id]) && callback(e.data.message),
                    delete _callbacks[e.data.id]
            } else if (e.data.emit) {
                (callback = _callbacks[e.data.evt]) && callback(e.data.msg)
            } else {
                var callback;
                (callback = _callbacks.transfer) && callback(e.data)
            }
        }
        init(),
            importClasses(),
            addListeners(),
            this.on = function(evt, callback) {
                _callbacks[evt] = callback
            }
            ,
            this.off = function(evt) {
                delete _callbacks[evt]
            }
            ,
            this.loadFunction = function() {
                let names = []
                    , load = code=>{
                        var split = (code = (code = code.toString()).replace("(", "!!!")).split("!!!")
                            , name = split[0].split(" ")[1];
                        code = "self." + name + " = function(" + split[1],
                            _worker.postMessage({
                                code: code
                            }),
                            createMethod(name),
                            names.push(name)
                    }
                ;
                for (var i = 0; i < arguments.length; i++)
                    load(arguments[i]);
                return names
            }
            ,
            this.importScript = function(path) {
                _worker.postMessage({
                    path: Thread.absolutePath(path),
                    importScript: !0
                })
            }
            ,
            this.importCode = function(code) {
                _worker.postMessage({
                    code: code
                })
            }
            ,
            this.importClass = function() {
                for (var i = 0; i < arguments.length; i++) {
                    var code = arguments[i];
                    importClass(code)
                }
            }
            ,
            this.importModules = this.importModule = function() {
                for (var i = 0; i < arguments.length; i++) {
                    let code = Modules.getConstructor(arguments[i]).toString();
                    _worker.postMessage({
                        code: `Module(${code})`
                    })
                }
            }
            ,
            this.importES6Class = function(name) {
                if (window._ES5_) {
                    let Class = window[name]
                        , base = Class.toString()
                        , proto = [];
                    Object.getOwnPropertyNames(Class.prototype).forEach((fn=>{
                            "constructor" != fn && Class.prototype[fn] && proto.push({
                                key: fn,
                                string: Class.prototype[fn].toString()
                            })
                        }
                    )),
                        _worker.postMessage({
                            es5: base,
                            name: name,
                            proto: proto
                        })
                } else
                    _worker.postMessage({
                        es6: `(${eval(name)})`,
                        name: name
                    })
            }
            ,
            this.send = function(name, message, callback) {
                if ("string" == typeof name) {
                    (message = message || {}).fn = name
                } else
                    callback = message,
                        message = name;
                Thread.UNIQUE_ID > 999999 && (Thread.UNIQUE_ID = 1);
                var id = Thread.UNIQUE_ID++;
                callback && (_callbacks[id] = callback),
                    message.transfer ? (message.msg.id = id,
                        message.msg.fn = message.fn,
                        message.msg.transfer = !0,
                        _worker.postMessage(message.msg, message.buffer)) : (_msg.message = message,
                        _msg.id = id,
                        _worker.postMessage(_msg))
            }
            ,
            this.onDestroy = function() {
                _worker.terminate && _worker.terminate()
            }
    }
), (()=>{
        var _shared;
        Thread.PATH = "",
            Thread.UNIQUE_ID = 1,
            Thread.absolutePath = Hydra.absolutePath,
            Thread.cluster = function() {
                return new function() {
                    let index = 0
                        , array = [];
                    this.push = function(thread) {
                        array.push(thread)
                    }
                        ,
                        this.get = function() {
                            let thread = array[index];
                            return index++,
                            index >= array.length && (index = 0),
                                thread
                        }
                        ,
                        this.array = array
                }
            }
            ,
            Thread.upload = function(...args) {
                let name;
                Thread.shared();
                for (let i = 0; i < _shared.array.length; i++)
                    name = _shared.array[i].loadFunction(...args);
                return name
            }
            ,
            Thread.shared = function(list) {
                if (!_shared) {
                    _shared = Thread.cluster();
                    let count = navigator.hardwareConcurrency || 4;
                    for (let i = 0; i < count; i++)
                        _shared.push(new Thread)
                }
                return list ? _shared : _shared.get()
            }
    }
)),
Class((function TweenManager() {
        Namespace(this);
        var _this = this
            , _tweens = [];
        function updateTweens(time, dt) {
            for (let i = _tweens.length - 1; i >= 0; i--) {
                let tween = _tweens[i];
                tween && tween.update ? tween.update(dt) : _this._removeMathTween(tween)
            }
        }
        function findEase(name) {
            for (var eases = _this.CubicEases, i = eases.length - 1; i > -1; i--)
                if (eases[i].name == name)
                    return eases[i];
            return !1
        }
        this.CubicEases = [],
            Render.start(updateTweens),
            this._addMathTween = function(tween) {
                _tweens.push(tween)
            }
            ,
            this._removeMathTween = function(tween) {
                _tweens.remove(tween)
            }
            ,
            this._getEase = function(name, values) {
                var ease = findEase(name);
                return !!ease && (values ? ease.path ? ease.path.solve : ease.values : ease.curve)
            }
            ,
            this._inspectEase = function(name) {
                return findEase(name)
            }
            ,
            this.tween = function(object, props, time, ease, delay, complete, isManual, scaledTime) {
                "number" != typeof delay && (update = complete,
                    complete = delay,
                    delay = 0);
                const tween = new MathTween(object,props,time,ease,delay,complete,isManual,scaledTime);
                let usePromise = null;
                return complete && complete instanceof Promise && (usePromise = complete,
                    complete = complete.resolve),
                usePromise || tween
            }
            ,
            this.clearTween = function(object) {
                if (object._mathTween && object._mathTween.stop && object._mathTween.stop(),
                    object._mathTweens) {
                    for (var tweens = object._mathTweens, i = 0; i < tweens.length; i++) {
                        var tw = tweens[i];
                        tw && tw.stop && tw.stop()
                    }
                    object._mathTweens = null
                }
            }
            ,
            this.addCustomEase = function(ease) {
                var add = !0;
                if ("object" != typeof ease || !ease.name || !ease.curve)
                    throw "TweenManager :: addCustomEase requires {name, curve}";
                for (var i = _this.CubicEases.length - 1; i > -1; i--)
                    ease.name == _this.CubicEases[i].name && (add = !1);
                if (add) {
                    if ("m" == ease.curve.charAt(0).toLowerCase()) {
                        if (!window.EasingPath)
                            throw "Using custom eases requires easingpath module";
                        ease.path = new EasingPath(ease.curve)
                    } else
                        ease.values = function stringToValues(str) {
                            for (var values = str.split("(")[1].slice(0, -1).split(","), i = 0; i < values.length; i++)
                                values[i] = parseFloat(values[i]);
                            return values
                        }(ease.curve);
                    _this.CubicEases.push(ease)
                }
                return ease
            }
            ,
            Math.interpolate = function(start, end, alpha, ease) {
                const fn = _this.Interpolation.convertEase(ease);
                return Math.mix(start, end, "function" == typeof fn ? fn(alpha) : _this.Interpolation.solve(fn, alpha))
            }
            ,
            window.tween = this.tween,
            window.clearTween = this.clearTween
    }
), "Static"),
TweenManager.Class((function Interpolation() {
        function calculateBezier(aT, aA1, aA2) {
            return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT
        }
        function A(aA1, aA2) {
            return 1 - 3 * aA2 + 3 * aA1
        }
        function B(aA1, aA2) {
            return 3 * aA2 - 6 * aA1
        }
        function C(aA1) {
            return 3 * aA1
        }
        this.convertEase = function(ease) {
            var fn = function() {
                switch (ease) {
                    case "easeInQuad":
                        return TweenManager.Interpolation.Quad.In;
                    case "easeInCubic":
                        return TweenManager.Interpolation.Cubic.In;
                    case "easeInQuart":
                        return TweenManager.Interpolation.Quart.In;
                    case "easeInQuint":
                        return TweenManager.Interpolation.Quint.In;
                    case "easeInSine":
                        return TweenManager.Interpolation.Sine.In;
                    case "easeInExpo":
                        return TweenManager.Interpolation.Expo.In;
                    case "easeInCirc":
                        return TweenManager.Interpolation.Circ.In;
                    case "easeInElastic":
                        return TweenManager.Interpolation.Elastic.In;
                    case "easeInBack":
                        return TweenManager.Interpolation.Back.In;
                    case "easeInBounce":
                        return TweenManager.Interpolation.Bounce.In;
                    case "easeOutQuad":
                        return TweenManager.Interpolation.Quad.Out;
                    case "easeOutCubic":
                        return TweenManager.Interpolation.Cubic.Out;
                    case "easeOutQuart":
                        return TweenManager.Interpolation.Quart.Out;
                    case "easeOutQuint":
                        return TweenManager.Interpolation.Quint.Out;
                    case "easeOutSine":
                        return TweenManager.Interpolation.Sine.Out;
                    case "easeOutExpo":
                        return TweenManager.Interpolation.Expo.Out;
                    case "easeOutCirc":
                        return TweenManager.Interpolation.Circ.Out;
                    case "easeOutElastic":
                        return TweenManager.Interpolation.Elastic.Out;
                    case "easeOutBack":
                        return TweenManager.Interpolation.Back.Out;
                    case "easeOutBounce":
                        return TweenManager.Interpolation.Bounce.Out;
                    case "easeInOutQuad":
                        return TweenManager.Interpolation.Quad.InOut;
                    case "easeInOutCubic":
                        return TweenManager.Interpolation.Cubic.InOut;
                    case "easeInOutQuart":
                        return TweenManager.Interpolation.Quart.InOut;
                    case "easeInOutQuint":
                        return TweenManager.Interpolation.Quint.InOut;
                    case "easeInOutSine":
                        return TweenManager.Interpolation.Sine.InOut;
                    case "easeInOutExpo":
                        return TweenManager.Interpolation.Expo.InOut;
                    case "easeInOutCirc":
                        return TweenManager.Interpolation.Circ.InOut;
                    case "easeInOutElastic":
                        return TweenManager.Interpolation.Elastic.InOut;
                    case "easeInOutBack":
                        return TweenManager.Interpolation.Back.InOut;
                    case "easeInOutBounce":
                        return TweenManager.Interpolation.Bounce.InOut;
                    case "linear":
                        return TweenManager.Interpolation.Linear.None
                }
            }();
            if (!fn) {
                var curve = TweenManager._getEase(ease, !0);
                fn = curve || TweenManager.Interpolation.Cubic.Out
            }
            return fn
        }
            ,
            this.solve = function(values, elapsed) {
                return values[0] == values[1] && values[2] == values[3] ? elapsed : calculateBezier(function getTForX(aX, mX1, mX2) {
                    for (var aT, aA1, aA2, aGuessT = aX, i = 0; i < 4; i++) {
                        var currentSlope = (aT = aGuessT,
                        3 * A(aA1 = mX1, aA2 = mX2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1));
                        if (0 == currentSlope)
                            return aGuessT;
                        aGuessT -= (calculateBezier(aGuessT, mX1, mX2) - aX) / currentSlope
                    }
                    return aGuessT
                }(elapsed, values[0], values[2]), values[1], values[3])
            }
            ,
            this.Linear = {
                None: function(k) {
                    return k
                }
            },
            this.Quad = {
                In: function(k) {
                    return k * k
                },
                Out: function(k) {
                    return k * (2 - k)
                },
                InOut: function(k) {
                    return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1)
                }
            },
            this.Cubic = {
                In: function(k) {
                    return k * k * k
                },
                Out: function(k) {
                    return --k * k * k + 1
                },
                InOut: function(k) {
                    return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2)
                }
            },
            this.Quart = {
                In: function(k) {
                    return k * k * k * k
                },
                Out: function(k) {
                    return 1 - --k * k * k * k
                },
                InOut: function(k) {
                    return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2)
                }
            },
            this.Quint = {
                In: function(k) {
                    return k * k * k * k * k
                },
                Out: function(k) {
                    return --k * k * k * k * k + 1
                },
                InOut: function(k) {
                    return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2)
                }
            },
            this.Sine = {
                In: function(k) {
                    return 1 - Math.cos(k * Math.PI / 2)
                },
                Out: function(k) {
                    return Math.sin(k * Math.PI / 2)
                },
                InOut: function(k) {
                    return .5 * (1 - Math.cos(Math.PI * k))
                }
            },
            this.Expo = {
                In: function(k) {
                    return 0 === k ? 0 : Math.pow(1024, k - 1)
                },
                Out: function(k) {
                    return 1 === k ? 1 : 1 - Math.pow(2, -10 * k)
                },
                InOut: function(k) {
                    return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (2 - Math.pow(2, -10 * (k - 1)))
                }
            },
            this.Circ = {
                In: function(k) {
                    return 1 - Math.sqrt(1 - k * k)
                },
                Out: function(k) {
                    return Math.sqrt(1 - --k * k)
                },
                InOut: function(k) {
                    return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1)
                }
            },
            this.Elastic = {
                In: function(k, a=1, p=.4) {
                    var s;
                    return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1,
                        s = p / 4) : s = p * Math.asin(1 / a) / (2 * Math.PI),
                    -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p))
                },
                Out: function(k, a=1, p=.4) {
                    var s;
                    return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1,
                        s = p / 4) : s = p * Math.asin(1 / a) / (2 * Math.PI),
                    a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1)
                },
                InOut: function(k, a=1, p=.4) {
                    var s;
                    return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1,
                        s = p / 4) : s = p * Math.asin(1 / a) / (2 * Math.PI),
                        (k *= 2) < 1 ? a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * -.5 : a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1)
                }
            },
            this.Back = {
                In: function(k) {
                    var s = 1.70158;
                    return k * k * ((s + 1) * k - s)
                },
                Out: function(k) {
                    var s = 1.70158;
                    return --k * k * ((s + 1) * k + s) + 1
                },
                InOut: function(k) {
                    var s = 2.5949095;
                    return (k *= 2) < 1 ? k * k * ((s + 1) * k - s) * .5 : .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2)
                }
            },
            this.Bounce = {
                In: function(k) {
                    return 1 - this.Bounce.Out(1 - k)
                },
                Out: function(k) {
                    return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375
                },
                InOut: function(k) {
                    return k < .5 ? .5 * this.Bounce.In(2 * k) : .5 * this.Bounce.Out(2 * k - 1) + .5
                }
            }
    }
), "Static"),
Class((function MathTween(_object, _props, _time, _ease, _delay, _callback, _manual, _scaledTime) {
        var _startTime, _startValues, _endValues, _easeFunction, _paused, _newEase, _spring, _damping, _update, _currentTime, _this = this, _elapsed = 0;
        function clear() {
            if (!_object && !_props)
                return !1;
            _object._mathTween = null,
                TweenManager._removeMathTween(_this),
                Utils.nullObject(_this),
            _object._mathTweens && _object._mathTweens.remove(_this._tweenWrapper)
        }
        _this.object = _object,
            _this.props = _props,
            _this.time = _time,
            _this.ease = _ease,
            _this.delay = _delay,
            defer((function() {
                    if (_this.overrideValues) {
                        let values = _this.overrideValues(_this, _object, _props, _time, _ease, _delay);
                        values && (_this.props = _props = values.props || _props,
                            _this.time = _time = values.time || _time,
                            _this.ease = _ease = values.ease || _ease,
                            _this.delay = _delay = values.delay || _delay)
                    }
                    if (_object && _props) {
                        if (_this.object = _object,
                        "number" != typeof _time)
                            throw "MathTween Requires object, props, time, ease";
                        !function start() {
                            _object.multiTween || !_object._mathTween || _manual || TweenManager.clearTween(_object);
                            _manual || TweenManager._addMathTween(_this);
                            _this.time = _time,
                                _this.delay = _delay;
                            let propString = function getPropString() {
                                let string = "";
                                for (let key in _props)
                                    "number" == typeof _props[key] && (string += key + " ");
                                return string
                            }();
                            _object._mathTween = _this,
                            _object.multiTween && (_object._mathTweens || (_object._mathTweens = []),
                                _object._mathTweens.forEach((t=>{
                                        t.props == propString && t.tween.stop()
                                    }
                                )),
                                _this._tweenWrapper = {
                                    props: propString,
                                    tween: _this
                                },
                                _object._mathTweens.push(_this._tweenWrapper));
                            _ease || (_ease = "linear");
                            "string" == typeof _ease && (_ease = TweenManager.Interpolation.convertEase(_ease),
                                _easeFunction = "function" == typeof _ease);
                            _startTime = _scaledTime ? Render.now() : performance.now(),
                                _currentTime = _startTime,
                                _startTime += _delay,
                                _endValues = _props,
                                _startValues = {},
                            _props.spring && (_spring = _props.spring);
                            _props.damping && (_damping = _props.damping);
                            for (var prop in _this.startValues = _startValues,
                                _endValues)
                                "number" == typeof _object[prop] && (_startValues[prop] = _object[prop])
                        }()
                    }
                }
            )),
            this.update = function(dt) {
                if (_paused)
                    return;
                if ((_currentTime += _scaledTime ? dt : Render.DT) < _startTime)
                    return;
                _elapsed = (_elapsed = (_currentTime - _startTime) / _time) > 1 ? 1 : _elapsed;
                let delta = this.interpolate(_elapsed);
                _update && _update(delta),
                1 == _elapsed && (_callback && _callback(),
                _this.completePromise && _this.completePromise.resolve(),
                    clear())
            }
            ,
            this.pause = function() {
                _paused = !0
            }
            ,
            this.resume = function() {
                _paused = !1
            }
            ,
            this.stop = function() {
                return _this.stopped = !0,
                    clear(),
                    null
            }
            ,
            this.setEase = function(ease) {
                _newEase != ease && (_newEase = ease,
                    _ease = TweenManager.Interpolation.convertEase(ease),
                    _easeFunction = "function" == typeof _ease)
            }
            ,
            this.getValues = function() {
                return {
                    start: _startValues,
                    end: _endValues
                }
            }
            ,
            this.interpolate = function(elapsed) {
                var delta = _easeFunction ? _ease(elapsed, _spring, _damping) : TweenManager.Interpolation.solve(_ease, elapsed);
                for (var prop in _startValues)
                    if ("number" == typeof _startValues[prop] && "number" == typeof _endValues[prop]) {
                        var start = _startValues[prop]
                            , end = _endValues[prop];
                        _object[prop] = start + (end - start) * delta
                    }
                return delta
            }
            ,
            this.onUpdate = function(callback) {
                return _update = callback,
                    this
            }
            ,
            this.onComplete = function(callback) {
                return _callback = callback,
                    this
            }
            ,
            this.promise = function() {
                return _this.completePromise = Promise.create(),
                    _this.completePromise
            }
            ,
            this.setElapsed = function(elapsed) {
                _startTime = performance.now(),
                    _currentTime = _startTime + _time * elapsed
            }
    }
)),
Class((function TweenTimeline() {
        Inherit(this, Component);
        const _this = this;
        let _tween, _total = 0;
        const _tweens = [];
        function calculate() {
            _tweens.sort((function(a, b) {
                    const ta = a.time + a.delay;
                    return b.time + b.delay - ta
                }
            ));
            const first = _tweens[0];
            _total = first.time + first.delay
        }
        function loop() {
            let time = _this.elapsed * _total;
            for (let i = _tweens.length - 1; i > -1; i--) {
                let t = _tweens[i]
                    , relativeTime = time - t.delay
                    , elapsed = Math.clamp(relativeTime / t.time, 0, 1);
                t.interpolate(elapsed)
            }
            _this.events.fire(Events.UPDATE, _this, !0)
        }
        this.elapsed = 0,
            this.get("timeRemaining", (()=>_total - _this.elapsed * _total)),
            this.add = function(object, props, time, ease, delay=0) {
                let tween;
                return (object instanceof MathTween || object instanceof FrameTween) && (props = object.props,
                    time = object.time,
                    ease = object.ease,
                    delay = object.delay,
                    object = object.object),
                    tween = object instanceof HydraObject ? new FrameTween(object,props,time,ease,delay,null,!0) : new MathTween(object,props,time,ease,delay,null,!0),
                    _tweens.push(tween),
                    defer(calculate),
                    tween
            }
            ,
            this.tween = function(to, time, ease, delay, callback) {
                return _this.clearTween(),
                    _tween = tween(_this, {
                        elapsed: to
                    }, time, ease, delay).onUpdate(loop).onComplete(callback),
                    _tween
            }
            ,
            this.clearTween = function() {
                _tween && _tween.stop && _tween.stop()
            }
            ,
            this.startRender = function() {
                Render.start(loop)
            }
            ,
            this.stopRender = function() {
                Render.stop(loop)
            }
            ,
            this.update = function() {
                loop()
            }
            ,
            this.onDestroy = function() {
                _this.clearTween(),
                    Render.stop(loop);
                for (var i = 0; i < _tweens.length; i++)
                    _tweens[i].stop()
            }
    }
)),
Class((function Data() {
        Inherit(this, Model);
        const _this = this;
        !async function() {
            await Hydra.ready(),
                await async function fetchCMSData() {
                    let data = Config.PREVIEW ? await get(Config.DATA) : window._DATA_ || await _this.loadData(Config.DATA);
                    Object.keys(data).forEach(((key,index)=>{
                            _this[key.toUpperCase()] = data[key]
                        }
                    ))
                }(),
                _this.HOME = {},
                _this.NAVIGATION = _this.NAVIGATION.sort(((a,b)=>a._index - b._index)).reduce(((accum,link)=>("/" === link.routeLink ? _this.HOME = link : accum.push(link),
                    accum)), []),
                _this.TEASER.filter((e=>e.environment)).sort(((a,b)=>a._index = b._index)).forEach((teaser=>{
                        Config.TRACKS || (Config.TRACKS = {});
                        let id = teaser.environment;
                        Config.TRACKS[id] = Object.assign({}, teaser, {
                            title: teaser.optionalTitle || teaser.title,
                            date: teaser.date,
                            trackLength: +teaser.trackLength,
                            locked: teaser.locked || !1,
                            audio: teaser.audio || !1
                        })
                    }
                )),
                console.log(_this.TEASER),
                _this.dataReady = !0
        }()
    }
), "static"),
window.ASSETS = ["assets/data/path/porter-path-full.json", "assets/data/path/porter-path-simple.json", "assets/data/path/porter-path.json", "assets/data/uil.json", "assets/shaders/compiled.vs"],
ASSETS.SW = ["assets/fonts/AdobeMyungjoStd-Medium-Alphabetic.woff", "assets/fonts/AdobeMyungjoStd-Medium-Alphabetic.woff2", "assets/fonts/AdobeMyungjoStd.json", "assets/fonts/AdobeMyungjoStd.otf", "assets/fonts/AdobeMyungjoStd.png", "assets/fonts/HelveticaNeue-Medium.json", "assets/fonts/HelveticaNeue-Medium.png", "assets/css/style.css", "assets/js/app.js"],
Class((function Colors() {
        Inherit(this, Component);
        this.WHITE = "#ffffff",
            this.BLACK = "#000000"
    }
), "static"),
Class((function Config() {
        this.GAMECENTER = Utils.query("localsocket") ? "ws://localhost" : "wss://s.dreamwave.network/porter/ws",
            this.GAMECENTER_PORTS = 1,
            this.PREVIEW = window._CONFIG_ && window._CONFIG_.PREVIEW && Utils.query("preview"),
        this.PREVIEW && (window._CONFIG_.DATA = `${window._CONFIG_.PREVIEW}`),
            this.DATA = window._CONFIG_ && window._CONFIG_.DATA,
            this.OFFSET = Device.mobile.phone ? 22 : 35,
            this.DRAW_TIMER = 2e4,
            this.AVATAR_COLORS = ["#80ff8f", "#8098ff", "#80fff5", "#ffce80", "#80b6ff", "#ff8080"],
            this.TEASER_PRE = Utils.query("teaser") || !1,
            this.TEASER_NUM = function() {
                if (!Hydra.LOCAL) {
                    let permas = ["everythinggoeson", "getyourwish", "somethingcomforting", "mirror", "lookatthesky", "preorder", "musician", "unfold", "nurture"];
                    if (window.location.href.includes(permas))
                        return 1
                }
            }(),
            this.GUITAR = function() {
                if (window.location.href.includes("guitar") || Utils.query("guitar"))
                    return !0
            }(),
            this.TEASER = this.TEASER_NUM || Utils.query("path") || !1,
            this.NEWSLETTER = "https://us-central1-porter-robinson-sc.cloudfunctions.net/newsletter",
            this.GEO = "https://us-central1-porter-robinson-sc.cloudfunctions.net/geo",
            this.ADMIN = "chrome" == Device.system.browser && (Hydra.LOCAL ? Utils.query("admin") : window._CONFIG_ && !0 === window._CONFIG_.avatar),
            this.FONTS = {
                serif: "Lora",
                sansSerif: "Nunito"
            },
            this.TRACKS = {
                water: {
                    title: "",
                    date: "",
                    trackLength: 0,
                    locked: !0
                },
                grass: {
                    title: "",
                    date: "",
                    trackLength: 0,
                    locked: !0
                },
                env3: {
                    title: "",
                    date: "",
                    trackLength: 0,
                    locked: !0
                },
                env4: {
                    title: "",
                    date: "",
                    trackLength: 0,
                    locked: !0
                },
                env5: {
                    title: "",
                    date: "",
                    trackLength: 0,
                    locked: !1
                },
                clouds: {
                    title: "",
                    date: "",
                    trackLength: 0,
                    locked: !1
                },
                preorder: {
                    title: "",
                    date: "",
                    trackLength: 0,
                    locked: !1
                }
            }
    }
), "static"),
Class((function Lyrics() {
        this.water = {
            color: "#092e7a",
            text: "#afe2ff",
            0: "",
            32: "i’ll make it right again",
            34: "but it’s no use",
            36: "you said",
            37: "as my hunger grows and grows",
            41: "i have to write",
            43: "the meaning of my life",
            46: "or else everything’s in vain",
            53: "when the glory tries to tempt you",
            58: "it may seem like what you need",
            62: "but if glory makes you happy,",
            66: "why are you so broken up?",
            70: "so tell me how it felt",
            73: "when you walked on water?",
            78: "did you get your wish?",
            82: "floating to the surface",
            85: "quicker than you sank",
            88: "idol, idol",
            91: "so tell me how it felt",
            94: "when you walked on water?",
            98: "did you get your wish?",
            102: "floating to the surface",
            104: "quicker than you sank",
            108: "idol, idol",
            122: "don’t say you lose just yet,",
            125: "get up and move ahead",
            129: "and not only for yourself.",
            133: "'cause that’s your role:",
            135: "the work that stirred your soul,",
            138: "you can make for someone else.",
            143: "one day you choke",
            145: "your urges overflow",
            148: "and obsession wears you down",
            153: "but don’t you waste",
            155: "the suffering you’ve faced",
            158: "it will serve you in due time",
            163: "so tell me how it felt",
            166: "when you walked on water?",
            170: "did you get your wish?",
            173: "floating to the surface",
            175: "quicker than you sank",
            179: "idol, idol",
            182: "so tell me how it felt",
            185: "when you walked on water?",
            189: "did you get your wish?",
            193: "floating to the surface",
            195: "quicker than you sank",
            198: "idol, idol",
            203: "so tell me",
            207: ""
        },
            this.grass = {
                color: "#17491b",
                text: "#c4f7d5",
                0: "",
                13: "if i send this void away,",
                20: "have i lost a part of me?",
                27: "when you wake you’re bargaining ",
                33: "for the promise to come back",
                39: "cause getting made you want more",
                42: "and hoping made you hurt more",
                45: "oh there must be",
                48: "something wrong with me",
                52: "and getting made you want more",
                55: "and hoping made you hurt more",
                59: "someone tell me something comforting",
                119: "take what you want,",
                121: "but you’re tied by the tooth",
                126: "wasn’t it meant to relieve you?",
                132: "so suffer the signs",
                135: "that you needed to change",
                140: "heed all the ways you’d been thinking",
                146: "cause getting made you want more",
                150: "and hoping made you hurt more",
                152: "oh there must be",
                155: "something wrong with me",
                160: "cause getting made you want more",
                163: "and hoping made you hurt more",
                165: "someone tell me something comforting",
                172: "something comforting",
                175: "something comforting ",
                179: "something comforting",
                182: "something comforting ",
                185: "something comforting",
                189: "something comforting ",
                192: "something comforting",
                196: "something comforting ",
                209: "something comforting",
                215: "and hoping made you hurt more",
                219: "oh there must be",
                222: "something wrong with me",
                226: "cause getting made you want more",
                230: "and hoping made you hurt more",
                232: "someone tell me something comforting",
                261: "oh, something comforting",
                266: ""
            },
            this.clouds = {
                color: "#e5eeff",
                text: "#6a5f5d",
                0: "",
                37: "Is it fate?",
                40: "if it’s not easy, it must not be",
                46: "At that age",
                49: "I cherished the flowers beneath my feet",
                54: "But then, something must have changed in me",
                58: "I used to feel so light",
                62: "Now I'll try",
                66: "I just want time",
                71: "Wait again, I will be much better then",
                78: "Holding on, I said:",
                82: "I will be much better then",
                89: "Look at the sky, I'm still here",
                93: "I'll be alive next year",
                97: "I can make something good, oh",
                103: "Something good",
                106: "Look at the sky, I'm still here",
                110: "I'll be alive next year",
                114: "I can make something good, oh",
                119: "Something good",
                123: "Are you close? ",
                127: "Shouldn't it come to you naturally?",
                131: "And everyone knows ",
                135: "You're losing your gift and it's plain to see",
                140: "But then something must have changed in me",
                143: "I don't fear it anymore",
                148: "Now I'm sure",
                152: "I'm sure",
                156: "Look at the sky, I'm still here",
                160: "I'll be alive next year",
                164: "I can make something good, oh",
                169: "Something good",
                173: "Look at the sky, I'm still here",
                177: "I'll be alive next year",
                181: "I can make something good, oh",
                186: "Something good",
                207: "Wait again, I will be much better then",
                215: "And suddenly, I've restored your faith in me",
                225: "Look at the sky",
                242: "Look at the sky, I'm still here",
                246: "I'll be alive next year",
                250: "I can make something good, oh",
                255: "Something good",
                275: "Look at the sky, I'm still here",
                279: "I'll be alive next year",
                283: "I can make something good",
                288: "Something good",
                292: "Look at the sky, I'm still here",
                296: "I'll be alive next year",
                300: "I can make something good",
                305: "Something good",
                308: ""
            },
            this.env5 = {
                color: "#15241a",
                text: "#b5dcd1",
                0: "",
                35: "Well, you were the aftermath",
                39: "Of every judgment",
                43: "So cold by the sweat that",
                48: "You’ll waste away",
                52: "And you carry your enemies",
                56: "But they’re so familiar",
                61: "I’m sick of the company",
                65: "So I cull the shame",
                68: "And I know you’ll say how I’m a burden",
                72: "Yeah, do your worst, all at once",
                76: "I know what you want from me (from me)",
                80: "I know what you’re thinking",
                85: "And it’s not the voice of all the others",
                90: "You’ve only said it to yourself",
                93: "I know what you want from me (from me)",
                98: "I know what you’re thinking",
                100: "(They come to feel like",
                102: "things we’re saying to ourselves.)",
                104: "An inch from my ears again:",
                109: "You should be sorry,",
                113: "A better song could fix my problems",
                120: "I’m tired of your questioning",
                125: "You’re cut down too easily",
                130: "And I don’t know what’s good for me",
                134: "I can’t decide",
                137: "And I know you’ll say how I’m a burden",
                141: "Yeah, do your worst, all at once",
                145: "I know what you want from me (from me)",
                149: "I know what you’re thinking",
                154: "And though they sound like one another",
                159: "You’ve only said it to yourself",
                163: "I know what you want from me (from me)",
                166: "I know what you’re thinking",
                169: "Now these voices have become our own.",
                190: "An inch from my ears again:",
                194: "You should be sorry,",
                198: "A solemn man:",
                200: "A better song could fix my problems",
                207: "I’m tired of your questioning",
                211: "You’re cut down too easily",
                215: "And I don’t know what’s good for me",
                220: "I can’t decide",
                222: "And I know you’ll say how I’m a burden",
                226: "Yeah, do your worst, all at once",
                231: "I know what you want from me (from me)",
                235: "I know what you’re thinking",
                239: "And it’s not the voice of all the others",
                244: "You’ve only said it to yourself",
                248: "I know what you want from me (from me)",
                252: "I know what you’re thinking",
                260: "And I know you’ll say how I’m a burden",
                263: "Yeah, do your worst, all at once",
                267: "I know what you want from me (from me)",
                271: "I know what you’re thinking",
                276: "And though they sound like one another",
                280: "You’ve only said it to yourself",
                285: "I know what you want from me (from me)",
                289: "I know what you’re thinking",
                295: "Sometimes, the inner voice is encouraging:",
                297: "Calling for you to run those final few yards;",
                300: "You’re nearly there, keep going",
                302: "keep going, keep going, keep going.",
                304: "It will all be OK in the end.",
                310: ""
            },
            this.env3 = {
                color: "#daecfb",
                text: "#3f4e61",
                0: "",
                10: "Watching wild skies,",
                16: "Wishing with closed eyes",
                23: "Run for a lifetime",
                31: "Follow the signs",
                37: "I put my pictures down,",
                41: "they’re not as good as the real thing.",
                45: "i wish i could go home",
                48: "“you’re just nostalgic”",
                51: "what do we wander from",
                56: "and only notice it now?",
                60: "so be here with me",
                67: "and i watched the water unfold",
                75: "it’s a feeling i want you know",
                82: "’cus i’m not the same as i was",
                90: "as i shoulder the weight of the world",
                96: "i was setting in stone",
                101: "until i noticed it right",
                104: "do you see how you’ve grown?",
                107: "don’t be sorry, then",
                112: "and i fall from my bones",
                116: "now i know i’m alive",
                119: "i want you to find it",
                125: "and i watched the water unfold",
                133: "it’s a feeling i want you know",
                140: "’cus i’m not the same as i was",
                147: "as i shoulder the weight of the world",
                155: "thaw your hands now (while i’ve been gone)",
                162: "put color in your cheeks (where i belong)",
                170: "i missed you back then ",
                176: "so be here with me",
                184: "and i watched the water unfold",
                192: "it’s a feeling i want you know",
                198: "and i watched the water unfold",
                205: "it’s a feeling i want you know",
                213: "’cus i’m not the same as i was",
                221: "as i shoulder the weight of the world",
                229: "’cus i’m not the same as i was",
                235: "as i shoulder the weight of the world",
                241: "and i watched the water unfold",
                251: "it’s a feeling i want you know",
                258: "’cus i’m not the same as i was",
                264: "as i shoulder the weight of the world",
                274: ""
            }
    }
), "Static"),
Mobile.Class((function Accelerometer() {
        var _this = this;
        function updateAccel(e) {
            switch (window.orientation) {
                case 0:
                    _this.x = -e.accelerationIncludingGravity.x,
                        _this.y = e.accelerationIncludingGravity.y,
                        _this.z = e.accelerationIncludingGravity.z,
                    e.rotationRate && (_this.rotationRate.alpha = e.rotationRate.beta * _this.toRadians,
                        _this.rotationRate.beta = -e.rotationRate.alpha * _this.toRadians,
                        _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians);
                    break;
                case 180:
                    _this.x = e.accelerationIncludingGravity.x,
                        _this.y = -e.accelerationIncludingGravity.y,
                        _this.z = e.accelerationIncludingGravity.z,
                    e.rotationRate && (_this.rotationRate.alpha = -e.rotationRate.beta * _this.toRadians,
                        _this.rotationRate.beta = e.rotationRate.alpha * _this.toRadians,
                        _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians);
                    break;
                case 90:
                    _this.x = e.accelerationIncludingGravity.y,
                        _this.y = e.accelerationIncludingGravity.x,
                        _this.z = e.accelerationIncludingGravity.z,
                    e.rotationRate && (_this.rotationRate.alpha = e.rotationRate.alpha * _this.toRadians,
                        _this.rotationRate.beta = e.rotationRate.beta * _this.toRadians,
                        _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians);
                    break;
                case -90:
                    _this.x = -e.accelerationIncludingGravity.y,
                        _this.y = -e.accelerationIncludingGravity.x,
                        _this.z = e.accelerationIncludingGravity.z,
                    e.rotationRate && (_this.rotationRate.alpha = -e.rotationRate.alpha * _this.toRadians,
                        _this.rotationRate.beta = -e.rotationRate.beta * _this.toRadians,
                        _this.rotationRate.gamma = e.rotationRate.gamma * _this.toRadians)
            }
            "android" == Device.system.os && (_this.x *= -1,
                _this.y *= -1,
                _this.z *= -1)
        }
        function updateOrientation(e) {
            for (var key in e)
                key.toLowerCase().includes("heading") && (_this.heading = e[key]);
            switch (window.orientation) {
                case 0:
                    _this.alpha = e.beta * _this.toRadians,
                        _this.beta = -e.alpha * _this.toRadians,
                        _this.gamma = e.gamma * _this.toRadians;
                    break;
                case 180:
                    _this.alpha = -e.beta * _this.toRadians,
                        _this.beta = e.alpha * _this.toRadians,
                        _this.gamma = e.gamma * _this.toRadians;
                    break;
                case 90:
                    _this.alpha = e.alpha * _this.toRadians,
                        _this.beta = e.beta * _this.toRadians,
                        _this.gamma = e.gamma * _this.toRadians;
                    break;
                case -90:
                    _this.alpha = -e.alpha * _this.toRadians,
                        _this.beta = -e.beta * _this.toRadians,
                        _this.gamma = e.gamma * _this.toRadians
            }
            _this.tilt = e.beta * _this.toRadians,
                _this.yaw = e.alpha * _this.toRadians,
                _this.roll = -e.gamma * _this.toRadians,
            "android" == Device.system.os && (_this.heading = function compassHeading(alpha, beta, gamma) {
                var degtorad = Math.PI / 180
                    , _x = beta ? beta * degtorad : 0
                    , _y = gamma ? gamma * degtorad : 0
                    , _z = alpha ? alpha * degtorad : 0
                    , cY = (Math.cos(_x),
                    Math.cos(_y))
                    , cZ = Math.cos(_z)
                    , sX = Math.sin(_x)
                    , sY = Math.sin(_y)
                    , sZ = Math.sin(_z)
                    , Vx = -cZ * sY - sZ * sX * cY
                    , Vy = -sZ * sY + cZ * sX * cY
                    , compassHeading = Math.atan(Vx / Vy);
                Vy < 0 ? compassHeading += Math.PI : Vx < 0 && (compassHeading += 2 * Math.PI);
                return compassHeading * (180 / Math.PI)
            }(e.alpha, e.beta, e.gamma))
        }
        this.x = 0,
            this.y = 0,
            this.z = 0,
            this.alpha = 0,
            this.beta = 0,
            this.gamma = 0,
            this.heading = 0,
            this.rotationRate = {},
            this.rotationRate.alpha = 0,
            this.rotationRate.beta = 0,
            this.rotationRate.gamma = 0,
            this.toRadians = "ios" == Device.system.os ? Math.PI / 180 : 1,
            this.capture = function() {
                this.active || (this.active = !0,
                    window.ondevicemotion = updateAccel,
                    window.addEventListener("deviceorientation", updateOrientation))
            }
            ,
            this.stop = function() {
                this.active = !1,
                    window.ondevicemotion = null,
                    _this.x = _this.y = _this.z = 0,
                    window.removeEventListener("deviceorientation", updateOrientation)
            }
    }
), "Static"),
Class((function Antimatter(_num, _config, _renderer=World.RENDERER, _defines=[]) {
        Inherit(this, AntimatterFBO);
        var _geometry, _this = this, _drawLimit = _num, _size = function findSize() {
            var values = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
            for (let i = 0; i < values.length; i++) {
                var p2 = values[i];
                if (p2 * p2 >= _num)
                    return p2
            }
        }();
        async function createBuffer() {
            let {geometry: geometry, vertices: vertices, attribs: attribs, usedDepth: usedDepth} = await AntimatterUtil.createBufferArray(_size, _num, _config);
            _this.vertices = _this.cloneVertices ? vertices.clone() : vertices,
                (_geometry = geometry.clone(!0)).drawRange.end = _drawLimit,
                _this.vertices.geometry = _geometry,
                _this.attribs = _this.random = attribs,
                _this.textureUsedDepth = usedDepth,
                _this.init(_geometry, _renderer, _size)
        }
        defer(createBuffer),
            this.createFloatArray = function(components=3) {
                return new Float32Array(_size * _size * components)
            }
            ,
            this.createFloatArrayAsync = async function(components=3, freshCopy) {
                let {array: array} = await AntimatterUtil.createFloatArray(_size * _size * components, freshCopy);
                return array
            }
            ,
            this.ready = function(callback) {
                return _this.wait(_this, "vertices")
            }
            ,
            this.useShader = function(vs, fs, params) {
                "object" == typeof fs && (params = fs,
                    fs = null),
                    this.vertexShader = vs,
                    this.fragmentShader = fs || vs,
                    this.uniforms = params
            }
            ,
            this.createMesh = this.getMesh = function() {
                let shader = _this.createShader(_this.fragmentShader || "AntimatterBasicFrag");
                return _this.mesh = new Points(_geometry,shader),
                    _this.mesh.frustumCulled = !1,
                    _this.shader = shader,
                    _this.geometry = _geometry,
                    _this.mesh
            }
            ,
            this.createShader = function(fs) {
                let uniforms = _this.uniforms || {}
                    , obj = {
                    tPos: {
                        type: "t",
                        value: _this.vertices.texture,
                        ignoreUIL: !0
                    },
                    tPrevPos: {
                        type: "t",
                        value: _this.vertices.texture,
                        ignoreUIL: !0
                    }
                };
                for (let key in uniforms)
                    obj[key] = uniforms[key];
                obj.customCompile = "Antimatter_" + Date.now();
                let shader = new Shader(_this.vertexShader || "AntimatterPosition",fs,obj)
                    , vs = shader.vertexShader;
                if (vs && !vs.includes("uniform sampler2D tPos")) {
                    let split = vs.split("__ACTIVE_THEORY_LIGHTS__")
                        , defined = "uniform sampler2D tPos;";
                    shader.vertexShader = split[0] + "\n" + defined + "\n__ACTIVE_THEORY_LIGHTS__\n" + split[1]
                }
                if (_defines && _defines.length) {
                    let str = "";
                    for (let i = 0, l = _defines.length; i < l; i++)
                        str += `#define ${_defines[i]}\n`;
                    shader.vertexShader = shader.vertexShader.replace("__DEFINES__", str),
                        shader.fragmentShader = shader.fragmentShader.replace("__DEFINES__", str)
                }
                return shader.vertexShader = shader.vertexShader.replace("__DEFINES__", ""),
                    shader.fragmentShader = shader.fragmentShader.replace("__DEFINES__", ""),
                    shader
            }
            ,
            this.getLookupArray = function() {
                return new Float32Array(_this.vertices.geometry.attributes.position.array)
            }
            ,
            this.getRandomArray = function() {
                return _geometry.attributes.random.array
            }
            ,
            this.overrideShader = function(original) {
                let shader = original.clone();
                original.copyUniformsTo(shader),
                    shader.uniforms.tPos = {
                        type: "t",
                        value: _this.vertices.texture,
                        ignoreUIL: !0
                    },
                    shader.uniforms.tPrevPos = {
                        type: "t",
                        value: _this.vertices.texture,
                        ignoreUIL: !0
                    },
                    _this.shader = shader,
                    _this.mesh.shader = shader
            }
            ,
            this.upload = async function() {
                _this.preventRender = !0,
                    _geometry.distributeBufferData = !0,
                    await _this.ready(),
                    await _this.vertices.uploadAsync(),
                    await defer(),
                    await _this.random.uploadAsync(),
                    await defer(),
                _this.mesh && (_this.mesh.upload(),
                    await _geometry.uploadBuffersAsync());
                for (let key in _this.shader.uniforms) {
                    let uniform = _this.shader.uniforms[key];
                    uniform.value && (uniform.value.uploadAsync ? await uniform.value.uploadAsync() : uniform.value.upload && (uniform.value.upload(),
                        await defer()))
                }
                await _this.wait(100);
                for (let i = 0; i < _this.passes.length; i++)
                    await _this.passes[i].upload();
                _this.preventRender = !1
            }
            ,
            this.uploadSync = async function() {
                await _this.ready(),
                _this.customClass && _this.customClass.loaded && await _this.customClass.loaded(),
                _this.mesh && _this.mesh.upload();
                for (let i = 0; i < 4; i++)
                    _this.update()
            }
            ,
            this.get("particleCount", (_=>_size * _size))
    }
)),
Class((function AntimatterAttribute(_data, _components) {
        Inherit(this, Component);
        var _this = this
            , _size = Math.sqrt(_data.length / (_components || 3));
        this.size = _size,
            this.count = _size * _size,
            this.buffer = _data,
            this.texture = new DataTexture(_data,_size,_size,4 == _components ? Texture.RGBAFormat : Texture.RGBFormat,Texture.FLOAT),
            this.set("needsUpdate", (function() {
                    _this.texture.needsUpdate = !0
                }
            )),
            this.bufferData = function(data, components) {
                _this.buffer = data,
                    components != _components ? (_this.texture.destroy(),
                        _this.texture = new DataTexture(data,_size,_size,4 == components ? Texture.RGBAFormat : Texture.RGBFormat,Texture.FLOAT)) : (_this.texture.data = data,
                        _this.texture.needsUpdate = !0),
                    _components = components,
                    _data = data
            }
            ,
            this.upload = function() {
                _this.texture.upload()
            }
            ,
            this.uploadAsync = function() {
                return _this.texture.distributeTextureData = !0,
                    _this.texture.upload(),
                    _this.texture.uploadAsync()
            }
            ,
            this.clone = function() {
                return new AntimatterAttribute(_data,_components)
            }
            ,
            this.onDestroy = function() {
                _this.texture && _this.texture.destroy && _this.texture.destroy()
            }
    }
)),
Class((function AntimatterFBO() {
        var _this, _gpuGeom, _renderer, _size, _prevRT, _scene, _mesh, _camera, _copy, _geometry;
        Inherit(this, Component);
        var _output = {
            type: "t",
            value: null,
            ignoreUIL: !0
        }
            , _prevOutput = {
            type: "t",
            value: null,
            ignoreUIL: !0
        };
        function copy(input, output) {
            World.RENDERER.blit(input, output) || (_copy.visible = !0,
                _mesh.visible = !1,
                _copy.shader.uniforms.tMap.value = input,
                _renderer.renderSingle(_copy, _camera, output),
                _copy.visible = !1,
                _mesh.visible = !0)
        }
        this.passes = [],
            this.init = function(geometry, renderer, size) {
                _this = this,
                    _gpuGeom = geometry.attributes.position.array,
                    _renderer = renderer,
                    _size = size,
                    function initPasses() {
                        _camera = World.CAMERA,
                            _geometry = World.QUAD,
                            _scene = new Scene,
                            (_mesh = new Mesh(_geometry,null)).frustumCulled = !1,
                            _mesh.noMatrices = !0,
                            _mesh.transient = !0,
                            _scene.add(_mesh);
                        let copyShader = AntimatterFBO.getCopyShader();
                        (_copy = new Mesh(_geometry,copyShader)).noMatrices = !0,
                            _scene.add(_copy),
                            _copy.visible = !1
                    }()
            }
            ,
            this.getGPUGeom = function() {
                return _gpuGeom
            }
            ,
            this.addPass = function(pass, index) {
                _this = this,
                pass.init || pass.initialize(_size),
                    "number" != typeof index ? _this.passes.push(pass) : _this.passes.splice(index, 0, pass)
            }
            ,
            this.findPass = function(name) {
                _this = this;
                for (var i = 0; i < _this.passes.length; i++) {
                    var pass = _this.passes[i];
                    if (pass.name == name)
                        return pass
                }
            }
            ,
            this.removePass = function(pass) {
                _this = this,
                    "number" == typeof pass ? _this.passes.splice(pass) : _this.passes.remove(pass)
            }
            ,
            this.update = function() {
                if ((_this = this).mesh && !_this.preventRender) {
                    var output = _output.value || _this.vertices.texture;
                    _this.storeVelocity && (_prevRT ? (copy(_output.value, _prevRT),
                        _prevOutput.value = _prevRT) : (_prevOutput.value = output,
                        (_prevRT = _this.passes[0].getRT(0).clone()).upload()));
                    for (var i = 0; i < _this.passes.length; i++) {
                        var pass = _this.passes[i]
                            , needsInit = !pass.init
                            , firstRender = !pass.first;
                        needsInit && pass.initialize(_size),
                            pass.first = !0,
                            _mesh.shader = pass.shader,
                            _mesh.shader.uniforms.tInput.value = firstRender ? _this.vertices.texture : pass.output,
                        pass.ready || (_mesh.shader.uniforms.tInput.value = _this.vertices.texture);
                        var rt = firstRender ? pass.getRT(0) : pass.getWrite();
                        output = pass.output;
                        _renderer.renderSingle(_scene.children[0], _camera, rt),
                            copy(rt, output),
                            pass.swap()
                    }
                    output && (_output.value = output,
                        _this.mesh.shader.uniforms.tPos.value = _output.value,
                        _this.mesh.shader.uniforms.tPrevPos.value = _prevOutput.value)
                }
            }
            ,
            this.onDestroy = function() {
                _this.vertices.destroy(),
                    _this.passes.forEach((function(pass) {
                            pass.first = !1,
                            _this.persistPasses || pass && pass.destroy && pass.destroy()
                        }
                    )),
                    _this.mesh.shader.destroy()
            }
            ,
            this.getOutput = function() {
                return _output
            }
            ,
            this.getPrevOutput = function() {
                return _prevOutput
            }
    }
), (function() {
        var _shader;
        AntimatterFBO.getCopyShader = function() {
            return _shader || ((_shader = new Shader("ScreenQuad")).uniforms = {
                tMap: {
                    type: "t",
                    value: null
                }
            },
                _shader._attachmentData = {
                    format: Texture.RGBAFormat,
                    type: Texture.FLOAT,
                    attachments: 1
                }),
                _shader
        }
    }
)),
Class((function AntimatterPass(_shader, _uni, _clone) {
        var _this = this;
        this.UILPrefix = "am_" + _shader;
        const _uniforms = {
            tInput: {
                type: "t",
                value: null,
                ignoreUIL: !0
            },
            fSize: {
                type: "f",
                value: 64,
                ignoreUIL: !0
            }
        };
        var _rts = []
            , _read = 0
            , _write = 0;
        function prepareShader(code, type) {
            if ("vs" == type)
                return code;
            let header = ["uniform sampler2D tInput;", "uniform float fSize;", "varying vec2 vUv;", Shaders.getShader("antimatter.glsl")].join("\n")
                , mainAt = code.indexOf("void main()")
                , before = code.slice(0, mainAt)
                , after = code.slice(mainAt);
            return code = before + header + after,
            _this.onCreateShader && (code = _this.onCreateShader(code)),
                code
        }
        function initRT(size) {
            var type = "ios" == Device.system.os ? Texture.HALF_FLOAT : Texture.FLOAT
                , parameters = {
                minFilter: Texture.NEAREST,
                magFilter: Texture.NEAREST,
                format: Texture.RGBAFormat,
                type: type
            }
                , rt = new RenderTarget(size,size,parameters);
            return rt.texture.generateMipmaps = !1,
                rt
        }
        this.uniforms = _uniforms,
            this.output = initRT(64),
            this.name = _shader,
            this.id = Utils.timestamp(),
            this.ready = !1,
            function() {
                if (_uni)
                    for (var key in _uni.unique && (_this.UILPrefix += "_" + _uni.unique.replace("/", "_"),
                        delete _uni.unique),
                    _uni.customCompile && (_this.customCompile = _uni.customCompile || "",
                        delete _uni.customCompile),
                        _uni)
                        _uniforms[key] = _uni[key]
            }(),
            this.addInput = function(name, attribute) {
                var uniform = "object" != typeof attribute || attribute.height || "string" != typeof attribute.type ? attribute instanceof AntimatterAttribute ? {
                    type: "t",
                    value: attribute.texture,
                    ignoreUIL: !0
                } : attribute instanceof AntimatterPass ? {
                    type: "t",
                    value: attribute.output,
                    ignoreUIL: !0
                } : {
                    type: "t",
                    value: attribute,
                    ignoreUIL: !0
                } : attribute;
                let lookup = UILStorage.parse(_this.UILPrefix + name);
                return lookup && (uniform.value = lookup.value),
                    _uniforms[name] = uniform,
                    uniform.ignoreUIL = !0,
                    _uniforms[name]
            }
            ,
            this.addUniforms = function(object) {
                for (let key in object) {
                    let uniform = object[key]
                        , lookup = UILStorage.parse(_this.UILPrefix + key);
                    if (lookup) {
                        if (Array.isArray(lookup.value))
                            switch (lookup.value.length) {
                                case 2:
                                    lookup.value = (new Vector2).fromArray(lookup.value);
                                    break;
                                case 3:
                                    lookup.value = (new Vector3).fromArray(lookup.value);
                                    break;
                                case 4:
                                    lookup.value = (new Vector4).fromArray(lookup.value)
                            }
                        uniform.value = lookup.value
                    }
                    _uniforms[key] = uniform
                }
            }
            ,
            this.getRT = function(index) {
                return _rts[index]
            }
            ,
            this.getRead = function() {
                return _rts[_read]
            }
            ,
            this.getWrite = function() {
                return _rts[_write]
            }
            ,
            this.setRead = function(index) {
                _read = index
            }
            ,
            this.setWrite = function(index) {
                _write = index
            }
            ,
            this.swap = function() {
                ++_write > 2 && (_write = 0,
                    _this.ready = !0),
                ++_read > 2 && (_this.onInit && (_this.onInit(),
                    _this.onInit = null),
                    _read = 0)
            }
            ,
            this.initialize = function(size) {
                if (!_this.init) {
                    _this.init = !0;
                    for (var i = 0; i < 3; i++)
                        _rts.push(initRT(size));
                    _this.output.setSize(size, size),
                    _shader instanceof Shader || ((_shader = new Shader("AntimatterPass",_shader,{
                        customCompile: _this.customCompile
                    }))._attachmentData = {
                        format: Texture.RGBAFormat,
                        type: Texture.FLOAT,
                        attachments: 1
                    },
                        _shader.preCompile = prepareShader,
                        _shader.uniforms = _uniforms,
                        _shader.UILPrefix = _this.UILPrefix,
                        _shader.id = Utils.timestamp()),
                        _this.shader = _shader,
                        _shader.uniforms.fSize.value = size
                }
            }
            ,
            this.setUniform = function(key, value) {
                _uniforms[key] || (_uniforms[key] = {
                    value: value
                }),
                    _uniforms[key].value = value,
                _shader && _shader.uniforms && (_shader.uniforms[key].value = value)
            }
            ,
            this.getUniform = function(key) {
                return _shader && _shader.uniforms ? _shader.uniforms[key].value : null
            }
            ,
            this.tween = function(key, value, time, ease, delay, callback, update) {
                return tween(_shader.uniforms[key], {
                    value: value
                }, time, ease, delay, callback, update)
            }
            ,
            this.clone = function() {
                return new AntimatterPass(_shader,_uni)
            }
            ,
            this.destroy = function() {
                _rts.forEach((function(rt) {
                        rt && rt.destroy && rt.destroy()
                    }
                ))
            }
            ,
            this.upload = async function() {
                _shader.upload(),
                    await defer();
                for (let i = 0; i < _rts.length; i++)
                    _rts[i].upload(),
                        await defer();
                for (let key in _shader.uniforms) {
                    let uniform = _shader.uniforms[key];
                    uniform.value && (uniform.value.uploadAsync ? await uniform.value.uploadAsync() : uniform.value.upload && (uniform.value.upload(),
                        await defer()))
                }
            }
    }
)),
Class((function AntimatterSpawn(_proton, _group, _input) {
        Inherit(this, Component);
        const _this = this;
        var _life, _pass, _velocity, _color, _index = -1, _total = _proton.particleCount, _releasedA = [], _releasedB = [];
        function loop() {
            let count = _releasedA.length;
            for (let i = count - 1; i > -1; i--) {
                let index = _releasedA[i];
                _life.buffer[4 * index + 0] = 0
            }
            _releasedA.length = 0,
            count && (_life.needsUpdate = !0);
            let hold = _releasedA;
            _releasedA = _releasedB,
                _releasedB = hold
        }
        !async function() {
            await async function initPass() {
                let[lifeBuffer,velocityBuffer] = await Promise.all([_proton.antimatter.createFloatArrayAsync(4, !0), _proton.antimatter.createFloatArrayAsync(3, !0)]);
                _life = _this.initClass(AntimatterAttribute, lifeBuffer, 4),
                    _velocity = _this.initClass(AntimatterAttribute, velocityBuffer, 3),
                    _pass = _this.initClass(AntimatterPass, "AntimatterSpawn", {
                        unique: _input.prefix,
                        uMaxCount: _proton.behavior.uniforms.uMaxCount,
                        tAttribs: _proton.behavior.uniforms.tAttribs,
                        tLife: {
                            value: _life,
                            ignoreUIL: !0
                        },
                        uSetup: {
                            value: 1,
                            ignoreUIL: !0
                        },
                        decay: {
                            value: 1
                        },
                        decayRandom: {
                            value: new Vector2(1,1)
                        }
                    }),
                    ShaderUIL.add(_pass, _group).setLabel("Life Shader"),
                    _pass.onInit = _=>{
                        _pass.setUniform("uSetup", 0),
                            _this.canEmit = !0
                    }
                    ,
                    _proton.behavior.addInput("tSpawn", _pass),
                    _proton.behavior.addInput("tVelocity", _velocity),
                    _proton.shader.addUniforms({
                        tLife: {
                            value: _pass.output
                        }
                    }),
                    _proton.antimatter.addPass(_pass, 0),
                    _this.lifeOutput = _pass.output
            }(),
                _this.startRender(loop)
        }(),
            this.emit = function(position, velocity, color) {
                if (!_this.canEmit)
                    return;
                if (velocity && position.length != velocity.length)
                    throw "Position and velocity need to be the same length";
                if (color && position.length != color.length)
                    throw "Position and color need to be the same length";
                let count = position.length / 3;
                for (let i = 0; i < count; i++) {
                    let index = ++_index;
                    _index >= _total && (_index = -1),
                        _life.buffer[4 * index + 0] = 1,
                        _life.buffer[4 * index + 1] = position[3 * i + 0],
                        _life.buffer[4 * index + 2] = position[3 * i + 1],
                        _life.buffer[4 * index + 3] = position[3 * i + 2],
                    velocity && (_velocity.buffer[3 * index + 0] = velocity[3 * i + 0],
                        _velocity.buffer[3 * index + 1] = velocity[3 * i + 1],
                        _velocity.buffer[3 * index + 2] = velocity[3 * i + 2]),
                    color && _color && (_color.buffer[3 * index + 0] = color[3 * i + 0],
                        _color.buffer[3 * index + 1] = color[3 * i + 1],
                        _color.buffer[3 * index + 2] = color[3 * i + 2]),
                        _releasedB.push(index)
                }
                _life.needsUpdate = !0,
                velocity && (_velocity.needsUpdate = !0),
                color && (_color.needsUpdate = !0)
            }
            ,
            this.release = function(pos, count=1, radius=0, velocity) {
                if (!_this.canEmit)
                    return;
                let positions = []
                    , velocities = velocity ? [] : null;
                for (let i = 0; i < count; i++)
                    positions[3 * i + 0] = pos.x + Math.random(-1, 1, 4) * radius,
                        positions[3 * i + 1] = pos.y + Math.random(-1, 1, 4) * radius,
                        positions[3 * i + 2] = pos.z + Math.random(-1, 1, 4) * radius,
                    velocities && (velocities[3 * i + 0] = velocity.x,
                        velocities[3 * i + 1] = velocity.y,
                        velocities[3 * i + 2] = velocity.z);
                _this.emit(positions, velocities)
            }
            ,
            this.upload = async function() {
                await _life.uploadAsync(),
                    await _velocity.uploadAsync()
            }
            ,
            this.useColor = async function() {
                let colorBuffer = await _proton.antimatter.createFloatArrayAsync(3, !0);
                _color = _this.initClass(AntimatterAttribute, colorBuffer, 3),
                    _proton.shader.addUniforms({
                        tColor: {
                            value: _color
                        }
                    })
            }
            ,
            this.get("total", (_=>_total)),
            this.get("index", (_=>_index)),
            this.set("index", (i=>_index = i))
    }
)),
Class((function AntimatterUtil() {
        Inherit(this, Component);
        var _thread, _promises = {};
        function createBufferArrayAntimatter(e, id) {
            let size = e.size
                , num = e.num
                , position = new Float32Array(size * size * 3);
            if (window.NativeUtils)
                NativeUtils.fillBufferUV(position, num, size);
            else
                for (let i = 0; i < num; i++)
                    position[3 * i + 0] = i % size / size,
                        position[3 * i + 1] = Math.floor(i / size) / size,
                        position[3 * i + 2] = i;
            let {w: w, h: h, d: d} = e.dimensions
                , usedDepth = num / (size * size)
                , grid = 0 == w[0] && 0 == w[1] && 0 == h[0] && 0 == h[1];
            var vertices = new Float32Array(size * size * 4);
            if (window.NativeUtils)
                grid ? NativeUtils.fillBufferGrid(vertices, num, size, usedDepth) : NativeUtils.fillBufferRange(vertices, num, w[0], w[1], h[0], h[1], d[0], d[1]);
            else
                for (let i = 0; i < num; i++)
                    grid ? (vertices[4 * i + 0] = Math.range(i % size, 0, size, -1, 1),
                        vertices[4 * i + 1] = Math.range(i / size, size * usedDepth * usedDepth, 0, -1, 1)) : (vertices[4 * i + 0] = Math.random(w[0], w[1], 10),
                        vertices[4 * i + 1] = Math.random(h[0], h[1], 10),
                        vertices[4 * i + 2] = Math.random(d[0], d[1], 10)),
                        vertices[4 * i + 3] = 1;
            var attribs = new Float32Array(size * size * 4);
            if (window.NativeUtils)
                NativeUtils.fillBufferRandom(attribs, attribs.length);
            else
                for (let i = 0; i < num; i++)
                    attribs[4 * i + 0] = Math.random(0, 1, 10),
                        attribs[4 * i + 1] = Math.random(0, 1, 10),
                        attribs[4 * i + 2] = Math.random(0, 1, 10),
                        attribs[4 * i + 3] = Math.random(0, 1, 10);
            resolve({
                geometry: position,
                vertices: vertices,
                attribs: attribs,
                usedDepth: usedDepth
            }, id, [position.buffer, vertices.buffer, attribs.buffer])
        }
        function createFloatArrayAntimatter({size: size}, id) {
            let array = new Float32Array(size);
            resolve({
                array: array
            }, id, [array.buffer])
        }
        this.createBufferArray = function(size, num, config={}) {
            _thread || function initThread() {
                _thread = !0,
                    Thread.upload(createBufferArrayAntimatter),
                    Thread.upload(createFloatArrayAntimatter)
            }();
            let key = `buffer_${JSON.stringify(config)}_${size}_${num}`;
            if (_promises[key])
                return _promises[key];
            let promise = _promises[key] = Promise.create();
            return Thread.shared().createBufferArrayAntimatter({
                size: size,
                num: num,
                dimensions: config
            }).then((data=>{
                    data.attribs = new AntimatterAttribute(data.attribs,4),
                        data.vertices = new AntimatterAttribute(data.vertices,4);
                    let geometry = data.geometry;
                    data.geometry = new Geometry,
                        data.geometry.addAttribute("position", new GeometryAttribute(geometry,3)),
                        data.geometry.addAttribute("random", new GeometryAttribute(data.attribs.buffer,4)),
                        promise.resolve(data)
                }
            )),
                promise
        }
            ,
            this.createFloatArray = function(size, freshCopy) {
                if (freshCopy)
                    return Thread.shared().createFloatArrayAntimatter({
                        size: size
                    });
                if (_promises[`float_size${size}`])
                    return _promises[`float_size${size}`];
                return _promises[`float_size${size}`] = Thread.shared().createFloatArrayAntimatter({
                    size: size
                })
            }
    }
), "static"),
Class((function AudioPlayer() {
        Inherit(this, Component);
        const SILENCE = "data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAADAAAGhgBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr///////////////////////////////////////////8AAAA5TEFNRTMuOThyAc0AAAAAAAAAABSAJAiqQgAAgAAABobxtI73AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//uQxAACFEII9ACZ/sJZwWEoEb8w/////N//////JcxjHjf+7/v/H2PzCCFAiDtGeyBCIx7bJJ1mmEEMy6g8mm2c8nrGABB4h2Mkmn//4z/73u773R5qHHu/j/w7Kxkzh5lWRWdsifCkNAnY9Zc1HvDAhjhSHdFkHFzLmabt/AQxSg2wwzLhHIJOBnAWwVY4zrhIYhhc2kvhYDfQ4hDi2Gmh5KyFn8EcGIrHAngNgIwVIEMf5bzbAiTRoAD///8z/KVhkkWEle6IX+d/z4fvH3BShK1e5kmjkCMoxVmXhd4ROlTKo3iipasvTilY21q19ta30/v/0/idPX1v8PNxJL6ramnOVsdvMv2akO0iSYIzdJFirtzWXCZicS9vHqvSKyqm5XJBdqBwPxyfJdykhWTZ0G0ZyTZGpLKxsNwwoRhsx3tZfhwmeOBVISm3impAC/IT/8hP/EKEM1KMdVdVKM2rHV4x7HVXZvbVVKN/qq8CiV9VL9jjH/6l6qf7MBCjZmOqsAibjcP+qqqv0oxqpa/NVW286hPo1nz2L/h8+jXt//uSxCmDU2IK/ECN98KKtE5IYzNoCfbw+u9i5r8PoadUMFPKqWL4LK3T/LCraMSHGkW4bpLXR/E6LlHOVQxmslKVJ8IULktMN06N0FKCpHCoYsjC4F+Z0NVqdNFoGSTjSiyjzLdnZ2fNqTi2eHKONONKLMPMKLONKLMPQRJGlFxZRoKcJFAYEeIFiRQkUWUeYfef//Ko04soswso40UJAgMw8wosososy0EalnZyjQUGBRQGIFggOWUacWUeYmuadrZziQKKEgQsQLAhQkUJAgMQDghltLO1onp0cpkNInSFMqlYeSEJ5AHsqFdOwy1DA2sRmRJKxdKRfLhfLw5BzUxBTUUzLjk4LjJVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjk4LjJVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7ksRRA8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU="
            , _this = this;
        var $player, _src = SILENCE, _loop = !0, _playing = !1, _initialized = !1, _playFirst = "assets/audio/blank.mp3";
        function addHandlers() {
            document.addEventListener(Device.mobile ? "touchend" : "mouseup", initInteraction, {
                passive: !1
            }),
                document.addEventListener("keyup", initInteraction, {
                    passive: !1
                }),
                $player.div.onended = _=>_this.events.fire(AudioPlayer.ENDED),
                _this.events.sub(AudioPlayer.ENDED, onEnded)
        }
        function initInteraction(e) {
            e && e.preventDefault && e.preventDefault(),
                document.removeEventListener("keyup", initInteraction, {
                    passive: !1
                }),
                document.removeEventListener(Device.mobile ? "touchend" : "mouseup", initInteraction, {
                    passive: !1
                }),
                _initialized = !0,
                _this.play(_playFirst)
        }
        function onEnded() {
            _playing = !1,
                _loop ? (_this.time = 0,
                    _this.play()) : navigator.mediaSession && (navigator.mediaSession.playbackState = "none")
        }
        AudioPlayer.volume = 0,
            function initPlayer() {
                ($player = $("player", "audio")).attr("src", SILENCE),
                    $player.div.volume = 0
            }(),
            defer(addHandlers),
            this.get("src", (_=>_src)),
            this.get("playing", (_=>_playing)),
            this.play = async function(src=!1, seek=0) {
                if (src)
                    await _this.load(src);
                else if (_playing)
                    return;
                if (_initialized || await defer(),
                    !_initialized)
                    return _playFirst = src,
                        void console.warn("audio must be initialized by a user interaction");
                try {
                    await $player.div.play(),
                        $player.div.currentTime = seek,
                        await $player.div.play(),
                        await _this.wait(500),
                        _playing = !0,
                        _this.events.fire(AudioPlayer.PLAYING),
                    navigator.mediaSession && (navigator.mediaSession.playbackState = "playing"),
                        _this.firstPlay = !0
                } catch (e) {}
            }
            ,
            _this.playSilence = ()=>{
                _this.firstPlay || _this.play("assets/audio/blank.mp3")
            }
            ,
            this.pause = function() {
                _playing && ($player.div.pause(),
                    _playing = !1,
                    _this.events.fire(AudioPlayer.PAUSED),
                navigator.mediaSession && (navigator.mediaSession.playbackState = "paused"))
            }
            ,
            this.load = async function(src, autoplay=!1) {
                if (src === _src)
                    return;
                _src = src;
                let canPlayThrough = Promise.create();
                $player.div.oncanplay = _=>canPlayThrough.resolve(),
                    $player.div.src = src,
                    _playing = !1,
                    _this.events.fire(AudioPlayer.LOADING),
                "ios" === Device.system.os && defer(canPlayThrough.resolve),
                    await canPlayThrough,
                    _this.events.fire(AudioPlayer.LOADED),
                autoplay && await _this.play()
            }
            ,
            this.seek = time=>$player.div.currentTime = Math.clamp(time, 0, _this.duration),
            this.get("duration", (_=>$player.div.duration)),
            this.get("initialized", (_=>_initialized)),
            this.get("progress", (_=>_this.time / _this.duration)),
            this.set("progress", (v=>_this.seek(v * _this.duration))),
            this.get("time", (_=>$player.div.currentTime)),
            this.set("time", (t=>_this.seek(t))),
            this.get("loop", (_=>_loop)),
            this.set("loop", (loop=>_loop = loop)),
            this.get("volume", (_=>$player.div.volume)),
            this.set("volume", (v=>$player.div.volume = v)),
            AudioPlayer.PLAYING = this.PLAYING = "audio_player_playing",
            AudioPlayer.LOADING = this.LOADING = "audio_player_loading",
            AudioPlayer.LOADED = this.LOADED = "audio_player_loaded",
            AudioPlayer.PAUSED = this.PAUSED = "audio_player_paused",
            AudioPlayer.ENDED = this.ENDED = "audio_player_ended"
    }
), "static"),
Class((function Canvas(_width, _height, _retina) {
        Inherit(this, Component);
        var _imgData, _this = this;
        function resize(w, h, retina) {
            var ratio = retina && Device.system.retina ? 2 : 1;
            _this.div && (_this.div.width = Math.round(w * ratio),
                _this.div.height = Math.round(h * ratio)),
                _this.width = w,
                _this.height = h,
                _this.scale = ratio
        }
        this.children = [],
            this.offset = {
                x: 0,
                y: 0
            },
            this.retina = _retina,
            _this.div = document.createElement("canvas"),
            _this.context = _this.div.getContext("2d"),
            _this.element = $(_this.div),
            _this.width = _width,
            _this.height = _height,
            _this.context._matrix = new Matrix2,
            resize(_width, _height, _retina),
            this.toDataURL = function(type, quality) {
                return _this.div.toDataURL(type, quality)
            }
            ,
            this.sort = function() {
                _objects.sort((function(a, b) {
                        return a.z - b.z
                    }
                ))
            }
            ,
            this.render = function(noClear) {
                "boolean" == typeof noClear && noClear || _this.clear();
                for (var len = _this.children.length, i = 0; i < len; i++)
                    _this.children[i].render();
                _this._rendered = Render.TIME
            }
            ,
            this.clear = function() {
                _this.context.clearRect(0, 0, _this.div.width, _this.div.height)
            }
            ,
            this.add = function(display) {
                display.setCanvas(this),
                    display._parent = this,
                    this.children.push(display),
                    display._z = this.children.length
            }
            ,
            this.remove = function(display) {
                if (display) {
                    display._canvas = null,
                        display._parent = null;
                    var i = this.children.indexOf(display);
                    i > -1 && this.children.splice(i, 1)
                }
            }
            ,
            this.onDestroy = function() {
                this.stopRender();
                for (var i = 0; i < this.children.length; i++)
                    this.children[i].destroy && this.children[i].destroy();
                this.element && this.element.remove && (this.element = this.element.remove())
            }
            ,
            this.start = function() {
                Render.start(_this.render)
            }
            ,
            this.stop = function() {
                Render.stop(_this.render)
            }
            ,
            this.getImageData = function(x, y, w, h) {
                return this.imageData = this.context.getImageData(x || 0, y || 0, w || this.width, h || this.height),
                    this.imageData
            }
            ,
            this.getPixel = function(x, y, dirty) {
                this.imageData && !dirty || _this.getImageData(0, 0, _this.width, _this.height),
                _imgData || (_imgData = {});
                var index = 4 * (x + y * _this.width)
                    , pixels = this.imageData.data;
                return _imgData.r = pixels[index],
                    _imgData.g = pixels[index + 1],
                    _imgData.b = pixels[index + 2],
                    _imgData.a = pixels[index + 3],
                    _imgData
            }
            ,
            this.texture = function(src) {
                var img = new Image;
                return img.src = src,
                    img
            }
            ,
            this.size = resize
    }
)),
Class((function CanvasTexture(_texture, _w, _h, _force) {
        Inherit(this, CanvasObject);
        var _mask, _this = this;
        function setDimensions() {
            _this.onload && _this.onload(),
            _this.width || _this.height || (_this.width = _texture.width / (_this._canvas && _this._canvas.retina ? 2 : 1),
                _this.height = _texture.height / (_this._canvas && _this._canvas.retina ? 2 : 1))
        }
        this.width = _w || 0,
            this.height = _h || 0,
            function initTexture() {
                if ("string" == typeof _texture) {
                    let url = _texture;
                    _texture = null,
                        Assets.decodeImage(url, !1).then((image=>{
                                _this.texture = _texture = image,
                                    setDimensions()
                            }
                        ))
                } else
                    setDimensions(),
                        _this.texture = _texture
            }(),
            this.set("texture", (function(img) {
                    _texture = img
                }
            )),
            this.draw = function(override) {
                var context = this._canvas.context;
                if (this.isMask() && !override)
                    return !1;
                _texture && (this.startDraw(this.anchor.tx, this.anchor.ty, override),
                    context.drawImage(_texture, -this.anchor.tx, -this.anchor.ty, this.width, this.height),
                    this.endDraw()),
                _mask && (context.globalCompositeOperation = "source-in",
                    _mask.render(!0),
                    context.globalCompositeOperation = "source-over")
            }
            ,
            this.mask = function(object) {
                if (!object)
                    return _mask = null;
                if (!this._parent)
                    throw "CanvasTexture :: Must add to parent before masking.";
                for (var siblings = this._parent.children, canMask = !1, i = 0; i < siblings.length; i++)
                    object == siblings[i] && (canMask = !0);
                if (!canMask)
                    throw "CanvasGraphics :: Can only mask a sibling";
                _mask = object,
                    object.masked = this
            }
    }
)),
Class((function Matrix2() {
        var a11, a12, a13, a21, a22, a23, a31, a32, a33, b11, b12, b13, b21, b22, b23, b31, b32, b33, _this = this, prototype = Matrix2.prototype;
        function identity(d) {
            (d = d || _this.data)[0] = 1,
                d[1] = 0,
                d[2] = 0,
                d[3] = 0,
                d[4] = 1,
                d[5] = 0,
                d[6] = 0,
                d[7] = 0,
                d[8] = 1
        }
        function noE(n) {
            return n = Math.abs(n) < 1e-6 ? 0 : n
        }
        this.type = "matrix2",
            this.data = new Float32Array(9),
            identity(),
        void 0 === prototype.identity && (prototype.identity = function(d) {
                return identity(d),
                    this
            }
                ,
                prototype.transformVector = function(v) {
                    var d = this.data
                        , x = v.x
                        , y = v.y;
                    return v.x = d[0] * x + d[1] * y + d[2],
                        v.y = d[3] * x + d[4] * y + d[5],
                        v
                }
                ,
                prototype.setTranslation = function(tx, ty, m) {
                    var d = m || this.data;
                    return d[0] = 1,
                        d[1] = 0,
                        d[2] = tx,
                        d[3] = 0,
                        d[4] = 1,
                        d[5] = ty,
                        d[6] = 0,
                        d[7] = 0,
                        d[8] = 1,
                        this
                }
                ,
                prototype.getTranslation = function(v) {
                    var d = this.data;
                    return (v = v || new Vector2).x = d[2],
                        v.y = d[5],
                        v
                }
                ,
                prototype.setScale = function(sx, sy, m) {
                    var d = m || this.data;
                    return d[0] = sx,
                        d[1] = 0,
                        d[2] = 0,
                        d[3] = 0,
                        d[4] = sy,
                        d[5] = 0,
                        d[6] = 0,
                        d[7] = 0,
                        d[8] = 1,
                        this
                }
                ,
                prototype.setShear = function(sx, sy, m) {
                    var d = m || this.data;
                    return d[0] = 1,
                        d[1] = sx,
                        d[2] = 0,
                        d[3] = sy,
                        d[4] = 1,
                        d[5] = 0,
                        d[6] = 0,
                        d[7] = 0,
                        d[8] = 1,
                        this
                }
                ,
                prototype.setRotation = function(a, m) {
                    var d = m || this.data
                        , r0 = Math.cos(a)
                        , r1 = Math.sin(a);
                    return d[0] = r0,
                        d[1] = -r1,
                        d[2] = 0,
                        d[3] = r1,
                        d[4] = r0,
                        d[5] = 0,
                        d[6] = 0,
                        d[7] = 0,
                        d[8] = 1,
                        this
                }
                ,
                prototype.setTRS = function(tx, ty, a, sx, sy) {
                    var d = this.data
                        , r0 = Math.cos(a)
                        , r1 = Math.sin(a);
                    return d[0] = r0 * sx,
                        d[1] = -r1 * sy,
                        d[2] = tx,
                        d[3] = r1 * sx,
                        d[4] = r0 * sy,
                        d[5] = ty,
                        d[6] = 0,
                        d[7] = 0,
                        d[8] = 1,
                        this
                }
                ,
                prototype.translate = function(tx, ty) {
                    return this.identity(Matrix2.__TEMP__),
                        this.setTranslation(tx, ty, Matrix2.__TEMP__),
                        this.multiply(Matrix2.__TEMP__)
                }
                ,
                prototype.rotate = function(a) {
                    return this.identity(Matrix2.__TEMP__),
                        this.setTranslation(a, Matrix2.__TEMP__),
                        this.multiply(Matrix2.__TEMP__)
                }
                ,
                prototype.scale = function(sx, sy) {
                    return this.identity(Matrix2.__TEMP__),
                        this.setScale(sx, sy, Matrix2.__TEMP__),
                        this.multiply(Matrix2.__TEMP__)
                }
                ,
                prototype.shear = function(sx, sy) {
                    return this.identity(Matrix2.__TEMP__),
                        this.setRotation(sx, sy, Matrix2.__TEMP__),
                        this.multiply(Matrix2.__TEMP__)
                }
                ,
                prototype.multiply = function(m) {
                    var a = this.data
                        , b = m.data || m;
                    return a11 = a[0],
                        a12 = a[1],
                        a13 = a[2],
                        a21 = a[3],
                        a22 = a[4],
                        a23 = a[5],
                        a31 = a[6],
                        a32 = a[7],
                        a33 = a[8],
                        b11 = b[0],
                        b12 = b[1],
                        b13 = b[2],
                        b21 = b[3],
                        b22 = b[4],
                        b23 = b[5],
                        b31 = b[6],
                        b32 = b[7],
                        b33 = b[8],
                        a[0] = a11 * b11 + a12 * b21 + a13 * b31,
                        a[1] = a11 * b12 + a12 * b22 + a13 * b32,
                        a[2] = a11 * b13 + a12 * b23 + a13 * b33,
                        a[3] = a21 * b11 + a22 * b21 + a23 * b31,
                        a[4] = a21 * b12 + a22 * b22 + a23 * b32,
                        a[5] = a21 * b13 + a22 * b23 + a23 * b33,
                        this
                }
                ,
                prototype.inverse = function(m) {
                    var a = (m = m || this).data
                        , b = this.data;
                    a11 = a[0],
                        a12 = a[1],
                        a13 = a[2],
                        a21 = a[3],
                        a22 = a[4],
                        a23 = a[5],
                        a31 = a[6],
                        a32 = a[7],
                        a33 = a[8];
                    var det = m.determinant();
                    Math.abs(det);
                    var invdet = 1 / det;
                    return b[0] = (a22 * a33 - a32 * a23) * invdet,
                        b[1] = (a13 * a32 - a12 * a33) * invdet,
                        b[2] = (a12 * a23 - a13 * a22) * invdet,
                        b[3] = (a23 * a31 - a21 * a33) * invdet,
                        b[4] = (a11 * a33 - a13 * a31) * invdet,
                        b[5] = (a21 * a13 - a11 * a23) * invdet,
                        b[6] = (a21 * a32 - a31 * a22) * invdet,
                        b[7] = (a31 * a12 - a11 * a32) * invdet,
                        b[8] = (a11 * a22 - a21 * a12) * invdet,
                        m
                }
                ,
                prototype.determinant = function() {
                    var a = this.data;
                    return a11 = a[0],
                        a12 = a[1],
                        a13 = a[2],
                        a21 = a[3],
                        a22 = a[4],
                        a23 = a[5],
                        a31 = a[6],
                        a32 = a[7],
                        a33 = a[8],
                    a11 * (a22 * a33 - a32 * a23) - a12 * (a21 * a33 - a23 * a31) + a13 * (a21 * a32 * a22 * a31)
                }
                ,
                prototype.copyTo = function(m) {
                    var a = this.data
                        , b = m.data || m;
                    return b[0] = a[0],
                        b[1] = a[1],
                        b[2] = a[2],
                        b[3] = a[3],
                        b[4] = a[4],
                        b[5] = a[5],
                        b[6] = a[6],
                        b[7] = a[7],
                        b[8] = a[8],
                        m
                }
                ,
                prototype.copyFrom = function(m) {
                    var a = this.data
                        , b = m.data || m;
                    return b[0] = a[0],
                        b[1] = a[1],
                        b[2] = a[2],
                        b[3] = a[3],
                        b[4] = a[4],
                        b[5] = a[5],
                        b[6] = a[6],
                        b[7] = a[7],
                        b[8] = a[8],
                        this
                }
                ,
                prototype.getCSS = function(force2D) {
                    var d = this.data;
                    return Device.tween.css3d && !force2D ? "matrix3d(" + noE(d[0]) + ", " + noE(d[3]) + ", 0, 0, " + noE(d[1]) + ", " + noE(d[4]) + ", 0, 0, 0, 0, 1, 0, " + noE(d[2]) + ", " + noE(d[5]) + ", 0, 1)" : "matrix(" + noE(d[0]) + ", " + noE(d[3]) + ", " + noE(d[1]) + ", " + noE(d[4]) + ", " + noE(d[2]) + ", " + noE(d[5]) + ")"
                }
        )
    }
), (function() {
        Matrix2.__TEMP__ = (new Matrix2).data
    }
)),
Class((function SplitTextfield() {
        var _style = {
            padding: 0,
            margin: 0,
            position: "relative",
            float: "",
            cssFloat: "",
            styleFloat: "",
            display: "inline-block",
            width: "auto",
            height: "auto"
        };
        this.split = function($obj, by) {
            return "word" == by ? function splitWord($obj) {
                var _array = []
                    , text = $obj.div.innerHTML
                    , split = (text = text.replace("&nbsp;", " ")).split(" ");
                $obj.attr("aria-label", text),
                    $obj.empty();
                for (var i = 0; i < split.length; i++) {
                    var word = $("t", "span")
                        , empty = $("t", "span");
                    word.html(split[i]).css(_style),
                        empty.html("&nbsp", !0).css(_style),
                        word.attr("aria-hidden", !0),
                        empty.attr("aria-hidden", !0),
                        _array.push(word),
                        _array.push(empty),
                        $obj.add(word),
                        $obj.add(empty)
                }
                return _array
            }($obj) : function splitLetter($obj) {
                var _array = []
                    , text = $obj.div.innerHTML
                    , split = text.split("");
                $obj.div.innerHTML = "",
                    $obj.attr("aria-label", text);
                for (var i = 0; i < split.length; i++) {
                    " " == split[i] && (split[i] = "&nbsp;");
                    var letter = $("t", "span");
                    letter.html(split[i], !0).css(_style),
                        letter.attr("aria-hidden", !0),
                        _array.push(letter),
                        $obj.add(letter)
                }
                return _array
            }($obj)
        }
    }
), "Static"),
Class((function Curl() {
        Inherit(this, Component);
        var _dx, _dy, _dz, _v, _pool;
        let range = Math.range
            , sin = Math.sin;
        function cnoise(v) {
            let t = null != v.z ? .3 * v.z : .3 * v.x;
            v.y *= .8;
            let noise = 0
                , s = .5;
            return noise += range(sin(.9 * v.x / s + 10 * t) + sin(2.4 * v.x / s + 15 * t) + sin(-3.5 * v.x / s + 4 * t) + sin(-2.5 * v.x / s + 7.1 * t), -1, 1, -.3, .3),
                noise += range(sin(-.3 * v.y / s + 18 * t) + sin(1.6 * v.y / s + 18 * t) + sin(2.6 * v.y / s + 8 * t) + sin(-2.6 * v.y / s + 4.5 * t), -1, 1, -.3, .3),
                noise
        }
        function snoiseVec3(x) {
            var s = cnoise(x)
                , s1 = cnoise(_v.set(x.y - 19.1, x.z + 33.4, x.x + 47.2))
                , s2 = cnoise(_v.set(x.z + 74.2, x.x - 124.5, x.y + 99.4))
                , v = _pool.get();
            return v.set(s, s1, s2),
                v
        }
        this.noise = function(p, o) {
            _pool || function initVectors() {
                _dx = new Vector3,
                    _dy = new Vector3,
                    _dz = new Vector3,
                    _x = new Vector3,
                    _v = new Vector3,
                    _pool = new ObjectPool(Vector3,10)
            }();
            var e = .1;
            _dx.set(e, 0, 0),
                _dy.set(0, e, 0),
                _dz.set(0, 0, e);
            var p_x0 = snoiseVec3(_x.copy(p).sub(_dx))
                , p_x1 = snoiseVec3(_x.copy(p).add(_dx))
                , p_y0 = snoiseVec3(_x.copy(p).sub(_dy))
                , p_y1 = snoiseVec3(_x.copy(p).add(_dy))
                , p_z0 = snoiseVec3(_x.copy(p).sub(_dz))
                , p_z1 = snoiseVec3(_x.copy(p).add(_dz))
                , x = p_y1.z - p_y0.z - p_z1.y + p_z0.y
                , y = p_z1.x - p_z0.x - p_x1.z + p_x0.z
                , z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;
            return _pool.put(p_x0),
                _pool.put(p_x1),
                _pool.put(p_y0),
                _pool.put(p_y1),
                _pool.put(p_z0),
                _pool.put(p_z1),
                (o = o || new Vector3).set(x, y, z).multiplyScalar(5).normalize(),
                o
        }
    }
), "static");
class CubicPoly {
    constructor(x0, x1, t0, t1) {
        this.init(x0, x1, t0, t1)
    }
    init(x0, x1, t0, t1) {
        this.c0 = x0,
            this.c1 = t0,
            this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1,
            this.c3 = 2 * x0 - 2 * x1 + t0 + t1
    }
    initCatmullRom(x0, x1, x2, x3, tension) {
        this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1))
    }
    initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
        let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1
            , t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1,
            t2 *= dt1,
            this.init(x1, x2, t1, t2)
    }
    calc(t) {
        let t2 = t * t
            , t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3
    }
}
Class((function Curve(_input) {
        Inherit(this, Component);
        const _this = this;
        var _curve;
        this.root = new Group,
            Array.isArray(_input) && Array.isArray(_input[0]) ? function initFromArray() {
                let points = [];
                for (let i = 0; i < _input.length; i++)
                    points.push((new Vector3).fromArray(_input[i]));
                _curve = new CatmullRomCurve(points)
            }() : function initFromObj(obj) {
                if ("string" == typeof obj) {
                    let name = obj;
                    if (!(obj = Assets.JSON[obj]))
                        throw `No curve ${name} found`;
                    obj.curves = obj.curves[0]
                } else
                    obj.curves = Array.isArray(obj.curves[0]) ? obj.curves[0] : obj.curves;
                for (var data = obj.curves, points = [], j = 0; j < data.length; j += 3)
                    points.push(new Vector3(data[j + 0],data[j + 1],data[j + 2]));
                _curve = new CatmullRomCurve(points)
            }(_input),
            this.debug = function() {
                let points = _curve.getPoints(50)
                    , geometry = (new Geometry).setFromPoints(points)
                    , shader = Utils3D.getTestShader(4095)
                    , curveObject = new Line(geometry,shader);
                return _this.root.add(curveObject),
                    _this.root
            }
            ,
            this.getPointAt = function(t) {
                t = Math.max(0, Math.min(1, t)),
                window.THREAD || this.root.updateMatrixWorld();
                let pos = _curve.getPointAt(t);
                return window.THREAD || pos.applyMatrix4(this.root.matrixWorld),
                    pos
            }
            ,
            this.getPoint = function(t) {
                t = Math.max(0, Math.min(1, t)),
                window.THREAD || this.root.updateMatrixWorld();
                let pos = _curve.getPoint(t);
                return window.THREAD || pos.applyMatrix4(this.root.matrixWorld),
                    pos
            }
            ,
            this.getTangent = function(t) {
                t = Math.max(0, Math.min(1, t)),
                window.THREAD || this.root.updateMatrixWorld();
                let pos = _curve.getTangent(t);
                return window.THREAD || pos.applyMatrix4(this.root.matrixWorld),
                    pos
            }
            ,
            this.set("closed", (v=>{
                    _curve.closed = v
                }
            )),
            this.get("curve", (_=>_curve))
    }
), (_=>{
        Curve.parseFile = async function(data) {
            "string" == typeof data && (data = await get(Assets.getPath(data)));
            let curves = [];
            return data.curves.forEach((array=>{
                    curves.push(new Curve({
                        curves: [array]
                    }))
                }
            )),
                curves
        }
            ,
            Curve.loadOnThread = function(thread) {
                thread.importES6Class("CubicPoly"),
                    thread.importES6Class("Curve3D"),
                    thread.importES6Class("CatmullRomCurve"),
                    thread.importClass(Curve)
            }
    }
));
class Curve3D {
    constructor() {
        this.arcLengthDivisions = 200
    }
    getPointAt(u) {
        let t = this.getUtoTmapping(u);
        return this.getPoint(t)
    }
    getPoints(divisions=5) {
        let points = [];
        for (let d = 0; d <= divisions; d++)
            points.push(this.getPoint(d / divisions));
        return points
    }
    getSpacedPoints(divisions=5) {
        let points = [];
        for (let d = 0; d <= divisions; d++)
            points.push(this.getPointAt(d / divisions));
        return points
    }
    getLength() {
        let lengths = this.getLengths();
        return lengths[lengths.length - 1]
    }
    getLengths(divisions=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        let current, p, cache = [], last = this.getPoint(0), sum = 0;
        for (cache.push(0),
                 p = 1; p <= divisions; p++)
            current = this.getPoint(p / divisions),
                sum += current.distanceTo(last),
                cache.push(sum),
                last = current;
        return this.cacheArcLengths = cache,
            cache
    }
    updateArtLengths() {
        this.needsUpdate = !0,
            this.getLengths()
    }
    getUtoTmapping(u, distance) {
        let targetArcLength, arcLengths = this.getLengths(), i = 0, il = arcLengths.length;
        targetArcLength = distance || u * arcLengths[il - 1];
        let comparison, low = 0, high = il - 1;
        for (; low <= high; )
            if (i = Math.floor(low + (high - low) / 2),
                comparison = arcLengths[i] - targetArcLength,
            comparison < 0)
                low = i + 1;
            else {
                if (!(comparison > 0)) {
                    high = i;
                    break
                }
                high = i - 1
            }
        if (i = high,
        arcLengths[i] === targetArcLength)
            return i / (il - 1);
        let lengthBefore = arcLengths[i];
        return (i + (targetArcLength - lengthBefore) / (arcLengths[i + 1] - lengthBefore)) / (il - 1)
    }
    getTangent(t) {
        let t1 = t - 1e-4
            , t2 = t + 1e-4;
        t1 < 0 && (t1 = 0),
        t2 > 1 && (t2 = 1);
        let pt1 = this.getPoint(t1);
        return this.getPoint(t2).clone().sub(pt1).normalize()
    }
    getTangentAt(u) {
        let t = this.getUtoTmapping(u);
        return this.getTangent(t)
    }
    computeFrenetFrames(segments, closed) {
        let i, u, theta, normal = new Vector3, tangents = [], normals = [], binormals = [], vec = new Vector3, mat = new Matrix4;
        for (i = 0; i <= segments; i++)
            u = i / segments,
                tangents[i] = this.getTangentAt(u),
                tangents[i].normalize();
        normals[0] = new Vector3,
            binormals[0] = new Vector3;
        let min = Number.MAX_VALUE
            , tx = Math.abs(tangents[0].x)
            , ty = Math.abs(tangents[0].y)
            , tz = Math.abs(tangents[0].z);
        for (tx <= min && (min = tx,
            normal.set(1, 0, 0)),
             ty <= min && (min = ty,
                 normal.set(0, 1, 0)),
             tz <= min && normal.set(0, 0, 1),
                 vec.crossVectors(tangents[0], normal).normalize(),
                 normals[0].crossVectors(tangents[0], vec),
                 binormals[0].crossVectors(tangents[0], normals[0]),
                 i = 1; i <= segments; i++)
            normals[i] = normals[i - 1].clone(),
                binormals[i] = binormals[i - 1].clone(),
                vec.crossVectors(tangents[i - 1], tangents[i]),
            vec.length() > Number.EPSILON && (vec.normalize(),
                theta = Math.acos(Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)),
                normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))),
                binormals[i].crossVectors(tangents[i], normals[i]);
        if (!0 === closed)
            for (theta = Math.acos(Math.clamp(normals[0].dot(normals[segments]), -1, 1)),
                     theta /= segments,
                 tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0 && (theta = -theta),
                     i = 1; i <= segments; i++)
                normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i)),
                    binormals[i].crossVectors(tangents[i], normals[i]);
        return {
            tangents: tangents,
            normals: normals,
            binormals: binormals
        }
    }
}
Class((function CurveLayer(_input, _group) {
        Inherit(this, Object3D);
        const _this = this;
        var _config, _curve, _debug;
        function getJSONPath() {
            let path = _config.get("json");
            return path.includes("assets/geometry") || (path = "assets/geometry/" + path),
            path.includes(".json") || (path += ".json"),
                path
        }
        !async function() {
            (_config = InputUIL.create(_input.prefix + "curve", _group)).setLabel("Curve"),
                _config.add("json"),
                _config.addToggle("debug"),
            _config.get("json") && await async function initCurve(path) {
                let data = _this.data = await get(Assets.getPath(path));
                _curve = _this.initClass(Curve, data),
                Global.PLAYGROUND && ((_debug = _curve.debug()).visible = _config.get("debug"),
                    _this.add(_debug))
            }(getJSONPath()),
                _config.onUpdate = _=>{
                    _debug && (_debug.visible = Global.PLAYGROUND && _config.get("debug"))
                }
                ,
                _this.flag("loaded", !0)
        }(),
            this.getData = async function() {
                return _config.get("json") || console.warn("No json path set on CurveLayer :: Promise won't resolve"),
                    await _this.wait("data"),
                    _this.data
            }
            ,
            this.getJSONPath = function() {
                return _config.get("json") || console.warn("No json path set on CurveLayer"),
                    getJSONPath()
            }
            ,
            this.getCurve = async function() {
                return await _this.wait("loaded"),
                    _curve
            }
    }
));
class CubicBezierCurve extends Curve3D {
    constructor(v0, v1, v2, v3) {
        super(),
            this.type = "CubicBezierCurve",
            this.v0 = v0 || new Vector3,
            this.v1 = v1 || new Vector3,
            this.v2 = v2 || new Vector3,
            this.v3 = v3 || new Vector3
    }
    getLength() {
        const tmp = this.tmp;
        let length = 0;
        return this.points.forEach(((p,i)=>{
                0 !== i && (tmp.subVectors(p, this.points[i - 1]),
                    length += tmp.length())
            }
        )),
            length
    }
    getPoint(t, optionalTarget) {
        var point = optionalTarget || new Vector3
            , v0 = this.v0
            , v1 = this.v1
            , v2 = this.v2
            , v3 = this.v3;
        return point.set(this.cubicBezier(t, v0.x, v1.x, v2.x, v3.x), this.cubicBezier(t, v0.y, v1.y, v2.y, v3.y), this.cubicBezier(t, v0.z, v1.z, v2.z, v3.z)),
            point
    }
    copy(source) {
        return this.copy.call(this, source),
            this.v0.copy(source.v0),
            this.v1.copy(source.v1),
            this.v2.copy(source.v2),
            this.v3.copy(source.v3),
            this
    }
    cubicBezierP0(t, p) {
        var k = 1 - t;
        return k * k * k * p
    }
    cubicBezierP1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p
    }
    cubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p
    }
    cubicBezierP3(t, p) {
        return t * t * t * p
    }
    cubicBezier(t, p0, p1, p2, p3) {
        return this.cubicBezierP0(t, p0) + this.cubicBezierP1(t, p1) + this.cubicBezierP2(t, p2) + this.cubicBezierP3(t, p3)
    }
}
class CatmullRomCurve extends Curve3D {
    constructor(points=[]) {
        if (super(),
            this.tmp = new Vector3,
            this.px = new CubicPoly,
            this.py = new CubicPoly,
            this.pz = new CubicPoly,
        points.length < 2)
            throw "CatmullRomCurve: Points array needs at least two entries.";
        this.points = points,
            this.closed = !1
    }
    getLength() {
        const tmp = this.tmp;
        let length = 0;
        return this.points.forEach(((p,i)=>{
                0 !== i && (tmp.subVectors(p, this.points[i - 1]),
                    length += tmp.length())
            }
        )),
            length
    }
    getPoint(t, target) {
        let p0, p1, p2, p3, tmp = this.tmp, px = this.px, py = this.py, pz = this.pz, points = this.points, l = points.length, point = (l - (this.closed ? 0 : 1)) * t, intPoint = Math.floor(point), weight = point - intPoint;
        if (this.closed ? intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length : 0 === weight && intPoint === l - 1 && (intPoint = l - 2,
            weight = 1),
            this.closed || intPoint > 0 ? p0 = points[(intPoint - 1) % l] : (tmp.subVectors(points[0], points[1]).add(points[0]),
                p0 = tmp),
            p1 = points[intPoint % l],
            p2 = points[(intPoint + 1) % l],
            this.closed || intPoint + 2 < l ? p3 = points[(intPoint + 2) % l] : (tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]),
                p3 = tmp),
        void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
            let pow = "chordal" === this.type ? .5 : .25
                , dt0 = Math.pow(p0.distanceToSquared(p1), pow)
                , dt1 = Math.pow(p1.distanceToSquared(p2), pow)
                , dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            dt1 < 1e-4 && (dt1 = 1),
            dt0 < 1e-4 && (dt0 = dt1),
            dt2 < 1e-4 && (dt2 = dt1),
                px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2),
                py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2),
                pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2)
        } else if ("catmullrom" === this.type) {
            let tension = void 0 !== this.tension ? this.tension : .5;
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension),
                py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension),
                pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension)
        }
        if (!target)
            return new Vector3(px.calc(weight),py.calc(weight),pz.calc(weight));
        target.set(px.calc(weight), py.calc(weight), pz.calc(weight))
    }
}
Class((function ImageDecoder() {
        Inherit(this, Component);
        var _compressed, _this = this;
        const ACTIVE = !(!(window.fetch && window.createImageBitmap && Device.system.browser.includes("chrome")) || window.AURA);
        function decodeImage(data, id) {
            (async _=>{
                    try {
                        let e = await fetch(data.path, {
                            mode: "cors"
                        });
                        if (200 != e.status)
                            throw resolve({
                                fail: !0
                            }, id),
                                `Image not found :: ${data.path}`;
                        let blob = await e.blob()
                            , obj = {
                            imageOrientation: "flipY",
                            crossOrigin: "anonymous"
                        };
                        data.params && !1 === data.params.premultiplyAlpha && (obj.premultiplyAlpha = "none"),
                            obj.imageOrientation = data.params && !1 === data.params.flipY ? void 0 : "flipY";
                        let bitmap = await createImageBitmap(blob, obj)
                            , message = {
                            post: !0,
                            id: id,
                            message: bitmap
                        };
                        self.postMessage(message, [bitmap])
                    } catch (e) {
                        throw resolve({
                            fail: !0
                        }, id),
                            e
                    }
                }
            )()
        }
        function decodeCompressedImage(data, id) {
            (async _=>{
                    let ext;
                    data.settings.dxt ? ext = "dxt" : data.settings.etc ? ext = "astc" : data.settings.pvrtc ? ext = "pvrtc" : data.settings.astc && (ext = "astc");
                    let fileName = data.path.split("/");
                    fileName = fileName[fileName.length - 1];
                    let e = await fetch(`${data.path}/${fileName}-${ext}.ktx`);
                    if (200 != e.status)
                        throw `Image not found :: ${data.path}`;
                    try {
                        let arrayBuffer = await e.arrayBuffer()
                            , header = new Int32Array(arrayBuffer,12,13)
                            , gliFormat = (header[1],
                            header[2],
                            header[3],
                            header[4])
                            , width = (header[5],
                            header[6])
                            , height = header[7]
                            , miplevels = header[11]
                            , bytesOfKeyValueData = header[12]
                            , buffers = []
                            , compressedData = []
                            , sizes = []
                            , dataOffset = 64 + bytesOfKeyValueData;
                        for (let level = 0; level < miplevels; level++) {
                            let imageSize = new Int32Array(arrayBuffer,dataOffset,1)[0];
                            dataOffset += 4;
                            let byteArray = new Uint8Array(arrayBuffer,dataOffset,imageSize);
                            dataOffset += imageSize,
                                dataOffset += 3 - (imageSize + 3) % 4,
                                sizes.push(width),
                                width = Math.max(1, .5 * width),
                                height = Math.max(1, .5 * height);
                            let clone = new Uint8Array(byteArray);
                            compressedData.push(clone),
                                buffers.push(clone.buffer)
                        }
                        resolve({
                            gliFormat: gliFormat,
                            compressedData: compressedData,
                            sizes: sizes,
                            width: width,
                            height: height
                        }, id, buffers)
                    } catch (e) {
                        throw `${data.path} could not be decoded`
                    }
                }
            )()
        }
        this.scale = 1,
            async function() {
                await Hydra.ready(),
                    Thread.upload(decodeImage),
                    Thread.upload(decodeCompressedImage)
            }(),
            this.decode = async function(path, params={}) {
                if (path = Thread.absolutePath(Assets.getPath(path)),
                    !_compressed) {
                    _compressed = {
                        dxt: !!Renderer.extensions.s3tc,
                        etc: !!Renderer.extensions.etc1,
                        pvrtc: !!Renderer.extensions.pvrtc,
                        astc: !!Renderer.extensions.astc
                    };
                    let found = !1;
                    for (let key in _compressed)
                        1 == _compressed[key] && (found = !0);
                    found || (_compressed = null)
                }
                if (!_compressed && path.includes("-compressedKtx") && (path = path.replace("-compressedKtx", "")),
                    path.includes("-compressedKtx")) {
                    return path = path.substring(0, path.lastIndexOf(".")),
                        await Thread.shared().decodeCompressedImage({
                            path: path,
                            params: params,
                            settings: _compressed
                        })
                }
                try {
                    let bitmap = await (ACTIVE ? Thread.shared().decodeImage({
                        path: path,
                        params: params
                    }) : Assets.decodeImage(path, params));
                    if (bitmap.fail)
                        throw "could not decode " + path;
                    return function process(bitmap, scale) {
                        if (1 == scale * _this.scale)
                            return bitmap;
                        let pow2 = Math.isPowerOf2(bitmap.width, bitmap.height)
                            , canvas = document.createElement("canvas");
                        return canvas.context = canvas.getContext("2d"),
                            canvas.width = Math.round(bitmap.width * _this.scale * scale),
                            canvas.height = Math.round(bitmap.height * _this.scale * scale),
                        pow2 && scale * _this.scale < 1 && (canvas.width = canvas.height = Math.floorPowerOf2(Math.max(canvas.width, canvas.height))),
                            canvas.context.drawImage(bitmap, 0, 0, canvas.width, canvas.height),
                            canvas
                    }(bitmap, params.scale || 1)
                } catch (e) {
                    throw "could not decode " + path
                }
            }
    }
), "static"),
    Class((function BaseCamera(_input, _group) {
            Inherit(this, Object3D);
            const _this = this;
            var _type = "perspective";
            function resize() {
                switch (_type) {
                    case "perspective":
                        _this.camera.aspect = Stage.width / Stage.height,
                            _this.camera.updateProjectionMatrix();
                        break;
                    case "orthographic":
                        if (_this.width || _this.height)
                            _this.camera.setViewport(_this.width, _this.height);
                        else {
                            let m = 900 / Stage.height / 100;
                            _this.camera.setViewport(Stage.width * m, Stage.height * m)
                        }
                }
            }
            this.camera = new PerspectiveCamera(30,Stage.width / Stage.height,.1,1e3),
                this.group.add(this.camera),
                this.startRender((_=>{
                        _this.group.updateMatrixWorld(!0)
                    }
                )),
                this.onResize((_=>{
                        resize()
                    }
                )),
            _group && (_this.prefix = _input.prefix,
                CameraUIL.add(_this, _group).setLabel("Camera")),
                this.playgroundLock = function(camera=Camera.instance()) {
                    if (!Global.PLAYGROUND)
                        return;
                    Utils.getConstructorName(_this.parent).includes(Global.PLAYGROUND.split("/")[0]) && RenderManager.type == RenderManager.NORMAL && camera.lock(_this.camera)
                }
                ,
                this.lock = function(camera=Camera.instance()) {
                    if ("orthographic" == _type)
                        return console.error("You can't lock an orthographic camera to the main camera. Use an FXScene .setCamera");
                    RenderManager.type == RenderManager.NORMAL && camera.lock(_this.camera)
                }
                ,
                this.transition = function(time, ease, delay, camera=Camera.instance()) {
                    "object" == typeof delay && (camera = delay,
                        delay = 0);
                    let p = Promise.create();
                    return camera.transition(_this.camera, time, ease, delay || 0),
                        delay > 0 ? _this.delayedCall((_=>p.resolve()), delay) : p.resolve(),
                        p
                }
                ,
                this.setFOV = function(fov) {
                    fov != this.camera.fov && (this.camera.fov = fov,
                        this.camera.updateProjectionMatrix())
                }
                ,
                this.getFOV = function() {
                    return this.camera.fov
                }
                ,
                this.useOrthographic = function(w, h) {
                    "orthographic" !== _type && "orthographic" !== _type && (isNaN(w) || (this.width = w),
                    isNaN(h) || (this.height = h),
                    this.camera && this.group.remove(this.camera),
                        this.camera = new OrthographicCamera,
                        this.group.add(this.camera),
                        _type = "orthographic",
                        resize())
                }
                ,
                this.usePerspective = function() {
                    "perspective" !== _type && (this.camera && this.group.remove(this.camera),
                        this.camera = new PerspectiveCamera,
                        this.group.add(this.camera),
                        _type = "perspective",
                        resize())
                }
        }
    )),
    Class((function Camera(_worldCamera) {
            Inherit(this, Component);
            const _this = this;
            var _debug, _prevCamera, _lockCamera, _curve, _calc = new Vector3, _target = new Group, _anim = {
                weight: 0,
                weight2: 0
            }, _center = new Vector3;
            function loop() {
                if (_debug && (_debug.visible = !_debug.position.equals(_center)),
                    _anim.weight = Math.lerp(_anim.weight2, _anim.weight, _this.lerp),
                    _prevCamera) {
                    if (_curve) {
                        let pos = _curve.getPoint(_anim.weight);
                        pos.lerp(_prevCamera.getWorldPosition(), Math.range(_anim.weight, 0, .1, 1, 0, !0)),
                            pos.lerp(_lockCamera.getWorldPosition(), Math.range(_anim.weight, .6, 1, 0, 1, !0)),
                        _curve.lerpPos || (_curve.lerpPos = (new Vector3).copy(_prevCamera.getWorldPosition()),
                            _curve.lerpBlend = {
                                value: 0
                            });
                        let lerp = Math.mix(_curveLerp || 1, 1, _curve.lerpBlend.value);
                        _curve.lerpPos.lerp(pos, lerp),
                        0 == _curve.lerpBlend.value && _calc.subVectors(_worldCamera.position, _lockCamera.getWorldPosition()).length() < .01 && (_curve.lerpBlend.value = .001,
                            tween(_curve.lerpBlend, {
                                value: 1
                            }, 1e3, "linear"),
                        _this.onCurveComplete && _this.onCurveComplete()),
                            _target.position.copy(_curve.lerpPos)
                    } else
                        _target.position.copy(_prevCamera.getWorldPosition()).lerp(_lockCamera.getWorldPosition(), _anim.weight);
                    _target.quaternion.copy(_prevCamera.getWorldQuaternion()).slerp(_lockCamera.getWorldQuaternion(), _anim.weight),
                    _worldCamera.fov != _lockCamera.fov && (_worldCamera.fov = Math.lerp(_lockCamera.fov, _worldCamera.fov, _anim.weight),
                        _worldCamera.updateProjectionMatrix()),
                        _worldCamera.position.lerp(_target.position, _this.lerp2),
                        _worldCamera.quaternion.slerp(_target.quaternion, _this.lerp2)
                } else
                    _lockCamera && (Utils3D.decompose(_lockCamera, _worldCamera),
                    _worldCamera.fov != _lockCamera.fov && (_worldCamera.fov = _lockCamera.fov,
                        _worldCamera.updateProjectionMatrix()));
                _debug && (_debug.position.copy(_worldCamera.position),
                    _debug.quaternion.copy(_worldCamera.quaternion))
            }
            this.lerp = 1,
                this.lerp2 = 1,
                this.worldCamera = _worldCamera,
                Utils.query("orbit") ? function initDebug() {
                    (_debug = new Mesh(new BoxGeometry(.25,.25,.5,1,1,5),new Shader("DebugCamera",{
                        uColor: {
                            value: new Color,
                            transparent: !0,
                            depthTest: !1
                        }
                    }))).renderOrder = 9999,
                        World.SCENE.add(_debug),
                        _worldCamera = new PerspectiveCamera;
                    let p = Global.PLAYGROUND || "m"
                        , pos = Storage.get(`debugCameraPos_${p}`) || World.CAMERA.position.toArray();
                    World.CAMERA.position.fromArray(pos);
                    let store = _=>Storage.set(`debugCameraPos_${p}`, World.CAMERA.position.toArray());
                    World.CONTROLS.onChange = store
                }() : World.CONTROLS && (World.CONTROLS.enabled = !1),
                _this.startRender(loop),
                this.lock = function(camera) {
                    _lockCamera = camera,
                        _worldCamera.fov = _lockCamera.fov,
                        _worldCamera.updateProjectionMatrix()
                }
                ,
                this.transition = function(camera, duration=1e3, ease="easeInOutCubic") {
                    return _curve && (_curve.lerpPos = _curve.lerpBlend = null),
                    camera.curve && ((_curve = camera.curve).lerpPos = camera.lerpPos),
                        _prevCamera === camera ? (duration *= .5 * Math.smoothStep(.5, 1, _anim.weight) + .5,
                            _anim.weight = 1 - _anim.weight) : _anim.weight = 0,
                        _anim.weight2 = _anim.weight,
                        _prevCamera = _lockCamera,
                        _lockCamera = camera,
                        tween(_anim, {
                            weight2: 1
                        }, duration, ease)
                }
                ,
                this.get("worldCamera", (_=>_worldCamera)),
                this.set("debugScale", (s=>{
                        _debug && _debug.scale.setScalar(s)
                    }
                )),
                this.createLocal = function(camera) {
                    return camera || (camera = World.CAMERA.clone(),
                        _this.onResize((_=>{
                                camera.aspect = Stage.width / Stage.height,
                                    camera.updateProjectionMatrix()
                            }
                        ))),
                        new Camera(camera.camera || camera)
                }
        }
    ), "singleton"),
    Class((function GazeCamera(_input, _group) {
            Inherit(this, BaseCamera);
            const _this = this;
            var _strength = {
                v: 1
            }
                , _move = new Vector3
                , _position = new Vector3
                , _wobble = new Vector3
                , _rotation = 0
                , _wobbleAngle = Math.radians(Math.rand(0, 360))
                , _innerGroup = new Group;
            function loop() {
                if (_this.useAccelerometer && Device.mobile)
                    _move.x = _this.position.x + Math.range(Mobile.Accelerometer.x, -2, 2, -1, 1, !0) * _strength.v * _this.moveXY.x * _this.strength,
                        _move.y = 0;
                else {
                    _move.x = _this.position.x + Math.range(Mouse.x, 0, Stage.width, -1, 1, !0) * _strength.v * _this.moveXY.x * _this.strength,
                        _move.y = _this.position.y + Math.range(Mouse.y, 0, Stage.height, -1, 1, !0) * _strength.v * _this.moveXY.y * _this.strength;
                    let rotateStrength = Math.range(Math.abs(Mouse.delta.x) / Stage.width, 0, .02, 0, 1, !0);
                    _rotation = Math.lerp(Math.radians(_this.deltaRotate) * rotateStrength * Math.sign(Mouse.delta.x), _rotation, .02 * _this.deltaLerp * _strength.v),
                        _this.group.rotation.z = Math.lerp(_rotation, _this.group.rotation.z, .07 * _this.deltaLerp)
                }
                if (_move.z = _this.position.z,
                    _position.lerp(_move, _this.lerpSpeed2),
                    _this.camera.position.lerp(_position, _this.lerpSpeed),
                    _this.camera.lookAt(_this.lookAt),
                _this.wobbleStrength > 0) {
                    let t = Render.TIME;
                    _wobble.x = Math.cos(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed)) * (_wobbleAngle + 200 * Math.sin(t * (95e-5 * _this.wobbleSpeed))),
                        _wobble.y = Math.sin(Math.asin(Math.cos(_wobbleAngle + t * (85e-5 * _this.wobbleSpeed)))) * (150 * Math.sin(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed))),
                        _wobble.x *= 2 * Math.sin(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed)),
                        _wobble.y *= 1.75 * Math.cos(_wobbleAngle + t * (65e-5 * _this.wobbleSpeed)),
                        _wobble.x *= 1.1 * Math.cos(_wobbleAngle + t * (75e-5 * _this.wobbleSpeed)),
                        _wobble.y *= 1.15 * Math.sin(_wobbleAngle + t * (25e-5 * _this.wobbleSpeed)),
                        _wobble.z = Math.sin(_wobbleAngle + .0025 * _wobble.x) * (100 * _this.wobbleZ),
                        _wobble.multiplyScalar(.001 * _this.wobbleStrength * _strength.v),
                        _innerGroup.position.lerp(_wobble, .07)
                }
            }
            this.strength = 1,
                this.moveXY = new Vector2(4,4),
                this.position = new function Position() {
                    Inherit(this, Component);
                    var _x = 0
                        , _y = 0
                        , _z = 0;
                    this.get("x", (_=>_x)),
                        this.get("y", (_=>_y)),
                        this.get("z", (_=>_z)),
                        this.set("x", (x=>{
                                _x = x
                            }
                        )),
                        this.set("y", (y=>{
                                _y = y
                            }
                        )),
                        this.set("z", (z=>{
                                _z = z,
                                    _move.z = _z,
                                    _this.camera.position.copy(_move),
                                    _position.copy(_move)
                            }
                        )),
                        this.set = function(x, y, z) {
                            _x = x,
                                _y = y,
                                _z = z,
                                _move.z = z,
                                _this.camera.position.copy(_move),
                                _position.copy(_move)
                        }
                        ,
                        this.toArray = function() {
                            return [_x, _y, _z]
                        }
                        ,
                        this.fromArray = function(array) {
                            _x = array[0],
                                _y = array[1],
                                _z = array[2],
                                _move.set(_x, _y, _z),
                                _this.camera.position.copy(_move),
                                _position.copy(_move)
                        }
                }
                ,
                this.lerpSpeed = .04,
                this.lerpSpeed2 = 1,
                this.lookAt = new Vector3(0,0,0),
                this.deltaRotate = 10,
                this.deltaLerp = 1,
                this.wobbleSpeed = 1,
                this.wobbleStrength = 0,
                this.wobbleZ = 1,
            _input && (_this.prefix = _input.prefix,
                CameraUIL.add(_this, _group).setLabel("Camera")),
                Mobile.Accelerometer.capture(),
                _this.startRender(loop),
                _innerGroup.add(_this.camera),
                _this.group.add(_innerGroup),
                this.orbit = function(time=1e3, ease="easeInOutSine") {
                    return tween(_strength, {
                        v: 1
                    }, time, ease)
                }
                ,
                this.still = function(time=300, ease="easeInOutSine") {
                    return tween(_strength, {
                        v: 0
                    }, time, ease)
                }
        }
    ));
class Base3D {
    constructor() {
        this.position = new Vector3D,
            this.rotation = new Euler,
            this.quaternion = new Quaternion,
            this.scale = new Vector3D(1,1,1),
            this._parent = null,
            this.up = new Vector3(0,1,0),
            this.isObject3D = !0,
            this.children = [],
            this.childrenLength = 0,
            this.modelViewMatrix = new Matrix4,
            this.normalMatrix = new Matrix3,
            this.matrix = new Matrix4,
            this.matrixWorld = new Matrix4,
            this.matrixAutoUpdate = !0,
            this.matrixWorldNeedsUpdate = !1,
            this.matrixDirty = !0,
            this.visible = !0,
            this.castShadow = !1,
            this.frustumCulled = !0,
            this._renderOrder = 0,
            this.worldPos = new Vector3;
        const _this = this;
        this.quaternion.onChange((_=>{
                _this.matrixDirty = !0,
                    _this.rotation.setFromQuaternion(_this.quaternion, void 0, !1)
            }
        )),
            this.rotation.onChange((_=>{
                    _this.matrixDirty = !0,
                        _this.quaternion.setFromEuler(_this.rotation, !1)
                }
            )),
            this.scale.onChange((_=>{
                    _this.matrixDirty = !0
                }
            )),
            this.position.onChange((_=>{
                    _this.matrixDirty = !0
                }
            ))
    }
    get renderOrder() {
        return this._renderOrder
    }
    set renderOrder(value) {
        this._renderOrder = value;
        let p = this._parent;
        for (; p; )
            p instanceof Scene && (p.displayNeedsUpdate = !0),
                p = p._parent;
        for (let i = 0; i < this.children.length; i++)
            this.children[i].renderOrder += value
    }
    applyMatrix(matrix) {
        return this.matrix.multiplyMatrices(matrix, this.matrix),
            this.matrix.decompose(this.position, this.quaternion, this.scale),
            this
    }
    applyQuaternion(q) {
        return this.quaternion.premultiply(q),
            this
    }
    setRotationFromAxisAngle(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle)
    }
    setRotationFromMatrix(m) {
        this.quaternion.setFromRotationMatrix(m)
    }
    setRotationFromQuaternion(q) {
        this.quaternion.copy(q)
    }
    localToWorld(v) {
        return v.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(v) {
        let m1 = this.M1 || new Matrix4;
        this.M1 = m1,
            v.applyMatrix4(m1.getInverse(this.matrixWorld))
    }
    lookAt(x, y, z) {
        let m1 = this.M1 || new Matrix4;
        this.M1 = m1;
        let v = this.V1 || new Vector3;
        this.V1 = v,
            x.isVector3 ? v.copy(x) : v.set(x, y, z),
            this.isCamera ? m1.lookAt(this.position, v, this.up) : m1.lookAt(v, this.position, this.up),
            this.quaternion.setFromRotationMatrix(m1)
    }
    add(object) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.add(arguments[i]);
            return this
        }
        if (object === this)
            return this;
        if (object && object.isObject3D ? (null !== object._parent && object._parent.remove(object),
            object._parent = this,
            this.children.push(object),
            this.childrenLength = this.children.length) : console.error("Object is not instance of Object3D", object),
            this.isScene)
            this.displayNeedsUpdate = !0;
        else {
            let p = this._parent;
            for (; p; )
                p instanceof Scene && (p.displayNeedsUpdate = !0),
                    p = p._parent
        }
        return this
    }
    remove(object) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        if (this.isScene)
            this.displayNeedsUpdate = !0;
        else {
            let p = this._parent;
            for (; p; )
                p instanceof Scene && (p.displayNeedsUpdate = !0),
                    p = p._parent
        }
        this.children.remove(object),
            this.childrenLength = this.children.length
    }
    getWorldPosition(target) {
        let v = this.V1 || new Vector3;
        return this.V1 = v,
        target || (target = v),
            this.updateMatrixWorld(),
            target.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldScale(target) {
        let v = this.V1 || new Vector3;
        this.V1 = v;
        let v2 = this.V12 || new Vector3;
        this.V2 = v2;
        let q = this.Q1 || new Quaternion;
        return this.Q1 = q,
        target || (target = v2),
            this.updateMatrixWorld(),
            this.matrixWorld.decompose(v, q, target),
            target
    }
    getWorldQuaternion(target) {
        let v = this.V1 || new Vector3;
        this.V1 = v;
        let q = this.Q1 || new Quaternion;
        return this.Q1 = q,
        target || (target = q),
            this.updateMatrixWorld(),
            this.matrixWorld.decompose(v, target, v),
            target
    }
    traverse(callback) {
        callback(this);
        let children = this.children;
        for (let i = 0; i < children.length; i++)
            children[i].traverse(callback)
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(force) {
        if (!force && !this.determineVisible())
            return;
        (this.determineDirty() || force) && !0 === this.matrixAutoUpdate && this.updateMatrix(),
        !0 !== this.matrixWorldNeedsUpdate && !0 !== force || (null === this._parent || this.determineNoTransform() ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this._parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1),
            this.children.forEach((c=>c.updateMatrixWorld(force))),
            this.matrixDirty = !1
    }
    clone(recursive) {
        (new this.constructor).copy(this, recursive)
    }
    copy(source, recursive) {
        if (this.name = source.name,
            this.up.copy(source.up),
            this.position.copy(source.position),
            this.quaternion.copy(source.quaternion),
            this.scale.copy(source.scale),
            this.matrix.copy(source.matrix),
            this.matrixWorld.copy(source.matrixWorld),
            this.matrixAutoUpdate = source.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate,
            this.visible = source.visible,
            this.castShadow = source.castShadow,
            this.receiveShadow = source.receiveShadow,
            this.frustumCulled = source.frustumCulled,
            this.renderOrder = source.renderOrder,
        !0 === recursive)
            for (let i = 0; i < source.children.length; i++) {
                let child = source.children[i];
                this.add(child.clone())
            }
        return this
    }
    render() {}
    determineVisible() {
        if (this.determineVisibleCacheTime > 0 && Render.TIME - this.determineVisibleCacheTime < 8)
            return this.determineVisibleCache;
        if (this.determineVisibleCacheTime = Render.TIME,
            !this.visible)
            return this.determineVisibleCache = !1,
                !1;
        let p = this._parent;
        for (; p; ) {
            if (!p.visible)
                return this.determineVisibleCache = !1,
                    !1;
            p = p._parent
        }
        return this.determineVisibleCache = !0,
            !0
    }
    determineDirty() {
        let p = this._parent;
        for (; p; ) {
            if (p.matrixDirty)
                return !0;
            p = p._parent
        }
        return this.matrixDirty
    }
    determineNoTransform() {
        return this._parent ? this._parent.determineNoTransform() && this.matrix.isIdentity() : this.matrix.isIdentity()
    }
    upload() {
        this.shader && (this.shader.upload(this, this.geometry),
        this.shader.shadow && this.shader.shadow.upload(this, this.geometry)),
        this.geometry && this.geometry.upload(this, this.shader)
    }
    destroy() {
        this.geometry && this.geometry.destroy && this.geometry.destroy(this),
        this.shader && this.shader.destroy && this.shader.destroy(this),
        this.hitDestroy && this.hitDestroy(),
        this._gl && this._gl.ubo && this._gl.ubo.destroy(),
        this._gl && this._gl.vao && this._gl.vao.destroy(),
        this._gl && (this._gl = null),
        this._parent && this._parent.remove(this),
        this.parent && this.parent.__destroyChild && this.parent.__destroyChild(this.__id)
    }
}
Class((function Renderer(_params={}) {
        Inherit(this, Component);
        const _this = this;
        var _canvas, _gl, _width, _height, _anisotropy, _projScreenMatrix, _frustum, _ubo, _dpr = 1, _resolution = new Vector2, _m0 = new Matrix4, _m1 = new Matrix4, _time = {
            value: 0
        };
        function initCameraUBO(camera) {
            camera._ubo = new UBO(0,_gl),
                camera._ubo.push({
                    value: camera.projectionMatrix
                }),
                camera._ubo.push({
                    value: camera.matrixWorldInverse
                }),
                camera._ubo.push({
                    value: camera.worldPos
                }),
                camera._ubo.push({
                    value: _resolution
                }),
                camera._ubo.push(_time),
                camera._ubo.push(Global.GRASS_TIME),
                camera._ubo.push(Render.timeScaleUniform),
                camera._ubo.upload()
        }
        function projectObject(object, camera, scene) {
            if (void 0 !== object.shader) {
                let visible = object.determineVisible() && object.shader.visible && !object.shader.neverRender;
                visible && (object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld),
                    object.normalMatrix.getNormalMatrix(object.modelViewMatrix)),
                (scene.displayNeedsUpdate || object.shader.transparent && !scene.disableAutoSort && visible) && object.getWorldPosition(object.worldPos),
                scene.displayNeedsUpdate && scene.toRender[object.shader.transparent ? 1 : 0].push(object)
            }
            if (!0 === object.visible || scene.displayNeedsUpdate)
                for (let i = object.childrenLength - 1; i > -1; i--)
                    projectObject(object.children[i], camera, scene)
        }
        function attachSceneUniforms(object, scene, camera) {
            if (Shader.renderer.appendUniform(object.shader, "normalMatrix", object.normalMatrix),
                Shader.renderer.appendUniform(object.shader, "modelMatrix", object.matrixWorld),
                Shader.renderer.appendUniform(object.shader, "modelViewMatrix", object.modelViewMatrix),
                _ubo ? camera._ubo.bind(object.shader._gl.program, "global") : (Shader.renderer.appendUniform(object.shader, "projectionMatrix", camera.projectionMatrix),
                    Shader.renderer.appendUniform(object.shader, "viewMatrix", camera.matrixWorldInverse),
                    Shader.renderer.appendUniform(object.shader, "cameraPosition", camera.worldPos),
                    Shader.renderer.appendUniform(object.shader, "resolution", _resolution),
                    Shader.renderer.appendUniform(object.shader, "time", _time.value),
                    Shader.renderer.appendUniform(object.shader, "timeGrass", Global.GRASS_TIME.value),
                    Shader.renderer.appendUniform(object.shader, "timeScale", Render.timeScaleUniform.value)),
            _this.shadows && object.shader.receiveShadow && !_this.overridePreventShadows) {
                let lights = Lighting.getShadowLights();
                object._gl || (object._gl = {}),
                object._gl.shadowData || (object._gl.shadowData = {
                    combined: new Float32Array(16 * lights.length)
                });
                for (let i = 0; i < lights.length; i++) {
                    let light = lights[i];
                    _m1.multiplyMatrices(light.shadow.camera.matrixWorldInverse, object.matrixWorld),
                        _m0.multiplyMatrices(light.shadow.camera.projectionMatrix, _m1),
                        _m0.toArray(object._gl.shadowData.combined, 16 * i)
                }
                scene._shadowData && scene._shadowData.count && (object.shader.uniforms.shadowMap.value = scene._shadowData[_this.overridePreventShadows ? "emptyMaps" : "maps"],
                    Shader.renderer.appendUniform(object.shader, "shadowMatrix", object._gl.shadowData.combined, "matrix"),
                    Shader.renderer.appendUniform(object.shader, "shadowLightPos", scene._shadowData.pos, "vec3"),
                    Shader.renderer.appendUniform(object.shader, "shadowSize", scene._shadowData.size, "float"))
            }
        }
        function attachShadowUniforms(object, scene, light) {
            light._mvm || (light._mvm = new Matrix4),
            light._nm || (light._nm = new Matrix3),
                light._mvm.multiplyMatrices(light.shadow.camera.matrixWorldInverse, object.matrixWorld),
                light._nm.getNormalMatrix(object.modelViewMatrix),
                Shader.renderer.appendUniform(object.shader.shadow, "normalMatrix", light._nm),
                Shader.renderer.appendUniform(object.shader.shadow, "modelMatrix", object.matrixWorld),
                Shader.renderer.appendUniform(object.shader.shadow, "modelViewMatrix", light._mvm),
                _ubo ? light.shadow.camera._ubo.bind(object.shader._gl.program, "global") : (Shader.renderer.appendUniform(object.shader.shadow, "projectionMatrix", light.shadow.camera.projectionMatrix),
                    Shader.renderer.appendUniform(object.shader.shadow, "viewMatrix", light.shadow.camera.matrixWorldInverse))
        }
        function loop(t, dt) {
            _time.value += .001 * dt
        }
        function render(scene, camera, rt) {
            rt ? (_resolution.set(rt.width, rt.height),
                RenderTarget.renderer.bind(rt)) : (Renderer.overrideViewport || (_gl.viewport(0, 0, _width * _dpr, _height * _dpr),
                _resolution.set(_canvas.width, _canvas.height)),
            _this.autoClear && (_gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]),
                _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT))),
            camera.parent || camera.updateMatrixWorld(),
                camera.getWorldPosition(camera.worldPos),
                _frustum.setFromCamera(camera),
            _ubo && (camera._ubo ? camera._ubo.update() : initCameraUBO(camera));
            for (let l = 0; l < 2; l++) {
                let len = scene.toRender[l].length;
                for (let i = 0; i < len; i++) {
                    let object = scene.toRender[l][i];
                    object.onBeforeRender && object.onBeforeRender(),
                    object.determineVisible() && object.shader.visible && !object.shader.neverRender && (!1 !== object.frustumCulled && !0 !== _frustum.intersectsObject(object) || (object.shader.draw(object, object.geometry),
                        attachSceneUniforms(object, scene, camera),
                        object.geometry.draw(object, object.shader)))
                }
            }
            rt && RenderTarget.renderer.unbind(rt)
        }
        Global.GRASS_TIME = {
            value: 0
        },
            this.autoClear = !0,
            this.shadows = Renderer.SHADOWS_MED,
            Renderer.instance = _this,
            Renderer.CLEAR = [0, 0, 0, 1],
            function initContext() {
                let contextAttributes = {
                    antialias: void 0 !== _params.antialias && _params.antialias,
                    powerPreference: _params.powerPreference,
                    preserveDrawingBuffer: _params.preserveDrawingBuffer,
                    xrCompatible: _params.xrCompatible,
                    alpha: void 0 !== _params.alpha && _params.alpha
                };
                if (_canvas = _params.canvas || document.createElement("canvas"),
                    _params.gl ? (_gl = _params.gl,
                        _this.type = Device.graphics.webgl.version.includes(["webgl 2", "webgl2"]) ? Renderer.WEBGL2 : Renderer.WEBGL1) : Device.graphics.webgl ? ["webgl2", "webgl", "experimental-webgl"].forEach((name=>{
                            _gl || "webgl2" == name && _params.forceWebGL1 || (_gl = _canvas.getContext(name, contextAttributes),
                                _this.type = _gl && "webgl2" == name ? Renderer.WEBGL2 : Renderer.WEBGL1)
                        }
                    )) : (_gl = new NoGLPolyfill,
                        _this.type = Renderer.WEBGL2),
                    !_gl)
                    throw "Error! Could not create WebGL context";
                _this.domElement = _canvas,
                    _canvas.style.background = "black",
                    Renderer.type = _this.type,
                    Renderer.context = _this.context = _gl
            }(),
            function setExtensions() {
                _this.extensions = {},
                    _this.type != Renderer.WEBGL2 ? (_this.extensions.VAO = _gl.getExtension("OES_vertex_array_object"),
                        _this.extensions.instancedArrays = _gl.getExtension("ANGLE_instanced_arrays"),
                        _this.extensions.standardDerivatives = _gl.getExtension("OES_standard_derivatives"),
                        _this.extensions.depthTextures = _gl.getExtension("WEBGL_depth_texture"),
                        _this.extensions.drawBuffers = _gl.getExtension("WEBGL_draw_buffers"),
                        _this.extensions.halfFloat = _gl.getExtension("OES_texture_half_float"),
                        _this.extensions.float = _gl.getExtension("OES_texture_float"),
                        _this.extensions.colorBufferFloat = _gl.getExtension("WEBGL_color_buffer_float")) : _this.extensions.colorBufferFloat = _gl.getExtension("EXT_color_buffer_float"),
                    _this.extensions.filterFloat = _gl.getExtension("OES_texture_float_linear"),
                    _this.extensions.anisotropy = _gl.getExtension("EXT_texture_filter_anisotropic") || _gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                    _this.extensions.astc = _gl.getExtension("WEBGL_compressed_texture_astc"),
                    _this.extensions.atc = _gl.getExtension("WEBGL_compressed_texture_atc"),
                    _this.extensions.etc = _gl.getExtension("WEBGL_compressed_texture_etc"),
                    _this.extensions.etc1 = _gl.getExtension("WEBGL_compressed_texture_etc1"),
                    _this.extensions.pvrtc = _gl.getExtension("WEBGL_compressed_texture_pvrtc") || _gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                    _this.extensions.s3tc = _gl.getExtension("WEBGL_compressed_texture_s3tc") || _gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
                    _this.extensions.s3tc_srgb = _gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                    Renderer.extensions = _this.extensions
            }(),
            function initRenderers() {
                Geometry.renderer = new GeometryRendererWebGL(_gl),
                    Texture.renderer = new TextureRendererWebGL(_gl),
                    Shader.renderer = new ShaderRendererWebGL(_gl),
                    RenderTarget.renderer = new FBORendererWebGL(_gl)
            }(),
            function initMath() {
                _projScreenMatrix = new Matrix4,
                    new Vector3,
                    _frustum = new Frustum
            }(),
            function initUBO() {
                _this.type == Renderer.WEBGL2 && (_ubo = !0),
                    Renderer.UBO = _ubo
            }(),
            _this.startRender(loop),
            this.render = function(scene, camera, rt, forceToScreen) {
                scene.displayNeedsUpdate && (scene.toRender[0].length = 0,
                    scene.toRender[1].length = 0),
                    scene.updateMatrixWorld(),
                    projectObject(scene, camera, scene),
                scene.displayNeedsUpdate && function sortOpaque(array) {
                    for (let i = array.length - 1; i > -1; i--) {
                        let obj = array[i];
                        obj.shader._gl || obj.shader.upload()
                    }
                    array.sort(((a,b)=>{
                            if (a.renderOrder !== b.renderOrder)
                                return a.renderOrder - b.renderOrder;
                            let aid = a.shader._gl._id
                                , bid = b.shader._gl._id;
                            return aid !== bid ? aid - bid : a.id - b.id
                        }
                    ))
                }(scene.toRender[0]),
                (scene.displayNeedsUpdate || scene.toRender[1].length && !scene.disableAutoSort) && function sortTransparent(array) {
                    RenderStats.update("SortTransparent", array.length),
                        array.sort(((a,b)=>a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.worldPos.z !== b.worldPos.z ? a.worldPos.z - b.worldPos.z : a.id - b.id))
                }(scene.toRender[1]),
                _this.shadows && !_this.overridePreventShadows && !_this.pauseShadowRendering && scene.hasShadowLight && function renderShadows(scene, camera) {
                    let render = light=>{
                        RenderTarget.renderer.bind(light.shadow.rt),
                            RenderStats.update("ShadowLights"),
                            light.shadow.camera.updateMatrixWorld(),
                            camera.getWorldPosition(camera.worldPos),
                            _frustum.setFromCamera(camera),
                        _ubo && (light.shadow.camera._ubo ? light.shadow.camera._ubo.update() : initCameraUBO(light.shadow.camera));
                        for (let l = 0; l < 2; l++)
                            for (let i = 0; i < scene.toRender[l].length; i++) {
                                let object = scene.toRender[l][i];
                                !0 === object.castShadow && object.determineVisible() && object.shader.visible && !object.shader.neverRender && (!1 !== object.frustumCulled && !0 !== _frustum.intersectsObject(object) || (object.shader.shadow || Lighting.initShadowShader(object),
                                    object.shader.shadow.draw(object, object.geometry),
                                    attachShadowUniforms(object, 0, light),
                                    object.geometry.draw(object, object.shader),
                                _ubo && light.shadow.camera._ubo.unbind(),
                                    RenderStats.update("ShadowMesh")))
                            }
                        RenderTarget.renderer.unbind(light.shadow.rt)
                    }
                        , lights = Lighting.getShadowLights();
                    scene._shadowData || (scene._shadowData = {
                        maps: [],
                        emptyMaps: [],
                        size: new Float32Array(lights.length),
                        pos: new Float32Array(3 * lights.length),
                        count: lights.length
                    }),
                    scene._shadowData.count != lights.length && (scene._shadowData.size = new Float32Array(lights.length),
                        scene._shadowData.pos = new Float32Array(3 * lights.length),
                        scene._shadowData.count = lights.length);
                    for (let i = 0; i < lights.length; i++) {
                        let light = lights[i];
                        light.prepareRender(),
                            scene._shadowData.maps[i] = light.shadow.rt.depth,
                            scene._shadowData.emptyMaps[i] = Utils3D.getEmptyTexture(),
                            scene._shadowData.size[i] = light.shadow.size,
                            light.position.toArray(scene._shadowData.pos, 3 * i)
                    }
                    for (let i = 0; i < lights.length; i++) {
                        let light = lights[i];
                        !light.shadow.frozen && light.determineVisible() && render(light)
                    }
                }(scene, camera),
                    rt || !_this.vrRenderingPath || forceToScreen ? rt || !_this.arRenderingPath || forceToScreen ? render(scene, camera, rt) : _this.arRenderingPath(render, scene, camera) : _this.vrRenderingPath(scene, camera, _projScreenMatrix, _frustum, attachSceneUniforms),
                    scene.displayNeedsUpdate = !1,
                    Shader.renderer.resetState()
            }
            ,
            this.renderSingle = function(object, camera, rt) {
                rt ? (_resolution.set(rt.width, rt.height),
                    RenderTarget.renderer.bind(rt)) : (Renderer.overrideViewport || (_gl.viewport(0, 0, _width * _dpr, _height * _dpr),
                    _resolution.set(_canvas.width, _canvas.height)),
                _this.autoClear && (_gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]),
                    _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT))),
                    camera.getWorldPosition(camera.worldPos),
                    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld),
                    object.normalMatrix.getNormalMatrix(object.modelViewMatrix),
                    object.getWorldPosition(object.worldPos),
                _ubo && (camera._ubo || initCameraUBO(camera)),
                    object.shader.draw(object, object.geometry),
                object.noMatrices || (Shader.renderer.appendUniform(object.shader, "normalMatrix", object.normalMatrix),
                    Shader.renderer.appendUniform(object.shader, "modelMatrix", object.matrixWorld),
                    Shader.renderer.appendUniform(object.shader, "modelViewMatrix", object.modelViewMatrix)),
                    _ubo ? camera._ubo.bind(object.shader._gl.program, "global") : (Shader.renderer.appendUniform(object.shader, "projectionMatrix", camera.projectionMatrix),
                        Shader.renderer.appendUniform(object.shader, "viewMatrix", camera.matrixWorldInverse),
                        Shader.renderer.appendUniform(object.shader, "cameraPosition", camera.worldPos),
                        Shader.renderer.appendUniform(object.shader, "resolution", _resolution),
                        Shader.renderer.appendUniform(object.shader, "time", _time.value),
                        Shader.renderer.appendUniform(object.shader, "timeGrass", Global.GRASS_TIME.value),
                        Shader.renderer.appendUniform(object.shader, "timeScale", Render.timeScaleUniform.value)),
                    object.geometry.draw(object, object.shader),
                _ubo && camera._ubo.unbind(),
                rt && RenderTarget.renderer.unbind(rt),
                    Shader.renderer.resetState()
            }
            ,
            this.setClearColor = function(color, alpha=1) {
                _this.clearColor = new Color(color),
                    Renderer.CLEAR = [_this.clearColor.r, _this.clearColor.g, _this.clearColor.b, alpha]
            }
            ,
            this.setClearAlpha = function(alpha) {
                Renderer.CLEAR[3] = alpha
            }
            ,
            this.getClearColor = function() {
                return _this.clearColor || (_this.clearColor = new Color(0,0,0)),
                    _this.clearColor
            }
            ,
            this.getClearAlpha = function() {
                return Renderer.CLEAR[3]
            }
            ,
            this.setPixelRatio = function(dpr) {
                _dpr = dpr,
                    this.setSize(_width, _height)
            }
            ,
            this.setSize = function(width, height) {
                _width = width,
                    _height = height,
                    _canvas.width = width * _dpr,
                    _canvas.height = height * _dpr,
                    _canvas.style.width = `${width}px`,
                    _canvas.style.height = `${height}px`,
                    _resolution.set(_canvas.width, _canvas.height)
            }
            ,
            this.getMaxAnisotropy = function() {
                return Device.graphics.webgl && _this.extensions.anisotropy ? (_anisotropy || (_anisotropy = _gl.getParameter(_this.extensions.anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),
                    _anisotropy) : 0
            }
            ,
            this.readPixels = function(rt, x=0, y=0, width, height) {
                width || (width = rt ? rt.width : 1),
                height || (height = rt ? rt.height : 1);
                let array = new Uint8Array((width - x) * (height - y) * 4);
                return _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt ? rt._gl : null),
                    _gl.readPixels(x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, array),
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
                    array
            }
            ,
            this.blit = function(input, output) {
                return _this.type == Renderer.WEBGL2 && (input._gl || input.upload(),
                output._gl || output.upload(),
                    _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, input._gl),
                    _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, output._gl),
                    _gl.blitFramebuffer(0, 0, input.width, input.height, 0, 0, output.width, output.height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST),
                    _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, null),
                    _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null),
                    !0)
            }
            ,
            this.get("resolution", (_=>_resolution)),
            this.get("time", (_=>_time)),
            this.get("canvas", (_=>_canvas))
    }
), (_=>{
        Renderer.WEBGL1 = "webgl1",
            Renderer.WEBGL2 = "webgl2",
            Renderer.STATIC_SHADOWS = "static_shadows",
            Renderer.SHADOWS_LOW = "shadows_low",
            Renderer.SHADOWS_MED = "shadows_med",
            Renderer.SHADOWS_HIGH = "shadows_high",
            Renderer.ID = 0
    }
));
class CameraBase3D extends Base3D {
    constructor() {
        super(),
            this.matrixWorldInverse = new Matrix4,
            this.projectionMatrix = new Matrix4,
            this.isCamera = !0
    }
    copy(source, recursive) {
        return Base3D.prototype.copy.call(this, source, recursive),
            this.matrixWorldInverse.copy(source.matrixWorldInverse),
            this.projectionMatrix.copy(source.projectionMatrix),
            this
    }
    updateMatrixWorld(force) {
        Base3D.prototype.updateMatrixWorld.call(this, force),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
class CubeCamera extends Base3D {
    constructor(near=.1, far=1e3, cubeResolution=512) {
        super();
        this.px = new PerspectiveCamera(90,1,near,far),
            this.px.up.set(0, -1, 0),
            this.px.lookAt(new Vector3(1,0,0)),
            this.add(this.px),
            this.nx = new PerspectiveCamera(90,1,near,far),
            this.nx.up.set(0, -1, 0),
            this.nx.lookAt(new Vector3(-1,0,0)),
            this.add(this.nx),
            this.py = new PerspectiveCamera(90,1,near,far),
            this.py.up.set(0, 0, 1),
            this.py.lookAt(new Vector3(0,1,0)),
            this.add(this.py),
            this.ny = new PerspectiveCamera(90,1,near,far),
            this.ny.up.set(0, 0, -1),
            this.ny.lookAt(new Vector3(0,-1,0)),
            this.add(this.ny),
            this.pz = new PerspectiveCamera(90,1,near,far),
            this.pz.up.set(0, -1, 0),
            this.pz.lookAt(new Vector3(0,0,1)),
            this.add(this.pz),
            this.nz = new PerspectiveCamera(90,1,near,far),
            this.nz.up.set(0, -1, 0),
            this.nz.lookAt(new Vector3(0,0,-1)),
            this.add(this.nz),
            this.rt = new CubeRenderTarget(cubeResolution,cubeResolution)
    }
    render(scene=World.SCENE, renderer=World.RENDERER) {
        let rt = this.rt;
        rt.activeFace = 0,
            renderer.render(scene, this.px, rt),
        this.afterRender && this.afterRender(rt),
            rt.activeFace = 1,
            renderer.render(scene, this.nx, rt),
        this.afterRender && this.afterRender(rt),
            rt.activeFace = 2,
            renderer.render(scene, this.py, rt),
        this.afterRender && this.afterRender(rt),
            rt.activeFace = 3,
            renderer.render(scene, this.ny, rt),
        this.afterRender && this.afterRender(rt),
            rt.activeFace = 4,
            renderer.render(scene, this.pz, rt),
        this.afterRender && this.afterRender(rt),
            rt.activeFace = 5,
            renderer.render(scene, this.nz, rt),
        this.afterRender && this.afterRender(rt)
    }
}
class OrthographicCamera extends CameraBase3D {
    constructor(left, right, top, bottom, near, far) {
        super(),
            this.isOrthographicCamera = !0,
            this.zoom = 1,
            this.left = left,
            this.right = right,
            this.top = top,
            this.bottom = bottom,
            this.near = void 0 !== near ? near : .1,
            this.far = void 0 !== far ? far : 2e3,
            this.position.z = 1,
            this.updateProjectionMatrix()
    }
    clone() {
        return (new OrthographicCamera).copy(this)
    }
    copy(source, recursive) {
        return CameraBase3D.prototype.copy.call(this, source, recursive),
            this.left = source.left,
            this.right = source.right,
            this.top = source.top,
            this.bottom = source.bottom,
            this.near = source.near,
            this.far = source.far,
            this.zoom = source.zoom,
            this.view = null === source.view ? null : Object.assign({}, source.view),
            this
    }
    updateProjectionMatrix() {
        let dx = (this.right - this.left) / (2 * this.zoom)
            , dy = (this.top - this.bottom) / (2 * this.zoom)
            , cx = (this.right + this.left) / 2
            , cy = (this.top + this.bottom) / 2
            , left = cx - dx
            , right = cx + dx
            , top = cy + dy
            , bottom = cy - dy;
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far)
    }
    setViewport(width, height) {
        this.left = width / -2,
            this.right = width / 2,
            this.top = height / 2,
            this.bottom = height / -2,
            this.updateProjectionMatrix()
    }
}
class PerspectiveCamera extends CameraBase3D {
    constructor(fov, aspect, near, far) {
        super(),
            this.type = "PerspectiveCamera",
            this.fov = fov || 50,
            this.zoom = 1,
            this.near = near || .1,
            this.far = far || 2e3,
            this.focus = 10,
            this.aspect = aspect || 1,
            this.filmGauge = 35,
            this.filmOffset = 0,
            this.updateProjectionMatrix()
    }
    clone() {
        return (new PerspectiveCamera).copy(this)
    }
    copy(source, recursive) {
        return CameraBase3D.prototype.copy.call(this, source, recursive),
            this.fov = source.fov,
            this.zoom = source.zoom,
            this.near = source.near,
            this.far = source.far,
            this.focus = source.focus,
            this.aspect = source.aspect,
            this.filmGauge = source.filmGauge,
            this.filmOffset = source.filmOffset,
            this
    }
    setFocalLength(focalLength) {
        let vExtentSlope = .5 * this.getFilmHeight() / focalLength;
        this.fov = Math.degrees(2 * Math.atan(vExtentSlope)),
            this.updateProjectionMatrix()
    }
    getFocalLength() {
        let vExtentSlope = Math.tan(Math.radians(.5 * this.fov));
        return .5 * this.getFilmHeight() / vExtentSlope
    }
    getEffectiveFOV() {
        return Math.degrees(2 * Math.atan(Math.tan(Math.radians(.5 * this.fov)) / this.zoom))
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    updateProjectionMatrix() {
        let near = this.near
            , top = near * Math.tan(Math.radians(.5 * this.fov)) / this.zoom
            , height = 2 * top
            , width = this.aspect * height
            , left = -.5 * width
            , skew = (this.view,
            this.filmOffset);
        0 !== skew && (left += near * skew / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far)
    }
}
class Geometry {
    constructor() {
        this.attributes = {},
            this.drawRange = {
                start: 0,
                end: 0
            },
            this.boundingBox = null,
            this.boundingSphere = null,
            this.index = null,
            this.maxInstancedCount = void 0,
            this.keepAlive = !1,
            this.id = Utils.timestamp()
    }
    draw(mesh, shader) {
        Geometry.renderer.draw(this, mesh, shader)
    }
    upload(mesh, shader) {
        Geometry.renderer.upload(this, mesh, shader)
    }
    destroy(mesh) {
        this.keepAlive || Geometry.renderer.destroy(this, mesh)
    }
    addAttribute(name, attribute) {
        attribute.meshPerAttribute >= 1 && (this.isInstanced = !0,
            this.maxInstancedCount = attribute.count),
            this.attributes[name] = attribute
    }
    setIndex(attribute) {
        this.index = attribute.array || attribute
    }
    toNonIndexed() {
        let geometry2 = new Geometry
            , indices = this.index
            , attributes = this.attributes;
        for (let name in attributes) {
            let attribute = attributes[name]
                , array = attribute.array
                , itemSize = attribute.itemSize
                , array2 = new array.constructor(indices.length * itemSize)
                , index = 0
                , index2 = 0;
            for (let i = 0, l = indices.length; i < l; i++) {
                index = indices[i] * itemSize;
                for (let j = 0; j < itemSize; j++)
                    array2[index2++] = array[index++]
            }
            geometry2.addAttribute(name, new GeometryAttribute(array2,itemSize))
        }
        return geometry2
    }
    normalizeNormals() {
        let vector = this._V1 || new Vector3;
        this._V1 = vector;
        let x, y, z, normals = this.attributes.normal;
        for (let i = 0, il = normals.count; i < il; i++)
            x = 3 * i + 0,
                y = 3 * i + 1,
                z = 3 * i + 2,
                vector.x = normals.array[x],
                vector.y = normals.array[y],
                vector.z = normals.array[z],
                vector.normalize(),
                normals.array[x] = vector.x,
                normals.array[y] = vector.y,
                normals.array[z] = vector.z
    }
    computeFaceNormals() {
        let cb = new Vector3
            , ab = new Vector3;
        for (let f = 0, fl = this.faces.length; f < fl; f++) {
            let face = this.faces[f]
                , vA = this.vertices[face.a]
                , vB = this.vertices[face.b]
                , vC = this.vertices[face.c];
            cb.subVectors(vC, vB),
                ab.subVectors(vA, vB),
                cb.cross(ab),
                cb.normalize(),
                face.normal.copy(cb)
        }
    }
    computeVertexNormals() {
        let index = this.index
            , attributes = this.attributes
            , groups = this.groups;
        if (attributes.position) {
            let positions = attributes.position.array;
            if (void 0 === attributes.normal)
                this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length),3));
            else {
                let array = attributes.normal.array;
                for (let i = 0, il = array.length; i < il; i++)
                    array[i] = 0
            }
            let vA, vB, vC, normals = attributes.normal.array, pA = new Vector3, pB = new Vector3, pC = new Vector3, cb = new Vector3, ab = new Vector3;
            if (index) {
                let indices = index.array;
                0 === groups.length && this.addGroup(0, indices.length);
                for (let j = 0, jl = groups.length; j < jl; ++j) {
                    let group = groups[j]
                        , start = group.start;
                    for (let i = start, il = start + group.count; i < il; i += 3)
                        vA = 3 * indices[i + 0],
                            vB = 3 * indices[i + 1],
                            vC = 3 * indices[i + 2],
                            pA.fromArray(positions, vA),
                            pB.fromArray(positions, vB),
                            pC.fromArray(positions, vC),
                            cb.subVectors(pC, pB),
                            ab.subVectors(pA, pB),
                            cb.cross(ab),
                            normals[vA] += cb.x,
                            normals[vA + 1] += cb.y,
                            normals[vA + 2] += cb.z,
                            normals[vB] += cb.x,
                            normals[vB + 1] += cb.y,
                            normals[vB + 2] += cb.z,
                            normals[vC] += cb.x,
                            normals[vC + 1] += cb.y,
                            normals[vC + 2] += cb.z
                }
            } else
                for (let i = 0, il = positions.length; i < il; i += 9)
                    pA.fromArray(positions, i),
                        pB.fromArray(positions, i + 3),
                        pC.fromArray(positions, i + 6),
                        cb.subVectors(pC, pB),
                        ab.subVectors(pA, pB),
                        cb.cross(ab),
                        normals[i] = cb.x,
                        normals[i + 1] = cb.y,
                        normals[i + 2] = cb.z,
                        normals[i + 3] = cb.x,
                        normals[i + 4] = cb.y,
                        normals[i + 5] = cb.z,
                        normals[i + 6] = cb.x,
                        normals[i + 7] = cb.y,
                        normals[i + 8] = cb.z;
            this.normalizeNormals(),
                attributes.normal.needsUpdate = !0
        }
    }
    computeBoundingBox() {
        this.boundingBox || (this.boundingBox = new Box3);
        let position = this.attributes.position;
        position ? this.boundingBox.setFromBufferAttribute(position) : this.boundingBox.makeEmpty()
    }
    computeBoundingSphere() {
        let box = new Box3
            , vector = new Vector3;
        this.boundingSphere || (this.boundingSphere = new Sphere);
        let position = this.attributes.position;
        if (position) {
            let center = this.boundingSphere.center;
            box.setFromBufferAttribute(position),
                box.getCenter(center);
            let maxRadiusSq = 0;
            for (let i = 0, il = position.count; i < il; i++)
                vector.x = position.array[3 * i + 0],
                    vector.y = position.array[3 * i + 1],
                    vector.z = position.array[3 * i + 2],
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq),
            isNaN(this.boundingSphere.radius) && console.error("Bounding Sphere came up NaN, broken position buffer.", this)
        }
    }
    merge(geometry) {
        let Float32ArrayConcat = (first,second)=>{
            let firstLength = first.length
                , result = new Float32Array(firstLength + second.length);
            return result.set(first),
                result.set(second, firstLength),
                result
        }
            , attributes = this.attributes;
        if (this.index) {
            let indices = geometry.index
                , offset = attributes.position.count;
            for (let i = 0, il = indices.length; i < il; i++)
                indices[i] = offset + indices[i];
            this.index = ((first,second)=>{
                    let firstLength = first.length
                        , result = new Uint16Array(firstLength + second.length);
                    return result.set(first),
                        result.set(second, firstLength),
                        result
                }
            )(this.index, indices)
        }
        for (let key in attributes)
            void 0 !== geometry.attributes[key] && (attributes[key].array = Float32ArrayConcat(attributes[key].array, geometry.attributes[key].array),
                attributes[key].count = attributes[key].array.length / attributes[key].itemSize);
        return this
    }
    clone(noCopy) {
        return (new Geometry).copy(this, noCopy)
    }
    copy(source, noCopy) {
        this.index = null,
            this.attributes = {},
            this.boundingBox = null,
            this.boundingSphere = null,
            this.index = source.index;
        let attributes = source.attributes;
        for (let name in attributes)
            this.addAttribute(name, attributes[name].clone(noCopy));
        let boundingBox = source.boundingBox;
        boundingBox && boundingBox.clone && (this.boundingBox = boundingBox.clone());
        let boundingSphere = source.boundingSphere;
        return boundingSphere && boundingSphere.clone && (this.boundingSphere = boundingSphere.clone()),
            this
    }
    center() {
        let offset = new Vector3;
        return this.computeBoundingBox(),
            this.boundingBox.getCenter(offset).negate(),
            this.applyMatrix((new Matrix4).makeTranslation(offset.x, offset.y, offset.z)),
            this
    }
    applyMatrix(matrix) {
        let position = this.attributes.position;
        position && (matrix.applyToBufferAttribute(position),
            position.needsUpdate = !0);
        let normal = this.attributes.normal;
        if (normal) {
            (new Matrix3).getNormalMatrix(matrix).applyToBufferAttribute(normal),
                normal.needsUpdate = !0
        }
        return this.boundingBox && this.computeBoundingBox(),
        this.boundingSphere && this.computeBoundingSphere(),
            this
    }
    scale(x, y, z) {
        this.applyMatrix((new Matrix4).makeScale(x, y, z))
    }
    setFromPoints(points) {
        let position = [];
        for (let i = 0, l = points.length; i < l; i++) {
            let point = points[i];
            position.push(point.x, point.y, point.z || 0)
        }
        return this.addAttribute("position", new GeometryAttribute(new Float32Array(position),3)),
            this
    }
    instanceFrom(geom) {
        geom.index && (geom = geom.toNonIndexed());
        for (let key in geom.attributes)
            this.addAttribute(key, geom.attributes[key]);
        return this
    }
    uploadBuffersAsync() {
        return Geometry.renderer.uploadBuffersAsync(this)
    }
}
class GeometryAttribute {
    constructor(_array, _itemSize, _meshPerAttribute) {
        this.array = _array,
            this.itemSize = _itemSize,
            this.count = void 0 !== _array ? _array.length / _itemSize : 0,
            this.dynamic = !1,
            this.updateRange = {
                offset: 0,
                count: -1
            },
            this.meshPerAttribute = _meshPerAttribute
    }
    setArray(array) {
        let newCount = void 0 !== array ? array.length / this.itemSize : 0;
        newCount != this.count && (this.needsNewBuffer = !0),
            this.array = array,
            this.count = newCount,
            this.needsUpdate = !0
    }
    clone(noCopy) {
        return noCopy ? this : new GeometryAttribute(new Float32Array(this.array),this.itemSize,this.meshPerAttribute)
    }
    getX(index) {
        return this.array[index * this.itemSize]
    }
    setX(index, x) {
        return this.array[index * this.itemSize] = x,
            this
    }
    getY(index) {
        return this.array[index * this.itemSize + 1]
    }
    setY(index, y) {
        return this.array[index * this.itemSize + 1] = y,
            this
    }
    getZ(index) {
        return this.array[index * this.itemSize + 2]
    }
    setZ(index, z) {
        return this.array[index * this.itemSize + 2] = z,
            this
    }
    getW(index) {
        return this.array[index * this.itemSize + 3]
    }
    setW(index, w) {
        return this.array[index * this.itemSize + 3] = w,
            this
    }
    setXY(index, x, y) {
        return index *= this.itemSize,
            this.array[index + 0] = x,
            this.array[index + 1] = y,
            this
    }
    setXYZ(index, x, y, z) {
        return index *= this.itemSize,
            this.array[index + 0] = x,
            this.array[index + 1] = y,
            this.array[index + 2] = z,
            this
    }
    setXYZW(index, x, y, z, w) {
        return index *= this.itemSize,
            this.array[index + 0] = x,
            this.array[index + 1] = y,
            this.array[index + 2] = z,
            this.array[index + 3] = w,
            this
    }
}
class Group extends Base3D {
    constructor() {
        super(),
            this.isGroup = !0
    }
}
class BaseLight extends Base3D {
    constructor(color=16777215, intensity=1, distance=9999) {
        super(),
            this.color = new Color(color),
            this.data = new Vector4,
            this.data2 = new Vector4,
            this.data3 = new Vector4,
            this.properties = new Vector4(intensity,distance,0,0)
    }
    destroy() {
        this.shadow && (Lighting.removeFromShadowGroup(this),
            this.shadow.destroy())
    }
    prepareRender() {
        this.shadow.camera.position.copy(this.position),
            this.shadow.camera.lookAt(this.shadow.target)
    }
    set castShadow(bool) {
        (this.shadow || bool) && (this.shadow || (this.shadow = new Shadow(this)),
            this.shadow.enabled = bool,
        this.silentShadow || (bool ? Lighting.addToShadowGroup(this) : Lighting.removeFromShadowGroup(this)))
    }
    set intensity(v) {
        this.properties.x = v
    }
    get intensity() {
        return this.properties.x
    }
    set distance(v) {
        this.properties.y = v
    }
    get distance() {
        return this.properties.y
    }
    set bounce(v) {
        this.properties.z = v
    }
    get bounce() {
        return this.properties.z
    }
}
class Line extends Base3D {
    constructor(geometry, shader) {
        super(),
            this.geometry = geometry,
            this.shader = shader,
            this.isLine = !0,
            this.id = Renderer.ID++
    }
    clone() {
        return new Line(this.geometry,this.shader).copy(this)
    }
}
class Mesh extends Base3D {
    constructor(geometry, shader) {
        super(),
            this._geometry = geometry,
            this._shader = shader && shader.shader ? shader.shader : shader,
            this.isMesh = !0,
            this.id = Utils.timestamp(),
        shader && (this._shader.mesh = this)
    }
    clone() {
        return new Mesh(this._geometry,this.shader).copy(this)
    }
    set geometry(g) {
        Geometry.renderer.resetMeshGeom(this),
            this._geometry = g
    }
    get geometry() {
        return this._geometry
    }
    set shader(shader) {
        this._shader = shader && shader.shader ? shader.shader : shader
    }
    get shader() {
        return this._shader
    }
}
class Points extends Base3D {
    constructor(geometry, shader) {
        super(),
            this._geometry = geometry,
            this.shader = shader,
            this.isPoints = !0,
            this.id = Renderer.ID++,
        shader && (this.shader.mesh = this)
    }
    clone() {
        return new Points(this._geometry,this.shader).copy(this)
    }
    set geometry(g) {
        Geometry.renderer.resetMeshGeom(this),
            this._geometry = g
    }
    get geometry() {
        return this._geometry
    }
}
class Scene extends Base3D {
    constructor() {
        super(),
            this.autoUpdate = !0,
            this.toRender = [[], []],
            this._displayNeedsUpdate = !0,
            this.isScene = !0,
            this.changes = []
    }
    set displayNeedsUpdate(v) {
        !0 === v && this.changes.forEach((cb=>cb())),
            this._displayNeedsUpdate = v
    }
    get displayNeedsUpdate() {
        return this._displayNeedsUpdate
    }
    bindSceneChange(cb) {
        this.changes.push(cb)
    }
}
Class((function FBORendererWebGL(_gl) {
        const WEBGL2 = Renderer.type == Renderer.WEBGL2
            , {getFormat: getFormat, getProperty: getProperty, getType: getType, getFloatParams: getFloatParams} = require("GLTypes");
        function prepareTexture(texture) {
            texture._gl = _gl.createTexture(),
                _gl.bindTexture(_gl.TEXTURE_2D, texture._gl),
                _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS)),
                _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT)),
                _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter)),
                _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter)),
                texture.needsUpdate = !1
        }
        function texImageDB(rt, texture) {
            if (texture.type.includes("float")) {
                let {internalformat: internalformat, format: format, type: type} = getFloatParams(texture);
                _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null)
            } else
                _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), getType(texture), null);
            _gl.bindTexture(_gl.TEXTURE_2D, null)
        }
        this.upload = function(rt) {
            if (!rt._gl) {
                if (rt.cube)
                    return function uploadCube(rt) {
                        rt._gl = _gl.createFramebuffer(),
                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl);
                        let texture = rt.texture;
                        texture._gl = _gl.createTexture(),
                            texture.cube = !0,
                            texture.needsUpdate = !1,
                            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
                        for (let i = 0; i < 6; i++)
                            _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), _gl.UNSIGNED_BYTE, null);
                        _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS)),
                            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT)),
                            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter)),
                            _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter)),
                            rt._depthBuffer = _gl.createRenderbuffer(),
                            _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer),
                            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, rt.width, rt.height),
                            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, rt._depthBuffer),
                            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
                            _gl.bindTexture(_gl.TEXTURE_2D, null),
                            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null)
                    }(rt);
                if (rt._gl = _gl.createFramebuffer(),
                rt.depth || rt.disableDepth || (rt._depthBuffer = _gl.createRenderbuffer(),
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer),
                    _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, rt.width, rt.height)),
                    RenderCount.add(`fbo_${rt.width}x${rt.height}`, rt),
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
                    rt.multi)
                    if (WEBGL2) {
                        let colorAttachments = [];
                        for (let i = 0; i < rt.attachments.length; i++) {
                            let key = "COLOR_ATTACHMENT" + i
                                , texture = rt.attachments[i];
                            colorAttachments.push(_gl[key]),
                                prepareTexture(texture),
                                texImageDB(rt, texture),
                                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl[key], _gl.TEXTURE_2D, texture._gl, 0)
                        }
                        _gl.drawBuffers(colorAttachments)
                    } else {
                        let ext = Renderer.extensions.drawBuffers
                            , colorAttachments = [];
                        for (let i = 0; i < rt.attachments.length; i++) {
                            let key = "COLOR_ATTACHMENT" + i + "_WEBGL"
                                , texture = rt.attachments[i];
                            colorAttachments.push(ext[key]),
                                prepareTexture(texture),
                                texImageDB(rt, texture),
                                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, ext[key], _gl.TEXTURE_2D, texture._gl, 0)
                        }
                        ext.drawBuffersWEBGL(colorAttachments)
                    }
                else {
                    if (prepareTexture(rt.texture),
                        rt.texture.type.includes("float")) {
                        let {internalformat: internalformat, format: format, type: type} = getFloatParams(rt.texture);
                        _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null)
                    } else
                        _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(rt.texture), rt.width, rt.height, 0, getFormat(rt.texture), getType(rt.texture), null);
                    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, rt.texture._gl, 0)
                }
                if (rt.depth) {
                    prepareTexture(rt.depth);
                    let iformat = WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT;
                    _gl.texImage2D(_gl.TEXTURE_2D, 0, iformat, rt.width, rt.height, 0, _gl.DEPTH_COMPONENT, _gl.UNSIGNED_INT, null),
                        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, rt.depth._gl, 0)
                } else
                    rt.disableDepth || _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, rt._depthBuffer);
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
                    _gl.bindTexture(_gl.TEXTURE_2D, null),
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null)
            }
        }
            ,
            this.bind = function(rt) {
                rt._gl || this.upload(rt),
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
                rt.cube && _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + rt.activeFace, rt.texture._gl, 0),
                rt.scissor && (_gl.enable(_gl.SCISSOR_TEST),
                    _gl.scissor(rt.scissor.x, rt.scissor.y, rt.scissor.width, rt.scissor.height)),
                    _gl.viewport(rt.viewport.x, rt.viewport.y, rt.width, rt.height),
                Renderer.instance.autoClear && (_gl.clearColor(Renderer.CLEAR[0], Renderer.CLEAR[1], Renderer.CLEAR[2], Renderer.CLEAR[3]),
                    _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT))
            }
            ,
            this.unbind = function(rt) {
                rt.scissor && _gl.disable(_gl.SCISSOR_TEST),
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null)
            }
            ,
            this.resize = function(rt) {
                if (rt.texture._gl && rt._gl) {
                    if (_gl.bindFramebuffer(_gl.FRAMEBUFFER, rt._gl),
                        rt.multi)
                        for (let i = 0; i < rt.attachments.length; i++) {
                            let texture = rt.attachments[i];
                            if (_gl.bindTexture(_gl.TEXTURE_2D, texture._gl),
                                texture.type.includes("float")) {
                                let {internalformat: internalformat, format: format, type: type} = getFloatParams(rt.texture);
                                _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null)
                            } else
                                _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(texture), rt.width, rt.height, 0, getFormat(texture), getType(texture), null)
                        }
                    else if (_gl.bindTexture(_gl.TEXTURE_2D, rt.texture._gl),
                        rt.texture.type.includes("float")) {
                        let {internalformat: internalformat, format: format, type: type} = getFloatParams(rt.texture);
                        _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, rt.width, rt.height, 0, format, type, null)
                    } else
                        _gl.texImage2D(_gl.TEXTURE_2D, 0, getFormat(rt.texture), rt.width, rt.height, 0, getFormat(rt.texture), getType(rt.texture), null);
                    if (rt.depth) {
                        _gl.bindTexture(_gl.TEXTURE_2D, rt.depth._gl);
                        let iformat = WEBGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT;
                        _gl.texImage2D(_gl.TEXTURE_2D, 0, iformat, rt.width, rt.height, 0, _gl.DEPTH_COMPONENT, _gl.UNSIGNED_INT, null),
                            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, rt.depth._gl, 0)
                    } else
                        rt.disableDepth || (_gl.bindRenderbuffer(_gl.RENDERBUFFER, rt._depthBuffer),
                            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, rt.width, rt.height));
                    _gl.bindTexture(_gl.TEXTURE_2D, null),
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null),
                        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null)
                }
            }
            ,
            this.destroy = function(rt) {
                _gl.deleteFramebuffer(rt._gl),
                    Texture.renderer.destroy(rt.texture),
                    RenderCount.remove(`fbo_${rt.width}x${rt.height}`),
                rt.multi && rt.attachments.forEach((t=>Texture.renderer.destroy(t))),
                    rt._gl = null
            }
    }
)),
    Class((function GeometryRendererWebGL(_gl) {
            var _cache = {};
            const WEBGL2 = Renderer.type == Renderer.WEBGL2;
            function updateBuffer(attrib) {
                if (!attrib._gl)
                    return;
                attrib.needsUpdate = !1,
                    _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
                    RenderStats.update("BufferUpdates");
                let array = attrib.array
                    , updateRange = attrib.updateRange;
                if (-1 === updateRange.count)
                    attrib.needsNewBuffer ? (_gl.bufferData(_gl.ARRAY_BUFFER, attrib.array, _gl.DYNAMIC_DRAW),
                        attrib.needsNewBuffer = !1) : _gl.bufferSubData(_gl.ARRAY_BUFFER, 0, array);
                else if (Array.isArray(updateRange)) {
                    for (let i = updateRange.length - 1; i > -1; i--) {
                        let {offset: offset, count: count} = updateRange[i];
                        _gl.bufferSubData(_gl.ARRAY_BUFFER, offset * array.BYTES_PER_ELEMENT, array.subarray(offset, offset + count))
                    }
                    updateRange.length = 0
                } else
                    _gl.bufferSubData(_gl.ARRAY_BUFFER, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
                _gl.bindBuffer(_gl.ARRAY_BUFFER, null)
            }
            this.draw = function(geom, mesh, shader) {
                geom._gl && !geom.needsUpdate && mesh._gl && mesh._gl.geomInit || this.upload(geom, mesh, shader),
                RenderStats.active && RenderStats.update("DrawCalls", 1, shader.vsName + "|" + shader.fsName, mesh);
                for (let key in geom.attributes) {
                    let attrib = geom.attributes[key];
                    mesh._gl.program != shader._gl.program ? (mesh._gl[key] = _gl.getAttribLocation(shader._gl.program, key),
                        mesh._gl.program = shader._gl.program) : void 0 === mesh._gl[key] && (mesh._gl[key] = _gl.getAttribLocation(shader._gl.program, key)),
                    -1 !== mesh._gl[key] && ((attrib.needsUpdate || attrib.dynamic) && updateBuffer(attrib))
                }
                geom.indexNeedsUpdate && (_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index),
                    _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geom.index, _gl.STATIC_DRAW),
                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null),
                    geom.indexNeedsUpdate = !1),
                    mesh._gl.vao.bind();
                let mode = mesh._gl.mode;
                mode || (mesh._gl.mode = mode = function getMode(mesh, shader) {
                    return mesh.isPoints ? _gl.POINTS : mesh.isLine ? _gl.LINE_STRIP : shader.wireframe ? _gl.LINES : _gl.TRIANGLES
                }(mesh, shader));
                let drawStart = geom.drawRange.start || 0
                    , drawEnd = geom.drawRange.end || geom.attributes.position.count;
                geom.isInstanced ? WEBGL2 ? geom.index ? _gl.drawElementsInstanced(mode, geom.index.length, _gl.UNSIGNED_SHORT, 0, geom.maxInstancedCount) : _gl.drawArraysInstanced(mode, drawStart, drawEnd, geom.maxInstancedCount) : geom.index ? Renderer.extensions.instancedArrays.drawElementsInstancedANGLE(mode, geom.index.length, _gl.UNSIGNED_SHORT, 0, geom.maxInstancedCount) : Renderer.extensions.instancedArrays.drawArraysInstancedANGLE(mode, 0, drawEnd, geom.maxInstancedCount) : geom.index ? _gl.drawElements(mode, geom.index.length, _gl.UNSIGNED_SHORT, 0) : _gl.drawArrays(mode, drawStart, drawEnd),
                    mesh._gl.vao.unbind()
            }
                ,
                this.upload = function(geom, mesh, shader) {
                    if (!mesh)
                        return;
                    geom._gl || (geom._gl = {
                        id: Utils.timestamp()
                    }),
                    mesh._gl || (mesh._gl = {}),
                        mesh._gl.geomInit = !0;
                    const KEY = `${geom._gl.id}_${shader._gl._id}`;
                    let cached = _cache[KEY];
                    if (cached)
                        return cached.count++,
                            mesh._gl.vao = cached.vao,
                            void (mesh._gl.lookup = KEY);
                    RenderCount.add("geometry"),
                    mesh._gl.vao && mesh._gl.vao.destroy(),
                        mesh._gl.vao = new VAO(_gl),
                    geom.distributeBufferData || RenderCount.add("geom_upload", geom);
                    for (let key in geom.attributes) {
                        let attrib = geom.attributes[key]
                            , location = mesh._gl[key] || _gl.getAttribLocation(shader._gl.program, key);
                        mesh._gl[key] = location,
                        attrib._gl || (attrib._gl = {},
                            attrib._gl.buffer = _gl.createBuffer(),
                            attrib._gl.bufferUploaded = !geom.distributeBufferData,
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
                            _gl.bufferData(_gl.ARRAY_BUFFER, geom.distributeBufferData ? attrib.array.length * attrib.array.BYTES_PER_ELEMENT : attrib.array, attrib.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW),
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, null),
                            attrib.needsUpdate = !1)
                    }
                    geom.index && (geom._gl.index || (geom._gl.index = _gl.createBuffer(),
                        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index),
                        _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, geom.index, _gl.STATIC_DRAW),
                        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null))),
                        mesh._gl.vao.bind();
                    for (let key in geom.attributes) {
                        let attrib = geom.attributes[key]
                            , location = mesh._gl[key];
                        -1 != location && (_gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
                            _gl.vertexAttribPointer(location, attrib.itemSize, _gl.FLOAT, !1, 0, 0),
                            _gl.enableVertexAttribArray(location),
                        geom.isInstanced && (WEBGL2 ? _gl.vertexAttribDivisor(location, attrib.meshPerAttribute) : Renderer.extensions.instancedArrays.vertexAttribDivisorANGLE(location, attrib.meshPerAttribute)))
                    }
                    geom.index && _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geom._gl.index),
                        mesh._gl.vao.unbind(),
                        _cache[KEY] = {
                            count: 1,
                            vao: mesh._gl.vao
                        }
                }
                ,
                this.destroy = function(geom, mesh) {
                    for (let key in geom.attributes) {
                        let attrib = geom.attributes[key];
                        attrib._gl && (_gl.deleteBuffer(attrib._gl.buffer),
                            attrib._gl = null)
                    }
                    if (mesh && mesh._gl && mesh._gl.vao) {
                        let cache = _cache[mesh._gl.lookup];
                        cache ? (cache.count--,
                        0 == cache.count && (cache.vao.destroy(),
                            delete _cache[mesh._gl.lookup])) : mesh._gl.vao.destroy(),
                            delete mesh._gl.vao
                    }
                    delete geom._gl
                }
                ,
                this.resetMeshGeom = function(mesh) {
                    mesh._gl && (mesh._gl.geomInit = !1)
                }
                ,
                this.uploadBuffersAsync = async function(geom) {
                    if (geom._gl && geom._gl.uploadedAsync)
                        return;
                    let upload = attrib=>{
                        let array = attrib.array
                            , buffer = attrib._gl.buffer
                            , promise = Promise.create()
                            , amt = 4
                            , match = !1;
                        for (; !match; )
                            amt--,
                            array.length % amt == 0 && (match = !0);
                        let chunk = array.length / amt
                            , i = 0
                            , worker = new Render.Worker((function uploadBuffersAsync() {
                                let offset = i * chunk
                                    , subarray = array.subarray(offset, offset + chunk);
                                if (!attrib._gl)
                                    return worker.stop(),
                                        promise.resolve();
                                subarray.length && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffer),
                                    _gl.bufferSubData(_gl.ARRAY_BUFFER, offset * array.BYTES_PER_ELEMENT, subarray),
                                    _gl.bindBuffer(_gl.ARRAY_BUFFER, null)),
                                ++i == amt && (promise.resolve(),
                                    worker.stop())
                            }
                        ));
                        return promise
                    }
                        , uploaded = !1;
                    for (let key in geom.attributes) {
                        let attrib = geom.attributes[key];
                        attrib._gl || (geom.distributeBufferData = !0,
                            attrib._gl = {},
                            attrib._gl.buffer = _gl.createBuffer(),
                            attrib._gl.bufferUploaded = !geom.distributeBufferData,
                        attrib.array.length && (_gl.bindBuffer(_gl.ARRAY_BUFFER, attrib._gl.buffer),
                            _gl.bufferData(_gl.ARRAY_BUFFER, attrib.array.length * attrib.array.BYTES_PER_ELEMENT, attrib.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW),
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, null)),
                            attrib.needsUpdate = !1,
                            geom.needsUpdate = !0),
                        attrib._gl.bufferUploaded || (attrib._gl.bufferUploaded = !0,
                            uploaded = !0,
                            await upload(attrib),
                            attrib.needsUpdate = !1)
                    }
                    geom._gl.uploadedAsync = !0,
                    uploaded && RenderCount.add("geom_uploadAsync", geom)
                }
        }
    )),
    Class((function ShaderRendererWebGL(_gl) {
            var _pool = {}
                , _programID = 0
                , _cached = {}
                , _uboCache = {};
            const WEBGL2 = Renderer.type == Renderer.WEBGL2
                , GLOBAL_UNIFORMS = ["normalMatrix", "modelMatrix", "modelViewMatrix", "projectionMatrix", "viewMatrix", "cameraPosition", "resolution", "time", "shadowMatrix", "shadowLightPos", "shadowSize"];
            function toTypedArray(uni) {
                uni.value;
                return uni._gl || (uni._gl = {}),
                    uni._gl.array && uni._gl.array.length == uni.value.length ? uni._gl.array.set(uni.value) : uni._gl.array = new Float32Array(uni.value),
                    uni._gl.array
            }
            function createShader(str, type) {
                let shader = _gl.createShader(type);
                if (_gl.shaderSource(shader, str),
                    _gl.compileShader(shader),
                Hydra.LOCAL && !_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
                    let error = _gl.getShaderInfoLog(shader);
                    _gl.deleteShader(shader);
                    let split = str.split("\n")
                        , errorString = "";
                    split.forEach(((line,index)=>{
                            index = function() {
                                switch (index.toString().length) {
                                    case 1:
                                        return "00" + index;
                                    case 2:
                                        return "0" + index
                                }
                                return index
                            }(),
                                errorString += `${index}: ${line}\n`
                        }
                    )),
                        console.warn(error, errorString)
                }
                return shader
            }
            function setupShaders(shader) {
                for (let key in shader.uniforms) {
                    let uniform = shader.uniforms[key];
                    if (void 0 === shader._gl[key] && uniform)
                        if (uniform.ubo)
                            if (WEBGL2) {
                                if (_uboCache[shader.UILPrefix] && !shader.ubo && (shader.ubo = _uboCache[shader.UILPrefix]),
                                    _uboCache[shader.UILPrefix]) {
                                    shader._gl[key] = "U";
                                    continue
                                }
                                shader.ubo || (shader.ubo = new UBO(1,_gl)),
                                    shader.ubo.push(uniform),
                                    shader._gl[key] = "U"
                            } else
                                shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key);
                        else
                            WEBGL2 && uniform.lightUBO ? (shader._gl[key] = "U",
                                shader.uboLight = !0) : shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key)
                }
                shader.ubo && !_uboCache[shader.UILPrefix] && (_uboCache[shader.UILPrefix] = shader.ubo),
                shader._gl.setupGlobals || (shader._gl.setupGlobals = !0,
                    GLOBAL_UNIFORMS.forEach((key=>{
                            shader._gl[key] = _gl.getUniformLocation(shader._gl.program, key)
                        }
                    ))),
                shader.uboLight && _gl.getUniformBlockIndex(shader._gl.program, "lights"),
                WEBGL2 && _gl.getUniformBlockIndex(shader._gl.program, "global")
            }
            function uniformTextureArray(uni, uLoc, shader) {
                let array = shader._gl.texArray || [];
                array.length = 0,
                    shader._gl.texArray = array;
                for (let i = 0; i < uni.value.length; i++) {
                    array.push(shader._gl.texIndex);
                    let texture = uni.value[i];
                    !1 === texture.loaded && (texture = Utils3D.getEmptyTexture()),
                    (void 0 === texture._gl || texture.needsReupload) && Texture.renderer.upload(texture),
                        _gl.activeTexture(_gl["TEXTURE" + shader._gl.texIndex++]),
                        _gl.bindTexture(_gl.TEXTURE_2D, texture._gl)
                }
                _gl.uniform1iv(uLoc, array)
            }
            this.upload = function(shader) {
                if (!shader._gl) {
                    shader._gl = {};
                    let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`
                        , cached = _pool[key];
                    cached ? (shader._gl.program = cached.program,
                        shader._gl._id = cached.id,
                        cached.count++) : (shader._gl.program = function createProgram(shader) {
                        let vsCode = shader.onBeforeCompile(shader.vertexShader, "vs")
                            , fsCode = shader.onBeforeCompile(shader.fragmentShader, "fs");
                        RenderCount.add("shader", shader);
                        let vs = createShader(vsCode, _gl.VERTEX_SHADER)
                            , fs = createShader(fsCode, _gl.FRAGMENT_SHADER);
                        Hydra.LOCAL && window.GLSLLinter && GLSLLinter.lint(shader, vsCode, fsCode);
                        let program = _gl.createProgram();
                        return _gl.attachShader(program, vs),
                            _gl.attachShader(program, fs),
                            _gl.linkProgram(program),
                        Hydra.LOCAL && (_gl.getProgramParameter(program, _gl.LINK_STATUS) || (console.warn(`Shader: ${shader.vsName} | ${shader.vsName}`),
                            console.warn(vsCode),
                            console.warn(fsCode),
                            console.error(`Could not compile WebGL program. ${shader.vsName} ${shader.fsName} \n\n` + _gl.getProgramInfoLog(program)))),
                            _gl.deleteShader(vs),
                            _gl.deleteShader(fs),
                            program
                    }(shader),
                        shader._gl._id = _programID++,
                        _pool[key] = {
                            count: 1,
                            program: shader._gl.program,
                            id: shader._gl._id
                        })
                }
                setupShaders(shader),
                shader.ubo && shader.ubo.upload(),
                    shader.vertexShader = shader.fragmentShader = ""
            }
                ,
                this.findCachedProgram = function(shader) {
                    let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`
                        , cached = _pool[key];
                    return !!cached && (shader._gl = {},
                        shader._gl.program = cached.program,
                        shader._gl._id = cached.id,
                    _uboCache[shader.UILPrefix] && (shader.ubo = shader.UILPrefix),
                        cached.count++,
                        !0)
                }
                ,
                this.draw = function(shader) {
                    void 0 === shader._gl && this.upload(shader),
                        shader._gl.texIndex = 0,
                    shader._gl.program != _cached.program && (_gl.useProgram(shader._gl.program),
                        _cached.program = shader._gl.program),
                    shader.ubo && shader.ubo.bind(shader._gl.program, "ubo"),
                    shader.uboLight && Lighting.bindUBO(shader._gl.program);
                    for (let key in shader.uniforms) {
                        let uni = shader.uniforms[key];
                        void 0 === shader._gl[key] && setupShaders(shader);
                        let uLoc = shader._gl[key];
                        if (uni && (null === uni.value && (uni.value = Utils3D.getEmptyTexture()),
                        null !== uLoc && -1 !== uLoc && "U" !== uLoc)) {
                            if (void 0 === uni.value)
                                throw `Uniform ${key} value is undefined. | ${shader.vsName} ${shader.fsName}`;
                            switch (uni.type || (uni.type = "string" == typeof (uniform = uni).type ? uniform.type : null === uniform.value || uniform.value instanceof Texture || uniform.value.texture || uniform.value.rt && uniform.value.rt.texture ? "t" : uniform.value instanceof Vector2 ? "v2" : uniform.value instanceof Vector3 || uniform.value instanceof Vector3D ? "v3" : uniform.value instanceof Vector4 ? "v4" : uniform.value instanceof Matrix4 ? "m4" : uniform.value instanceof Matrix3 ? "m3" : uniform.value instanceof Color ? "c" : uniform.value instanceof Quaternion ? "q" : Array.isArray(uniform.value) && uniform.value[0]instanceof Texture ? "tv" : "f"),
                                uni.type) {
                                case "f":
                                    _gl.uniform1f(uLoc, uni.value);
                                    break;
                                case "v2":
                                    _gl.uniform2f(uLoc, uni.value.x, uni.value.y);
                                    break;
                                case "v3":
                                    _gl.uniform3f(uLoc, uni.value.x, uni.value.y, uni.value.z);
                                    break;
                                case "c":
                                    _gl.uniform3f(uLoc, uni.value.r, uni.value.g, uni.value.b);
                                    break;
                                case "q":
                                case "v4":
                                    _gl.uniform4f(uLoc, uni.value.x, uni.value.y, uni.value.z, uni.value.w);
                                    break;
                                case "v3v":
                                    _gl.uniform3fv(uLoc, toTypedArray(uni));
                                    break;
                                case "v4v":
                                    _gl.uniform4fv(uLoc, toTypedArray(uni));
                                    break;
                                case "v2v":
                                    _gl.uniform2fv(uLoc, toTypedArray(uni));
                                    break;
                                case "fv":
                                    _gl.uniform1fv(uLoc, toTypedArray(uni));
                                    break;
                                case "m4":
                                    _gl.uniformMatrix4fv(uLoc, !1, uni.value.elements);
                                    break;
                                case "m3":
                                    _gl.uniformMatrix3fv(uLoc, !1, uni.value.elements);
                                    break;
                                case "tv":
                                    uniformTextureArray(uni, uLoc, shader);
                                    break;
                                case "t":
                                    let texture = uni.value;
                                    texture.isTexture || (uni.value.rt && (texture = uni.value.rt.overrideTexture || uni.value.rt.texture),
                                    uni.value.texture && (texture = uni.value.texture)),
                                    !1 === texture.loaded && (texture = Utils3D.getEmptyTexture());
                                    let texIndex = shader._gl.texIndex++;
                                    uni.value.vrRT && (shader._gl.vrRT = !0,
                                        uni.value._glTexIndex = texIndex),
                                        Texture.renderer.draw(texture, uLoc, key, texIndex)
                            }
                        }
                    }
                    var uniform;
                    if (shader.polygonOffset) {
                        let key = shader.polygonOffsetFactor + "_" + shader.polygonOffsetUnits;
                        _cached.polygonOffset != key && (_gl.enable(_gl.POLYGON_OFFSET_FILL),
                            _gl.polygonOffset(shader.polygonOffsetFactor, shader.polygonOffsetUnits)),
                            _cached.polygonOffset = key
                    } else
                        _cached.polygonOffset && _gl.disable(_gl.POLYGON_OFFSET_FILL),
                            _cached.polygonOffset = !1;
                    if (shader.transparent ? (_cached.transparent || _gl.enable(_gl.BLEND),
                        _cached.transparent = !0) : (_cached.transparent && _gl.disable(_gl.BLEND),
                        _cached.transparent = !1),
                    _cached.blending != shader.blending) {
                        switch (shader.blending) {
                            case Shader.ADDITIVE_BLENDING:
                                _gl.blendEquation(_gl.FUNC_ADD),
                                    _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);
                                break;
                            default:
                                _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD),
                                    _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA)
                        }
                        _cached.blending = shader.blending
                    }
                    switch (shader.depthTest ? (_cached.depthTest || _gl.enable(_gl.DEPTH_TEST),
                        _cached.depthTest = !0) : (_cached.depthTest && _gl.disable(_gl.DEPTH_TEST),
                        _cached.depthTest = !1),
                        shader.side) {
                        case Shader.BACK_SIDE:
                            _cached.side != Shader.BACK_SIDE && (_gl.enable(_gl.CULL_FACE),
                                _gl.cullFace(_gl.FRONT),
                                _cached.side = Shader.BACK_SIDE);
                            break;
                        case Shader.DOUBLE_SIDE:
                            _cached.side != Shader.DOUBLE_SIDE && (_gl.disable(_gl.CULL_FACE),
                                _cached.side = Shader.DOUBLE_SIDE);
                            break;
                        default:
                            _cached.side != Shader.FRONT_SIDE && (_gl.enable(_gl.CULL_FACE),
                                _gl.cullFace(_gl.BACK),
                                _cached.side = Shader.FRONT_SIDE)
                    }
                    switch (_cached.depthMask != shader.depthWrite && (_gl.depthMask(!!shader.depthWrite),
                        _cached.depthMask = shader.depthWrite),
                        shader.colorMask) {
                        case Shader.COLOR_MASK_NONE:
                            _cached.colorMask != shader.colorMask && (_gl.colorMask(!0, !0, !0, !0),
                                _cached.colorMask = shader.colorMask);
                            break;
                        case Shader.COLOR_MASK_RGB:
                            _cached.colorMask != shader.colorMask && (_gl.colorMask(!1, !1, !1, !0),
                                _cached.colorMask = shader.colorMask);
                            break;
                        case Shader.COLOR_MASK_RGBA:
                            _cached.colorMask != shader.colorMask && (_gl.colorMask(!1, !1, !1, !1),
                                _cached.colorMask = shader.colorMask)
                    }
                }
                ,
                this.destroy = function(shader) {
                    delete shader._gl,
                    shader.ubo && shader.ubo.destroy();
                    let key = `${shader.vsName}_${shader.fsName}_${shader.customCompile}`;
                    _pool[key]
                }
                ,
                this.appendUniform = function(shader, key, value, hint) {
                    let loc = shader._gl[key];
                    if (void 0 === loc && (loc = loc = _gl.getUniformLocation(shader._gl.program, key)),
                    null !== loc)
                        if (value.isMatrix4)
                            _gl.uniformMatrix4fv(loc, !1, value.elements);
                        else if (value.isMatrix3)
                            _gl.uniformMatrix3fv(loc, !1, value.elements);
                        else if (value.isVector3)
                            _gl.uniform3f(loc, value.x, value.y, value.z);
                        else if (value.isVector2)
                            _gl.uniform2f(loc, value.x, value.y);
                        else if (value instanceof Float32Array)
                            switch (hint) {
                                case "matrix":
                                    _gl.uniformMatrix4fv(loc, !1, value);
                                    break;
                                case "float":
                                    _gl.uniform1fv(loc, value);
                                    break;
                                case "vec3":
                                    _gl.uniform3fv(loc, value)
                            }
                        else if (Array.isArray(value)) {
                            let array = shader._gl.texArray || [];
                            array.length = 0,
                                shader._gl.texArray = array;
                            for (let i = 0; i < value.length; i++)
                                array.push(shader._gl.texIndex),
                                    _gl.activeTexture(_gl["TEXTURE" + shader._gl.texIndex++]),
                                    _gl.bindTexture(_gl.TEXTURE_2D, value[i]._gl);
                            _gl.uniform1iv(loc, array)
                        } else
                            _gl.uniform1f(loc, value)
                }
                ,
                this.resetState = function() {
                    _cached.depthMask || (_gl.depthMask(!0),
                        _cached.depthMask = !0),
                    _cached.depthTest || _gl.enable(_gl.DEPTH_TEST),
                        _cached.depthTest = !0,
                    _cached.colorMask != Shader.COLOR_MASK_NONE && (_gl.colorMask(!0, !0, !0, !0),
                        _cached.colorMask = Shader.COLOR_MASK_NONE),
                        _cached.program = null
                }+ư
                ,
                this.clearState = function() {
                    _cached = {}
                }
        }
    )),
    Class((function TextureRendererWebGL(_gl) {
            const _this = this;
            var _state = {};
            const DATA = new Uint8Array([0, 0, 0, 0])
                , {getFormat: getFormat, getProperty: getProperty, getType: getType, getFloatParams: getFloatParams} = require("GLTypes");
            function setTextureParams(texture, textureType=_gl.TEXTURE_2D) {
                let format = getFormat(texture);
                textureType != _gl.TEXTURE_2D || texture.compressed || _gl.texImage2D(textureType, 0, format, 1, 1, 0, format, _gl.UNSIGNED_BYTE, DATA),
                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, getProperty(texture.wrapS)),
                    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, getProperty(texture.wrapT)),
                    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, getProperty(texture.magFilter)),
                    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, getProperty(texture.minFilter)),
                    texture.data || texture.format != Texture.RGBAFormat ? 1 == _state.premultiply && (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                        _state.premultiply = !1) : !1 === texture.premultiplyAlpha ? (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                        _state.premultiply = !1) : (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
                        _state.premultiply = !0),
                texture.anisotropy > 1 && _gl.texParameterf(_gl.TEXTURE_2D, Renderer.extensions.anisotropy.TEXTURE_MAX_ANISOTROPY_EXT, texture.anisotropy)
            }
            this.draw = function(texture, loc, key, id) {
                if ((void 0 === texture._gl || texture.needsReupload) && this.upload(texture),
                    _gl.activeTexture(_gl[`TEXTURE${id}`]),
                    texture.cube)
                    _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl);
                else {
                    let texType = texture.EXT_OES ? _gl.TEXTURE_EXTERNAL_OES : _gl.TEXTURE_2D;
                    _gl.bindTexture(texType, texture._gl)
                }
                _gl.uniform1i(loc, id),
                (texture.dynamic || texture.needsUpdate) && function updateDynamic(texture) {
                    if (texture.isDataTexture) {
                        if (!0 === texture.flipY ? _state.flipY || (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0),
                            _state.flipY = !0) : _state.flipY && (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !1),
                            _state.flipY = !1),
                        _state.premultiply && (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                            _state.premultiply = !1),
                            !texture.glFormat) {
                            let {format: format, type: type} = getFloatParams(texture);
                            texture.glFormat = format,
                                texture.glType = type
                        }
                        _gl.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, texture.width, texture.height, texture.glFormat, texture.glType, texture.data)
                    } else
                        _state.flipY || (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0),
                            _state.flipY = !0),
                            texture.format == Texture.RGBAFormat ? !1 === texture.premultiplyAlpha ? (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                                _state.premultiply = !1) : (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
                                _state.premultiply = !0) : _state.premultiply && (_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                                _state.premultiply = !1),
                        texture.glFormat || (texture.glFormat = getFormat(texture)),
                            _gl.texImage2D(_gl.TEXTURE_2D, 0, texture.glFormat, texture.glFormat, getType(texture), texture.image)
                }(texture),
                    texture.needsUpdate = !1
            }
                ,
                this.upload = function(texture) {
                    if (texture._gl && !texture.needsReupload && !texture.needsUpdate)
                        return;
                    let format = getFormat(texture);
                    if (RenderCount.add("texture"),
                    texture.distributeTextureData || RenderCount.add("tex_upload", texture),
                        texture.cube) {
                        if (6 != texture.cube.length)
                            throw "Cube texture requires 6 images";
                        return function uploadCube(texture) {
                            void 0 === texture._gl && (texture._gl = _gl.createTexture(),
                                _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture._gl),
                            _state.flipY || (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0),
                                _state.flipY = !0),
                                setTextureParams(texture, _gl.TEXTURE_CUBE_MAP));
                            let format = getFormat(texture);
                            for (let i = 0; i < 6; i++)
                                _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, format, format, getType(texture), texture.cube[i]);
                            _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP),
                                texture.needsUpdate = texture.needsReupload = !1,
                            texture.onUpdate && texture.onUpdate()
                        }(texture)
                    }
                    let texType = texture.EXT_OES ? _gl.TEXTURE_EXTERNAL_OES : _gl.TEXTURE_2D;
                    if (void 0 === texture._gl ? (texture._gl = _gl.createTexture(),
                        _gl.bindTexture(texType, texture._gl),
                        setTextureParams(texture, texType)) : _gl.bindTexture(texType, texture._gl),
                    texture.isDataTexture || texture.type && texture.type.includes("float")) {
                        !0 === texture.flipY ? _state.flipY || (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0),
                            _state.flipY = !0) : _state.flipY && (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !1),
                            _state.flipY = !1),
                            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, 1);
                        let {internalformat: internalformat, format: format, type: type} = getFloatParams(texture);
                        if ("ie" === Device.system.browser)
                            try {
                                _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, texture.width, texture.height, 0, format, type, texture.distributeTextureData ? null : texture.data)
                            } catch (e) {
                                console.log(e)
                            }
                        else
                            _gl.texImage2D(_gl.TEXTURE_2D, 0, internalformat, texture.width, texture.height, 0, format, type, texture.distributeTextureData ? null : texture.data)
                    } else if (_state.flipY || (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0),
                        _state.flipY = !0),
                    texture.image && texture.compressed) {
                        let data = texture.image.compressedData;
                        for (let i = 0; i < data.length; i++) {
                            let size = texture.image.sizes[i];
                            _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, texture.image.gliFormat, size, size, 0, data[i])
                        }
                        data.length = 0
                    } else if (texture.image && !(texture.image instanceof HTMLVideoElement))
                        try {
                            _gl.texImage2D(_gl.TEXTURE_2D, 0, format, format, getType(texture), texture.image)
                        } catch (e) {
                            console.log("error loading texture", e, texture.image)
                        }
                    (texture.image || texture.data) && texture.generateMipmaps && !texture.compressed && _gl.generateMipmap(_gl.TEXTURE_2D),
                        texture.needsUpdate = texture.needsReupload = !1,
                    texture.onUpdate && texture.onUpdate()
                }
                ,
                this.uploadAsync = function(texture) {
                    let {format: format, type: type} = getFloatParams(texture);
                    if (texture._uploadAsyncPromise)
                        return texture._uploadAsyncPromise;
                    texture._uploadAsyncPromise = Promise.create(),
                        RenderCount.add("tex_uploadAsync", texture),
                    texture._gl || (texture.distributeTextureData = !0,
                        _this.upload(texture));
                    let pixelsPerChunk = texture.height / 4
                        , dataPerChunk = texture.data.length / 4
                        , i = 0
                        , worker = new Render.Worker((function workerUploadAsync() {
                            let pixelOffset = pixelsPerChunk * i
                                , dataOffset = dataPerChunk * i
                                , subarray = texture.data.subarray(dataOffset, dataOffset + dataPerChunk);
                            !0 === texture.flipY ? _state.flipY || (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !0),
                                _state.flipY = !0) : _state.flipY && (_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, !1),
                                _state.flipY = !1),
                                _gl.bindTexture(_gl.TEXTURE_2D, texture._gl),
                                _gl.texSubImage2D(_gl.TEXTURE_2D, 0, 0, pixelOffset, texture.width, pixelsPerChunk, format, type, subarray),
                                _gl.bindTexture(_gl.TEXTURE_2D, null),
                            4 == ++i && (worker.stop(),
                                texture._uploadAsyncPromise.resolve())
                        }
                    ));
                    return texture._uploadAsyncPromise
                }
                ,
                this.destroy = function(texture) {
                    texture._gl && (_gl.deleteTexture(texture._gl),
                        RenderCount.remove("texture"),
                        RenderCount.add("tex_destroy", texture)),
                        delete texture._gl
                }
        }
    ));
class RenderTarget {
    constructor(width, height, options={}) {
        this.width = width,
            this.height = height,
            this.viewport = new Vector2(0,0),
        void 0 === options.minFilter && (options.minFilter = Texture.LINEAR),
            this.texture = new Texture(null),
            this.texture.generateMipmaps = options.generateMipmaps,
            this.texture.width = width,
            this.texture.height = height,
            this.texture.minFilter = options.minFilter || Texture.LINEAR,
            this.texture.magFilter = options.magFilter || Texture.LINEAR,
            this.texture.wrapS = options.wrapS || Texture.CLAMP_TO_EDGE,
            this.texture.wrapT = options.wrapT || Texture.CLAMP_TO_EDGE,
            this.texture.format = options.format || Texture.RGBFormat,
        options.type && (this.texture.type = options.type),
            this.isRT = !0
    }
    setSize(width, height) {
        this.width = width,
            this.height = height,
            this.texture.width = width,
            this.texture.height = height,
            this.viewport.set(0, 0),
            RenderTarget.renderer.resize(this)
    }
    clone() {
        return (new RenderTarget).copy(this)
    }
    copy(source) {
        return this.width = source.width,
            this.height = source.height,
            this.viewport.copy(source.viewport),
            this.texture = source.texture.clone(),
            this
    }
    createDepthTexture() {
        return this.depth = new Texture(null),
            this.depth.generateMipmaps = !1,
            this.depth.minFilter = Texture.NEAREST,
            this.depth.magFilter = Texture.NEAREST,
            this.depth.wrapS = Texture.CLAMP_TO_EDGE,
            this.depth.wrapT = Texture.CLAMP_TO_EDGE,
            this.depth
    }
    destroy() {
        RenderTarget.renderer.destroy(this)
    }
    upload() {
        this._gl || RenderTarget.renderer.upload(this)
    }
}
class MultiRenderTarget extends RenderTarget {
    constructor(width, height, options={}) {
        super(width, height, options),
            this.multi = !0,
            this.attachments = [this.texture]
    }
}
class CubeRenderTarget extends RenderTarget {
    constructor(width, height, options={}) {
        super(width, height, options),
            this.activeFace = 0,
            this.cube = !0
    }
}
Class((function Shader(_vertexShader, _fragmentShader, _params, _onBeforeBuild, _postfix) {
        const _this = this;
        this.uniforms = {},
            this.side = Shader.FRONT_SIDE,
            this.blending = Shader.NORMAL_BLENDING,
            this.colorMask = Shader.COLOR_MASK_NONE,
            this.polygonOffset = !1,
            this.polygonOffsetFactor = 0,
            this.polygonOffsetUnits = 1,
            this.depthTest = !0,
            this.depthWrite = !0,
            this.wireframe = !1,
            this.transparent = !1,
            this.visible = !0,
            this.persists = !1,
            this.precision = "high",
            this.customCompile = "",
        "string" != typeof _fragmentShader && (_params = _fragmentShader,
            _fragmentShader = _vertexShader),
            _params = _params || {},
            _this.vsParam = _vertexShader,
            _this.fsParam = _fragmentShader,
            _this.params = _params,
            _this.vsName = _vertexShader,
            _this.fsName = (_fragmentShader || _vertexShader) + (_postfix || ""),
        _params.vsName && (_this.vsName = _params.vsName,
            delete _params.vsName),
        _params.precision && (_this.precision = _params.precision),
        _params.receiveShadow && (_this.receiveLight = !0,
        World.RENDERER.shadows && (_this.precision = "high"));
        let vs = _vertexShader
            , fs = _fragmentShader;
        _params.uilFrom && (vs = _params.uilFrom,
            fs = _params.uilFrom,
            delete _params.uilFrom),
            _this.UILPrefix = _params.UILPrefix || `${vs}/${fs}/${_params.unique ? _params.unique + "/" : ""}`,
            Shader.parseParams(_params, _this),
        Shader.renderer.findCachedProgram(_this) || (_this.vertexShader = Shader.process(Shaders.getShader(_vertexShader + ".vs"), "vs", _this, _onBeforeBuild),
            _this.fragmentShader = Shader.process(Shaders.getShader(_fragmentShader + ".fs"), "fs", _this, _onBeforeBuild))
    }
), (_=>{
        Shader.FRONT_SIDE = "shader_front_side",
            Shader.BACK_SIDE = "shader_back_side",
            Shader.DOUBLE_SIDE = "shader_double_side",
            Shader.ADDITIVE_BLENDING = "shader_additive_blending",
            Shader.NORMAL_BLENDING = "shader_normal_blending",
            Shader.CUSTOM_DEPTH = "shader_custom_depth",
            Shader.COLOR_MASK_RGB = "shader_colormask_rgb",
            Shader.COLOR_MASK_RGBA = "shader_colormask_rgba",
            Shader.COLOR_MASK_NONE = "shader_colormask_none",
            Shader.parseParams = function(_params, _this) {
                for (let key in _params)
                    if ("receiveShadow" == key)
                        _this.receiveShadow = _params[key];
                    else if ("receiveLight" == key)
                        _this.receiveLight = _params[key];
                    else if (_params[key] && void 0 !== _params[key].value)
                        window.UILStorage ? (_this.uniforms[key] = UILStorage.parse(_this.UILPrefix + key, _params[key].value) || _params[key],
                        _params[key].ubo && (_this.uniforms[key].ubo = !0)) : _this.uniforms[key] = _params[key];
                    else {
                        if ("unique" == key)
                            continue;
                        _this[key] = _params[key]
                    }
            }
            ,
            Shader.process = function(code, type, _this, _onBeforeBuild) {
                const WEBGL2 = Renderer.type == Renderer.WEBGL2;
                if (!code)
                    throw "No shader found! " + _this.vsName + " | " + _this.fsName;
                const externalOES = code.includes("samplerOES") && window.AURA && "android" == Device.system.os
                    , standardDeriv = !WEBGL2 && code.includes(["fwidth", "dFdx"])
                    , drawBuffers = !WEBGL2 && code.includes(["gl_FragData", "#drawbuffer"]) && window.World && World.NUKE.useDrawBuffers;
                return header = "vs" == type ? ["#version 300 es", `precision ${_this.precision}p float;`, `precision ${_this.precision}p int;`, "attribute vec2 uv;", "attribute vec3 position;", "attribute vec3 normal;", "uniform mat3 normalMatrix;", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform global {", "mat4 projectionMatrix;", "mat4 viewMatrix;", "vec3 cameraPosition;", "vec2 resolution;", "float time;", "float timeScale;", "};"].join("\n") : ["#version 300 es", externalOES ? "#extension GL_OES_EGL_image_external_essl3 : require" : "", standardDeriv ? "#extension GL_OES_standard_derivatives : enable" : "", drawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", `precision ${_this.precision}p float;`, `precision ${_this.precision}p int;`, "uniform mat3 normalMatrix;", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform global {", "mat4 projectionMatrix;", "mat4 viewMatrix;", "vec3 cameraPosition;", "vec2 resolution;", "float time;", "float timeScale;", "};", "out vec4 FragColor;"].join("\n"),
                    header += "\n__ACTIVE_THEORY_LIGHTS__\n\n",
                window.AURA && (header += "#define AURA\n"),
                _onBeforeBuild && (code = _onBeforeBuild(code, type)),
                    code = header + code
            }
        ;
        const prototype = Shader.prototype;
        var _emptyShadowMap;
        prototype.copyUniformsTo = function(shader, linked) {
            if (linked)
                shader.uniforms = this.uniforms;
            else
                for (let key in this.uniforms)
                    shader.uniforms[key] = {
                        type: this.uniforms[key].type,
                        value: this.uniforms[key].value
                    }
        }
            ,
            prototype.addUniforms = function(uniforms) {
                uniforms.UILPrefix && (this.UILPrefix = uniforms.UILPrefix,
                    delete uniforms.UILPrefix);
                for (let key in uniforms)
                    this.uniforms[key] = uniforms[key]
            }
            ,
            prototype.draw = function(mesh, geom) {
                this.receiveLight && !this.__lighting && Lighting.getLighting(this),
                    Shader.renderer.draw(this, mesh, geom)
            }
            ,
            prototype.upload = function(mesh, geom) {
                let p = this.mesh
                    , scene = World.SCENE;
                for (; p; )
                    p instanceof Scene && (scene = p),
                        p = p._parent;
                scene.nuke && scene.nuke.onBeforeShaderCompile(this.mesh),
                    Shader.renderer.upload(this, mesh, geom),
                this.receiveShadow && !this.shadow && Lighting.initShadowShader(this, mesh)
            }
            ,
            prototype.destroy = function() {
                this.persists || (Shader.renderer.destroy(this),
                this.shadow && this.shadow.destroy()),
                this.receiveLight && Lighting.destroyShader(this)
            }
            ,
            prototype.onBeforeCompile = function(code, type) {
                const WEBGL2 = Renderer.type == Renderer.WEBGL2;
                this.receiveShadow && (this.receiveLight = !0);
                let replace, varyings = [];
                (code = code.split("\n")).forEach(((line,index)=>{
                        "fs" == type && line.includes("#drawbuffer") && (line.includes("#drawbuffer Color") ? code[index] = line.replace("#drawbuffer Color", "") : code[index] = ""),
                        line.includes("varying") && varyings.push(line)
                    }
                )),
                    code = code.join("\n"),
                varyings.length && varyings.forEach((varying=>{
                        let count = 0;
                        varyings.forEach((v2=>{
                                varying == v2 && count++
                            }
                        )),
                        count > 1 && (replace || (replace = []),
                        replace.includes(varying) || replace.push(varying))
                    }
                )),
                replace && replace.forEach((varying=>{
                        let index = code.lastIndexOf(varying);
                        code = code.substring(0, index) + code.substring(index + varying.length)
                    }
                )),
                "fs" == type && (WEBGL2 ? code.includes("gl_FragColor") && (code = code.replace(/gl_FragColor/g, "FragColor")) : code.includes("#applyShadow") && (code = code.replace("#applyShadow", ""))),
                    code = code.replace("__ACTIVE_THEORY_LIGHTS__", function getLightingCode(_this) {
                        if (!_this.receiveLight || _this.isShadow)
                            return "";
                        let numLights = Lighting.getLighting(_this).position.length / 4;
                        return 0 == numLights ? Lighting.getShadowUniforms(_this) : [`#define NUM_LIGHTS ${numLights}`, "uniform lights {", `vec4 lightPos[${numLights}];`, `vec4 lightColor[${numLights}];`, `vec4 lightData[${numLights}];`, `vec4 lightData2[${numLights}];`, `vec4 lightData3[${numLights}];`, `vec4 lightProperties[${numLights}];`, "};"].join("\n") + Lighting.getShadowUniforms(_this)
                    }(this)),
                "fs" == type && code.includes("SHADOW_MAPS") && (code = require("GLSLOptimizer")(code.replace("SHADOW_COUNT", Lighting.getShadowCount(this)))),
                this.preCompile && (code = this.preCompile(code, type));
                let converter = require("ShaderCode");
                return code = WEBGL2 ? converter.convertWebGL2(code, type) : converter.convertWebGL1(code)
            }
            ,
            prototype.set = function(key, value, ref) {
                let _this = ref || this;
                return _this.uniforms[key] ? (void 0 !== value && (TweenManager.clearTween(_this.uniforms[key]),
                    _this.uniforms[key].value = value,
                _this.ubo && (_this.ubo.needsUpdate = !0)),
                    _this.uniforms[key].value) : console.warn(`No key ${key} found on shader`, _this)
            }
            ,
            prototype.get = function(key, ref) {
                return (ref || this).uniforms[key].value
            }
            ,
            prototype.tween = function(key, value, time, ease, delay, callback, update, scaledTime) {
                return "number" == typeof value ? tween(this.uniforms[key], {
                    value: value
                }, time, ease, delay, callback, update, null, scaledTime) : tween(this.uniforms[key].value, value, time, ease, delay, callback, update, null, scaledTime)
            }
            ,
            prototype.clone = function(noShadows, postfix) {
                const _this = this;
                noShadows && (_this.params.receiveShadow = !1);
                let shader = new Shader(_this.vsParam,_this.fsParam,_this.params,null,postfix);
                for (let key in _this)
                    key.includes(["vsName", "fsName", "uniforms"]) || "function" == typeof _this[key] || (shader[key] = _this[key]);
                for (let key in _this.uniforms)
                    shader.uniforms[key] = {
                        type: _this.uniforms[key].type,
                        value: _this.uniforms[key].value
                    };
                return shader
            }
            ,
            prototype.resetProgram = function() {
                this.destroy(),
                    this.vertexShader = Shader.process(Shaders.getShader(this.vsName + ".vs"), "vs", this),
                    this.fragmentShader = Shader.process(Shaders.getShader(this.fsName + ".fs"), "fs", this)
            }
            ,
            Object.defineProperty(prototype, "receiveShadow", {
                set: function(v) {
                    this._receiveShadow = v,
                    v && (_emptyShadowMap || (_emptyShadowMap = [Utils3D.getEmptyTexture()]),
                        this.uniforms.shadowMap = {
                            value: _emptyShadowMap
                        })
                },
                get: function() {
                    return this._receiveShadow
                }
            })
    }
));
class Texture {
    constructor(img) {
        this.magFilter = Texture.LINEAR,
            this.minFilter = Texture.LINEAR_MIPMAP,
            this.format = Texture.RGBAFormat,
            this.wrapS = this.wrapT = Texture.CLAMP_TO_EDGE,
            this._image = img,
            this.needsUpdate = !0,
            this.generateMipmaps = !0,
            this.anisotropy = 1,
            this.type = Texture.UNSIGNED_BYTE,
            this.isTexture = !0,
        img && img.onCreateTexture && img.onCreateTexture(this)
    }
    set image(img) {
        this._image = img,
        img && img.onCreateTexture && img.onCreateTexture(this)
    }
    get image() {
        return this._image
    }
    upload() {
        this._gl || Texture.renderer.upload(this)
    }
    destroy() {
        Texture.renderer.destroy(this),
            this._image = null
    }
    clone() {
        let texture = new Texture(this.img);
        return texture.format = this.format,
            texture.type = this.type,
            texture.anisotropy = this.anisotropy,
            texture.wrapS = this.wrapS,
            texture.wrapT = this.wrapT,
            texture.generateMipmaps = this.generateMipmaps,
            texture.minFilter = this.minFilter,
            texture.magFilter = this.magFilter,
            texture
    }
}
class DataTexture extends Texture {
    constructor(data, width, height, format, type) {
        super(),
        format && (this.format = format),
            this.width = width,
            this.height = height,
            this.data = data,
            this.minFilter = this.magFilter = Texture.NEAREST,
            this.generateMipmaps = !1,
            this.type = type || Texture.FLOAT,
            this.isDataTexture = !0
    }
    uploadAsync() {
        return Texture.renderer.uploadAsync(this)
    }
}
Texture.NEAREST = "texture_nearest",
    Texture.CLAMP_TO_EDGE = "texture_clamp",
    Texture.REPEAT = "texture_repeat",
    Texture.MIRROR_REPEAT = "texture_mirror_repeat",
    Texture.LINEAR = "texture_linear",
    Texture.LINEAR_MIPMAP = "texture_linear_mip",
    Texture.LINEAR_MIPMAP_NEAREST = "texture_linear_mip_nearest",
    Texture.NEAREST_MIPMAP = "texture_nearest_mip",
    Texture.RGBFormat = "texture_rgbFormat",
    Texture.RGBAFormat = "texture_rgbaFormat",
    Texture.UNSIGNED_BYTE = "texture_unsigned_byte",
    Texture.DEPTH = "texture_depth",
    Texture.FLOAT = "texture_float",
    Texture.HALF_FLOAT = "texture_half_float",
    Module((function GLSLOptimizer() {
            this.exports = function(code) {
                return function unrollLoops(string) {
                    return string.replace(/#pragma unroll_loop[\s]+?for \(int i \= (\d+)\; i < (\d+)\; i\+\+\) \{([\s\S]+?)(?=\})\}/g, (function replace(match, start, end, snippet) {
                            let unroll = "";
                            for (let i = parseInt(start); i < parseInt(end); i++)
                                unroll += snippet.replace(/\[i\]/g, "[" + i + "]");
                            return unroll
                        }
                    ))
                }(code)
            }
        }
    )),
    Module((function GLTypes() {
            function getType(texture) {
                let _gl = Renderer.context;
                switch (texture.type) {
                    case Texture.FLOAT:
                        return _gl.FLOAT;
                    case Texture.HALF_FLOAT:
                        return Renderer.type == Renderer.WEBGL2 ? _gl.HALF_FLOAT : Renderer.extensions.halfFloat.HALF_FLOAT_OES;
                    default:
                        return _gl.UNSIGNED_BYTE
                }
            }
            this.exports = {
                getFormat: function getFormat(texture) {
                    let _gl = Renderer.context;
                    return texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB
                },
                getProperty: function getProperty(property) {
                    let _gl = Renderer.context;
                    switch (property) {
                        case Texture.NEAREST:
                            return _gl.NEAREST;
                        case Texture.LINEAR:
                            return _gl.LINEAR;
                        case Texture.LINEAR_MIPMAP:
                            return _gl.LINEAR_MIPMAP_LINEAR;
                        case Texture.NEAREST_MIPMAP:
                            return _gl.NEAREST_MIPMAP_LINEAR;
                        case Texture.LINEAR_MIPMAP_NEAREST:
                            return _gl.LINEAR_MIPMAP_NEAREST;
                        case Texture.CLAMP_TO_EDGE:
                            return _gl.CLAMP_TO_EDGE;
                        case Texture.REPEAT:
                            return _gl.REPEAT;
                        case Texture.MIRROR_REPEAT:
                            return _gl.MIRRORED_REPEAT
                    }
                },
                getType: getType,
                getFloatParams: function getFloatParams(texture) {
                    let _gl = Renderer.context;
                    return {
                        internalformat: function() {
                            if (Renderer.type == Renderer.WEBGL2) {
                                switch (texture.type) {
                                    case Texture.HALF_FLOAT:
                                        return texture.format == Texture.RGBAFormat ? _gl.RGBA16F : _gl.RGB16F;
                                    case Texture.FLOAT:
                                        return texture.format == Texture.RGBAFormat ? _gl.RGBA32F : _gl.RGB32F
                                }
                                return texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB
                            }
                            return texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB
                        }(),
                        format: texture.format == Texture.RGBAFormat ? _gl.RGBA : _gl.RGB,
                        type: getType(texture)
                    }
                }
            }
        }
    )),
    Module((function ShaderCode() {
            function removeUBO(code, name) {
                let uniforms = code.split(`uniform ${name} {`)[1];
                uniforms = uniforms.split("};")[0],
                    uniforms = uniforms.split("\n"),
                    uniforms.forEach((u=>{
                            u.length && (code = code.replace(u, "uniform " + u))
                        }
                    ));
                let split = code.split(`uniform ${name} {`);
                return split[1] = split[1].replace("};", ""),
                    code = (code = split.join("")).replace(`uniform ${name} {`, "")
            }
            this.exports = {
                convertWebGL1: function convertWebGL1(code) {
                    return (code = (code = code.replace("#version 300 es", "")).replace("out vec4 FragColor;", "")).includes("samplerExternalOES") && (code = code.replace("samplerExternalOES", "sampler2D")),
                    code.includes("uniform global {") && (code = removeUBO(code, "global")),
                    code.includes("uniform ubo {") && (code = removeUBO(code, "ubo")),
                    code.includes("uniform lights {") && (code = removeUBO(code, "lights")),
                        code
                },
                convertWebGL2: function convertWebGL2(code, type) {
                    return code = code.replace(/texture2D/g, "texture"),
                    !(code = "vs" == type ? (code = code.replace(/attribute/g, "in")).replace(/varying/g, "out") : (code = code.replace(/varying/g, "in")).replace(/textureCube/g, "texture")).includes("samplerExternalOES") || "android" == Device.system.os && window.AURA || (code = code.replace("samplerExternalOES", "sampler2D")),
                        Renderer.UBO ? (code.includes("uniform global {") && (code = code.replace("uniform global", "layout(std140) uniform global")),
                        code.includes("uniform ubo {") && (code = code.replace("uniform ubo", "layout(std140) uniform ubo")),
                            Lighting.UBO ? code.includes("uniform lights {") && (code = code.replace("uniform lights", "layout(std140) uniform lights")) : code.includes("uniform lights {") && (code = removeUBO(code, "lights"))) : (code.includes("uniform global {") && (code = removeUBO(code, "global")),
                        code.includes("uniform ubo {") && (code = removeUBO(code, "ubo")),
                        code.includes("uniform lights {") && (code = removeUBO(code, "lights"))),
                        code
                }
            }
        }
    ));
class UBO {
    constructor(location, gl=Renderer.context) {
        this.gl = gl,
            this.arrays = [];
        for (let i = 0; i < 30; i++)
            this.arrays.push([]);
        this.arrayIndex = 0,
            this.objects = [],
            this.location = location,
            this.data = null,
            this.lastUpdate = 0
    }
    _getSize(uniform) {
        let obj = uniform.value;
        return Array.isArray(obj) ? uniform.components ? obj.length / uniform.components * 16 : 16 * obj.length : obj instanceof Vector2 ? 8 : obj instanceof Vector3 || obj instanceof Vector4 || obj instanceof Color ? 16 : obj instanceof Matrix4 ? 64 : obj instanceof Matrix3 ? 48 : obj instanceof Quaternion ? 16 : 4
    }
    _getValues(uniform) {
        let obj = uniform.value;
        return Array.isArray(obj) ? obj : obj instanceof Vector2 ? this._array(obj.x, obj.y) : obj instanceof Vector3 ? this._array(obj.x, obj.y, obj.z) : obj instanceof Matrix4 || obj instanceof Matrix3 ? obj.elements : obj instanceof Color ? this._array(obj.r, obj.g, obj.b) : obj instanceof Quaternion ? this._array(obj.x, obj.y, obj.z, obj.w) : this._array(obj)
    }
    _array() {
        this.arrayIndex++ >= this.arrays.length - 1 && (this.arrayIndex = 0);
        let array = this.arrays[this.arrayIndex];
        return array.length = 0,
            array.push.apply(array, arguments),
            array
    }
    clear() {
        for (let i = 0; i < this.arrays.length; i++)
            this.arrays[i].length = 0
    }
    calculate() {
        let len = this.objects.length
            , chunk = 16
            , tsize = 0
            , offset = 0
            , size = 0;
        for (let i = 0; i < len; i++) {
            let obj = this.objects[i];
            size = this._getSize(obj),
                tsize = chunk - size,
                tsize < 0 && chunk < 16 ? (offset += chunk,
                i > 0 && (this.objects[i - 1].chunkLen += chunk),
                    chunk = 16) : tsize < 0 && 16 == chunk || (0 == tsize ? chunk = 16 : chunk -= size),
                obj.offset = offset / 4,
                obj.chunkLen = size / 4,
                obj.dataLen = size / 4,
                offset += size
        }
        return offset % 16 != 0 && (this.objects[this.objects.length - 1].chunkLen += chunk / 4,
            offset += chunk),
        offset / 4
    }
    compileData() {
        let i, array = this._array(), len = this.calculate();
        for (i = 0; i < len; i++)
            array[i] = 0;
        for (i = 0; i < this.objects.length; i++) {
            let obj = this.objects[i]
                , values = this._getValues(obj);
            for (let j = 0; j < values.length; j++)
                array[obj.offset + j] = values[j]
        }
        return array
    }
    upload() {
        if (this.data)
            return;
        let gl = Renderer.context
            , array = this.compileData();
        array.length && (this.data = new Float32Array(array),
            this.buffer = gl.createBuffer(),
            gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer),
            gl.bufferData(gl.UNIFORM_BUFFER, this.data, gl.DYNAMIC_DRAW),
            gl.bindBuffer(gl.UNIFORM_BUFFER, null),
            gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer))
    }
    bind(program, name) {
        this.data || this.upload(),
        this.needsUpdate && this.update();
        let location, gl = Renderer.context;
        location = program == this.lastProgram && name == this.lastName && void 0 !== this.lastLocation ? this.lastLocation : gl.getUniformBlockIndex(program, name),
        location > 99999 || -1 == location || (gl.uniformBlockBinding(program, location, this.location),
            gl.bindBufferBase(gl.UNIFORM_BUFFER, this.location, this.buffer),
            this.lastProgram = program,
            this.lastName = name,
            this.lastLocation = location)
    }
    update() {
        if (this.data || this.upload(),
            !this.data)
            return;
        let gl = Renderer.context
            , array = this.compileData();
        this.data.set(array),
            gl.bindBuffer(gl.UNIFORM_BUFFER, this.buffer),
            gl.bufferSubData(gl.UNIFORM_BUFFER, 0, this.data),
            gl.bindBuffer(gl.UNIFORM_BUFFER, null),
            this.needsUpdate = !1
    }
    unbind() {}
    push() {
        if (this.data)
            throw "Can't modify UBO after initial upload!";
        for (let i = 0; i < arguments.length; i++)
            this.objects.push(arguments[i])
    }
    destroy() {
        this.gl.deleteBuffer(this.buffer)
    }
}
class VAO {
    constructor(gl) {
        this.gl = gl,
            this.WEBGL2 = Renderer.type == Renderer.WEBGL2,
            this.WEBGL2 ? this.vao = gl.createVertexArray() : this.vao = Renderer.extensions.VAO.createVertexArrayOES()
    }
    bind() {
        const gl = this.gl;
        this.WEBGL2 ? gl.bindVertexArray(this.vao) : Renderer.extensions.VAO.bindVertexArrayOES(this.vao)
    }
    unbind() {
        const gl = this.gl;
        this.WEBGL2 ? gl.bindVertexArray(null) : Renderer.extensions.VAO.bindVertexArrayOES(null)
    }
    destroy() {
        const gl = this.gl;
        this.WEBGL2 ? gl.deleteVertexArray(this.vao) : Renderer.extensions.VAO.deleteVertexArrayOES(this.vao),
            this.vao = null
    }
}
class BoxGeometry extends Geometry {
    constructor(width=1, height=1, depth=1, widthSegments=1, heightSegments=1, depthSegments=1) {
        super(),
            widthSegments = Math.floor(widthSegments),
            heightSegments = Math.floor(heightSegments),
            depthSegments = Math.floor(depthSegments);
        let indices = []
            , vertices = []
            , normals = []
            , uvs = []
            , numberOfVertices = 0;
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            let ix, iy, segmentWidth = width / gridX, segmentHeight = height / gridY, widthHalf = width / 2, heightHalf = height / 2, depthHalf = depth / 2, gridX1 = gridX + 1, gridY1 = gridY + 1, vertexCounter = 0, vector = new Vector3;
            for (iy = 0; iy < gridY1; iy++) {
                let y = iy * segmentHeight - heightHalf;
                for (ix = 0; ix < gridX1; ix++) {
                    let x = ix * segmentWidth - widthHalf;
                    vector[u] = x * udir,
                        vector[v] = y * vdir,
                        vector[w] = depthHalf,
                        vertices.push(vector.x, vector.y, vector.z),
                        vector[u] = 0,
                        vector[v] = 0,
                        vector[w] = depth > 0 ? 1 : -1,
                        normals.push(vector.x, vector.y, vector.z),
                        uvs.push(ix / gridX),
                        uvs.push(1 - iy / gridY),
                        vertexCounter += 1
                }
            }
            for (iy = 0; iy < gridY; iy++)
                for (ix = 0; ix < gridX; ix++) {
                    let a = numberOfVertices + ix + gridX1 * iy
                        , b = numberOfVertices + ix + gridX1 * (iy + 1)
                        , c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1)
                        , d = numberOfVertices + (ix + 1) + gridX1 * iy;
                    indices.push(a, b, d),
                        indices.push(b, c, d)
                }
            numberOfVertices += vertexCounter
        }
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0),
            buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1),
            buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2),
            buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3),
            buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4),
            buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5),
            this.index = new Uint16Array(indices),
            this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices),3)),
            this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals),3)),
            this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs),2))
    }
}
class CircleGeometry extends Geometry {
    constructor(radius=1, segments=8, thetaStart=0, thetaLength=2 * Math.PI) {
        super();
        var i, s, indices = [], vertices = [], normals = [], uvs = [], vertex = new Vector3, uv = new Vector2;
        for (vertices.push(0, 0, 0),
                 normals.push(0, 0, 1),
                 uvs.push(.5, .5),
                 s = 0,
                 i = 3; s <= segments; s++,
                 i += 3) {
            var segment = thetaStart + s / segments * thetaLength;
            vertex.x = radius * Math.cos(segment),
                vertex.y = radius * Math.sin(segment),
                vertices.push(vertex.x, vertex.y, vertex.z),
                normals.push(0, 0, 1),
                uv.x = (vertices[i] / radius + 1) / 2,
                uv.y = (vertices[i + 1] / radius + 1) / 2,
                uvs.push(uv.x, uv.y)
        }
        for (i = 1; i <= segments; i++)
            indices.push(i, i + 1, 0);
        this.index = new Uint16Array(indices),
            this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices),3)),
            this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals),3)),
            this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs),2))
    }
}
class CylinderGeometry extends Geometry {
    constructor(radiusTop=1, radiusBottom=1, height=1, radialSegments=8, heightSegments=1, openEnded=!1, thetaStart=0, thetaLength=2 * Math.PI) {
        super(),
            radialSegments = Math.floor(radialSegments),
            heightSegments = Math.floor(heightSegments);
        let indices = []
            , vertices = []
            , normals = []
            , uvs = []
            , index = 0
            , indexArray = []
            , halfHeight = height / 2;
        function generateCap(top) {
            let x, centerIndexStart, centerIndexEnd, uv = new Vector2, vertex = new Vector3, radius = !0 === top ? radiusTop : radiusBottom, sign = !0 === top ? 1 : -1;
            for (centerIndexStart = index,
                     x = 1; x <= radialSegments; x++)
                vertices.push(0, halfHeight * sign, 0),
                    normals.push(0, sign, 0),
                    uvs.push(.5, .5),
                    index++;
            for (centerIndexEnd = index,
                     x = 0; x <= radialSegments; x++) {
                let theta = x / radialSegments * thetaLength + thetaStart
                    , cosTheta = Math.cos(theta)
                    , sinTheta = Math.sin(theta);
                vertex.x = radius * sinTheta,
                    vertex.y = halfHeight * sign,
                    vertex.z = radius * cosTheta,
                    vertices.push(vertex.x, vertex.y, vertex.z),
                    normals.push(0, sign, 0),
                    uv.x = .5 * cosTheta + .5,
                    uv.y = .5 * sinTheta * sign + .5,
                    uvs.push(uv.x, uv.y),
                    index++
            }
            for (x = 0; x < radialSegments; x++) {
                let c = centerIndexStart + x
                    , i = centerIndexEnd + x;
                !0 === top ? indices.push(i, i + 1, c) : indices.push(i + 1, i, c)
            }
        }
        !function generateTorso() {
            let x, y, normal = new Vector3, vertex = new Vector3, slope = (radiusBottom - radiusTop) / height;
            for (y = 0; y <= heightSegments; y++) {
                let indexRow = []
                    , v = y / heightSegments
                    , radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                    let u = x / radialSegments
                        , theta = u * thetaLength + thetaStart
                        , sinTheta = Math.sin(theta)
                        , cosTheta = Math.cos(theta);
                    vertex.x = radius * sinTheta,
                        vertex.y = -v * height + halfHeight,
                        vertex.z = radius * cosTheta,
                        vertices.push(vertex.x, vertex.y, vertex.z),
                        normal.set(sinTheta, slope, cosTheta).normalize(),
                        normals.push(normal.x, normal.y, normal.z),
                        uvs.push(u, 1 - v),
                        indexRow.push(index++)
                }
                indexArray.push(indexRow)
            }
            for (x = 0; x < radialSegments; x++)
                for (y = 0; y < heightSegments; y++) {
                    let a = indexArray[y][x]
                        , b = indexArray[y + 1][x]
                        , c = indexArray[y + 1][x + 1]
                        , d = indexArray[y][x + 1];
                    indices.push(a, b, d),
                        indices.push(b, c, d)
                }
        }(),
        !1 === openEnded && (radiusTop > 0 && generateCap(!0),
        radiusBottom > 0 && generateCap(!1)),
            this.index = new Uint16Array(indices),
            this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices),3)),
            this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals),3)),
            this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs),2))
    }
}
class ConeGeometry extends CylinderGeometry {
    constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength)
    }
}
class PlaneGeometry extends Geometry {
    constructor(width=1, height=1, widthSegments=1, heightSegments=1) {
        super();
        let ix, iy, width_half = width / 2, height_half = height / 2, gridX = Math.floor(widthSegments) || 1, gridY = Math.floor(heightSegments) || 1, gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, indices = [], vertices = [], normals = [], uvs = [];
        for (iy = 0; iy < gridY1; iy++) {
            let y = iy * segment_height - height_half;
            for (ix = 0; ix < gridX1; ix++) {
                let x = ix * segment_width - width_half;
                vertices.push(x, -y, 0),
                    normals.push(0, 0, 1),
                    uvs.push(ix / gridX),
                    uvs.push(1 - iy / gridY)
            }
        }
        for (iy = 0; iy < gridY; iy++)
            for (ix = 0; ix < gridX; ix++) {
                let a = ix + gridX1 * iy
                    , b = ix + gridX1 * (iy + 1)
                    , c = ix + 1 + gridX1 * (iy + 1)
                    , d = ix + 1 + gridX1 * iy;
                indices.push(a, b, d),
                    indices.push(b, c, d)
            }
        this.index = new Uint16Array(indices),
            this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices),3)),
            this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals),3)),
            this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs),2))
    }
}
class PolyhedronGeometry extends Geometry {
    constructor(vertices, indices=[], radius=1, detail=0) {
        super();
        let vertexBuffer = []
            , uvBuffer = [];
        function subdivideFace(a, b, c, detail) {
            var i, j, cols = Math.pow(2, detail), v = [];
            for (i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols)
                    , bj = b.clone().lerp(c, i / cols)
                    , rows = cols - i;
                for (j = 0; j <= rows; j++)
                    v[i][j] = 0 === j && i === cols ? aj : aj.clone().lerp(bj, j / rows)
            }
            for (i = 0; i < cols; i++)
                for (j = 0; j < 2 * (cols - i) - 1; j++) {
                    var k = Math.floor(j / 2);
                    j % 2 == 0 ? (pushVertex(v[i][k + 1]),
                        pushVertex(v[i + 1][k]),
                        pushVertex(v[i][k])) : (pushVertex(v[i][k + 1]),
                        pushVertex(v[i + 1][k + 1]),
                        pushVertex(v[i + 1][k]))
                }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z)
        }
        function getVertexByIndex(index, vertex) {
            let stride = 3 * index;
            vertex.x = vertices[stride + 0],
                vertex.y = vertices[stride + 1],
                vertex.z = vertices[stride + 2]
        }
        function correctUV(uv, stride, vector, azimuth) {
            azimuth < 0 && 1 === uv.x && (uvBuffer[stride] = uv.x - 1),
            0 === vector.x && 0 === vector.z && (uvBuffer[stride] = azimuth / 2 / Math.PI + .5)
        }
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x)
        }
        !function subdivide(detail) {
            let a = new Vector3
                , b = new Vector3
                , c = new Vector3;
            for (let i = 0; i < indices.length; i += 3)
                getVertexByIndex(indices[i + 0], a),
                    getVertexByIndex(indices[i + 1], b),
                    getVertexByIndex(indices[i + 2], c),
                    subdivideFace(a, b, c, detail)
        }(detail),
            function appplyRadius(radius) {
                for (var vertex = new Vector3, i = 0; i < vertexBuffer.length; i += 3)
                    vertex.x = vertexBuffer[i + 0],
                        vertex.y = vertexBuffer[i + 1],
                        vertex.z = vertexBuffer[i + 2],
                        vertex.normalize().multiplyScalar(radius),
                        vertexBuffer[i + 0] = vertex.x,
                        vertexBuffer[i + 1] = vertex.y,
                        vertexBuffer[i + 2] = vertex.z
            }(radius),
            function generateUVs() {
                let vertex = new Vector3;
                for (let i = 0; i < vertexBuffer.length; i += 3) {
                    vertex.x = vertexBuffer[i + 0],
                        vertex.y = vertexBuffer[i + 1],
                        vertex.z = vertexBuffer[i + 2];
                    let u = azimuth(vertex) / 2 / Math.PI + .5
                        , v = (vector = vertex,
                    Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z)) / Math.PI + .5);
                    uvBuffer.push(u, 1 - v)
                }
                var vector;
                (function correctUVs() {
                        let a = new Vector3
                            , b = new Vector3
                            , c = new Vector3
                            , centroid = new Vector3
                            , uvA = new Vector2
                            , uvB = new Vector2
                            , uvC = new Vector2;
                        for (let i = 0, j = 0; i < vertexBuffer.length; i += 9,
                            j += 6) {
                            a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]),
                                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]),
                                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]),
                                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]),
                                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]),
                                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]),
                                centroid.copy(a).add(b).add(c).divideScalar(3);
                            let azi = azimuth(centroid);
                            correctUV(uvA, j + 0, a, azi),
                                correctUV(uvB, j + 2, b, azi),
                                correctUV(uvC, j + 4, c, azi)
                        }
                    }
                )(),
                    function correctSeam() {
                        for (let i = 0; i < uvBuffer.length; i += 6) {
                            let x0 = uvBuffer[i + 0]
                                , x1 = uvBuffer[i + 2]
                                , x2 = uvBuffer[i + 4]
                                , max = Math.max(x0, x1, x2)
                                , min = Math.min(x0, x1, x2);
                            max > .9 && min < .1 && (x0 < .2 && (uvBuffer[i + 0] += 1),
                            x1 < .2 && (uvBuffer[i + 2] += 1),
                            x2 < .2 && (uvBuffer[i + 4] += 1))
                        }
                    }()
            }(),
            this.addAttribute("position", new GeometryAttribute(new Float32Array(vertexBuffer),3)),
            this.addAttribute("normal", new GeometryAttribute(new Float32Array(vertexBuffer.slice()),3)),
            this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvBuffer),2)),
            0 === detail ? this.computeVertexNormals() : this.normalizeNormals()
    }
}
class IcosahedronGeometry extends PolyhedronGeometry {
    constructor(radius, detail) {
        let t = (1 + Math.sqrt(5)) / 2;
        super([-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], radius, detail)
    }
}
class RingGeometry extends Geometry {
    constructor(innerRadius=.5, outerRadius=1, thetaSegments=8, phiSegments=1, thetaStart=0, thetaLength=2 * Math.PI) {
        super();
        var segment, j, i, indices = [], vertices = [], normals = [], uvs = [], radius = innerRadius, radiusStep = (outerRadius - innerRadius) / phiSegments, vertex = new Vector3, uv = new Vector2;
        for (j = 0; j <= phiSegments; j++) {
            for (i = 0; i <= thetaSegments; i++)
                segment = thetaStart + i / thetaSegments * thetaLength,
                    vertex.x = radius * Math.cos(segment),
                    vertex.y = radius * Math.sin(segment),
                    vertices.push(vertex.x, vertex.y, vertex.z),
                    normals.push(0, 0, 1),
                    uv.x = (vertex.x / outerRadius + 1) / 2,
                    uv.y = (vertex.y / outerRadius + 1) / 2,
                    uvs.push(uv.x, uv.y);
            radius += radiusStep
        }
        for (j = 0; j < phiSegments; j++) {
            var thetaSegmentLevel = j * (thetaSegments + 1);
            for (i = 0; i < thetaSegments; i++) {
                var a = segment = i + thetaSegmentLevel
                    , b = segment + thetaSegments + 1
                    , c = segment + thetaSegments + 2
                    , d = segment + 1;
                indices.push(a, b, d),
                    indices.push(b, c, d)
            }
        }
        this.index = new Uint16Array(indices),
            this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices),3)),
            this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals),3)),
            this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs),2))
    }
}
class SphereGeometry extends Geometry {
    constructor(radius=1, widthSegments=8, heightSegments=6, phiStart=0, phiLength=2 * Math.PI, thetaStart=0, thetaLength=Math.PI) {
        super(),
            widthSegments = Math.max(3, Math.floor(widthSegments)),
            heightSegments = Math.max(2, Math.floor(heightSegments));
        let ix, iy, thetaEnd = thetaStart + thetaLength, index = 0, grid = [], vertex = new Vector3, normal = new Vector3, indices = [], vertices = [], normals = [], uvs = [];
        for (iy = 0; iy <= heightSegments; iy++) {
            let verticesRow = []
                , v = iy / heightSegments;
            for (ix = 0; ix <= widthSegments; ix++) {
                let u = ix / widthSegments;
                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength),
                    vertex.y = radius * Math.cos(thetaStart + v * thetaLength),
                    vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength),
                    vertices.push(vertex.x, vertex.y, vertex.z),
                    normal.set(vertex.x, vertex.y, vertex.z).normalize(),
                    normals.push(normal.x, normal.y, normal.z),
                    uvs.push(u, 1 - v),
                    verticesRow.push(index++)
            }
            grid.push(verticesRow)
        }
        for (iy = 0; iy < heightSegments; iy++)
            for (ix = 0; ix < widthSegments; ix++) {
                let a = grid[iy][ix + 1]
                    , b = grid[iy][ix]
                    , c = grid[iy + 1][ix]
                    , d = grid[iy + 1][ix + 1];
                (0 !== iy || thetaStart > 0) && indices.push(a, b, d),
                (iy !== heightSegments - 1 || thetaEnd < Math.PI) && indices.push(b, c, d)
            }
        this.index = new Uint16Array(indices),
            this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices),3)),
            this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals),3)),
            this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs),2))
    }
}
class TorusKnotGeometry extends Geometry {
    constructor(radius=1, tube=.4, tubularSegments=64, radialSegments=8, p=2, q=3) {
        super();
        let i, j, indices = [], vertices = [], normals = [], uvs = [], vertex = new Vector3, normal = new Vector3, P1 = new Vector3, P2 = new Vector3, B = new Vector3, T = new Vector3, N = new Vector3;
        for (i = 0; i <= tubularSegments; ++i) {
            let u = i / tubularSegments * p * Math.PI * 2;
            for (calculatePositionOnCurve(u, p, q, radius, P1),
                     calculatePositionOnCurve(u + .01, p, q, radius, P2),
                     T.subVectors(P2, P1),
                     N.addVectors(P2, P1),
                     B.crossVectors(T, N),
                     N.crossVectors(B, T),
                     B.normalize(),
                     N.normalize(),
                     j = 0; j <= radialSegments; ++j) {
                let v = j / radialSegments * Math.PI * 2
                    , cx = -tube * Math.cos(v)
                    , cy = tube * Math.sin(v);
                vertex.x = P1.x + (cx * N.x + cy * B.x),
                    vertex.y = P1.y + (cx * N.y + cy * B.y),
                    vertex.z = P1.z + (cx * N.z + cy * B.z),
                    vertices.push(vertex.x, vertex.y, vertex.z),
                    normal.subVectors(vertex, P1).normalize(),
                    normals.push(normal.x, normal.y, normal.z),
                    uvs.push(i / tubularSegments),
                    uvs.push(j / radialSegments)
            }
        }
        for (j = 1; j <= tubularSegments; j++)
            for (i = 1; i <= radialSegments; i++) {
                let a = (radialSegments + 1) * (j - 1) + (i - 1)
                    , b = (radialSegments + 1) * j + (i - 1)
                    , c = (radialSegments + 1) * j + i
                    , d = (radialSegments + 1) * (j - 1) + i;
                indices.push(a, b, d),
                    indices.push(b, c, d)
            }
        function calculatePositionOnCurve(u, p, q, radius, position) {
            let cu = Math.cos(u)
                , su = Math.sin(u)
                , quOverP = q / p * u
                , cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * .5 * cu,
                position.y = radius * (2 + cs) * su * .5,
                position.z = radius * Math.sin(quOverP) * .5
        }
        this.index = new Uint16Array(indices),
            this.addAttribute("position", new GeometryAttribute(new Float32Array(vertices),3)),
            this.addAttribute("normal", new GeometryAttribute(new Float32Array(normals),3)),
            this.addAttribute("uv", new GeometryAttribute(new Float32Array(uvs),2))
    }
}
Class((function Interaction3D(_camera) {
        Inherit(this, Component);
        const _this = this;
        let _hover, _click;
        var _v3 = new Vector3
            , _input = {}
            , _enabled = !0;
        _this.ID = Utils.timestamp(),
            _camera = _camera || World.CAMERA;
        let _ray = _this.initClass(Raycaster, _camera);
        _ray.testVisibility = !0;
        let _meshes = []
            , _test = [];
        const _event = {};
        function parseMeshes(meshes) {
            Array.isArray(meshes) || (meshes = [meshes]);
            let output = [];
            return meshes.forEach((function checkMesh(obj) {
                    obj.hitArea && (obj = function initHitMesh(obj) {
                        obj.hitMesh || (obj.hitMesh = new Mesh(obj.hitArea),
                            obj.add(obj.hitMesh));
                        return (obj = obj.hitMesh).isHitMesh = !0,
                            obj.testVisibility = !1,
                            obj.visible = !1,
                            obj
                    }(obj));
                    "boolean" == typeof obj.isHitMesh ? (obj.mouseEnabled = function(visible) {
                        visible ? ~_meshes.indexOf(obj) || _meshes.push(obj) : _meshes.remove(obj)
                    }
                        ,
                        output.push(obj)) : output.push(obj);
                    obj.children.length && obj.children.forEach(checkMesh)
                }
            )),
                output
        }
        function testObjects() {
            _test.length = 0;
            for (let i = _meshes.length - 1; i > -1; i--) {
                let obj = _meshes[i];
                obj.determineVisible() && _test.push(obj)
            }
            return _test
        }
        function start() {
            if (!_enabled)
                return;
            let hit = move();
            "3d" == _input.type && _this.events.fire(Interaction3D.EXTERNAL_PRESS),
                hit ? (_click = hit.object,
                    _click.time = Render.TIME) : _click = null
        }
        function move() {
            if (!_enabled)
                return void Interaction3D.requestCursor("auto", _this);
            let hit;
            if ("2d" == _input.type ? hit = _ray.checkHit(testObjects(), _input.position, _input.rect || Stage)[0] : (_v3.set(0, 0, -1).applyQuaternion(_input.quaternion),
                hit = _ray.checkFromValues(testObjects(), _input.position, _v3)[0]),
                hit) {
                let mesh = hit.object;
                return mesh.onHitUpdate ? (mesh.onHitUpdate(hit),
                    !1) : (_input.obj && _input.obj.setHitPosition && _input.obj.setHitPosition(hit),
                    _hover !== mesh ? (_hover && triggerHover("out", _hover, hit),
                        _hover = mesh,
                        triggerHover("over", _hover, hit),
                        _hover.__clickCallback ? Interaction3D.requestCursor("pointer", _this) : Interaction3D.requestCursor("auto", _this)) : function triggerMove(mesh, hit) {
                        _event.action = "move",
                            _event.mesh = mesh,
                            _event.hit = hit,
                            _this.events.fire(Interaction3D.MOVE, _event, !0),
                        mesh["__moveCallback" + _this.ID] && mesh["__moveCallback" + _this.ID](_event)
                    }(_hover, hit),
                    hit)
            }
            return end(),
            _input.obj && _input.obj.setHitPosition && _input.obj.setHitPosition(!1),
                !1
        }
        function end() {
            _hover && (triggerHover("out", _hover, null),
                _hover = null,
                Interaction3D.requestCursor(_this.cursor, _this))
        }
        function click(e) {
            if ("3d" == _input.type && _this.events.fire(Interaction3D.EXTERNAL_RELEASE),
                !_this.enabled)
                return;
            if (!_click)
                return;
            let hit;
            if ("2d" == _input.type) {
                let element = document.elementFromPoint(e.x, e.y);
                if (element && "hit" === element.className || GLUI.HIT)
                    return;
                hit = _ray.checkHit(testObjects(), _input.position, _input.rect)[0]
            } else
                _v3.set(0, 0, -1).applyQuaternion(_input.quaternion),
                    hit = _ray.checkFromValues(testObjects(), _input.position, _v3)[0];
            hit && hit.object === _click && function triggerClick(mesh, hit) {
                _event.action = "click",
                    _event.mesh = mesh,
                    _event.hit = hit,
                    _this.events.fire(Interaction3D.CLICK, _event, !0),
                _click.__clickCallback && _click.__clickCallback(_event)
            }(_click, hit),
                _click = null
        }
        function triggerHover(action, mesh, hit) {
            _event.action = action,
                _event.mesh = mesh,
                _event.hit = hit,
                _this.events.fire(Interaction3D.HOVER, _event, !0),
            _hover.__hoverCallback && _hover.__hoverCallback(_event)
        }
        this.cursor = "auto",
            this.set("camera", (c=>{
                    _ray.camera = c
                }
            )),
            this.add = function(meshes, hover, click, move, seo) {
                let seoRoot;
                Array.isArray(meshes) || (meshes = parseMeshes(meshes)),
                move && "function" != typeof move && (seo = move,
                    move = null),
                seo && seo.root && (seoRoot = seo.root,
                    seo = seo.seo),
                    meshes.forEach(((mesh,i)=>{
                            if (seo)
                                try {
                                    mesh._divFocus = _=>hover({
                                        action: "over",
                                        mesh: mesh
                                    }),
                                        mesh._divBlur = _=>hover({
                                            action: "out",
                                            mesh: mesh
                                        }),
                                        mesh._divSelect = _=>click({
                                            action: "click",
                                            mesh: mesh
                                        });
                                    let {url: url, label: label} = Array.isArray(seo) ? seo[i] : seo;
                                    GLSEO.objectNode(mesh, seoRoot),
                                        mesh.seo.aLink(url, label)
                                } catch (e) {
                                    Hydra.LOCAL && console.warn("Could not add SEO to Interaction3D meshes", e)
                                }
                            mesh.hitDestroy = _=>_meshes.remove(mesh),
                            hover && (mesh.__hoverCallback = hover),
                            click && (mesh.__clickCallback = click),
                            move && (mesh["__moveCallback" + _this.ID] = move),
                                _meshes.push(mesh)
                        }
                    ))
            }
            ,
            this.remove = function(meshes) {
                Array.isArray(meshes) || (meshes = parseMeshes(meshes)),
                    meshes.forEach((mesh=>{
                            mesh === _hover && (_hover = null,
                                Interaction3D.requestCursor(_this.cursor, _this)),
                            mesh.seo && mesh.seo.unlink();
                            for (let i = _meshes.length - 1; i >= 0; i--)
                                mesh === _meshes[i] && _meshes.splice(i, 1)
                        }
                    ))
            }
            ,
            this.set("testVisibility", (v=>_ray.testVisibility = v)),
            this.set("input", (obj=>{
                    (_input = {}).obj = obj,
                        _input.position = obj.group ? obj.group.position : obj,
                        _input.quaternion = obj.group ? obj.group.quaternion : null,
                        _input.type = "number" == typeof _input.position.z ? "3d" : "2d",
                        _input.rect = obj.rect,
                        "3d" == _input.type ? (new Vector3,
                            new Vector3) : (new Vector2,
                            new Vector2),
                        obj == Mouse ? function addHandlers() {
                            _this.events.sub(Mouse.input, Interaction.START, start),
                            Device.mobile && _this.events.sub(Mouse.input, Interaction.END, end),
                                _this.events.sub(Mouse.input, Interaction.MOVE, move),
                                _this.events.sub(Mouse.input, Interaction.CLICK, click)
                        }() : (!function removeHandlers() {
                            _this.events.unsub(Mouse.input, Interaction.START, start),
                            Device.mobile && _this.events.unsub(Mouse.input, Interaction.END, end),
                                _this.events.unsub(Mouse.input, Interaction.MOVE, move),
                                _this.events.unsub(Mouse.input, Interaction.CLICK, click)
                        }(),
                            _this.events.sub(obj, VRInput.SELECT_START, start),
                            _this.events.sub(obj, VRInput.SELECT_END, click),
                            _this.startRender(move, 24))
                }
            )),
            this.get("enabled", (_=>_enabled)),
            this.set("enabled", (v=>{
                    (_enabled = v) || (_hover && triggerHover("out", _hover, null),
                        _hover = null)
                }
            ))
    }
), (()=>{
        Interaction3D.HOVER = "interaction3d_hover",
            Interaction3D.CLICK = "interaction3d_click",
            Interaction3D.MOVE = "interaction3d_move",
            Interaction3D.EXTERNAL_PRESS = "interaction3d_ext_press",
            Interaction3D.EXTERNAL_RELEASE = "interaction3d_ext_release";
        var _cursorObj, _map = new Map, _input = Mouse;
        Interaction3D.find = function(camera) {
            if (camera = camera.camera || camera,
                !_map.has(camera)) {
                let interaction = new Interaction3D(camera);
                interaction.input = _input,
                    _map.set(camera, interaction)
            }
            return _map.get(camera)
        }
            ,
            Interaction3D.useInput = function(obj) {
                for (let[camera,interaction] of _map)
                    interaction.input = obj;
                _input = obj
            }
            ,
            Interaction3D.requestCursor = function(cursor, obj) {
                "pointer" == cursor && (_cursorObj = obj,
                    Stage.css("cursor", cursor)),
                "auto" == cursor && _cursorObj == obj && (Stage.css("cursor", cursor),
                    _cursorObj = null)
            }
    }
)),
    Class((function Lighting() {
            Inherit(this, Component);
            const _this = this;
            var _activeScene, _scenes = {};
            function loop() {
                if (decomposeLights(_activeScene.lights),
                    _this.UBO) {
                    let shader = _activeScene.shaders.start();
                    shader && (updateArrays(shader),
                        _activeScene.ubo.created ? _activeScene.ubo.update() : createUBO(shader.uniforms))
                } else {
                    let shader = _activeScene.shaders.start();
                    for (; shader; )
                        updateArrays(shader),
                            shader = _activeScene.shaders.next()
                }
            }
            function createUBO(uniforms) {
                _activeScene.ubo.created = !0,
                    _activeScene.ubo.push(uniforms.lightPos),
                    _activeScene.ubo.push(uniforms.lightColor),
                    _activeScene.ubo.push(uniforms.lightData),
                    _activeScene.ubo.push(uniforms.lightData2),
                    _activeScene.ubo.push(uniforms.lightData3),
                    _activeScene.ubo.push(uniforms.lightProperties),
                    _activeScene.ubo.upload()
            }
            function decomposeLights(lights) {
                for (let i = lights.length - 1; i > -1; i--) {
                    let light = lights[i];
                    light._decomposedTime && Render.TIME - light._decomposedTime < 8 || (light._decomposedTime = Render.TIME,
                    light._parent || light.updateMatrixWorld(),
                    light._world || (light._world = new Vector3),
                        light.lockToLocal ? light._world.copy(light.position) : light.getWorldPosition(light._world))
                }
            }
            function updateArrays(shader) {
                let lighting = shader.__lighting;
                lighting.position.length = 0,
                    lighting.color.length = 0,
                    lighting.data.length = 0,
                    lighting.data2.length = 0,
                    lighting.data3.length = 0,
                    lighting.properties.length = 0;
                for (let i = 0; i < _activeScene.lights.length; i++) {
                    let light = _activeScene.lights[i];
                    light._world || decomposeLights(_activeScene.lights),
                        lighting.position.push(light._world.x, light._world.y, light._world.z, 0),
                        lighting.color.push(light.color.r, light.color.g, light.color.b, 0),
                        lighting.data.push(light.data.x, light.data.y, light.data.z, light.data.w),
                        lighting.data2.push(light.data2.x, light.data2.y, light.data2.z, light.data2.w),
                        lighting.data3.push(light.data3.x, light.data3.y, light.data3.z, light.data3.w),
                        lighting.properties.push(light.properties.x, light.properties.y, light.properties.z, light.properties.w)
                }
            }
            function findParentScene(obj3d) {
                if (!obj3d)
                    return _activeScene;
                if (obj3d._lightingData)
                    return obj3d._lightingData;
                let scene, p = obj3d._parent;
                for (; p; )
                    p instanceof Scene && p._lightingData && (scene = p._lightingData),
                        p = p._parent;
                return scene || (scene = _activeScene),
                    scene
            }
            this.fallbackAreaToPoint = !1,
                this.scenes = _scenes,
                async function() {
                    await Hydra.ready(),
                        _this.createScene("default"),
                        _this.useScene("default")
                }(),
                this.createScene = function(name, scene, forced) {
                    if (_scenes[name] && !forced)
                        return this;
                    let obj = {
                        lights: [],
                        renderShadows: [],
                        ubo: new (window.Metal ? MetalUBO : UBO)(2),
                        shaders: new LinkedList,
                        name: name
                    };
                    return scene && (scene._lightingData = obj),
                        _scenes[name] = obj,
                        this
                }
                ,
                this.useScene = function(name) {
                    let scene = _scenes[name];
                    if (_activeScene != scene) {
                        if (!(_activeScene = _scenes[name]))
                            throw `Scene ${name} not found`;
                        return loop(),
                            this
                    }
                }
                ,
                this.destroyScene = function(name) {
                    delete _scenes[name]
                }
                ,
                this.push = this.add = function(light) {
                    _this.UBO = Renderer.UBO && !(window.AURA || RenderManager.type == RenderManager.WEBVR),
                    window.Metal && (_this.UBO = !0);
                    let scene = findParentScene(light);
                    scene.lights.push(light),
                    light.isAreaLight && (scene.hasAreaLight = !0),
                    _this.startedLoop || (_this.startedLoop = !0,
                        RenderManager.type == RenderManager.WEBVR ? _this.events.sub(RenderManager.BEFORE_RENDER, (_=>loop())) : Render.onDrawFrame(loop))
                }
                ,
                this.remove = function(light) {
                    _activeScene.lights.remove(light)
                }
                ,
                this.getLighting = function(shader, force) {
                    if (shader.__lighting && !force)
                        return shader.__lighting;
                    let scene = findParentScene(shader.mesh);
                    scene.shaders.push(shader),
                    window.AreaLightUtil && scene.hasAreaLight && AreaLightUtil.append(shader);
                    let lighting = shader.__lighting = {
                        position: [],
                        color: [],
                        data: [],
                        data2: [],
                        data3: [],
                        properties: []
                    }
                        , lightUBO = _this.UBO;
                    return shader.uniforms.lightPos = {
                        type: "v4v",
                        value: lighting.position,
                        ignoreUIL: !0,
                        lightUBO: lightUBO,
                        components: 4,
                        metalIgnore: !0
                    },
                        shader.uniforms.lightColor = {
                            type: "v4v",
                            value: lighting.color,
                            ignoreUIL: !0,
                            lightUBO: lightUBO,
                            components: 4,
                            metalIgnore: !0
                        },
                        shader.uniforms.lightData = {
                            type: "v4v",
                            value: lighting.data,
                            ignoreUIL: !0,
                            lightUBO: lightUBO,
                            components: 4,
                            metalIgnore: !0
                        },
                        shader.uniforms.lightData2 = {
                            type: "v4v",
                            value: lighting.data2,
                            ignoreUIL: !0,
                            lightUBO: lightUBO,
                            components: 4,
                            metalIgnore: !0
                        },
                        shader.uniforms.lightData3 = {
                            type: "v4v",
                            value: lighting.data3,
                            ignoreUIL: !0,
                            lightUBO: lightUBO,
                            components: 4,
                            metalIgnore: !0
                        },
                        shader.uniforms.lightProperties = {
                            type: "v4v",
                            value: lighting.properties,
                            ignoreUIL: !0,
                            lightUBO: lightUBO,
                            components: 4,
                            metalIgnore: !0
                        },
                        updateArrays(shader),
                    _this.UBO && !_activeScene.ubo.created && createUBO(shader.uniforms),
                        shader.__lighting
                }
                ,
                this.destroyShader = function(shader) {
                    findParentScene(shader.mesh);
                    _activeScene.shaders.remove(shader)
                }
                ,
                this.sort = function(callback) {
                    _activeScene.lights.sort(callback)
                }
                ,
                this.addToShadowGroup = function(light) {
                    findParentScene(light).renderShadows.push(light)
                }
                ,
                this.removeFromShadowGroup = function(light) {
                    findParentScene(light);
                    _activeScene.renderShadows.remove(light)
                }
                ,
                this.getShadowLights = function() {
                    return _activeScene.renderShadows
                }
                ,
                this.getShadowCount = function() {
                    return _activeScene.renderShadows.length
                }
                ,
                this.initShadowShader = function(object, mesh) {
                    let scene, shader = object.shader || object;
                    if (shader.mesh) {
                        let p = shader.mesh._parent;
                        for (; p; )
                            p instanceof Scene && p._lightingData && (scene = p._lightingData),
                                p = p._parent
                    }
                    if (scene || (scene = _activeScene),
                    !World.RENDERER.shadows || 0 == scene.renderShadows.length)
                        return "";
                    shader._gl || shader.upload();
                    let vsName = shader.vsName
                        , fsName = "ShadowDepth";
                    shader.customShadowShader && (fsName = shader.customShadowShader),
                        shader.shadow = new Shader(vsName,fsName,{
                            receiveLight: shader.receiveLight,
                            UILPrefix: shader.UILPrefix,
                            precision: "high"
                        }),
                    shader.vertexShader && (shader.shadow.vertexShader = shader.vertexShader),
                        shader.shadow.lights = shader.lights,
                        shader.shadow.isShadow = !0,
                        shader.copyUniformsTo(shader.shadow, !0),
                        shader.shadow.upload()
                }
                ,
                this.getShadowUniforms = function(shader) {
                    let scene;
                    if (shader.mesh) {
                        let p = shader.mesh._parent;
                        for (; p; )
                            p instanceof Scene && p._lightingData && (scene = p._lightingData),
                                p = p._parent
                    }
                    return scene || (scene = _activeScene),
                        World.RENDERER.shadows && 0 != scene.renderShadows.length ? [`\n#define SHADOW_MAPS ${scene.renderShadows.length}`, World.RENDERER.shadows == Renderer.SHADOWS_LOW ? "#define SHADOWS_LOW" : "", World.RENDERER.shadows == Renderer.SHADOWS_MED ? "#define SHADOWS_MED" : "", World.RENDERER.shadows == Renderer.SHADOWS_HIGH ? "#define SHADOWS_HIGH" : "", `uniform sampler2D shadowMap[${scene.renderShadows.length}];`, `uniform mat4 shadowMatrix[${scene.renderShadows.length}];`, `uniform vec3 shadowLightPos[${scene.renderShadows.length}];`, `uniform float shadowSize[${scene.renderShadows.length}];`].join("\n") : ""
                }
                ,
                this.bindUBO = function(shader) {
                    _activeScene.ubo.created && _activeScene.ubo.bind(shader, "lights")
                }
                ,
                this.fallbackAreaToPointTest = function() {
                    return _this.fallbackAreaToPoint
                }
                ,
                this.get("activeScene", (_=>_activeScene))
        }
    ), "static");
class Shadow {
    constructor(light) {
        this.light = light,
            this.camera = new PerspectiveCamera(60,1,.1,50),
            this.target = new Vector3,
            this.rt = new RenderTarget(1024,1024),
            this.rt.createDepthTexture(),
            this.enabled = !0,
            this._size = 1024,
            this._fov = 60,
            this._far = 50,
            this._near = .1,
            light.add(this.camera)
    }
    destroy() {
        this.rt.destroy()
    }
    set fov(value) {
        this._fov = value,
            this.camera.fov = value,
            this.camera.updateProjectionMatrix(),
        -1 == value && (this.camera = new OrthographicCamera(-5,5,5,-5,.1,50))
    }
    get fov() {
        return this._fov
    }
    set area(value) {
        this._area = value,
            this.camera.left = -value,
            this.camera.right = value,
            this.camera.top = value,
            this.camera.bottom = -value,
            this.camera.updateProjectionMatrix()
    }
    get area() {
        return this._area
    }
    set far(value) {
        this._far = value,
            this.camera.far = value,
            this.camera.updateProjectionMatrix()
    }
    get far() {
        return this._far
    }
    set near(value) {
        this._near = value,
            this.camera.near = value,
            this.camera.updateProjectionMatrix()
    }
    get near() {
        return this._near
    }
    set size(value) {
        this._size = value,
            this.rt.setSize(value, value)
    }
    get size() {
        return this._size
    }
}
class Box2 {
    constructor(min, max) {
        this.min = void 0 !== min ? min : new Vector2(1 / 0,1 / 0),
            this.max = void 0 !== max ? max : new Vector2(-1 / 0,-1 / 0)
    }
    set(min, max) {
        return this.min.copy(min),
            this.max.copy(max),
            this
    }
    setFromPoints(points) {
        this.makeEmpty();
        for (let i = 0, il = points.length; i < il; i++)
            this.expandByPoint(points[i]);
        return this
    }
    setFromCenterAndSize(center, size) {
        let v1 = this.V1 || new Vector2;
        this.V1 = v1;
        let halfSize = v1.copy(size).multiplyScalar(.5);
        return this.min.copy(center).sub(halfSize),
            this.max.copy(center).add(halfSize),
            this
    }
    clone() {
        return (new Box2).copy(this)
    }
    copy(box) {
        return this.min.copy(box.min),
            this.max.copy(box.max),
            this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(target) {
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(target) {
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min)
    }
    expandByPoint(point) {
        return this.min.min(point),
            this.max.max(point),
            this
    }
    expandByVector(vector) {
        return this.min.sub(vector),
            this.max.add(vector),
            this
    }
    expandByScalar(scalar) {
        return this.min.addScalar(-scalar),
            this.max.addScalar(scalar),
            this
    }
    containsPoint(point) {
        return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y)
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y
    }
    getParameter(point, target) {
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(box) {
        return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y)
    }
    clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max)
    }
    distanceToPoint(point) {
        let v1 = this.V1 || new Vector2;
        return this.V1 = v1,
            v1.copy(point).clamp(this.min, this.max).sub(point).length()
    }
    intersect(box) {
        return this.min.max(box.min),
            this.max.min(box.max),
            this
    }
    union(box) {
        return this.min.min(box.min),
            this.max.max(box.max),
            this
    }
    translate(offset) {
        return this.min.add(offset),
            this.max.add(offset),
            this
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max)
    }
}
class Box3 {
    constructor(min, max) {
        this.min = void 0 !== min ? min : new Vector3(1 / 0,1 / 0,1 / 0),
            this.max = void 0 !== max ? max : new Vector3(-1 / 0,-1 / 0,-1 / 0)
    }
    set(min, max) {
        return this.min.copy(min),
            this.max.copy(max),
            this
    }
    setFromArray(array) {
        let minX = 1 / 0
            , minY = 1 / 0
            , minZ = 1 / 0
            , maxX = -1 / 0
            , maxY = -1 / 0
            , maxZ = -1 / 0;
        for (let i = 0, l = array.length; i < l; i += 3) {
            let x = array[i]
                , y = array[i + 1]
                , z = array[i + 2];
            x < minX && (minX = x),
            y < minY && (minY = y),
            z < minZ && (minZ = z),
            x > maxX && (maxX = x),
            y > maxY && (maxY = y),
            z > maxZ && (maxZ = z)
        }
        return this.min.set(minX, minY, minZ),
            this.max.set(maxX, maxY, maxZ),
            this
    }
    setFromBufferAttribute(attribute) {
        let minX = 1 / 0
            , minY = 1 / 0
            , minZ = 1 / 0
            , maxX = -1 / 0
            , maxY = -1 / 0
            , maxZ = -1 / 0;
        for (let i = 0, l = attribute.count; i < l; i++) {
            let x = attribute.array[3 * i + 0]
                , y = attribute.array[3 * i + 1]
                , z = attribute.array[3 * i + 2];
            x < minX && (minX = x),
            y < minY && (minY = y),
            z < minZ && (minZ = z),
            x > maxX && (maxX = x),
            y > maxY && (maxY = y),
            z > maxZ && (maxZ = z)
        }
        return this.min.set(minX, minY, minZ),
            this.max.set(maxX, maxY, maxZ),
            this
    }
    setFromPoints(points) {
        this.makeEmpty();
        for (let i = 0, il = points.length; i < il; i++)
            this.expandByPoint(points[i]);
        return this
    }
    setFromCenterAndSize(center, size) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1;
        let halfSize = v1.copy(size).multiplyScalar(.5);
        return this.min.copy(center).sub(halfSize),
            this.max.copy(center).add(halfSize),
            this
    }
    setFromObject(object) {
        return this.makeEmpty(),
            this.expandByObject(object)
    }
    clone() {
        return (new Box3).copy(this)
    }
    copy(box) {
        return this.min.copy(box.min),
            this.max.copy(box.max),
            this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min)
    }
    expandByPoint(point) {
        return this.min.min(point),
            this.max.max(point),
            this
    }
    expandByVector(vector) {
        return this.min.sub(vector),
            this.max.add(vector),
            this
    }
    expandByScalar(scalar) {
        return this.min.addScalar(-scalar),
            this.max.addScalar(scalar),
            this
    }
    expandByObject(object, local) {
        let scope, i, l, v1 = this.V1 || new Vector3;
        return this.V1 = v1,
            scope = this,
            object.updateMatrixWorld(!0),
            object.traverse((node=>{
                    let geometry = node.geometry;
                    if (!geometry)
                        return;
                    let attribute = geometry.attributes.position;
                    if (void 0 !== attribute)
                        for (i = 0,
                                 l = attribute.count; i < l; i++)
                            v1.fromBufferAttribute(attribute, i).applyMatrix4(local ? node.matrix : node.matrixWorld),
                                scope.expandByPoint(v1)
                }
            )),
            this
    }
    containsPoint(point) {
        return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z)
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z
    }
    getParameter(point, target) {
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(box) {
        return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z)
    }
    intersectsSphere(sphere) {
        let closestPoint = this.V1 || new Vector3;
        return this.V1 = closestPoint,
            this.clampPoint(sphere.center, closestPoint),
        closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius
    }
    intersectsPlane(plane) {
        let min, max;
        return plane.normal.x > 0 ? (min = plane.normal.x * this.min.x,
            max = plane.normal.x * this.max.x) : (min = plane.normal.x * this.max.x,
            max = plane.normal.x * this.min.x),
            plane.normal.y > 0 ? (min += plane.normal.y * this.min.y,
                max += plane.normal.y * this.max.y) : (min += plane.normal.y * this.max.y,
                max += plane.normal.y * this.min.y),
            plane.normal.z > 0 ? (min += plane.normal.z * this.min.z,
                max += plane.normal.z * this.max.z) : (min += plane.normal.z * this.max.z,
                max += plane.normal.z * this.min.z),
        min <= plane.constant && max >= plane.constant
    }
    intersectsTriangle(triangle) {
        let v0 = this.V0 || new Vector3;
        this.V0 = v0;
        let v1 = this.V1 || new Vector3;
        this.V1 = v1;
        let v2 = this.V2 || new Vector3;
        this.V2 = v2;
        let f0 = this.F0 || new Vector3;
        this.F0 = f0;
        let f1 = this.F1 || new Vector3;
        this.F1 = f1;
        let f2 = this.F2 || new Vector3;
        this.F2 = f2;
        let testAxis = this.V3 || new Vector3;
        this.V3 = testAxis;
        let center = this.V4 || new Vector3;
        this.V4 = center;
        let extents = this.V5 || new Vector3;
        this.V5 = extents;
        let triangleNormal = this.V6 || new Vector3;
        function satForAxes(axes) {
            let i, j;
            for (i = 0,
                     j = axes.length - 3; i <= j; i += 3) {
                testAxis.fromArray(axes, i);
                let r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z)
                    , p0 = v0.dot(testAxis)
                    , p1 = v1.dot(testAxis)
                    , p2 = v2.dot(testAxis);
                if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r)
                    return !1
            }
            return !0
        }
        if (this.V6 = triangleNormal,
            this.isEmpty())
            return !1;
        this.getCenter(center),
            extents.subVectors(this.max, center),
            v0.subVectors(triangle.a, center),
            v1.subVectors(triangle.b, center),
            v2.subVectors(triangle.c, center),
            f0.subVectors(v1, v0),
            f1.subVectors(v2, v1),
            f2.subVectors(v0, v2);
        let axes = [0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y, f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x, -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0];
        return !!satForAxes(axes) && (axes = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !!satForAxes(axes) && (triangleNormal.crossVectors(f0, f1),
            axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z],
            satForAxes(axes)))
    }
    clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max)
    }
    distanceToPoint(point) {
        let v1 = this.V1 || new Vector3;
        return this.V1 = v1,
            v1.copy(point).clamp(this.min, this.max).sub(point).length()
    }
    getBoundingSphere(target=new Sphere) {
        let v1 = this.V1 || new Vector3;
        return this.V1 = v1,
            this.getCenter(target.center),
            target.radius = .5 * this.getSize(v1).length(),
            target
    }
    intersect(box) {
        return this.min.max(box.min),
            this.max.min(box.max),
        this.isEmpty() && this.makeEmpty(),
            this
    }
    union(box) {
        return this.min.min(box.min),
            this.max.max(box.max),
            this
    }
    applyMatrix4(matrix) {
        if (this.isEmpty())
            return this;
        let m = matrix.elements
            , xax = m[0] * this.min.x
            , xay = m[1] * this.min.x
            , xaz = m[2] * this.min.x
            , xbx = m[0] * this.max.x
            , xby = m[1] * this.max.x
            , xbz = m[2] * this.max.x
            , yax = m[4] * this.min.y
            , yay = m[5] * this.min.y
            , yaz = m[6] * this.min.y
            , ybx = m[4] * this.max.y
            , yby = m[5] * this.max.y
            , ybz = m[6] * this.max.y
            , zax = m[8] * this.min.z
            , zay = m[9] * this.min.z
            , zaz = m[10] * this.min.z
            , zbx = m[8] * this.max.z
            , zby = m[9] * this.max.z
            , zbz = m[10] * this.max.z;
        return this.min.x = Math.min(xax, xbx) + Math.min(yax, ybx) + Math.min(zax, zbx) + m[12],
            this.min.y = Math.min(xay, xby) + Math.min(yay, yby) + Math.min(zay, zby) + m[13],
            this.min.z = Math.min(xaz, xbz) + Math.min(yaz, ybz) + Math.min(zaz, zbz) + m[14],
            this.max.x = Math.max(xax, xbx) + Math.max(yax, ybx) + Math.max(zax, zbx) + m[12],
            this.max.y = Math.max(xay, xby) + Math.max(yay, yby) + Math.max(zay, zby) + m[13],
            this.max.z = Math.max(xaz, xbz) + Math.max(yaz, ybz) + Math.max(zaz, zbz) + m[14],
            this
    }
    translate(offset) {
        return this.min.add(offset),
            this.max.add(offset),
            this
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max)
    }
    setFromBufferAttribute(attribute) {
        let minX = 1 / 0
            , minY = 1 / 0
            , minZ = 1 / 0
            , maxX = -1 / 0
            , maxY = -1 / 0
            , maxZ = -1 / 0;
        for (let i = 0, l = attribute.count; i < l; i++) {
            let x = attribute.array[3 * i + 0]
                , y = attribute.array[3 * i + 1]
                , z = attribute.array[3 * i + 2];
            x < minX && (minX = x),
            y < minY && (minY = y),
            z < minZ && (minZ = z),
            x > maxX && (maxX = x),
            y > maxY && (maxY = y),
            z > maxZ && (maxZ = z)
        }
        return this.min.set(minX, minY, minZ),
            this.max.set(maxX, maxY, maxZ),
            this
    }
}
class Color {
    constructor(r, g, b) {
        return null == r && null == g && null == b ? this.setRGB(1, 1, 1) : void 0 === g && void 0 === b ? this.set(r) : void this.setRGB(r, g, b)
    }
    set(value) {
        return value && value instanceof Color ? this.copy(value) : "number" == typeof value ? this.setHex(value) : "string" == typeof value && this.setStyle(value),
            this
    }
    setScalar(scalar) {
        return this.r = scalar,
            this.g = scalar,
            this.b = scalar,
            this
    }
    setHex(hex) {
        return hex = Math.floor(hex),
            this.r = (hex >> 16 & 255) / 255,
            this.g = (hex >> 8 & 255) / 255,
            this.b = (255 & hex) / 255,
            this
    }
    setStyle(string) {
        return this.setHex(Number(string.replace("#", "0x")))
    }
    setRGB(r, g, b) {
        return this.r = r,
            this.g = g,
            this.b = b,
            this
    }
    setHSL(h, s, l) {
        function hue2rgb(p, q, t) {
            return t < 0 && (t += 1),
            t > 1 && (t -= 1),
                t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + 6 * (q - p) * (2 / 3 - t) : p
        }
        if (h = Math.euclideanModulo(h, 1),
            s = Math.clamp(s, 0, 1),
            l = Math.clamp(l, 0, 1),
        0 === s)
            this.r = this.g = this.b = l;
        else {
            let p = l <= .5 ? l * (1 + s) : l + s - l * s
                , q = 2 * l - p;
            this.r = hue2rgb(q, p, h + 1 / 3),
                this.g = hue2rgb(q, p, h),
                this.b = hue2rgb(q, p, h - 1 / 3)
        }
        return this
    }
    clone() {
        return new Color(this.r,this.g,this.b)
    }
    copy(color) {
        return this.r = color.r,
            this.g = color.g,
            this.b = color.b,
            this
    }
    copyGammaToLinear(color, gammaFactor) {
        return void 0 === gammaFactor && (gammaFactor = 2),
            this.r = Math.pow(color.r, gammaFactor),
            this.g = Math.pow(color.g, gammaFactor),
            this.b = Math.pow(color.b, gammaFactor),
            this
    }
    copyLinearToGamma(color, gammaFactor) {
        void 0 === gammaFactor && (gammaFactor = 2);
        let safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        return this.r = Math.pow(color.r, safeInverse),
            this.g = Math.pow(color.g, safeInverse),
            this.b = Math.pow(color.b, safeInverse),
            this
    }
    convertGammaToLinear(gammaFactor) {
        return this.copyGammaToLinear(this, gammaFactor),
            this
    }
    convertLinearToGamma(gammaFactor) {
        return this.copyLinearToGamma(this, gammaFactor),
            this
    }
    getHex() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
    }
    getHexString() {
        return "#" + ("000000" + this.getHex().toString(16)).slice(-6)
    }
    getHSL() {
        let target = this.target || {};
        this.target = target;
        let hue, saturation, r = this.r, g = this.g, b = this.b, max = Math.max(r, g, b), min = Math.min(r, g, b), lightness = (min + max) / 2;
        if (min === max)
            hue = 0,
                saturation = 0;
        else {
            let delta = max - min;
            switch (saturation = lightness <= .5 ? delta / (max + min) : delta / (2 - max - min),
                max) {
                case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                case g:
                    hue = (b - r) / delta + 2;
                    break;
                case b:
                    hue = (r - g) / delta + 4
            }
            hue /= 6
        }
        return target.h = hue,
            target.s = saturation,
            target.l = lightness,
            target
    }
    tween(color, time, ease, delay) {
        const _this = this;
        _this.tweenObj || (_this.tweenObj = {
            v: 0
        }),
            _this.tweenObj.v = 0;
        let clone = this.clone();
        return TweenManager.tween(_this.tweenObj, {
            v: 1
        }, time, ease, delay).onUpdate((_=>{
                _this.copy(clone).lerp(color, _this.tweenObj.v)
            }
        ))
    }
    offsetHSL(h, s, l) {
        let hsl = this.getHSL();
        return hsl.h += h,
            hsl.s += s,
            hsl.l += l,
            this.setHSL(hsl.h, hsl.s, hsl.l),
            this
    }
    add(color) {
        return this.r += color.r,
            this.g += color.g,
            this.b += color.b,
            this
    }
    addColors(color1, color2) {
        return this.r = color1.r + color2.r,
            this.g = color1.g + color2.g,
            this.b = color1.b + color2.b,
            this
    }
    addScalar(s) {
        return this.r += s,
            this.g += s,
            this.b += s,
            this
    }
    sub(color) {
        return this.r = Math.max(0, this.r - color.r),
            this.g = Math.max(0, this.g - color.g),
            this.b = Math.max(0, this.b - color.b),
            this
    }
    multiply(color) {
        return this.r *= color.r,
            this.g *= color.g,
            this.b *= color.b,
            this
    }
    multiplyScalar(s) {
        return this.r *= s,
            this.g *= s,
            this.b *= s,
            this
    }
    invert() {
        return this.r = 1 - this.r,
            this.g = 1 - this.g,
            this.b = 1 - this.b,
            this
    }
    lerp(color, alpha) {
        return this.r += (color.r - this.r) * alpha,
            this.g += (color.g - this.g) * alpha,
            this.b += (color.b - this.b) * alpha,
            this
    }
    equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b
    }
    fromArray(array, offset) {
        return void 0 === offset && (offset = 0),
            this.r = array[offset],
            this.g = array[offset + 1],
            this.b = array[offset + 2],
            this
    }
    toArray(array, offset) {
        return void 0 === array && (array = []),
        void 0 === offset && (offset = 0),
            array[offset] = this.r,
            array[offset + 1] = this.g,
            array[offset + 2] = this.b,
            array
    }
}
class Cylindrical {
    constructor(radius=1, theta=0, y=0) {
        this.radius = radius,
            this.theta = theta,
            this.y = y
    }
    set(radius, theta, y) {
        return this.radius = radius,
            this.theta = theta,
            this.y = y,
            this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(other) {
        return this.radius = other.radius,
            this.theta = other.theta,
            this.y = other.y,
            this
    }
    setFromVector3(vec3) {
        return this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z),
            this.theta = Math.atan2(vec3.x, vec3.z),
            this.y = vec3.y,
            this
    }
}
class Euler {
    constructor(x, y, z, order) {
        this._x = x || 0,
            this._y = y || 0,
            this._z = z || 0,
            this._order = order || "XYZ",
            this.isEuler = !0
    }
    set x(value) {
        this._x = value,
            this.onChangeCallback()
    }
    get x() {
        return this._x
    }
    set y(value) {
        this._y = value,
            this.onChangeCallback()
    }
    get y() {
        return this._y
    }
    set z(value) {
        this._z = value,
            this.onChangeCallback()
    }
    get z() {
        return this._z
    }
    set order(value) {
        this._order = value,
            this.onChangeCallback()
    }
    get order() {
        return this._order
    }
    set(x, y, z, order) {
        return this._x = x,
            this._y = y,
            this._z = z,
            this._order = order || this._order,
            this.onChangeCallback(),
            this
    }
    clone() {
        return new Euler(this._x,this._y,this._z,this._order)
    }
    copy(euler) {
        return this._x = euler._x,
            this._y = euler._y,
            this._z = euler._z,
            this._order = euler._order,
            this.onChangeCallback(),
            this
    }
    setFromRotationMatrix(m, order, update) {
        let clamp = Math.clamp
            , te = m.elements
            , m11 = te[0]
            , m12 = te[4]
            , m13 = te[8]
            , m21 = te[1]
            , m22 = te[5]
            , m23 = te[9]
            , m31 = te[2]
            , m32 = te[6]
            , m33 = te[10];
        return "XYZ" === (order = order || this._order) ? (this._y = Math.asin(clamp(m13, -1, 1)),
            Math.abs(m13) < .99999 ? (this._x = Math.atan2(-m23, m33),
                this._z = Math.atan2(-m12, m11)) : (this._x = Math.atan2(m32, m22),
                this._z = 0)) : "YXZ" === order ? (this._x = Math.asin(-clamp(m23, -1, 1)),
            Math.abs(m23) < .99999 ? (this._y = Math.atan2(m13, m33),
                this._z = Math.atan2(m21, m22)) : (this._y = Math.atan2(-m31, m11),
                this._z = 0)) : "ZXY" === order ? (this._x = Math.asin(clamp(m32, -1, 1)),
            Math.abs(m32) < .99999 ? (this._y = Math.atan2(-m31, m33),
                this._z = Math.atan2(-m12, m22)) : (this._y = 0,
                this._z = Math.atan2(m21, m11))) : "ZYX" === order ? (this._y = Math.asin(-clamp(m31, -1, 1)),
            Math.abs(m31) < .99999 ? (this._x = Math.atan2(m32, m33),
                this._z = Math.atan2(m21, m11)) : (this._x = 0,
                this._z = Math.atan2(-m12, m22))) : "YZX" === order ? (this._z = Math.asin(clamp(m21, -1, 1)),
            Math.abs(m21) < .99999 ? (this._x = Math.atan2(-m23, m22),
                this._y = Math.atan2(-m31, m11)) : (this._x = 0,
                this._y = Math.atan2(m13, m33))) : "XZY" === order && (this._z = Math.asin(-clamp(m12, -1, 1)),
            Math.abs(m12) < .99999 ? (this._x = Math.atan2(m32, m22),
                this._y = Math.atan2(m13, m11)) : (this._x = Math.atan2(-m23, m33),
                this._y = 0)),
            this._order = order,
        !1 !== update && this.onChangeCallback(),
            this
    }
    setFromQuaternion(q, order, update) {
        let matrix = this.M1 || new Matrix4;
        return this.M1 = matrix,
            matrix.makeRotationFromQuaternion(q),
            this.setFromRotationMatrix(matrix, order, update)
    }
    setFromVector3(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order)
    }
    reorder(newOrder) {
        let q = this.Q1 || new Quaternion;
        return this.Q1 = q,
            q.setFromEuler(this),
            this.setFromQuaternion(q, newOrder)
    }
    lerp(euler, alpha) {
        this._x += (euler._x - this._x) * alpha,
            this._y += (euler._y - this._y) * alpha,
            this._z += (euler._z - this._z) * alpha,
            this.onChangeCallback()
    }
    equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order
    }
    fromArray(array) {
        return this._x = array[0],
            this._y = array[1],
            this._z = array[2],
        void 0 !== array[3] && (this._order = array[3]),
            this.onChangeCallback(),
            this
    }
    toArray(array, offset) {
        return void 0 === array && (array = []),
        void 0 === offset && (offset = 0),
            array[offset] = this._x,
            array[offset + 1] = this._y,
            array[offset + 2] = this._z,
            array[offset + 3] = this._order,
            array
    }
    toVector3(optionalResult) {
        return optionalResult ? optionalResult.set(this._x, this._y, this._z) : new Vector3(this._x,this._y,this._z)
    }
    onChange(callback) {
        this.onChangeCallback = callback
    }
    onChangeCallback() {}
}
Euler.DefaultOrder = "XYZ",
    Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Frustum {
    constructor(p0, p1, p2, p3, p4, p5) {
        this.planes = [void 0 !== p0 ? p0 : new Plane, void 0 !== p1 ? p1 : new Plane, void 0 !== p2 ? p2 : new Plane, void 0 !== p3 ? p3 : new Plane, void 0 !== p4 ? p4 : new Plane, void 0 !== p5 ? p5 : new Plane]
    }
    set(p0, p1, p2, p3, p4, p5) {
        let planes = this.planes;
        return planes[0].copy(p0),
            planes[1].copy(p1),
            planes[2].copy(p2),
            planes[3].copy(p3),
            planes[4].copy(p4),
            planes[5].copy(p5),
            this
    }
    clone() {
        return (new Frustum).copy(this)
    }
    copy(frustum) {
        let planes = this.planes;
        for (let i = 0; i < 6; i++)
            planes[i].copy(frustum.planes[i]);
        return this
    }
    setFromMatrix(m) {
        let planes = this.planes
            , me = m.elements
            , me0 = me[0]
            , me1 = me[1]
            , me2 = me[2]
            , me3 = me[3]
            , me4 = me[4]
            , me5 = me[5]
            , me6 = me[6]
            , me7 = me[7]
            , me8 = me[8]
            , me9 = me[9]
            , me10 = me[10]
            , me11 = me[11]
            , me12 = me[12]
            , me13 = me[13]
            , me14 = me[14]
            , me15 = me[15];
        return planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize(),
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize(),
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize(),
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize(),
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize(),
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize(),
            this
    }
    setFromCamera(camera) {
        let matrix = this.M1 || new Matrix4;
        return this.M1 = matrix,
            matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse),
            this.setFromMatrix(matrix)
    }
    intersectsObject(object) {
        let sphere = this.S1 || new Sphere;
        this.S1 = sphere;
        let geometry = object.geometry;
        return null === geometry.boundingSphere && geometry.computeBoundingSphere(),
            sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld),
            this.intersectsSphere(sphere)
    }
    intersectsSphere(sphere) {
        let planes = this.planes
            , center = sphere.center
            , negRadius = -sphere.radius;
        for (let i = 0; i < 6; i++) {
            if (planes[i].distanceToPoint(center) < negRadius)
                return !1
        }
        return !0
    }
    intersectsBox(box) {
        let p1 = this.V1 || new Vector3
            , p2 = this.V2 || new Vector3;
        this.V1 = p1,
            this.V2 = p2;
        let planes = this.planes;
        for (let i = 0; i < 6; i++) {
            let plane = planes[i];
            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x,
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x,
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y,
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y,
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z,
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            let d1 = plane.distanceToPoint(p1)
                , d2 = plane.distanceToPoint(p2);
            if (d1 < 0 && d2 < 0)
                return !1
        }
        return !0
    }
    containsPoint(point) {
        let planes = this.planes;
        for (let i = 0; i < 6; i++)
            if (planes[i].distanceToPoint(point) < 0)
                return !1;
        return !0
    }
}
class Line3 {
    constructor(start=new Vector3, end=new Vector3) {
        this.start = start,
            this.end = end
    }
    set(start, end) {
        return this.start.copy(start),
            this.end.copy(end),
            this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(line) {
        return this.start.copy(line.start),
            this.end.copy(line.end),
            this
    }
    getCenter(target=new Vector3) {
        return target.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(target=new Vector3) {
        return target.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(t, target=new Vector3) {
        return this.delta(target).multiplyScalar(t).add(this.start)
    }
    closestPointToPointParameter(point, clampToLine) {
        let startP = this.V1 || new Vector3
            , startEnd = this.V2 || new Vector3;
        this.V1 = startP,
            this.V2 = startEnd,
            startP.subVectors(point, this.start),
            startEnd.subVectors(this.end, this.start);
        let startEnd2 = startEnd.dot(startEnd)
            , t = startEnd.dot(startP) / startEnd2;
        return clampToLine && (t = Math.clamp(t, 0, 1)),
            t
    }
    closestPointToPoint(point, clampToLine, target=new Vector3) {
        let t = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(target).multiplyScalar(t).add(this.start)
    }
    applyMatrix4(matrix) {
        return this.start.applyMatrix4(matrix),
            this.end.applyMatrix4(matrix),
            this
    }
    equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end)
    }
}
class Matrix3 {
    constructor() {
        this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        let te = this.elements;
        return te[0] = n11,
            te[1] = n21,
            te[2] = n31,
            te[3] = n12,
            te[4] = n22,
            te[5] = n32,
            te[6] = n13,
            te[7] = n23,
            te[8] = n33,
            this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
    }
    clone() {
        return (new Matrix3).fromArray(this.elements)
    }
    copy(m) {
        let te = this.elements
            , me = m.elements;
        return te[0] = me[0],
            te[1] = me[1],
            te[2] = me[2],
            te[3] = me[3],
            te[4] = me[4],
            te[5] = me[5],
            te[6] = me[6],
            te[7] = me[7],
            te[8] = me[8],
            this
    }
    setFromMatrix4(m) {
        let me = m.elements;
        return this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]),
            this
    }
    multiply(m) {
        return this.multiplyMatrices(this, m)
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this)
    }
    multiplyMatrices(a, b) {
        let ae = a.elements
            , be = b.elements
            , te = this.elements
            , a11 = ae[0]
            , a12 = ae[3]
            , a13 = ae[6]
            , a21 = ae[1]
            , a22 = ae[4]
            , a23 = ae[7]
            , a31 = ae[2]
            , a32 = ae[5]
            , a33 = ae[8]
            , b11 = be[0]
            , b12 = be[3]
            , b13 = be[6]
            , b21 = be[1]
            , b22 = be[4]
            , b23 = be[7]
            , b31 = be[2]
            , b32 = be[5]
            , b33 = be[8];
        return te[0] = a11 * b11 + a12 * b21 + a13 * b31,
            te[3] = a11 * b12 + a12 * b22 + a13 * b32,
            te[6] = a11 * b13 + a12 * b23 + a13 * b33,
            te[1] = a21 * b11 + a22 * b21 + a23 * b31,
            te[4] = a21 * b12 + a22 * b22 + a23 * b32,
            te[7] = a21 * b13 + a22 * b23 + a23 * b33,
            te[2] = a31 * b11 + a32 * b21 + a33 * b31,
            te[5] = a31 * b12 + a32 * b22 + a33 * b32,
            te[8] = a31 * b13 + a32 * b23 + a33 * b33,
            this
    }
    multiplyScalar(s) {
        let te = this.elements;
        return te[0] *= s,
            te[3] *= s,
            te[6] *= s,
            te[1] *= s,
            te[4] *= s,
            te[7] *= s,
            te[2] *= s,
            te[5] *= s,
            te[8] *= s,
            this
    }
    determinant() {
        let te = this.elements
            , a = te[0]
            , b = te[1]
            , c = te[2]
            , d = te[3]
            , e = te[4]
            , f = te[5]
            , g = te[6]
            , h = te[7]
            , i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g
    }
    getInverse(matrix, throwOnDegenerate) {
        let me = matrix.elements
            , te = this.elements
            , n11 = me[0]
            , n21 = me[1]
            , n31 = me[2]
            , n12 = me[3]
            , n22 = me[4]
            , n32 = me[5]
            , n13 = me[6]
            , n23 = me[7]
            , n33 = me[8]
            , t11 = n33 * n22 - n32 * n23
            , t12 = n32 * n13 - n33 * n12
            , t13 = n23 * n12 - n22 * n13
            , det = n11 * t11 + n21 * t12 + n31 * t13;
        if (0 === det) {
            let msg = ".getInverse() can't invert matrix, determinant is 0";
            if (!0 === throwOnDegenerate)
                throw new Error(msg);
            return this.identity()
        }
        let detInv = 1 / det;
        return te[0] = t11 * detInv,
            te[1] = (n31 * n23 - n33 * n21) * detInv,
            te[2] = (n32 * n21 - n31 * n22) * detInv,
            te[3] = t12 * detInv,
            te[4] = (n33 * n11 - n31 * n13) * detInv,
            te[5] = (n31 * n12 - n32 * n11) * detInv,
            te[6] = t13 * detInv,
            te[7] = (n21 * n13 - n23 * n11) * detInv,
            te[8] = (n22 * n11 - n21 * n12) * detInv,
            this
    }
    transpose() {
        let tmp, m = this.elements;
        return tmp = m[1],
            m[1] = m[3],
            m[3] = tmp,
            tmp = m[2],
            m[2] = m[6],
            m[6] = tmp,
            tmp = m[5],
            m[5] = m[7],
            m[7] = tmp,
            this
    }
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose()
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        let c = Math.cos(rotation)
            , s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1)
    }
    scale(sx, sy) {
        let te = this.elements;
        return te[0] *= sx,
            te[3] *= sx,
            te[6] *= sx,
            te[1] *= sy,
            te[4] *= sy,
            te[7] *= sy,
            this
    }
    rotate(theta) {
        let c = Math.cos(theta)
            , s = Math.sin(theta)
            , te = this.elements
            , a11 = te[0]
            , a12 = te[3]
            , a13 = te[6]
            , a21 = te[1]
            , a22 = te[4]
            , a23 = te[7];
        return te[0] = c * a11 + s * a21,
            te[3] = c * a12 + s * a22,
            te[6] = c * a13 + s * a23,
            te[1] = -s * a11 + c * a21,
            te[4] = -s * a12 + c * a22,
            te[7] = -s * a13 + c * a23,
            this
    }
    translate(tx, ty) {
        let te = this.elements;
        return te[0] += tx * te[2],
            te[3] += tx * te[5],
            te[6] += tx * te[8],
            te[1] += ty * te[2],
            te[4] += ty * te[5],
            te[7] += ty * te[8],
            this
    }
    equals(matrix) {
        let te = this.elements
            , me = matrix.elements;
        for (let i = 0; i < 9; i++)
            if (te[i] !== me[i])
                return !1;
        return !0
    }
    fromArray(array, offset) {
        void 0 === offset && (offset = 0);
        for (let i = 0; i < 9; i++)
            this.elements[i] = array[i + offset];
        return this
    }
    toArray(array, offset) {
        void 0 === array && (array = []),
        void 0 === offset && (offset = 0);
        let te = this.elements;
        return array[offset] = te[0],
            array[offset + 1] = te[1],
            array[offset + 2] = te[2],
            array[offset + 3] = te[3],
            array[offset + 4] = te[4],
            array[offset + 5] = te[5],
            array[offset + 6] = te[6],
            array[offset + 7] = te[7],
            array[offset + 8] = te[8],
            array
    }
    applyToBufferAttribute(attribute) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1;
        for (let i = 0, l = attribute.count; i < l; i++)
            v1.x = attribute.array[3 * i + 0],
                v1.y = attribute.array[3 * i + 1],
                v1.z = attribute.array[3 * i + 2],
                v1.applyMatrix3(this),
                attribute.array[3 * i + 0] = v1.x,
                attribute.array[3 * i + 1] = v1.y,
                attribute.array[3 * i + 2] = v1.z;
        return attribute
    }
}
class Matrix4 {
    constructor() {
        this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        let te = this.elements;
        return te[0] = n11,
            te[4] = n12,
            te[8] = n13,
            te[12] = n14,
            te[1] = n21,
            te[5] = n22,
            te[9] = n23,
            te[13] = n24,
            te[2] = n31,
            te[6] = n32,
            te[10] = n33,
            te[14] = n34,
            te[3] = n41,
            te[7] = n42,
            te[11] = n43,
            te[15] = n44,
            this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
    }
    clone() {
        return (new Matrix4).fromArray(this.elements)
    }
    copy(m) {
        let te = this.elements
            , me = m.elements;
        return te[0] = me[0],
            te[1] = me[1],
            te[2] = me[2],
            te[3] = me[3],
            te[4] = me[4],
            te[5] = me[5],
            te[6] = me[6],
            te[7] = me[7],
            te[8] = me[8],
            te[9] = me[9],
            te[10] = me[10],
            te[11] = me[11],
            te[12] = me[12],
            te[13] = me[13],
            te[14] = me[14],
            te[15] = me[15],
            this
    }
    copyPosition(m) {
        let te = this.elements
            , me = m.elements;
        return te[12] = me[12],
            te[13] = me[13],
            te[14] = me[14],
            this
    }
    extractBasis(xAxis, yAxis, zAxis) {
        return xAxis.setFromMatrixColumn(this, 0),
            yAxis.setFromMatrixColumn(this, 1),
            zAxis.setFromMatrixColumn(this, 2),
            this
    }
    makeBasis(xAxis, yAxis, zAxis) {
        return this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1),
            this
    }
    extractRotation(m) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1;
        let te = this.elements
            , me = m.elements
            , scaleX = 1 / v1.setFromMatrixColumn(m, 0).length()
            , scaleY = 1 / v1.setFromMatrixColumn(m, 1).length()
            , scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
        return te[0] = me[0] * scaleX,
            te[1] = me[1] * scaleX,
            te[2] = me[2] * scaleX,
            te[4] = me[4] * scaleY,
            te[5] = me[5] * scaleY,
            te[6] = me[6] * scaleY,
            te[8] = me[8] * scaleZ,
            te[9] = me[9] * scaleZ,
            te[10] = me[10] * scaleZ,
            this
    }
    makeRotationFromEuler(euler) {
        let te = this.elements
            , x = euler.x
            , y = euler.y
            , z = euler.z
            , a = Math.cos(x)
            , b = Math.sin(x)
            , c = Math.cos(y)
            , d = Math.sin(y)
            , e = Math.cos(z)
            , f = Math.sin(z);
        if ("XYZ" === euler.order) {
            let ae = a * e
                , af = a * f
                , be = b * e
                , bf = b * f;
            te[0] = c * e,
                te[4] = -c * f,
                te[8] = d,
                te[1] = af + be * d,
                te[5] = ae - bf * d,
                te[9] = -b * c,
                te[2] = bf - ae * d,
                te[6] = be + af * d,
                te[10] = a * c
        } else if ("YXZ" === euler.order) {
            let ce = c * e
                , cf = c * f
                , de = d * e
                , df = d * f;
            te[0] = ce + df * b,
                te[4] = de * b - cf,
                te[8] = a * d,
                te[1] = a * f,
                te[5] = a * e,
                te[9] = -b,
                te[2] = cf * b - de,
                te[6] = df + ce * b,
                te[10] = a * c
        } else if ("ZXY" === euler.order) {
            let ce = c * e
                , cf = c * f
                , de = d * e
                , df = d * f;
            te[0] = ce - df * b,
                te[4] = -a * f,
                te[8] = de + cf * b,
                te[1] = cf + de * b,
                te[5] = a * e,
                te[9] = df - ce * b,
                te[2] = -a * d,
                te[6] = b,
                te[10] = a * c
        } else if ("ZYX" === euler.order) {
            let ae = a * e
                , af = a * f
                , be = b * e
                , bf = b * f;
            te[0] = c * e,
                te[4] = be * d - af,
                te[8] = ae * d + bf,
                te[1] = c * f,
                te[5] = bf * d + ae,
                te[9] = af * d - be,
                te[2] = -d,
                te[6] = b * c,
                te[10] = a * c
        } else if ("YZX" === euler.order) {
            let ac = a * c
                , ad = a * d
                , bc = b * c
                , bd = b * d;
            te[0] = c * e,
                te[4] = bd - ac * f,
                te[8] = bc * f + ad,
                te[1] = f,
                te[5] = a * e,
                te[9] = -b * e,
                te[2] = -d * e,
                te[6] = ad * f + bc,
                te[10] = ac - bd * f
        } else if ("XZY" === euler.order) {
            let ac = a * c
                , ad = a * d
                , bc = b * c
                , bd = b * d;
            te[0] = c * e,
                te[4] = -f,
                te[8] = d * e,
                te[1] = ac * f + bd,
                te[5] = a * e,
                te[9] = ad * f - bc,
                te[2] = bc * f - ad,
                te[6] = b * e,
                te[10] = bd * f + ac
        }
        return te[3] = 0,
            te[7] = 0,
            te[11] = 0,
            te[12] = 0,
            te[13] = 0,
            te[14] = 0,
            te[15] = 1,
            this
    }
    makeRotationFromQuaternion(q) {
        let te = this.elements
            , x = q._x
            , y = q._y
            , z = q._z
            , w = q._w;
        if (window.NativeUtils && NativeUtils.makeRotationFromQuaternion)
            NativeUtils.makeRotationFromQuaternion(te, x, y, z, w);
        else {
            let x2 = x + x
                , y2 = y + y
                , z2 = z + z
                , xx = x * x2
                , xy = x * y2
                , xz = x * z2
                , yy = y * y2
                , yz = y * z2
                , zz = z * z2
                , wx = w * x2
                , wy = w * y2
                , wz = w * z2;
            te[0] = 1 - (yy + zz),
                te[4] = xy - wz,
                te[8] = xz + wy,
                te[1] = xy + wz,
                te[5] = 1 - (xx + zz),
                te[9] = yz - wx,
                te[2] = xz - wy,
                te[6] = yz + wx,
                te[10] = 1 - (xx + yy),
                te[3] = 0,
                te[7] = 0,
                te[11] = 0,
                te[12] = 0,
                te[13] = 0,
                te[14] = 0,
                te[15] = 1
        }
        return this
    }
    lookAt(eye, target, up) {
        let x = this.V1 || new Vector3
            , y = this.V2 || new Vector3
            , z = this.V3 || new Vector3;
        this.V1 = x,
            this.V2 = y,
            this.V3 = z;
        let te = this.elements;
        return z.subVectors(eye, target),
        0 === z.lengthSq() && (z.z = 1),
            z.normalize(),
            x.crossVectors(up, z),
        0 === x.lengthSq() && (1 === Math.abs(up.z) ? z.x += 1e-4 : z.z += 1e-4,
            z.normalize(),
            x.crossVectors(up, z)),
            x.normalize(),
            y.crossVectors(z, x),
            te[0] = x.x,
            te[4] = y.x,
            te[8] = z.x,
            te[1] = x.y,
            te[5] = y.y,
            te[9] = z.y,
            te[2] = x.z,
            te[6] = y.z,
            te[10] = z.z,
            this
    }
    multiply(m) {
        return this.multiplyMatrices(this, m)
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this)
    }
    multiplyMatrices(a, b) {
        let ae = a.elements
            , be = b.elements
            , te = this.elements;
        if (window.NativeUtils && NativeUtils.multiplyMatrices)
            NativeUtils.multiplyMatrices(ae, be, te);
        else {
            let a11 = ae[0]
                , a12 = ae[4]
                , a13 = ae[8]
                , a14 = ae[12]
                , a21 = ae[1]
                , a22 = ae[5]
                , a23 = ae[9]
                , a24 = ae[13]
                , a31 = ae[2]
                , a32 = ae[6]
                , a33 = ae[10]
                , a34 = ae[14]
                , a41 = ae[3]
                , a42 = ae[7]
                , a43 = ae[11]
                , a44 = ae[15]
                , b11 = be[0]
                , b12 = be[4]
                , b13 = be[8]
                , b14 = be[12]
                , b21 = be[1]
                , b22 = be[5]
                , b23 = be[9]
                , b24 = be[13]
                , b31 = be[2]
                , b32 = be[6]
                , b33 = be[10]
                , b34 = be[14]
                , b41 = be[3]
                , b42 = be[7]
                , b43 = be[11]
                , b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41,
                te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42,
                te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43,
                te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44,
                te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41,
                te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42,
                te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43,
                te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44,
                te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41,
                te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42,
                te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43,
                te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44,
                te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41,
                te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42,
                te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43,
                te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44
        }
        return this
    }
    multiplyScalar(s) {
        let te = this.elements;
        return te[0] *= s,
            te[4] *= s,
            te[8] *= s,
            te[12] *= s,
            te[1] *= s,
            te[5] *= s,
            te[9] *= s,
            te[13] *= s,
            te[2] *= s,
            te[6] *= s,
            te[10] *= s,
            te[14] *= s,
            te[3] *= s,
            te[7] *= s,
            te[11] *= s,
            te[15] *= s,
            this
    }
    determinant() {
        let te = this.elements
            , n11 = te[0]
            , n12 = te[4]
            , n13 = te[8]
            , n14 = te[12]
            , n21 = te[1]
            , n22 = te[5]
            , n23 = te[9]
            , n24 = te[13]
            , n31 = te[2]
            , n32 = te[6]
            , n33 = te[10]
            , n34 = te[14];
        return te[3] * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + te[7] * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + te[11] * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + te[15] * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31)
    }
    transpose() {
        let tmp, te = this.elements;
        return tmp = te[1],
            te[1] = te[4],
            te[4] = tmp,
            tmp = te[2],
            te[2] = te[8],
            te[8] = tmp,
            tmp = te[6],
            te[6] = te[9],
            te[9] = tmp,
            tmp = te[3],
            te[3] = te[12],
            te[12] = tmp,
            tmp = te[7],
            te[7] = te[13],
            te[13] = tmp,
            tmp = te[11],
            te[11] = te[14],
            te[14] = tmp,
            this
    }
    setPosition(v) {
        let te = this.elements;
        return te[12] = v.x,
            te[13] = v.y,
            te[14] = v.z,
            this
    }
    getInverse(m, throwOnDegenerate) {
        let te = this.elements
            , me = m.elements
            , n11 = me[0]
            , n21 = me[1]
            , n31 = me[2]
            , n41 = me[3]
            , n12 = me[4]
            , n22 = me[5]
            , n32 = me[6]
            , n42 = me[7]
            , n13 = me[8]
            , n23 = me[9]
            , n33 = me[10]
            , n43 = me[11]
            , n14 = me[12]
            , n24 = me[13]
            , n34 = me[14]
            , n44 = me[15]
            , t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44
            , t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44
            , t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44
            , t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34
            , det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (0 === det) {
            let msg = ".getInverse() can't invert matrix, determinant is 0";
            if (!0 === throwOnDegenerate)
                throw new Error(msg);
            return this.identity()
        }
        let detInv = 1 / det;
        return te[0] = t11 * detInv,
            te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv,
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv,
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv,
            te[4] = t12 * detInv,
            te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv,
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv,
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv,
            te[8] = t13 * detInv,
            te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv,
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv,
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv,
            te[12] = t14 * detInv,
            te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv,
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv,
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv,
            this
    }
    scale(v) {
        let te = this.elements
            , x = v.x
            , y = v.y
            , z = v.z;
        return window.NativeUtils && NativeUtils.scaleMatrix ? NativeUtils.scaleMatrix(te, x, y, z) : (te[0] *= x,
            te[4] *= y,
            te[8] *= z,
            te[1] *= x,
            te[5] *= y,
            te[9] *= z,
            te[2] *= x,
            te[6] *= y,
            te[10] *= z,
            te[3] *= x,
            te[7] *= y,
            te[11] *= z),
            this
    }
    getMaxScaleOnAxis() {
        let te = this.elements;
        if (window.NativeUtils && NativeUtils.getMaxScaleOnAxis)
            return NativeUtils.getMaxScaleOnAxis(te);
        {
            let scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2]
                , scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6]
                , scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq))
        }
    }
    makeTranslation(x, y, z) {
        return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1),
            this
    }
    makeRotationX(theta) {
        let c = Math.cos(theta)
            , s = Math.sin(theta);
        return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1),
            this
    }
    makeRotationY(theta) {
        let c = Math.cos(theta)
            , s = Math.sin(theta);
        return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1),
            this
    }
    makeRotationZ(theta) {
        let c = Math.cos(theta)
            , s = Math.sin(theta);
        return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
    }
    makeRotationAxis(axis, angle) {
        let c = Math.cos(angle)
            , s = Math.sin(angle)
            , t = 1 - c
            , x = axis.x
            , y = axis.y
            , z = axis.z
            , tx = t * x
            , ty = t * y;
        return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1),
            this
    }
    makeScale(x, y, z) {
        return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1),
            this
    }
    makeShear(x, y, z) {
        return this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1),
            this
    }
    compose(position, quaternion, scale) {
        return this.makeRotationFromQuaternion(quaternion),
            this.scale(scale),
            this.setPosition(position),
            this
    }
    decompose(position, quaternion, scale) {
        let vector = this.V1 || new Vector3;
        this.V1 = vector;
        let matrix = this.M1 || new Matrix4;
        this.M1 = matrix;
        let te = this.elements
            , sx = vector.set(te[0], te[1], te[2]).length()
            , sy = vector.set(te[4], te[5], te[6]).length()
            , sz = vector.set(te[8], te[9], te[10]).length();
        this.determinant() < 0 && (sx = -sx),
            position.x = te[12],
            position.y = te[13],
            position.z = te[14],
            matrix.copy(this);
        let invSX = 1 / sx
            , invSY = 1 / sy
            , invSZ = 1 / sz;
        return matrix.elements[0] *= invSX,
            matrix.elements[1] *= invSX,
            matrix.elements[2] *= invSX,
            matrix.elements[4] *= invSY,
            matrix.elements[5] *= invSY,
            matrix.elements[6] *= invSY,
            matrix.elements[8] *= invSZ,
            matrix.elements[9] *= invSZ,
            matrix.elements[10] *= invSZ,
            quaternion.setFromRotationMatrix(matrix),
            scale.x = sx,
            scale.y = sy,
            scale.z = sz,
            this
    }
    makePerspective(left, right, top, bottom, near, far) {
        let te = this.elements
            , x = 2 * near / (right - left)
            , y = 2 * near / (top - bottom)
            , a = (right + left) / (right - left)
            , b = (top + bottom) / (top - bottom)
            , c = -(far + near) / (far - near)
            , d = -2 * far * near / (far - near);
        return te[0] = x,
            te[4] = 0,
            te[8] = a,
            te[12] = 0,
            te[1] = 0,
            te[5] = y,
            te[9] = b,
            te[13] = 0,
            te[2] = 0,
            te[6] = 0,
            te[10] = c,
            te[14] = d,
            te[3] = 0,
            te[7] = 0,
            te[11] = -1,
            te[15] = 0,
            this
    }
    makeOrthographic(left, right, top, bottom, near, far) {
        let te = this.elements
            , w = 1 / (right - left)
            , h = 1 / (top - bottom)
            , p = 1 / (far - near)
            , x = (right + left) * w
            , y = (top + bottom) * h
            , z = (far + near) * p;
        return te[0] = 2 * w,
            te[4] = 0,
            te[8] = 0,
            te[12] = -x,
            te[1] = 0,
            te[5] = 2 * h,
            te[9] = 0,
            te[13] = -y,
            te[2] = 0,
            te[6] = 0,
            te[10] = -2 * p,
            te[14] = -z,
            te[3] = 0,
            te[7] = 0,
            te[11] = 0,
            te[15] = 1,
            this
    }
    equals(matrix) {
        let te = this.elements
            , me = matrix.elements;
        if (window.NativeUtils && NativeUtils.arrayEquals)
            return NativeUtils.arrayEquals(te, me);
        for (let i = 0; i < 16; i++)
            if (te[i] !== me[i])
                return !1;
        return !0
    }
    fromArray(array, offset) {
        void 0 === offset && (offset = 0);
        for (let i = 0; i < 16; i++)
            this.elements[i] = array[i + offset];
        return this
    }
    toArray(array, offset) {
        void 0 === array && (array = []),
        void 0 === offset && (offset = 0);
        let te = this.elements;
        return array[offset] = te[0],
            array[offset + 1] = te[1],
            array[offset + 2] = te[2],
            array[offset + 3] = te[3],
            array[offset + 4] = te[4],
            array[offset + 5] = te[5],
            array[offset + 6] = te[6],
            array[offset + 7] = te[7],
            array[offset + 8] = te[8],
            array[offset + 9] = te[9],
            array[offset + 10] = te[10],
            array[offset + 11] = te[11],
            array[offset + 12] = te[12],
            array[offset + 13] = te[13],
            array[offset + 14] = te[14],
            array[offset + 15] = te[15],
            array
    }
    applyToBufferAttribute(attribute) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1;
        for (let i = 0, l = attribute.count; i < l; i++)
            v1.x = attribute.array[3 * i + 0],
                v1.y = attribute.array[3 * i + 1],
                v1.z = attribute.array[3 * i + 2],
                v1.applyMatrix4(this),
                attribute.array[3 * i + 0] = v1.x,
                attribute.array[3 * i + 1] = v1.y,
                attribute.array[3 * i + 2] = v1.z;
        return attribute
    }
    isIdentity() {
        return this.equals(Matrix4.__IDENTITY__)
    }
}
Matrix4.__IDENTITY__ = new Matrix4;
class Plane {
    constructor(normal, constant) {
        this.normal = void 0 !== normal ? normal : new Vector3(1,0,0),
            this.constant = void 0 !== constant ? constant : 0
    }
    set(normal, constant) {
        return this.normal.copy(normal),
            this.constant = constant,
            this
    }
    setComponents(x, y, z, w) {
        return this.normal.set(x, y, z),
            this.constant = w,
            this
    }
    setFromNormalAndCoplanarPoint(normal, point) {
        return this.normal.copy(normal),
            this.constant = -point.dot(this.normal),
            this
    }
    setFromCoplanarPoints(a, b, c) {
        let v1 = this.V1 || new Vector3
            , v2 = this.V2 || new Vector3;
        this.V1 = v1,
            this.V2 = v2;
        var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
        return this.setFromNormalAndCoplanarPoint(normal, a),
            this
    }
    clone() {
        return (new Plane).copy(this)
    }
    copy(plane) {
        return this.normal.copy(plane.normal),
            this.constant = plane.constant,
            this
    }
    normalize() {
        var inverseNormalLength = 1 / this.normal.length();
        return this.normal.multiplyScalar(inverseNormalLength),
            this.constant *= inverseNormalLength,
            this
    }
    negate() {
        return this.constant *= -1,
            this.normal.negate(),
            this
    }
    distanceToPoint(point) {
        return this.normal.dot(point) + this.constant
    }
    distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius
    }
    projectPoint(point, target) {
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point)
    }
    intersectLine(line, target) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1;
        var direction = line.delta(v1)
            , denominator = this.normal.dot(direction);
        if (0 === denominator)
            return 0 === this.distanceToPoint(line.start) ? target.copy(line.start) : void 0;
        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
        return t < 0 || t > 1 ? void 0 : target.copy(direction).multiplyScalar(t).add(line.start)
    }
    intersectsLine(line) {
        var startSign = this.distanceToPoint(line.start)
            , endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0
    }
    intersectsBox(box) {
        return box.intersectsPlane(this)
    }
    intersectsSphere(sphere) {
        return sphere.intersectsPlane(this)
    }
    coplanarPoint(target) {
        return target.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1;
        let m1 = this.M1 || new Matrix3;
        this.M1 = m1;
        var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix)
            , referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix)
            , normal = this.normal.applyMatrix3(normalMatrix).normalize();
        return this.constant = -referencePoint.dot(normal),
            this
    }
    translate(offset) {
        return this.constant -= offset.dot(this.normal),
            this
    }
    equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant
    }
}
class Quaternion {
    constructor(x, y, z, w) {
        this._x = x || 0,
            this._y = y || 0,
            this._z = z || 0,
            this._w = void 0 !== w ? w : 1
    }
    set x(v) {
        this._x = v,
        this.onChangeCallback && this.onChangeCallback()
    }
    get x() {
        return this._x
    }
    set y(v) {
        this._y = v,
        this.onChangeCallback && this.onChangeCallback()
    }
    get y() {
        return this._y
    }
    set z(v) {
        this._z = v,
        this.onChangeCallback && this.onChangeCallback()
    }
    get z() {
        return this._z
    }
    set w(v) {
        this._w = v,
        this.onChangeCallback && this.onChangeCallback()
    }
    get w() {
        return this._w
    }
    clone() {
        return new Quaternion(this._x,this._y,this._z,this._w)
    }
    copy(quaternion) {
        return this._x = quaternion.x,
            this._y = quaternion.y,
            this._z = quaternion.z,
            this._w = quaternion.w,
            this.onChangeCallback(),
            this
    }
    set(x, y, z, w) {
        this._x = x,
            this._y = y,
            this._z = z,
            this._w = w,
            this.onChangeCallback()
    }
    setFromEuler(euler, update) {
        let x = euler._x
            , y = euler._y
            , z = euler._z
            , order = euler.order
            , cos = Math.cos
            , sin = Math.sin
            , c1 = cos(x / 2)
            , c2 = cos(y / 2)
            , c3 = cos(z / 2)
            , s1 = sin(x / 2)
            , s2 = sin(y / 2)
            , s3 = sin(z / 2);
        return "XYZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3,
            this._y = c1 * s2 * c3 - s1 * c2 * s3,
            this._z = c1 * c2 * s3 + s1 * s2 * c3,
            this._w = c1 * c2 * c3 - s1 * s2 * s3) : "YXZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3,
            this._y = c1 * s2 * c3 - s1 * c2 * s3,
            this._z = c1 * c2 * s3 - s1 * s2 * c3,
            this._w = c1 * c2 * c3 + s1 * s2 * s3) : "ZXY" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3,
            this._y = c1 * s2 * c3 + s1 * c2 * s3,
            this._z = c1 * c2 * s3 + s1 * s2 * c3,
            this._w = c1 * c2 * c3 - s1 * s2 * s3) : "ZYX" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3,
            this._y = c1 * s2 * c3 + s1 * c2 * s3,
            this._z = c1 * c2 * s3 - s1 * s2 * c3,
            this._w = c1 * c2 * c3 + s1 * s2 * s3) : "YZX" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3,
            this._y = c1 * s2 * c3 + s1 * c2 * s3,
            this._z = c1 * c2 * s3 - s1 * s2 * c3,
            this._w = c1 * c2 * c3 - s1 * s2 * s3) : "XZY" === order && (this._x = s1 * c2 * c3 - c1 * s2 * s3,
            this._y = c1 * s2 * c3 - s1 * c2 * s3,
            this._z = c1 * c2 * s3 + s1 * s2 * c3,
            this._w = c1 * c2 * c3 + s1 * s2 * s3),
        !1 !== update && this.onChangeCallback(),
            this
    }
    setFromAxisAngle(axis, angle) {
        let halfAngle = angle / 2
            , s = Math.sin(halfAngle);
        return this._x = axis.x * s,
            this._y = axis.y * s,
            this._z = axis.z * s,
            this._w = Math.cos(halfAngle),
            this.onChangeCallback(),
            this
    }
    setFromRotationMatrix(m) {
        let s, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        return trace > 0 ? (s = .5 / Math.sqrt(trace + 1),
            this._w = .25 / s,
            this._x = (m32 - m23) * s,
            this._y = (m13 - m31) * s,
            this._z = (m21 - m12) * s) : m11 > m22 && m11 > m33 ? (s = 2 * Math.sqrt(1 + m11 - m22 - m33),
            this._w = (m32 - m23) / s,
            this._x = .25 * s,
            this._y = (m12 + m21) / s,
            this._z = (m13 + m31) / s) : m22 > m33 ? (s = 2 * Math.sqrt(1 + m22 - m11 - m33),
            this._w = (m13 - m31) / s,
            this._x = (m12 + m21) / s,
            this._y = .25 * s,
            this._z = (m23 + m32) / s) : (s = 2 * Math.sqrt(1 + m33 - m11 - m22),
            this._w = (m21 - m12) / s,
            this._x = (m13 + m31) / s,
            this._y = (m23 + m32) / s,
            this._z = .25 * s),
            this.onChangeCallback(),
            this
    }
    setFromUnitVectors(vFrom, vTo) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1;
        let r = vFrom.dot(vTo) + 1;
        return r < 1e-6 ? (r = 0,
            Math.abs(vFrom.x) > Math.abs(vFrom.z) ? v1.set(-vFrom.y, vFrom.x, 0) : v1.set(0, -vFrom.z, vFrom.y)) : v1.crossVectors(vFrom, vTo),
            this._x = v1.x,
            this._y = v1.y,
            this._z = v1.z,
            this._w = r,
            this.normalize()
    }
    inverse() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this.onChangeCallback(),
            this
    }
    dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let l = this.length();
        return 0 === l ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (l = 1 / l,
            this._x = this._x * l,
            this._y = this._y * l,
            this._z = this._z * l,
            this._w = this._w * l),
            this.onChangeCallback(),
            this
    }
    multiply(q) {
        return this.multiplyQuaternions(this, q)
    }
    premultiply(q) {
        return this.multiplyQuaternions(q, this)
    }
    multiplyQuaternions(a, b) {
        let qax = a._x
            , qay = a._y
            , qaz = a._z
            , qaw = a._w
            , qbx = b._x
            , qby = b._y
            , qbz = b._z
            , qbw = b._w;
        return this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby,
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz,
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx,
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz,
            this.onChangeCallback(),
            this
    }
    slerp(qb, t) {
        if (0 === t)
            return this;
        if (1 === t)
            return this.copy(qb);
        let x = this._x
            , y = this._y
            , z = this._z
            , w = this._w
            , cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0 ? (this._w = -qb._w,
            this._x = -qb._x,
            this._y = -qb._y,
            this._z = -qb._z,
            cosHalfTheta = -cosHalfTheta) : this.copy(qb),
        cosHalfTheta >= 1)
            return this._w = w,
                this._x = x,
                this._y = y,
                this._z = z,
                this;
        let sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
        if (Math.abs(sinHalfTheta) < .001)
            return this._w = .5 * (w + this._w),
                this._x = .5 * (x + this._x),
                this._y = .5 * (y + this._y),
                this._z = .5 * (z + this._z),
                this;
        let halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta)
            , ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta
            , ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        return this._w = w * ratioA + this._w * ratioB,
            this._x = x * ratioA + this._x * ratioB,
            this._y = y * ratioA + this._y * ratioB,
            this._z = z * ratioA + this._z * ratioB,
            this.onChangeCallback(),
            this
    }
    equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w
    }
    fromArray(array, offset) {
        return void 0 === offset && (offset = 0),
            this._x = array[offset],
            this._y = array[offset + 1],
            this._z = array[offset + 2],
            this._w = array[offset + 3],
            this.onChangeCallback(),
            this
    }
    toArray(array, offset) {
        return void 0 === array && (array = []),
        void 0 === offset && (offset = 0),
            array[offset] = this._x,
            array[offset + 1] = this._y,
            array[offset + 2] = this._z,
            array[offset + 3] = this._w,
            array
    }
    onChange(callback) {
        this.onChangeCallback = callback
    }
    onChangeCallback() {}
}
class RayManager {
    constructor(origin, direction, near=0, far=1 / 0) {
        this.ray = new Ray(origin,direction),
            this.near = near,
            this.far = far,
            this.params = {
                Mesh: {},
                Points: {
                    threshold: 1
                }
            }
    }
    set(origin, direction) {
        return this.ray.set(origin, direction),
            this
    }
    setFromCamera(coords, camera) {
        camera.isPerspective ? (this.ray.origin.setFromMatrixPosition(camera.matrixWorld),
            this.ray.direction.set(coords.x, coords.y, .5).unproject(camera).sub(this.ray.origin).normalize()) : (this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera),
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld))
    }
    _ascSort(a, b) {
        return a.distance - b.distance
    }
    _intersectObject(object, raycaster, intersects, recursive) {
        if (!1 !== object.visible && (object.raycast(raycaster, intersects),
        !0 === recursive)) {
            let children = object.children;
            for (let i = 0, l = children.length; i < l; i++)
                this._intersectObject(children[i], raycaster, intersects, !0)
        }
    }
    intersectObject(object, recursive, optionalTarget) {
        let intersects = optionalTarget || [];
        return this._intersectObject(object, this, intersects, recursive),
            intersects.sort(this._ascSort),
            intersects
    }
    intersectObjects(objects, recursive, optionalTarget) {
        let intersects = optionalTarget || [];
        for (let i = 0, l = objects.length; i < l; i++)
            this._intersectObject(objects[i], this, intersects, recursive);
        return intersects.sort(this._ascSort),
            intersects
    }
}
class Ray {
    constructor(origin=new Vector3, direction=new Vector3) {
        this.origin = origin,
            this.direction = direction
    }
    set(origin, direction) {
        return this.origin.copy(origin),
            this.direction.copy(direction),
            this
    }
    clone() {
        return (new Ray).copy(this)
    }
    copy(ray) {
        return this.origin.copy(ray.origin),
            this.direction.copy(ray.direction),
            this
    }
    at(t, target=new Vector3) {
        return target.copy(this.direction).multiplyScalar(t).add(this.origin)
    }
    lookAt(v) {
        return this.direction.copy(v).sub(this.origin).normalize(),
            this
    }
    recast(t) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1,
            this.origin.copy(this.at(t, v1))
    }
    closestPointToPoint(point, target=new Vector3) {
        target.subVectors(point, this.origin);
        let directionDistance = target.dot(this.direction);
        return directionDistance < 0 ? target.copy(this.origin) : target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin)
    }
    distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point))
    }
    distanceSqToPoint(point) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1;
        let directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
        return directionDistance < 0 ? this.origin.distanceToSquared(point) : (v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin),
            v1.distanceToSquared(point))
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        let segCenter = this.V1 || new Vector3
            , segDir = this.V2 || new Vector3
            , diff = this.V3 || new Vector3;
        this.V1 = segCenter,
            this.V2 = segDir,
            this.V3 = diff,
            segCenter.copy(v0).add(v1).multiplyScalar(.5),
            segDir.copy(v1).sub(v0).normalize(),
            diff.copy(this.origin).sub(segCenter);
        let s0, s1, sqrDist, extDet, segExtent = .5 * v0.distanceTo(v1), a01 = -this.direction.dot(segDir), b0 = diff.dot(this.direction), b1 = -diff.dot(segDir), c = diff.lengthSq(), det = Math.abs(1 - a01 * a01);
        if (det > 0)
            if (s0 = a01 * b1 - b0,
                s1 = a01 * b0 - b1,
                extDet = segExtent * det,
            s0 >= 0)
                if (s1 >= -extDet)
                    if (s1 <= extDet) {
                        let invDet = 1 / det;
                        s0 *= invDet,
                            s1 *= invDet,
                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c
                    } else
                        s1 = segExtent,
                            s0 = Math.max(0, -(a01 * s1 + b0)),
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                else
                    s1 = -segExtent,
                        s0 = Math.max(0, -(a01 * s1 + b0)),
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            else
                s1 <= -extDet ? (s0 = Math.max(0, -(-a01 * segExtent + b0)),
                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent),
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c) : s1 <= extDet ? (s0 = 0,
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent),
                    sqrDist = s1 * (s1 + 2 * b1) + c) : (s0 = Math.max(0, -(a01 * segExtent + b0)),
                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent),
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c);
        else
            s1 = a01 > 0 ? -segExtent : segExtent,
                s0 = Math.max(0, -(a01 * s1 + b0)),
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        return optionalPointOnRay && optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin),
        optionalPointOnSegment && optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter),
            sqrDist
    }
    intersectSphere(sphere, target) {
        let v1 = this.V1 || new Vector3;
        this.V1 = v1,
            v1.subVectors(sphere.center, this.origin);
        let tca = v1.dot(this.direction)
            , d2 = v1.dot(v1) - tca * tca
            , radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
            return null;
        let thc = Math.sqrt(radius2 - d2)
            , t0 = tca - thc
            , t1 = tca + thc;
        return t0 < 0 && t1 < 0 ? null : t0 < 0 ? this.at(t1, target) : this.at(t0, target)
    }
    intersectsSphere(sphere) {
        return this.distanceToPoint(sphere.center) <= sphere.radius
    }
    distanceToPlane(plane) {
        let denominator = plane.normal.dot(this.direction);
        if (0 === denominator)
            return 0 === plane.distanceToPoint(this.origin) ? 0 : null;
        let t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null
    }
    intersectPlane(plane, target) {
        let t = this.distanceToPlane(plane);
        return null === t ? null : this.at(t, target)
    }
    intersectsPlane(plane) {
        let distToPoint = plane.distanceToPoint(this.origin);
        return 0 === distToPoint || plane.normal.dot(this.direction) * distToPoint < 0
    }
    intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax, invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z, origin = this.origin;
        return invdirx >= 0 ? (tmin = (box.min.x - origin.x) * invdirx,
            tmax = (box.max.x - origin.x) * invdirx) : (tmin = (box.max.x - origin.x) * invdirx,
            tmax = (box.min.x - origin.x) * invdirx),
            invdiry >= 0 ? (tymin = (box.min.y - origin.y) * invdiry,
                tymax = (box.max.y - origin.y) * invdiry) : (tymin = (box.max.y - origin.y) * invdiry,
                tymax = (box.min.y - origin.y) * invdiry),
            tmin > tymax || tymin > tmax ? null : ((tymin > tmin || tmin != tmin) && (tmin = tymin),
            (tymax < tmax || tmax != tmax) && (tmax = tymax),
                invdirz >= 0 ? (tzmin = (box.min.z - origin.z) * invdirz,
                    tzmax = (box.max.z - origin.z) * invdirz) : (tzmin = (box.max.z - origin.z) * invdirz,
                    tzmax = (box.min.z - origin.z) * invdirz),
                tmin > tzmax || tzmin > tmax ? null : ((tzmin > tmin || tmin != tmin) && (tmin = tzmin),
                (tzmax < tmax || tmax != tmax) && (tmax = tzmax),
                    tmax < 0 ? null : this.at(tmin >= 0 ? tmin : tmax, target)))
    }
    intersectsBox(box) {
        let v = this.V1 || new Vector3;
        return this.V1 = v,
        null !== this.intersectBox(box, v)
    }
    intersectsTriangle(a, b, c, backfaceCulling, target) {
        let diff = this.V1 || new Vector3
            , edge1 = this.V2 || new Vector3
            , edge2 = this.V3 || new Vector3
            , normal = this.V4 || new Vector3;
        this.V1 = diff,
            this.V2 = edge1,
            this.V3 = edge2,
            this.V4 = normal,
            edge1.subVectors(b, a),
            edge2.subVectors(c, a),
            normal.crossVectors(edge1, edge2);
        let sign, DdN = this.direction.dot(normal);
        if (DdN > 0) {
            if (backfaceCulling)
                return null;
            sign = 1
        } else {
            if (!(DdN < 0))
                return null;
            sign = -1,
                DdN = -DdN
        }
        diff.subVectors(this.origin, a);
        let DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
        if (DdQxE2 < 0)
            return null;
        let DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
        if (DdE1xQ < 0)
            return null;
        if (DdQxE2 + DdE1xQ > DdN)
            return null;
        let QdN = -sign * diff.dot(normal);
        return QdN < 0 ? null : this.at(QdN / DdN, target)
    }
    applyMatrix4(matrix4) {
        return this.origin.applyMatrix4(matrix4),
            this.direction.transformDirection(matrix4),
            this
    }
    equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
    }
}
class Sphere {
    constructor(center=new Vector3, radius=0) {
        this.center = center,
            this.radius = radius
    }
    set(center, radius) {
        return this.center.copy(center),
            this.radius = radius,
            this
    }
    setFromPoints(points, optionalCenter) {
        let box = this.V1 || new Box3;
        this.V1 = box;
        let center = this.center;
        void 0 !== optionalCenter ? center.copy(optionalCenter) : box.setFromPoints(points).getCenter(center);
        let maxRadiusSq = 0;
        for (let i = 0, il = points.length; i < il; i++)
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
        return this.radius = Math.sqrt(maxRadiusSq),
            this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(sphere) {
        return this.center.copy(sphere.center),
            this.radius = sphere.radius,
            this
    }
    empty() {
        return this.radius <= 0
    }
    containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius
    }
    intersectsSphere(sphere) {
        let radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
    }
    intersectsBox(box) {
        return box.intersectsSphere(this)
    }
    intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(point, target=new Vector3) {
        let deltaLengthSq = this.center.distanceToSquared(point);
        return target.copy(point),
        deltaLengthSq > this.radius * this.radius && (target.sub(this.center).normalize(),
            target.multiplyScalar(this.radius).add(this.center)),
            target
    }
    getBoundingBox(target=new Box3) {
        return target.set(this.center, this.center),
            target.expandByScalar(this.radius),
            target
    }
    applyMatrix4(matrix) {
        return this.center.applyMatrix4(matrix),
            this.radius = this.radius * matrix.getMaxScaleOnAxis(),
            this
    }
    translate(offset) {
        return this.center.add(offset),
            this
    }
    equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius
    }
}
class Spherical {
    constructor(radius=1, phi=0, theta=0) {
        this.radius = radius,
            this.phi = phi,
            this.theta = theta
    }
    set(radius, phi, theta) {
        return this.radius = radius,
            this.phi = phi,
            this.theta = theta,
            this
    }
    clone() {
        return (new Spherical).copy(this)
    }
    copy(other) {
        return this.radius = other.radius,
            this.phi = other.phi,
            this.theta = other.theta,
            this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
    }
    setFromVector3(vec3) {
        return this.radius = vec3.length(),
            0 === this.radius ? (this.theta = 0,
                this.phi = 0) : (this.theta = Math.atan2(vec3.x, vec3.z),
                this.phi = Math.acos(Math.clamp(vec3.y / this.radius, -1, 1))),
            this
    }
}
class Triangle {
    constructor(a=new Vector3, b=new Vector3, c=new Vector3) {
        this.a = a,
            this.b = b,
            this.c = c
    }
    set(a, b, c) {
        return this.a.copy(a),
            this.b.copy(b),
            this.c.copy(c),
            this
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
        return this.a.copy(points[i0]),
            this.b.copy(points[i1]),
            this.c.copy(points[i2]),
            this
    }
    clone() {
        return (new Triangle).copy(this)
    }
    copy(triangle) {
        return this.a.copy(triangle.a),
            this.b.copy(triangle.b),
            this.c.copy(triangle.c),
            this
    }
    getArea() {
        let v0 = this.V0 || new Vector3
            , v1 = this.V1 || new Vector3;
        return this.V0 = v0,
            this.V1 = v1,
            v0.subVectors(this.c, this.b),
            v1.subVectors(this.a, this.b),
        .5 * v0.cross(v1).length()
    }
    getMidpoint(target=new Vector3) {
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target)
    }
    getPlane(target=new Vector3) {
        return target.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target)
    }
    containsPoint(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c)
    }
    intersectsBox(box) {
        return box.intersectsTriangle(this)
    }
    equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c)
    }
}
class Vector2 {
    constructor(x=0, y=0) {
        this.x = x,
            this.y = y
    }
    set(x, y) {
        return this.x = x,
            this.y = y,
            this
    }
    get width() {
        return this.x
    }
    get height() {
        return this.y
    }
    setScalar(s) {
        return this.x = this.y = s,
            this
    }
    clone() {
        return new Vector2(this.x,this.y)
    }
    copy(v) {
        return this.x = v.x,
            this.y = v.y,
            this
    }
    add(v) {
        return this.x += v.x,
            this.y += v.y,
            this
    }
    addScalar(s) {
        return this.x += s,
            this.y += s,
            this
    }
    addVectors(a, b) {
        return this.x = a.x + b.x,
            this.y = a.y + b.y,
            this
    }
    addScaledVector(v, s) {
        return this.x += v.x * s,
            this.y += v.y * s,
            this
    }
    sub(v) {
        return this.x -= v.x,
            this.y -= v.y,
            this
    }
    subScalar(s) {
        return this.x -= s,
            this.y -= s,
            this
    }
    subVectors(a, b) {
        return this.x = a.x - b.x,
            this.y = a.y - b.y,
            this
    }
    multiply(v) {
        return this.x *= v.x,
            this.y *= v.y,
            this
    }
    multiplyScalar(scalar) {
        return this.x *= scalar,
            this.y *= scalar,
            this
    }
    divide(v) {
        return this.x /= v.x,
            this.y /= v.y,
            this
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar)
    }
    applyMatrix3(m) {
        let x = this.x
            , y = this.y
            , e = m.elements;
        return this.x = e[0] * x + e[3] * y + e[6],
            this.y = e[1] * x + e[4] * y + e[7],
            this
    }
    min(v) {
        return this.x = Math.min(this.x, v.x),
            this.y = Math.min(this.y, v.y),
            this
    }
    max(v) {
        return this.x = Math.max(this.x, v.x),
            this.y = Math.max(this.y, v.y),
            this
    }
    clamp(min, max) {
        return this.x = Math.max(min.x, Math.min(max.x, this.x)),
            this.y = Math.max(min.y, Math.min(max.y, this.y)),
            this
    }
    clampScalar(minVal, maxVal) {
        let min = new Vector2
            , max = new Vector2;
        return min.set(minVal, minVal),
            max.set(maxVal, maxVal),
            this.clamp(min, max)
    }
    clampLength(min, max) {
        let length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
    }
    floor() {
        return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
    }
    round() {
        return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
    }
    negate() {
        return this.x = -this.x,
            this.y = -this.y,
            this
    }
    dot(v) {
        return this.x * v.x + this.y * v.y
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        let angle = Math.atan2(this.y, this.x);
        return angle < 0 && (angle += 2 * Math.PI),
            angle
    }
    angleTo(a, b) {
        return b || (b = this),
            Math.atan2(a.y - b.y, a.x - b.x)
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v))
    }
    distanceToSquared(v) {
        let dx = this.x - v.x
            , dy = this.y - v.y;
        return dx * dx + dy * dy
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y)
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length)
    }
    lerp(v, alpha) {
        return this.x = Math.lerp(v.x, this.x, alpha),
            this.y = Math.lerp(v.y, this.y, alpha),
            this
    }
    lerpVectors(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
    }
    equals(v) {
        return v.x === this.x && v.y === this.y
    }
    setAngleRadius(a, r) {
        return this.x = Math.cos(a) * r,
            this.y = Math.sin(a) * r,
            this
    }
    addAngleRadius(a, r) {
        return this.x += Math.cos(a) * r,
            this.y += Math.sin(a) * r,
            this
    }
    fromArray(array, offset) {
        return void 0 === offset && (offset = 0),
            this.x = array[offset],
            this.y = array[offset + 1],
            this
    }
    toArray(array, offset) {
        return void 0 === array && (array = []),
        void 0 === offset && (offset = 0),
            array[offset] = this.x,
            array[offset + 1] = this.y,
            array
    }
    rotateAround(center, angle) {
        let c = Math.cos(angle)
            , s = Math.sin(angle)
            , x = this.x - center.x
            , y = this.y - center.y;
        return this.x = x * c - y * s + center.x,
            this.y = x * s + y * c + center.y,
            this
    }
    fromBufferAttribute(attribute, index) {
        this.x = attribute.array[2 * index + 0],
            this.y = attribute.array[2 * index + 1]
    }
}
class Vector3 {
    constructor(x, y, z) {
        this.x = x || 0,
            this.y = y || 0,
            this.z = z || 0
    }
    set(x, y, z) {
        return this.x = x || 0,
            this.y = y || 0,
            this.z = z || 0,
            this
    }
    setScalar(scalar) {
        return this.x = scalar,
            this.y = scalar,
            this.z = scalar,
            this
    }
    clone() {
        return new Vector3(this.x,this.y,this.z)
    }
    copy(v) {
        return this.x = v.x,
            this.y = v.y,
            this.z = v.z,
            this
    }
    add(v) {
        return this.x += v.x,
            this.y += v.y,
            this.z += v.z,
            this
    }
    addScalar(s) {
        return this.x += s,
            this.y += s,
            this.z += s,
            this
    }
    addVectors(a, b) {
        return this.x = a.x + b.x,
            this.y = a.y + b.y,
            this.z = a.z + b.z,
            this
    }
    addScaledVector(v) {
        return this.x += v.x * s,
            this.y += v.y * s,
            this.z += v.z * s,
            this
    }
    sub(v) {
        return this.x -= v.x,
            this.y -= v.y,
            this.z -= v.z,
            this
    }
    subScalar(s) {
        return this.x -= s,
            this.y -= s,
            this.z -= s,
            this
    }
    subVectors(a, b) {
        return this.x = a.x - b.x,
            this.y = a.y - b.y,
            this.z = a.z - b.z,
            this
    }
    multiply(v) {
        return this.x *= v.x,
            this.y *= v.y,
            this.z *= v.z,
            this
    }
    multiplyScalar(scalar) {
        return this.x *= scalar,
            this.y *= scalar,
            this.z *= scalar,
            this
    }
    multiplyVectors(a, b) {
        return this.x = a.x * b.x,
            this.y = a.y * b.y,
            this.z = a.z * b.z,
            this
    }
    applyEuler(euler) {
        let quaternion = this.Q1 || new Quaternion;
        return this.Q1 = quaternion,
            this.applyQuaternion(quaternion.setFromEuler(euler))
    }
    applyAxisAngle(axis, angle) {
        let quaternion = this.Q1 || new Quaternion;
        return this.Q1 = quaternion,
            this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))
    }
    applyMatrix3(m) {
        let x = this.x
            , y = this.y
            , z = this.z
            , e = m.elements;
        return this.x = e[0] * x + e[3] * y + e[6] * z,
            this.y = e[1] * x + e[4] * y + e[7] * z,
            this.z = e[2] * x + e[5] * y + e[8] * z,
            this
    }
    applyMatrix4(m) {
        let x = this.x
            , y = this.y
            , z = this.z
            , e = m.elements
            , w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        return this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w,
            this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w,
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w,
            this
    }
    applyQuaternion(q) {
        let x = this.x
            , y = this.y
            , z = this.z
            , qx = q.x
            , qy = q.y
            , qz = q.z
            , qw = q.w
            , ix = qw * x + qy * z - qz * y
            , iy = qw * y + qz * x - qx * z
            , iz = qw * z + qx * y - qy * x
            , iw = -qx * x - qy * y - qz * z;
        return this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy,
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz,
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx,
            this
    }
    project(camera) {
        let matrix = this.M1 || new Matrix4;
        return this.M1 = matrix,
            matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld)),
            this.applyMatrix4(matrix)
    }
    unproject(camera) {
        let matrix = this.M1 || new Matrix4;
        return this.M1 = matrix,
            matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix)),
            this.applyMatrix4(matrix)
    }
    transformDirection(m) {
        let x = this.x
            , y = this.y
            , z = this.z
            , e = m.elements;
        return this.x = e[0] * x + e[4] * y + e[8] * z,
            this.y = e[1] * x + e[5] * y + e[9] * z,
            this.z = e[2] * x + e[6] * y + e[10] * z,
            this.normalize()
    }
    divide(v) {
        return this.x /= v.x,
            this.y /= v.y,
            this.z /= v.z,
            this
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar)
    }
    min(v) {
        return this.x = Math.min(this.x, v.x),
            this.y = Math.min(this.y, v.y),
            this.z = Math.min(this.z, v.z),
            this
    }
    max(v) {
        return this.x = Math.max(this.x, v.x),
            this.y = Math.max(this.y, v.y),
            this.z = Math.max(this.z, v.z),
            this
    }
    clamp(min, max) {
        return this.x = Math.max(min.x, Math.min(max.x, this.x)),
            this.y = Math.max(min.y, Math.min(max.y, this.y)),
            this.z = Math.max(min.z, Math.min(max.z, this.z)),
            this
    }
    clampScalar(minVal, maxVal) {
        let min = new Vector3
            , max = new Vector3;
        return min.set(minVal, minVal, minVal),
            max.set(maxVal, maxVal, maxVal),
            this.clamp(min, max)
    }
    clampLength(min, max) {
        let length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
    }
    floor() {
        return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
    }
    round() {
        return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
    }
    negate() {
        return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length)
    }
    lerp(v, alpha) {
        return this.x = Math.lerp(v.x, this.x, alpha),
            this.y = Math.lerp(v.y, this.y, alpha),
            this.z = Math.lerp(v.z, this.z, alpha),
            this
    }
    lerpVectors(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
    }
    cross(v) {
        return this.crossVectors(this, v)
    }
    crossVectors(a, b) {
        let ax = a.x
            , ay = a.y
            , az = a.z
            , bx = b.x
            , by = b.y
            , bz = b.z;
        return this.x = ay * bz - az * by,
            this.y = az * bx - ax * bz,
            this.z = ax * by - ay * bx,
            this
    }
    projectOnVector(vector) {
        let scalar = vector.dot(this) / vector.lengthSq();
        return this.copy(vector).multiplyScalar(scalar)
    }
    projectOnPlane(planeNormal) {
        let v1 = this.V1 || new Vector3;
        return this.V1 = v1,
            v1.copy(this).projectOnVector(planeNormal),
            this.sub(v1)
    }
    reflect(normal) {
        let v1 = this.V1 || new Vector3;
        return this.V1 = v1,
            this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))
    }
    angleTo(v) {
        let theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
        return Math.acos(Math.clamp(theta, -1, 1))
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v))
    }
    distanceToSquared(v) {
        let dx = this.x - v.x
            , dy = this.y - v.y
            , dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
    }
    setFromSpherical(s) {
        let sinPhiRadius = Math.sin(s.phi) * s.radius;
        return this.x = sinPhiRadius * Math.sin(s.theta),
            this.y = Math.cos(s.phi) * s.radius,
            this.z = sinPhiRadius * Math.cos(s.theta),
            this
    }
    setFromCylindrical(c) {
        return this.x = c.radius * Math.sin(c.theta),
            this.y = c.y,
            this.z = c.radius * Math.cos(c.theta),
            this
    }
    setFromMatrixPosition(m) {
        let e = m.elements;
        return this.x = e[12],
            this.y = e[13],
            this.z = e[14],
            this
    }
    setFromMatrixScale(m) {
        let sx = this.setFromMatrixColumn(m, 0).length()
            , sy = this.setFromMatrixColumn(m, 1).length()
            , sz = this.setFromMatrixColumn(m, 2).length();
        return this.x = sx,
            this.y = sy,
            this.z = sz,
            this
    }
    setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, 4 * index)
    }
    setAngleRadius(a, r, dir="xy") {
        return this[dir[0]] = Math.cos(a) * r,
            this[dir[1]] = Math.sin(a) * r,
            this
    }
    addAngleRadius(a, r, dir="xy") {
        return this[dir[0]] += Math.cos(a) * r,
            this[dir[1]] += Math.sin(a) * r,
            this
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z
    }
    fromArray(array, offset) {
        return void 0 === offset && (offset = 0),
            this.x = array[offset],
            this.y = array[offset + 1],
            this.z = array[offset + 2],
            this
    }
    toArray(array, offset) {
        return void 0 === array && (array = []),
        void 0 === offset && (offset = 0),
            array[offset] = this.x,
            array[offset + 1] = this.y,
            array[offset + 2] = this.z,
            array
    }
    fromBufferAttribute(attribute, index) {
        return this.x = attribute.array[3 * index + 0],
            this.y = attribute.array[3 * index + 1],
            this.z = attribute.array[3 * index + 2],
            this
    }
}
class Vector3D {
    constructor(x, y, z) {
        this._x = x || 0,
            this._y = y || 0,
            this._z = z || 0
    }
    get x() {
        return this._x
    }
    set x(v) {
        if (window.Hydra && Hydra.LOCAL && isNaN(v))
            return console.trace("Vector3D::NaN");
        Math.abs(this._x - v) > 1e-4 && this.onChangeCallback(),
            this._x = v
    }
    get y() {
        return this._y
    }
    set y(v) {
        if (window.Hydra && Hydra.LOCAL && isNaN(v))
            return console.trace("Vector3D::NaN");
        Math.abs(this._y - v) > 1e-4 && this.onChangeCallback(),
            this._y = v
    }
    get z() {
        return this._z
    }
    set z(v) {
        if (window.Hydra && Hydra.LOCAL && isNaN(v))
            return console.trace("Vector3D::NaN");
        Math.abs(this._z - v) > 1e-4 && this.onChangeCallback(),
            this._z = v
    }
    onChangeCallback() {}
    set(x, y, z) {
        return this._x = x || 0,
            this._y = y || 0,
            this._z = z || 0,
            this.onChangeCallback(),
            this
    }
    setScalar(scalar) {
        return this._x = scalar,
            this._y = scalar,
            this._z = scalar,
            this.onChangeCallback(),
            this
    }
    clone() {
        return new Vector3(this._x,this._y,this._z)
    }
    copy(v) {
        let dirty = Math.abs(this._x - v.x) > 1e-4 || Math.abs(this._y - v.y) > 1e-4 || Math.abs(this._z - v.z) > 1e-4;
        return this._x = v.x,
            this._y = v.y,
            this._z = v.z,
        dirty && this.onChangeCallback(),
            this
    }
    add(v) {
        return this._x += v.x,
            this._y += v.y,
            this._z += v.z,
            this.onChangeCallback(),
            this
    }
    addScalar(s) {
        return this._x += s,
            this._y += s,
            this._z += s,
            this.onChangeCallback(),
            this
    }
    addVectors(a, b) {
        return this._x = a.x + b.x,
            this._y = a.y + b.y,
            this._z = a.z + b.z,
            this.onChangeCallback(),
            this
    }
    addScaledVector(v) {
        return this._x += v.x * s,
            this._y += v.y * s,
            this._z += v.z * s,
            this.onChangeCallback(),
            this
    }
    sub(v) {
        return this._x -= v.x,
            this._y -= v.y,
            this._z -= v.z,
            this.onChangeCallback(),
            this
    }
    subScalar(s) {
        return this._x -= s,
            this._y -= s,
            this._z -= s,
            this.onChangeCallback(),
            this
    }
    subVectors(a, b) {
        return this._x = a.x - b.x,
            this._y = a.y - b.y,
            this._z = a.z - b.z,
            this.onChangeCallback(),
            this
    }
    multiply(v) {
        return this._x *= v.x,
            this._y *= v.y,
            this._z *= v.z,
            this.onChangeCallback(),
            this
    }
    multiplyScalar(scalar) {
        return this._x *= scalar,
            this._y *= scalar,
            this._z *= scalar,
            this.onChangeCallback(),
            this
    }
    multiplyVectors(a, b) {
        return this._x = a.x * b.x,
            this._y = a.y * b.y,
            this._z = a.z * b.z,
            this.onChangeCallback(),
            this
    }
    applyEuler(euler) {
        let quaternion = this.Q1 || new Quaternion;
        return this.Q1 = quaternion,
            this.applyQuaternion(quaternion.setFromEuler(euler))
    }
    applyAxisAngle(axis, angle) {
        let quaternion = this.Q1 || new Quaternion;
        return this.Q1 = quaternion,
            this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))
    }
    applyMatrix3(m) {
        let x = this._x
            , y = this._y
            , z = this._z
            , e = m.elements;
        return this._x = e[0] * x + e[3] * y + e[6] * z,
            this._y = e[1] * x + e[4] * y + e[7] * z,
            this._z = e[2] * x + e[5] * y + e[8] * z,
            this.onChangeCallback(),
            this
    }
    applyMatrix4(m) {
        let x = this._x
            , y = this._y
            , z = this._z
            , e = m.elements
            , w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        return this._x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w,
            this._y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w,
            this._z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w,
            this.onChangeCallback(),
            this
    }
    applyQuaternion(q) {
        let x = this._x
            , y = this._y
            , z = this._z
            , qx = q.x
            , qy = q.y
            , qz = q.z
            , qw = q.w
            , ix = qw * x + qy * z - qz * y
            , iy = qw * y + qz * x - qx * z
            , iz = qw * z + qx * y - qy * x
            , iw = -qx * x - qy * y - qz * z;
        return this._x = ix * qw + iw * -qx + iy * -qz - iz * -qy,
            this._y = iy * qw + iw * -qy + iz * -qx - ix * -qz,
            this._z = iz * qw + iw * -qz + ix * -qy - iy * -qx,
            this.onChangeCallback(),
            this
    }
    project(camera) {
        let matrix = this.M1 || new Matrix4;
        return this.M1 = matrix,
            matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld)),
            this.applyMatrix4(matrix)
    }
    unproject(camera) {
        let matrix = this.M1 || new Matrix4;
        return this.M1 = matrix,
            matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix)),
            this.applyMatrix4(matrix)
    }
    transformDirection(m) {
        let x = this._x
            , y = this._y
            , z = this._z
            , e = m.elements;
        return this._x = e[0] * x + e[4] * y + e[8] * z,
            this._y = e[1] * x + e[5] * y + e[9] * z,
            this._z = e[2] * x + e[6] * y + e[10] * z,
            this.onChangeCallback(),
            this.normalize()
    }
    divide(v) {
        return this._x /= v.x,
            this._y /= v.y,
            this._z /= v.z,
            this.onChangeCallback(),
            this
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar)
    }
    min(v) {
        return this._x = Math.min(this._x, v.x),
            this._y = Math.min(this._y, v.y),
            this._z = Math.min(this._z, v.z),
            this.onChangeCallback(),
            this
    }
    max(v) {
        return this._x = Math.max(this._x, v.x),
            this._y = Math.max(this._y, v.y),
            this._z = Math.max(this._z, v.z),
            this
    }
    clamp(min, max) {
        return this._x = Math.max(min.x, Math.min(max.x, this._x)),
            this._y = Math.max(min.y, Math.min(max.y, this._y)),
            this._z = Math.max(min.z, Math.min(max.z, this._z)),
            this
    }
    clampScalar(minVal, maxVal) {
        let min = new Vector3
            , max = new Vector3;
        return min.set(minVal, minVal, minVal),
            max.set(maxVal, maxVal, maxVal),
            this.clamp(min, max)
    }
    clampLength(min, max) {
        let length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
    }
    floor() {
        return this._x = Math.floor(this._x),
            this._y = Math.floor(this._y),
            this._z = Math.floor(this._z),
            this.onChangeCallback(),
            this
    }
    ceil() {
        return this._x = Math.ceil(this._x),
            this._y = Math.ceil(this._y),
            this._z = Math.ceil(this._z),
            this.onChangeCallback(),
            this
    }
    round() {
        return this._x = Math.round(this._x),
            this._y = Math.round(this._y),
            this._z = Math.round(this._z),
            this.onChangeCallback(),
            this
    }
    roundToZero() {
        return this._x = this._x < 0 ? Math.ceil(this._x) : Math.floor(this._x),
            this._y = this._y < 0 ? Math.ceil(this._y) : Math.floor(this._y),
            this._z = this._z < 0 ? Math.ceil(this._z) : Math.floor(this._z),
            this.onChangeCallback(),
            this
    }
    negate() {
        return this._x = -this._x,
            this._y = -this._y,
            this._z = -this._z,
            this.onChangeCallback(),
            this
    }
    dot(v) {
        return this._x * v.x + this._y * v.y + this._z * v.z
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z)
    }
    manhattanLength() {
        return Math.abs(this._x) + Math.abs(this._y) + Math.abs(this._z)
    }
    normalize() {
        return this.onChangeCallback(),
            this.divideScalar(this.length() || 1)
    }
    setLength(length) {
        return this.onChangeCallback(),
            this.normalize().multiplyScalar(length)
    }
    lerp(v, alpha) {
        return this._x = Math.lerp(v.x, this._x, alpha),
            this._y = Math.lerp(v.y, this._y, alpha),
            this._z = Math.lerp(v.z, this._z, alpha),
            this.onChangeCallback(),
            this
    }
    lerpVectors(v1, v2, alpha) {
        return this.onChangeCallback(),
            this.subVectors(v2, v1).multiplyScalar(alpha).add(v1)
    }
    cross(v) {
        return this.crossVectors(this, v)
    }
    crossVectors(a, b) {
        let ax = a.x
            , ay = a.y
            , az = a.z
            , bx = b.x
            , by = b.y
            , bz = b.z;
        return this._x = ay * bz - az * by,
            this._y = az * bx - ax * bz,
            this._z = ax * by - ay * bx,
            this.onChangeCallback(),
            this
    }
    projectOnVector(vector) {
        let scalar = vector.dot(this) / vector.lengthSq();
        return this.copy(vector).multiplyScalar(scalar)
    }
    projectOnPlane(planeNormal) {
        let v1 = this.V1 || new Vector3;
        return this.V1 = v1,
            this.onChangeCallback(),
            v1.copy(this).projectOnVector(planeNormal),
            this.sub(v1)
    }
    reflect(normal) {
        let v1 = this.V1 || new Vector3;
        return this.V1 = v1,
            this.onChangeCallback(),
            this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))
    }
    angleTo(v) {
        let theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
        return Math.acos(Math.clamp(theta, -1, 1))
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v))
    }
    distanceToSquared(v) {
        let dx = this._x - v.x
            , dy = this._y - v.y
            , dz = this._z - v.z;
        return dx * dx + dy * dy + dz * dz
    }
    manhattanDistanceTo(v) {
        return Math.abs(this._x - v.x) + Math.abs(this._y - v.y) + Math.abs(this._z - v.z)
    }
    setFromSpherical(s) {
        let sinPhiRadius = Math.sin(s.phi) * s.radius;
        return this._x = sinPhiRadius * Math.sin(s.theta),
            this._y = Math.cos(s.phi) * s.radius,
            this._z = sinPhiRadius * Math.cos(s.theta),
            this.onChangeCallback(),
            this
    }
    setFromCylindrical(c) {
        return this._x = c.radius * Math.sin(c.theta),
            this._y = c.y,
            this._z = c.radius * Math.cos(c.theta),
            this.onChangeCallback(),
            this
    }
    setFromMatrixPosition(m) {
        let e = m.elements;
        return this._x = e[12],
            this._y = e[13],
            this._z = e[14],
            this.onChangeCallback(),
            this
    }
    setFromMatrixScale(m) {
        let sx = this.setFromMatrixColumn(m, 0).length()
            , sy = this.setFromMatrixColumn(m, 1).length()
            , sz = this.setFromMatrixColumn(m, 2).length();
        return this.onChangeCallback(),
            this._x = sx,
            this._y = sy,
            this._z = sz,
            this
    }
    setFromMatrixColumn(m, index) {
        return this.onChangeCallback(),
            this.fromArray(m.elements, 4 * index)
    }
    equals(v) {
        return v.x === this._x && v.y === this._y && v.z === this._z
    }
    fromArray(array, offset) {
        return void 0 === offset && (offset = 0),
            this._x = array[offset],
            this._y = array[offset + 1],
            this._z = array[offset + 2],
            this.onChangeCallback(),
            this
    }
    toArray(array, offset) {
        return void 0 === array && (array = []),
        void 0 === offset && (offset = 0),
            array[offset] = this._x,
            array[offset + 1] = this._y,
            array[offset + 2] = this._z,
            array
    }
    fromBufferAttribute(attribute, index) {
        this._x = attribute.array[3 * index + 0],
            this._y = attribute.array[3 * index + 1],
            this._z = attribute.array[3 * index + 2],
            this.onChangeCallback()
    }
    onChange(callback) {
        this.onChangeCallback = callback
    }
    onChangeCallback() {}
}
class Vector4 {
    constructor(x=0, y=0, z=0, w=0) {
        this.x = x,
            this.y = y,
            this.z = z,
            this.w = w
    }
    multiplyScalar(s) {
        return this.x *= s,
            this.y *= s,
            this.z *= s,
            this.w *= s,
            this
    }
    set(x, y, z, w) {
        return this.x = x,
            this.y = y,
            this.z = z,
            this.w = w,
            this
    }
    copy(v) {
        return this.x = v.x,
            this.y = v.y,
            this.z = v.z,
            this.w = v.w,
            this
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    applyMatrix4(m) {
        let x = this.x
            , y = this.y
            , z = this.z
            , w = this.w
            , e = m.elements;
        return this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w,
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w,
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w,
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w,
            this
    }
    toArray(array, offset) {
        return void 0 === array && (array = []),
        void 0 === offset && (offset = 0),
            array[offset] = this.x,
            array[offset + 1] = this.y,
            array[offset + 2] = this.z,
            array[offset + 3] = this.w,
            array
    }
    fromArray(array, offset) {
        return void 0 === offset && (offset = 0),
            this.x = array[offset],
            this.y = array[offset + 1],
            this.z = array[offset + 2],
            this.w = array[offset + 3],
            this
    }
    set width(v) {
        this.z = v
    }
    set height(v) {
        this.w = v
    }
    get width() {
        return this.z
    }
    get height() {
        return this.w
    }
}
class Face3 {
    constructor(a, b, c, normal=new Vector3) {
        this.a = a,
            this.b = b,
            this.c = c,
            this.normal = normal
    }
}
Class((function zUtils3D() {
        var diff, edge1, edge2, normal, v1, v0;
        Math.euclideanModulo = function(n, m) {
            return (n % m + m) % m
        }
            ,
            Math.isPowerOf2 = function(w, h) {
                let test = value=>0 == (value & value - 1);
                return test(w) && test(h)
            }
            ,
            Math.floorPowerOf2 = function(value) {
                return Math.pow(2, Math.floor(Math.log(value) / Math.LN2))
            }
            ,
            Geometry.TYPES = {
                SphereGeometry: SphereGeometry,
                IcosahedronGeometry: IcosahedronGeometry,
                BoxGeometry: BoxGeometry,
                PlaneGeometry: PlaneGeometry,
                CylinderGeometry: CylinderGeometry
            },
            Matrix4.prototype.isMatrix4 = !0,
            Matrix3.prototype.isMatrix3 = !0,
            Vector3.prototype.isVector3 = !0,
            Vector2.prototype.isVector2 = !0,
            CameraBase3D.prototype.isCamera = !0,
            PerspectiveCamera.prototype.isPerspective = !0,
        window.THREAD && (Shader = {
            FRONT_SIDE: "shader_front_side",
            BACK_SIDE: "shader_back_side",
            DOUBLE_SIDE: "shader_double_side"
        }),
            Ray.prototype.intersectTriangle = (diff = new Vector3,
                    edge1 = new Vector3,
                    edge2 = new Vector3,
                    normal = new Vector3,
                    function intersectTriangle(a, b, c, backfaceCulling, target) {
                        edge1.subVectors(b, a),
                            edge2.subVectors(c, a),
                            normal.crossVectors(edge1, edge2);
                        var sign, DdN = this.direction.dot(normal);
                        if (DdN > 0) {
                            if (backfaceCulling)
                                return null;
                            sign = 1
                        } else {
                            if (!(DdN < 0))
                                return null;
                            sign = -1,
                                DdN = -DdN
                        }
                        diff.subVectors(this.origin, a);
                        var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                        if (DdQxE2 < 0)
                            return null;
                        var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                        if (DdE1xQ < 0)
                            return null;
                        if (DdQxE2 + DdE1xQ > DdN)
                            return null;
                        var QdN = -sign * diff.dot(normal);
                        return QdN < 0 ? null : this.at(QdN / DdN, target)
                    }
            ),
            Mesh.prototype.raycast = function() {
                let inverseMatrix = new Matrix4
                    , ray = new Ray
                    , sphere = new Sphere
                    , vA = new Vector3
                    , vB = new Vector3
                    , vC = new Vector3
                    , uvA = (new Vector3,
                    new Vector3,
                    new Vector3,
                    new Vector3,
                    new Vector2)
                    , uvB = new Vector2
                    , uvC = new Vector2
                    , barycoord = new Vector3
                    , intersectionPoint = new Vector3
                    , intersectionPointWorld = new Vector3;
                function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
                    vA.fromBufferAttribute(position, a),
                        vB.fromBufferAttribute(position, b),
                        vC.fromBufferAttribute(position, c);
                    let intersection = function checkIntersection(object, shader, raycaster, ray, pA, pB, pC, point) {
                        let intersect;
                        if (intersect = shader.side === Shader.BACK_SIDE ? ray.intersectTriangle(pC, pB, pA, !0, point) : ray.intersectTriangle(pA, pB, pC, shader.side !== Shader.DOUBLE_SIDE, point),
                        null === intersect)
                            return null;
                        intersectionPointWorld.copy(point),
                            intersectionPointWorld.applyMatrix4(object.matrixWorld);
                        let distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                        return distance < raycaster.near || distance > raycaster.far ? null : {
                            distance: distance,
                            point: intersectionPointWorld.clone(),
                            object: object
                        }
                    }(object, object.shader, raycaster, ray, vA, vB, vC, intersectionPoint);
                    if (intersection) {
                        uv && (uvA.fromBufferAttribute(uv, a),
                            uvB.fromBufferAttribute(uv, b),
                            uvC.fromBufferAttribute(uv, c),
                            intersection.uv = function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                                return Triangle.getBarycoord(point, p1, p2, p3, barycoord),
                                    uv1.multiplyScalar(barycoord.x),
                                    uv2.multiplyScalar(barycoord.y),
                                    uv3.multiplyScalar(barycoord.z),
                                    uv1.add(uv2).add(uv3),
                                    uv1.clone()
                            }(intersectionPoint, vA, vB, vC, uvA, uvB, uvC));
                        let face = new Face3(a,b,c);
                        Triangle.getNormal(vA, vB, vC, face.normal),
                            intersection.face = face
                    }
                    return intersection
                }
                return function raycast(raycaster, intersects) {
                    let intersection, a, b, c, geometry = this.geometry, shader = this.shader, matrixWorld = this.matrixWorld;
                    if (void 0 === shader)
                        return;
                    if (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
                        sphere.copy(geometry.boundingSphere),
                        sphere.applyMatrix4(matrixWorld),
                    !1 === raycaster.ray.intersectsSphere(sphere))
                        return;
                    if (inverseMatrix.getInverse(matrixWorld),
                        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix),
                    null !== geometry.boundingBox && !1 === ray.intersectsBox(geometry.boundingBox))
                        return;
                    let i, l, index = geometry.index, position = geometry.attributes.position, uv = geometry.attributes.uv;
                    if (null !== index)
                        for (i = 0,
                                 l = index.length; i < l; i += 3)
                            a = index[i],
                                b = index[i + 1],
                                c = index[i + 2],
                                intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c),
                            intersection && (intersection.faceIndex = Math.floor(i / 3),
                                intersects.push(intersection));
                    else if (void 0 !== position)
                        for (i = 0,
                                 l = position.count; i < l; i += 3)
                            a = i,
                                b = i + 1,
                                c = i + 2,
                                intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c),
                            intersection && (intersection.faceIndex = Math.floor(i / 3),
                                intersects.push(intersection))
                }
            }(),
            Triangle.prototype.closestPointToPoint = function() {
                let plane = new Plane
                    , edgeList = [new Line3, new Line3, new Line3]
                    , projectedPoint = new Vector3
                    , closestPoint = new Vector3;
                return function closestPointToPoint(point, target=new Vector3) {
                    let minDistance = 1 / 0;
                    if (plane.setFromCoplanarPoints(this.a, this.b, this.c),
                        plane.projectPoint(point, projectedPoint),
                    !0 === this.containsPoint(projectedPoint))
                        target.copy(projectedPoint);
                    else {
                        edgeList[0].set(this.a, this.b),
                            edgeList[1].set(this.b, this.c),
                            edgeList[2].set(this.c, this.a);
                        for (let i = 0; i < edgeList.length; i++) {
                            edgeList[i].closestPointToPoint(projectedPoint, !0, closestPoint);
                            let distance = projectedPoint.distanceToSquared(closestPoint);
                            distance < minDistance && (minDistance = distance,
                                target.copy(closestPoint))
                        }
                    }
                    return target
                }
            }(),
            Points.prototype.raycast = function() {
                let inverseMatrix = new Matrix4
                    , ray = new Ray
                    , sphere = new Sphere;
                return function raycast(raycaster, intersects) {
                    let object = this
                        , geometry = this.geometry
                        , matrixWorld = this.matrixWorld
                        , threshold = raycaster.params.Points.threshold;
                    if (null === geometry.boundingSphere && geometry.computeBoundingSphere(),
                        sphere.copy(geometry.boundingSphere),
                        sphere.applyMatrix4(matrixWorld),
                        sphere.radius += threshold,
                    !1 === raycaster.ray.intersectsSphere(sphere))
                        return;
                    inverseMatrix.getInverse(matrixWorld),
                        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                    let localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                        , localThresholdSq = localThreshold * localThreshold
                        , position = new Vector3
                        , intersectPoint = new Vector3;
                    function testPoint(point, index) {
                        let rayPointDistanceSq = ray.distanceSqToPoint(point);
                        if (rayPointDistanceSq < localThresholdSq) {
                            ray.closestPointToPoint(point, intersectPoint),
                                intersectPoint.applyMatrix4(matrixWorld);
                            let distance = raycaster.ray.origin.distanceTo(intersectPoint);
                            if (distance < raycaster.near || distance > raycaster.far)
                                return;
                            intersects.push({
                                distance: distance,
                                distanceToRay: Math.sqrt(rayPointDistanceSq),
                                point: intersectPoint.clone(),
                                index: index,
                                face: null,
                                object: object
                            })
                        }
                    }
                    let index = geometry.index
                        , positions = geometry.attributes.position.array;
                    if (null !== index) {
                        let indices = index.array;
                        for (let i = 0, il = indices.length; i < il; i++) {
                            let a = indices[i];
                            position.fromArray(positions, 3 * a),
                                testPoint(position, a)
                        }
                    } else
                        for (let i = 0, l = positions.length / 3; i < l; i++)
                            position.fromArray(positions, 3 * i),
                                testPoint(position, i)
                }
            }(),
            Object.assign(Triangle, {
                getNormal: (v0 = new Vector3,
                        function getNormal(a, b, c, target=new Vector3) {
                            target.subVectors(c, b),
                                v0.subVectors(a, b),
                                target.cross(v0);
                            var targetLengthSq = target.lengthSq();
                            return targetLengthSq > 0 ? target.multiplyScalar(1 / Math.sqrt(targetLengthSq)) : target.set(0, 0, 0)
                        }
                ),
                getBarycoord: function() {
                    var v0 = new Vector3
                        , v1 = new Vector3
                        , v2 = new Vector3;
                    return function getBarycoord(point, a, b, c, target=new Vector3) {
                        v0.subVectors(c, a),
                            v1.subVectors(b, a),
                            v2.subVectors(point, a);
                        var dot00 = v0.dot(v0)
                            , dot01 = v0.dot(v1)
                            , dot02 = v0.dot(v2)
                            , dot11 = v1.dot(v1)
                            , dot12 = v1.dot(v2)
                            , denom = dot00 * dot11 - dot01 * dot01;
                        if (0 === denom)
                            return target.set(-2, -1, -1);
                        var invDenom = 1 / denom
                            , u = (dot11 * dot02 - dot01 * dot12) * invDenom
                            , v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                        return target.set(1 - u - v, v, u)
                    }
                }(),
                containsPoint: (v1 = new Vector3,
                        function containsPoint(point, a, b, c) {
                            return Triangle.getBarycoord(point, a, b, c, v1),
                            v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1
                        }
                )
            })
    }
), "static"),
    Class((function FXLayer(_parentNuke, _type, _preventDrawBuffers=!1) {
            Inherit(this, Component);
            var _nuke, _rt, _this = this, _scene = new Scene, _objects = [], _textureIndex = -1, _visible = !0, _id = Utils.timestamp(), _name = Utils.getConstructorName(_this), _useDrawBuffers = !_preventDrawBuffers;
            function resizeHandler() {
                _rt.setSize && _rt.setSize(_nuke.stage.width * _this.resolution * _nuke.dpr, _nuke.stage.height * _this.resolution * _nuke.dpr)
            }
            this.resolution = 1,
                this.enabled = !0,
                this.renderShadows = !0,
                this.set("visible", (v=>_this.scene.visible = _visible = v)),
                this.get("visible", (_=>_visible)),
                this.onInvisible = function() {
                    _this.scene.visible = !1
                }
                ,
                this.onVisible = function() {
                    _this.scene.visible = !0
                }
                ,
                this.create = function(nuke=World.NUKE, type, rt) {
                    if (!nuke)
                        return;
                    let format;
                    _useDrawBuffers = nuke.useDrawBuffers,
                    type && "object" == typeof type && ("boolean" == typeof type.useDrawBuffers && (_useDrawBuffers = type.useDrawBuffers),
                        format = type.format,
                        type = type.type),
                        _this.rtType = type || Texture.UNSIGNED_BYTE,
                        _this.rtFormat = format || Texture.RGBFormat,
                        (_this = this).scene = _scene,
                        (_nuke = _this.initClass(Nuke, nuke.stage, {
                            renderer: nuke.renderer,
                            camera: nuke.camera,
                            scene: _scene,
                            dpr: nuke.dpr,
                            useDrawBuffers: !1
                        })).parentNuke = nuke,
                        _parentNuke = nuke,
                        _this.nuke = _nuke,
                        function initRT(rt) {
                            if (_useDrawBuffers) {
                                let texture = new Texture;
                                texture.minFilter = Texture.LINEAR,
                                    texture.magFilter = Texture.LINEAR,
                                    texture.format = Texture.RGBAFormat,
                                _this.rtType && (texture.type = _this.rtType),
                                _this.rtFormat && (texture.format = _this.rtFormat),
                                    texture.wrapS = texture.wrapT = Texture.CLAMP_TO_EDGE,
                                    texture.fxLayer = _this,
                                    _this.textureIndex = _textureIndex = _parentNuke.attachDrawBuffer(texture),
                                    _rt = {
                                        texture: texture
                                    }
                            } else
                                _rt = rt || Utils3D.createRT(_nuke.stage.width * _this.resolution * _nuke.dpr, _nuke.stage.height * _this.resolution * _nuke.dpr, _this.rtType || Texture.RGBAFormat);
                            _this.rt = _rt,
                                _this.nuke.setSize(_rt.width, _rt.height)
                        }(rt),
                        function addListeners() {
                            _this.events.sub(Events.RESIZE, resizeHandler)
                        }()
                }
                ,
                this.addObject = this.add = function(object) {
                    if (_nuke)
                        if (_useDrawBuffers)
                            object.shader && object.shader.fragmentShader && (!function editDBShader(mesh) {
                                const WEBGL2 = Renderer.type == Renderer.WEBGL2;
                                let modifyMarker = (fs,name,index)=>{
                                    if (WEBGL2 && !fs.includes(`layout(location=${index})`)) {
                                        let mainAt = (fs = fs.replace("out vec4 FragColor;", "")).indexOf("void main()")
                                            , before = fs.slice(0, mainAt)
                                            , after = fs.slice(mainAt);
                                        fs = before + `layout(location=${index}) out vec4 ${name};\n` + after
                                    }
                                    let marker = "#drawbuffer " + name;
                                    if (fs.includes(marker)) {
                                        let split = fs.split(marker + " ")
                                            , finalOut = WEBGL2 ? name : `gl_FragData[${index}]`;
                                        split[1] = split[1].replace("gl_FragColor", finalOut),
                                            fs = split[0] + split[1]
                                    }
                                    for (; fs.includes("#applyShadow"); ) {
                                        fs = fs.split("\n");
                                        for (let i = 0; i < fs.length; i++)
                                            fs[i].includes("#applyShadow") && (fs[i] = fs[i].replace("#applyShadow", ""));
                                        fs = fs.join("\n")
                                    }
                                    return fs
                                }
                                    , shader = mesh.shader
                                    , fs = shader.fragmentShader
                                    , name = _this.name || _name;
                                WEBGL2 && fs.includes("location=0") || (fs = modifyMarker(fs, "Color", 0)),
                                    fs = modifyMarker(fs, name, _textureIndex),
                                    shader.fragmentShader = fs
                            }(object),
                                object.shader._attachmentData = {
                                    format: _this.rtFormat,
                                    type: _this.rtType,
                                    attachments: _parentNuke.attachments
                                });
                        else {
                            let clone = object.clone();
                            for (object["clone_" + _id] = clone,
                                     _scene.add(clone),
                                     _objects.push(object),
                                 object.shader && function editShader(mesh) {
                                     let modifyShader = (shader,name)=>{
                                             let fs = shader._fragmentShader;
                                             if (!fs)
                                                 return;
                                             let marker = "#drawbuffer " + name;
                                             if (fs.includes(marker)) {
                                                 let split = fs.split(marker + " ");
                                                 fs = split[0] + split[1]
                                             }
                                             for (; fs.includes("#drawbuffer"); ) {
                                                 fs = fs.split("\n");
                                                 for (let i = 0; i < fs.length; i++)
                                                     fs[i].includes("#drawbuffer") && (fs[i] = "");
                                                 fs = fs.join("\n")
                                             }
                                             shader.fragmentShader = fs
                                         }
                                         , applyShadow = (shader,bool)=>{
                                             let fs = shader.fragmentShader;
                                             if (fs) {
                                                 for (; fs.includes("#applyShadow"); ) {
                                                     fs = fs.split("\n");
                                                     for (let i = 0; i < fs.length; i++)
                                                         bool ? fs[i].includes("#applyShadow") && (fs[i] = fs[i].replace("#applyShadow", "")) : fs[i].includes("#applyShadow") && (fs[i] = "");
                                                     fs = fs.join("\n")
                                                 }
                                                 shader.fragmentShader = fs
                                             }
                                         }
                                     ;
                                     mesh.shader._fragmentShader || (mesh.shader._fragmentShader = mesh.shader.fragmentShader),
                                         modifyShader(mesh.shader, "Color");
                                     let shader = mesh.shader.clone(!_this.renderShadows, `-${_this.name || _name}`);
                                     modifyShader(shader, _this.name || _name),
                                         applyShadow(shader, _this.renderShadows),
                                         applyShadow(mesh.shader, !0),
                                         mesh.shader.copyUniformsTo(shader, !0),
                                         mesh.shader = shader
                                 }(clone); clone.children.length; )
                                clone.remove(clone.children[0])
                        }
                }
                ,
                this.removeObject = function(object) {
                    _nuke && (_scene.remove(object["clone_" + _id]),
                        _objects.remove(object),
                        delete object["clone_" + _id])
                }
                ,
                this.render = this.draw = function(stage, camera) {
                    if (_nuke && _this.enabled && !_useDrawBuffers && _parentNuke.enabled && _objects.length) {
                        stage && (_nuke.stage = stage,
                            _this.setSize(stage.width, stage.height)),
                            _nuke.camera = camera || _nuke.parentNuke.camera,
                        _this.renderShadows || (_nuke.renderer.overridePreventShadows = !0);
                        for (let i = _objects.length - 1; i > -1; i--) {
                            let obj = _objects[i]
                                , clone = obj["clone_" + _id];
                            _this.forceVisible ? clone.visible = !0 : clone.visible = obj.determineVisible(),
                            clone.visible && (obj.updateMatrixWorld(),
                            obj.ignoreMatrix || Utils3D.decompose(obj, clone))
                        }
                        _nuke.rtt = _rt,
                            _nuke.render(),
                            RenderStats.update("FXLayer"),
                            _nuke.renderer.overridePreventShadows = !1
                    }
                }
                ,
                this.addPass = function(pass) {
                    _nuke && _nuke.add(pass)
                }
                ,
                this.removePass = function(pass) {
                    _nuke && _nuke.remove(pass)
                }
                ,
                this.setSize = function(width, height) {
                    _nuke && (_rt.width == width && _rt.height == height || (_this.events.unsub(Events.RESIZE, resizeHandler),
                    _rt && _rt.setSize(width * _this.resolution * _nuke.dpr, height * _this.resolution * _nuke.dpr),
                        _nuke.setSize(width * _this.resolution * _nuke.dpr, height * _this.resolution * _nuke.dpr)))
                }
                ,
                this.setDPR = function(dpr) {
                    _nuke && (_nuke.dpr = dpr,
                        resizeHandler())
                }
                ,
                this.setResolution = function(res) {
                    _this.resolution = res,
                        resizeHandler()
                }
                ,
                this.getObjects = function() {
                    return _objects
                }
                ,
                this.useRT = function(rt) {
                    _rt = _this.rt = rt
                }
                ,
                this.getName = function() {
                    return _this.name || _name
                }
                ,
            _parentNuke instanceof Nuke && this.create(_parentNuke, _type)
        }
    )),
    Namespace("FX"),
    Class((function FXScene(_parentNuke, _type) {
            Inherit(this, Component);
            var _nuke, _rt, _this = this, _scene = new Scene, _id = Utils.timestamp(), _objects = [], _visible = !0;
            function resizeHandler() {
                _rt.setSize && _rt.setSize(_nuke.stage.width * _this.resolution * _nuke.dpr, _nuke.stage.height * _this.resolution * _nuke.dpr),
                    _this.nuke.setSize(_rt.width, _rt.height),
                    _this.width = _rt.width,
                    _this.height = _rt.height
            }
            this.resolution = 1,
                this.autoVisible = !0,
                this.enabled = !0,
                this.scene = _scene,
                this.renderShadows = !0,
                this.set("visible", (v=>{
                        _this.scene && (_this.scene.visible = _visible = v)
                    }
                )),
                this.get("visible", (_=>_visible)),
                this.onInvisible = function() {
                    this.scene.visible && (this.scene.visible = !1,
                        _this.flag("needsOnVisible", !0))
                }
                ,
                this.onVisible = function() {
                    _this.flag("needsOnVisible") && (this.scene.visible = !0,
                        _this.flag("needsOnVisible", !1))
                }
                ,
                this.create = function(nuke=World.NUKE, rt, options) {
                    Hydra.LOCAL && Utils.query("scenes") && SceneDebug.instance().add(Utils.getConstructorName(_this), _this),
                    rt && "object" == typeof rt && (rt.isRT || (options = rt,
                        rt = void 0)),
                    options || (options = {}),
                        _this.rtFormat = options.format || Texture.RGBFormat,
                        _this.rtType = options.type || Texture.UNSIGNED_BYTE,
                        (_this = this).scene = _scene,
                        _this.nuke = _nuke = _this.initClass(Nuke, nuke.stage, {
                            renderer: nuke.renderer,
                            camera: nuke.camera,
                            scene: _scene,
                            dpr: nuke.dpr
                        }),
                        _scene.nuke = _nuke,
                        function initRT(rt, options={}) {
                            options.type == Texture.FLOAT && (options.format = Texture.RGBAFormat),
                                _this.width = _nuke.stage.width * _this.resolution * _nuke.dpr,
                                _this.height = _nuke.stage.height * _this.resolution * _nuke.dpr,
                                _rt = rt || new RenderTarget(_this.width,_this.height,Object.assign({
                                    minFilter: Texture.LINEAR,
                                    magFilter: Texture.LINEAR,
                                    generateMipmaps: !1
                                }, options)),
                                _this.rt = _rt,
                                _rt.fxscene = _this
                        }(rt, options),
                        rt ? _this.flag("recycle_rt", !0) : function addListeners() {
                            _this.events.sub(Events.RESIZE, resizeHandler)
                        }(),
                    FXScene.onCreate && FXScene.onCreate(_this)
                }
                ,
                this.onDestroy = this.fxDestroy = function() {
                    _this.scene.deleted = !0,
                    _this.flag("recycle_rt") || _rt && _rt.destroy && _rt.destroy()
                }
                ,
                this.setSize = function(width, height, exact) {
                    _nuke && (_rt.width == width && _rt.height == height || (_this.events.unsub(Events.RESIZE, resizeHandler),
                        exact ? (_this.width = width,
                            _this.height = height) : (_this.width = width * _this.resolution * _nuke.dpr,
                            _this.height = height * _this.resolution * _nuke.dpr),
                    _rt && _rt.setSize(_this.width, _this.height),
                        _nuke.setSize(_this.width, _this.height)))
                }
                ,
                this.add = this.addObject = function(object) {
                    if (!object)
                        return console.error("FXScene addObject undefined!");
                    let clone = object.clone();
                    for (object["clone_" + _id] = clone,
                             _scene.add(clone),
                             _objects.push(object),
                             object.shader._attachmentData = {
                                 format: _this.rtFormat,
                                 type: _this.rtType,
                                 attachments: 1
                             }; clone.children.length; )
                        clone.remove(clone.children[0]);
                    return clone
                }
                ,
                this.removeObject = function(object) {
                    _scene.remove(object["clone_" + _id]),
                        _objects.remove(object),
                        delete object["clone_" + _id]
                }
                ,
                this.setScissor = function(x, y, w, h) {
                    this.scissor || (this.scissor = new Vector4),
                        this.scissor.x = x * _this.width,
                        this.scissor.y = _this.height - h * _this.height - y * _this.height,
                        this.scissor.width = w * _this.width,
                        this.scissor.height = h * _this.height,
                        this.rt.scissor = this.scissor
                }
                ,
                this.render = this.draw = function(stage, camera) {
                    stage && (_this.events.unsub(Events.RESIZE, resizeHandler),
                        _this.setSize(stage.width, stage.height),
                        _this.nuke.stage = stage),
                    camera && (_this.nuke.camera = camera,
                    RenderManager.type == RenderManager.WEBVR && (_this.vrRT || (_this.vrRT = new Map),
                    _this.vrRT.get(camera) || _this.vrRT.set(camera, _rt.clone())));
                    let clearColor = null
                        , alpha = 1;
                    _this.clearColor && (clearColor = _nuke.renderer.getClearColor().getHex(),
                        _nuke.renderer.setClearColor(_this.clearColor)),
                    _this.clearAlpha > -1 && (alpha = _nuke.renderer.getClearAlpha(),
                        _nuke.renderer.setClearAlpha(_this.clearAlpha)),
                    _this.renderShadows || (_nuke.renderer.overridePreventShadows = !0);
                    for (let i = _objects.length - 1; i > -1; i--) {
                        let obj = _objects[i]
                            , clone = obj["clone_" + _id];
                        _this.forceVisible || obj.cloneVisible ? clone.visible = "boolean" != typeof clone.isVisible || clone.isVisible : clone.visible = obj.determineVisible(),
                        clone.visible && (obj.updateMatrixWorld(!1 === obj.visible || void 0),
                        obj.ignoreMatrix || (Utils3D.decompose(obj, clone),
                        clone.overrideScale && clone.scale.setScalar(clone.overrideScale)))
                    }
                    _this.preventRTDraw || (RenderStats.update("FXScene", 1, _this),
                        _nuke.rtt = _rt,
                    camera && RenderManager.type == RenderManager.WEBVR && (_nuke.rtt = _this.vrRT.get(camera)),
                        _nuke.render()),
                        _nuke.renderer.overridePreventShadows = !1,
                    _this.clearColor && _nuke.renderer.setClearColor(clearColor),
                    _this.clearAlpha > -1 && _nuke.renderer.setClearAlpha(_this.clearAlpha)
                }
                ,
                this.setDPR = function(dpr) {
                    return _nuke ? (_nuke.dpr = dpr,
                        resizeHandler(),
                        _this) : _this
                }
                ,
                this.addPass = function(pass) {
                    _nuke && _nuke.add(pass)
                }
                ,
                this.removePass = function(pass) {
                    _nuke && _nuke.remove(pass)
                }
                ,
                this.setResolution = function(res) {
                    return _this.resolution = res,
                        resizeHandler(),
                        this
                }
                ,
                this.useRT = function(rt) {
                    _rt = _this.rt = rt
                }
                ,
                this.upload = function() {
                    _rt && _rt.upload()
                }
                ,
                this.useCamera = function(camera) {
                    _this.nuke.camera = camera.camera || camera
                }
                ,
                this.useScene = function(scene) {
                    _this.nuke.scene = scene
                }
                ,
                this.createDepthTexture = function(useRTTBuffer) {
                    return _this.depthTexture || (_this.nuke.passes.length || useRTTBuffer ? (_this.nuke.rttBuffer.createDepthTexture(),
                        _this.depthTexture = _this.nuke.rttBuffer.depth) : (_this.rt.createDepthTexture(),
                        _this.depthTexture = _this.rt.depth)),
                        _this.depthTexture
                }
                ,
            _parentNuke instanceof Nuke && this.create(_parentNuke, _type)
        }
    )),
    Class((function BlitPass(_forceNuke) {
            Inherit(this, NukePass);
            this.uniforms = {},
                this.init("BlitPass"),
            _forceNuke || (this.blitFramebuffer = !0)
        }
    )),
    Class((function Nuke(_stage, _params) {
            Inherit(this, Component);
            var _width, _height, _nukeMesh, _this = this;
            _params.renderer || console.error("Nuke :: Must define renderer"),
                _this.stage = _stage,
                _this.renderer = _params.renderer,
                _this.camera = _params.camera,
                _this.scene = _params.scene,
                _this.rtt = _params.rtt,
                _this.enabled = 0 != _params.enabled,
                _this.passes = _params.passes || [],
                _this.useDrawBuffers = void 0 !== _params.useDrawBuffers ? _params.useDrawBuffers : !(Renderer.type != Renderer.WEBGL2 && !window.Metal) || !Utils.query("noDrawBuffers") && !Nuke.NO_DRAWBUFFERS && Device.graphics.webgl && Device.graphics.webgl.detect("draw_buffers");
            var _rttPing, _rttPong, _rttBuffer, _dpr = _params.dpr || 1, _drawBuffers = [];
            function resizeHandler() {
                var width = _this.stage.width * _dpr
                    , height = _this.stage.height * _dpr;
                _rttPing.setSize(width, height),
                    _rttPong.setSize(width, height),
                    _rttBuffer.setSize(width, height)
            }
            _this.scene.nuke = _this,
                function initNuke() {
                    let width = _this.stage.width * _dpr
                        , height = _this.stage.height * _dpr;
                    _rttPing = Nuke.getRT(width, height, !1, 1),
                        _rttPong = Nuke.getRT(width, height, !1, 2),
                        _rttBuffer = Nuke.getRT(width, height, _this.useDrawBuffers),
                        (_nukeMesh = new Mesh(World.QUAD,null)).frustumCulled = !1,
                        _nukeMesh.noMatrices = !0,
                        _nukeMesh.transient = !0,
                        _width = width,
                        _height = height
                }(),
                function addListeners() {
                    _this.events.sub(Events.RESIZE, resizeHandler)
                }(),
                _this.onBeforeShaderCompile = function(obj) {
                    if (!obj)
                        return;
                    let shader = obj.shader;
                    if (!(shader && shader.fragmentShader && _this.useDrawBuffers && _drawBuffers.length))
                        return;
                    const WEBGL2 = Renderer.type == Renderer.WEBGL2;
                    let key = WEBGL2 ? " Color " : "gl_FragData[0]";
                    if (!shader.fragmentShader.includes(key)) {
                        let fs = shader.fragmentShader;
                        WEBGL2 || (fs = "#extension GL_EXT_draw_buffers : require\n" + fs),
                            fs = fs.split("void main() {"),
                            fs = fs[0] + "void main() {\nvec4 tmpFragColor;\n" + fs[1],
                            fs = fs.replace(/gl_FragColor/g, "tmpFragColor");
                        let idx = fs.lastIndexOf("}");
                        fs = fs.slice(0, idx) + "#drawbuffer Color gl_FragColor = tmpFragColor;\n" + fs.slice(idx),
                            shader.fragmentShader = fs
                    }
                    _drawBuffers.forEach(((t,i)=>{
                            let name = t.fxLayer.getName()
                                , key = WEBGL2 ? `${name} =` : `gl_FragData[${i + 1}]`;
                            if (!shader.fragmentShader.includes(key)) {
                                let fs = shader.fragmentShader
                                    , idx = fs.lastIndexOf("}");
                                fs = fs.slice(0, idx) + `#drawbuffer ${name} gl_FragColor = vec4(0.0);\n` + fs.slice(idx),
                                    shader.fragmentShader = fs,
                                    t.fxLayer.add(obj)
                            }
                        }
                    ))
                }
                ,
                _this.add = function(pass, index) {
                    "number" != typeof index ? _this.passes.push(pass) : _this.passes.splice(index, 0, pass)
                }
                ,
                _this.remove = function(pass) {
                    "number" == typeof pass ? _this.passes.splice(pass) : _this.passes.remove(pass)
                }
                ,
                _this.render = function(directCallback) {
                    if (RenderStats.update("Nuke"),
                        _this.events.fire(Nuke.RENDER, _this, !0),
                    _this.onBeforeRender && _this.onBeforeRender(),
                    !_this.enabled || !_this.passes.length)
                        return _this.renderer.render(_this.scene, _this.camera, _this.rtt, null, directCallback),
                        _this.onBeforeProcess && _this.onBeforeProcess(),
                            void (_this.postRender && _this.postRender());
                    RenderStats.update("NukePass", _this.passes.length),
                        _this.hasRendered = !0,
                    _this.onBeforeProcess && _this.onBeforeProcess(),
                        _this.renderer.render(_this.scene, _this.camera, _rttBuffer, !0);
                    let usedBuffer = !1
                        , pingPong = !0
                        , count = _this.passes.length;
                    for (var i = 0; i < count; i++) {
                        if (_this.passes[i].disabled)
                            continue;
                        let shader = _this.passes[i].pass
                            , inTexture = usedBuffer ? pingPong ? _rttPing.texture : _rttPong.texture : _rttBuffer.texture
                            , outTexture = pingPong ? _rttPong : _rttPing;
                        i == count - 1 && (outTexture = _this.rtt),
                            _nukeMesh.shader = shader,
                            _nukeMesh.shader.depthTest = !1,
                            _nukeMesh.shader.depthWrite = !1,
                            _nukeMesh.shader.uniforms.tDiffuse.value = inTexture,
                            _this.renderer.renderSingle(_nukeMesh, _this.camera || World.CAMERA, outTexture, i == count - 1 ? directCallback : null),
                            usedBuffer = !0,
                            pingPong = !pingPong
                    }
                    _this.postRender && _this.postRender()
                }
                ,
                _this.setSize = function(width, height) {
                    width == _width && height == _height || (_width = width,
                        _height = height,
                        resizeHandler())
                }
                ,
                _this.attachDrawBuffer = function(texture) {
                    if (_this.hasRendered && console.warn("Attempt to attach draw buffer after first render! Create FXLayer instance before first render."),
                        _drawBuffers.push(texture),
                    _rttBuffer && _rttBuffer.attachments) {
                        _rttBuffer.attachments = [_rttBuffer.attachments[0]];
                        for (let i = 0; i < _drawBuffers.length; i++)
                            _rttBuffer.attachments.push(_drawBuffers[i])
                    }
                    return _drawBuffers.length
                }
                ,
                _this.upload = function() {
                    _this.passes.length && _this.enabled && (_rttPing.upload(),
                        _rttPong.upload(),
                        _rttBuffer.upload()),
                    _rttBuffer.depth && _rttBuffer.depth.upload(),
                    _this.rtt && _this.rtt.upload()
                }
                ,
                _this.set("dpr", (function(v) {
                        _dpr = v,
                            resizeHandler()
                    }
                )),
                _this.get("dpr", (function() {
                        return _dpr
                    }
                )),
                _this.get("output", (function() {
                        return _nukeMesh.shader && _nukeMesh.shader.uniforms ? _nukeMesh.shader.uniforms.tDiffuse.value : null
                    }
                )),
                _this.get("rttBuffer", (function() {
                        return _rttBuffer
                    }
                )),
                this.set("rttBuffer", (function(v) {
                        _rttBuffer = v
                    }
                )),
                _this.get("prevFrameRT", (function() {
                        return _rttBuffer && _rttBuffer.texture ? _rttBuffer.texture : null
                    }
                )),
                _this.get("nukeScene", (function() {
                        return _nukeScene
                    }
                )),
                _this.get("ping", (function() {
                        return _rttPing
                    }
                )),
                _this.get("pong", (function() {
                        return _rttPong
                    }
                )),
                _this.get("attachments", (function() {
                        return _rttBuffer.attachments.length
                    }
                ))
        }
    ), (function() {
            Nuke.RENDER = "nuke_render";
            var _rts = {};
            Nuke.getRT = function(width, height, multi, index) {
                let rt, exists = _rts[`${width}_${height}_${multi}_${index}`];
                return exists || (rt = multi ? Utils3D.createMultiRT(width, height) : Utils3D.createRT(width, height),
                index > 0 && Nuke.recyclePingPong && (_rts[`${width}_${height}_${multi}_${index}`] = rt),
                    rt)
            }
        }
    )),
    Class((function NukePass(_fs, _uniforms, _pass) {
            Inherit(this, Component);
            var _this = this;
            this.UILPrefix = "string" == typeof _fs ? _fs : Utils.getConstructorName(_fs),
                this.init = function(fs, vs) {
                    if (_this.pass)
                        return;
                    _this = this;
                    fs || this.constructor.toString().match(/function ([^\(]+)/)[1],
                    Array.isArray(fs) && fs.join("");
                    if (_this.uniforms = _uniforms || _this.uniforms || {},
                        _this.uniforms.tDiffuse = {
                            type: "t",
                            value: null,
                            ignoreUIL: !0
                        },
                    _this.uniforms.unique && (_this.UILPrefix += "_" + _this.uniforms.unique + "_"),
                        window.UILStorage)
                        for (let key in _this.uniforms)
                            "unique" !== key && (_this.uniforms[key] = UILStorage.parse(_this.UILPrefix + key, _this.uniforms[key].value) || _this.uniforms[key]);
                    _this.pass = _this.initClass(Shader, vs || "NukePass", fs, Utils.mergeObject(_this.uniforms, {
                        precision: "high"
                    }), ((code,type)=>"fs" == type ? function prefix(code) {
                        if (!code)
                            throw `No shader ${_fs} found`;
                        let pre = "";
                        return code.includes("uniform sampler2D tDiffuse") || (pre += "uniform sampler2D tDiffuse;\n",
                            pre += "varying vec2 vUv;\n"),
                        pre + code
                    }(code) : code)),
                        _this.uniforms = _this.pass.uniforms
                }
                ,
                this.set = function(key, value) {
                    TweenManager.clearTween(_this.uniforms[key]),
                        _this.uniforms[key].value = value
                }
                ,
                this.get = function(key) {
                    return void 0 === _this.uniforms[key] ? null : _this.uniforms[key].value
                }
                ,
                this.tween = function(key, value, time, ease, delay, callback, update) {
                    return tween(_this.uniforms[key], {
                        value: value
                    }, time, ease, delay, callback, update)
                }
                ,
                this.clone = function() {
                    return _this.pass || _this.init(_fs),
                        new NukePass(null,null,_this.pass.clone())
                }
                ,
                this.upload = function() {
                    _this.pass.upload()
                }
                ,
                "string" == typeof _fs ? _this.init(_fs) : _pass && (_this.pass = _pass,
                    _this.uniforms = _pass.uniforms)
        }
    )),
    Class((function Raycaster(_camera) {
            Inherit(this, Component);
            const _this = this;
            let _mouse = new Vector3
                , _raycaster = new RayManager;
            function ascSort(a, b) {
                return a.distance - b.distance
            }
            function intersectObject(object, raycaster, intersects, recursive) {
                let obj = object;
                for (; obj && _this.testVisibility; ) {
                    if (!1 === obj.visible && !obj.forceRayVisible && !1 !== obj.testVisibility)
                        return;
                    obj = obj.parent
                }
                if (object.raycast && (object.raycast(raycaster, intersects),
                !0 === recursive)) {
                    let children = object.children;
                    for (let i = 0, l = children.length; i < l; i++)
                        intersectObject(children[i], raycaster, intersects, !0)
                }
            }
            function intersect(objects) {
                Array.isArray(objects) || (objects = [objects]);
                let intersects = [];
                return objects.forEach((object=>{
                        intersectObject(object, _raycaster, intersects, !1)
                    }
                )),
                    intersects.sort(ascSort),
                    intersects
            }
            this.testVisibility = !0,
                this.set("camera", (function(camera) {
                        _camera = camera
                    }
                )),
                this.set("pointsThreshold", (function(value) {
                        _raycaster.params.Points.threshold = value
                    }
                )),
                this.get("ray", (()=>_raycaster.ray)),
                this.checkHit = function(objects, mouse, rect=Stage) {
                    return mouse = mouse || Mouse,
                        _mouse.x = mouse.x / rect.width * 2 - 1,
                        _mouse.y = -mouse.y / rect.height * 2 + 1,
                        _raycaster.setFromCamera(_mouse, _camera),
                        intersect(objects)
                }
                ,
                this.checkFromValues = function(objects, origin, direction) {
                    return _raycaster.set(origin, direction, 0, Number.POSITIVE_INFINITY),
                        intersect(objects)
                }
        }
    ), (_=>{
            var _ray, _map = new WeakMap;
            Raycaster.checkHit = function(objects, mouse) {
                return _ray || (_ray = new Raycaster(World.CAMERA)),
                    _ray.checkHit(objects, mouse)
            }
                ,
                Raycaster.checkFromValues = function(objects, origin, direction) {
                    return _ray || (_ray = new Raycaster(World.CAMERA)),
                        _ray.checkFromValues(objects, origin, direction)
                }
                ,
                Raycaster.find = function(camera) {
                    if (!_map.has(camera)) {
                        let ray = new Raycaster(camera);
                        _map.set(camera, ray)
                    }
                    return _map.get(camera)
                }
        }
    )),
    Class((function ScreenProjection(_camera) {
            Inherit(this, Component);
            var _v3 = new Vector3
                , _v32 = new Vector3
                , _value = new Vector3;
            _camera = _camera.camera || _camera,
                this.set("camera", (function(v) {
                        _camera = v.camera || v
                    }
                )),
                this.get("camera", (_=>_camera)),
                this.unproject = function(mouse, rect=Stage, distance=0) {
                    "number" == typeof rect && (distance = rect,
                        rect = Stage),
                        _v3.set(mouse.x / rect.width * 2 - 1, -mouse.y / rect.height * 2 + 1, .5),
                        _v3.unproject(_camera);
                    let pos = _camera.getWorldPosition();
                    _v3.sub(pos).normalize();
                    let dist = -pos.z / _v3.z;
                    return _value.copy(pos).add(_v3.multiplyScalar(dist - distance)),
                        _value
                }
                ,
                this.project = function(pos, screen) {
                    return screen = screen || Stage,
                        pos instanceof Base3D ? (pos.updateMatrixWorld(),
                            _v32.set(0, 0, 0).setFromMatrixPosition(pos.matrixWorld)) : _v32.copy(pos),
                        _v32.project(_camera),
                        _v32.x = (_v32.x + 1) / 2 * screen.width,
                        _v32.y = -(_v32.y - 1) / 2 * screen.height,
                        _v32
                }
        }
    ), (_=>{
            var _screen, _map = new WeakMap;
            ScreenProjection.unproject = function(mouse, distance) {
                return _screen || (_screen = new ScreenProjection(World.CAMERA)),
                    _screen.unproject(mouse, distance)
            }
                ,
                ScreenProjection.project = function(pos, screen) {
                    return _screen || (_screen = new ScreenProjection(World.CAMERA)),
                        _screen.project(pos, screen)
                }
                ,
                ScreenProjection.find = function(camera) {
                    if (!_map.has(camera)) {
                        let projection = new ScreenProjection(camera);
                        _map.set(camera, projection)
                    }
                    return _map.get(camera)
                }
        }
    )),
    Class((function Object3D() {
            Inherit(this, Component);
            var _this = this
                , _visible = !0;
            this.__element = !0,
                this.group = new Group,
                this.group.classRef = this,
                this.add = function(child) {
                    this.group.add(child.group || child)
                }
                ,
                this.remove = function(child) {
                    this.group.remove(child.group || child)
                }
                ,
                this.onDestroy = function() {
                    this.group.deleted = !0,
                        this.group.classRef = null,
                    this.group && this.group.parent && this.group.parent.remove(this.group)
                }
                ,
                this.set("visible", (v=>_this.group.visible = _visible = v)),
                this.get("visible", (_=>_visible))
        }
    )),
    Class((function Utils3D() {
            const _this = this;
            var _emptyTexture, _q, _textures = {};
            window.Vec2 = window.Vector2,
                window.Vec3 = window.Vector3,
                async function() {
                    await Hydra.ready();
                    let threads = Thread.shared(!0);
                    for (let i = 0; i < threads.array.length; i++)
                        _this.loadEngineOnThread(threads.array[i])
                }(),
                this.decompose = function(local, world) {
                    local.matrixWorld.decompose(world.position, world.quaternion, world.scale)
                }
                ,
                this.createDebug = function(size=1, color) {
                    return new Mesh(new IcosahedronGeometry(size,1),_this.getTestShader(color))
                }
                ,
                this.getTestShader = function(color) {
                    return color ? new Shader("ColorMaterial",{
                        color: {
                            value: color instanceof Color ? color : new Color(color)
                        },
                        alpha: {
                            value: 1
                        }
                    }) : new Shader("TestMaterial")
                }
                ,
                this.createMultiRT = function(width, height, type, format) {
                    let rt = new MultiRenderTarget(width,height,{
                        minFilter: Texture.LINEAR,
                        magFilter: Texture.LINEAR,
                        format: format || Texture.RGBFormat,
                        type: type
                    });
                    return rt.texture.generateMipmaps = !1,
                        rt
                }
                ,
                this.createRT = function(width, height, type, format) {
                    let rt = new RenderTarget(width,height,{
                        minFilter: Texture.LINEAR,
                        magFilter: Texture.LINEAR,
                        format: format || Texture.RGBFormat,
                        type: type
                    });
                    return rt.texture.generateMipmaps = !1,
                        rt
                }
                ,
                this.getFloatType = function() {
                    return "android" == Device.system.os ? Texture.FLOAT : Texture.HALF_FLOAT
                }
                ,
                this.getTexture = function(path, params={}) {
                    if (!Device.graphics.webgl && !window.AURA) {
                        let texture = new Texture;
                        return texture.promise = Promise.resolve(),
                            texture.dimensions = {
                                width: 0,
                                height: 0
                            },
                            texture
                    }
                    if (path.includes("://")) {
                        let guard = path.split("://");
                        guard[1] = guard[1].replace(/\/\//g, "/"),
                            path = guard.join("://")
                    } else
                        path = path.replace(/\/\//g, "/");
                    let cacheBust = path.includes("?");
                    if (cacheBust && (path = path.split("?")[0]),
                        _textures[path])
                        _textures[path].exists++;
                    else {
                        let texture = new Texture;
                        texture.exists = 1,
                            texture.loaded = !1,
                            texture.compressed = path.includes("compressedKtx"),
                            texture.promise = Promise.create(),
                            texture._destroy = texture.destroy,
                            texture.destroy = function() {
                                texture.forcePersist || --texture.exists > 0 || (delete _textures[path],
                                    this._destroy())
                            }
                            ,
                            _textures[path] = texture,
                            texture.format = path.match(/jpe?g/) ? Texture.RGBFormat : Texture.RGBAFormat,
                            texture.src = path,
                        !1 === params.premultiplyAlpha && (texture.premultiplyAlpha = !1),
                        _this.onTextureCreated && _this.onTextureCreated(texture);
                        let cb = imgBmp=>{
                            imgBmp.crossOrigin = "anonymous",
                                texture.image = imgBmp,
                                texture.dimensions = {
                                    width: imgBmp.width,
                                    height: imgBmp.height
                                },
                                texture.loaded = !0,
                                texture.needsReupload = !0,
                            Math.isPowerOf2(imgBmp.width, imgBmp.height) || (texture.minFilter = Texture.LINEAR,
                                texture.generateMipmaps = !1),
                            imgBmp.gliFormat && (texture.minFilter = Texture.LINEAR),
                                texture.onUpdate = function() {
                                    !params.preserveData && imgBmp.close && imgBmp.close(),
                                        texture.onUpdate = null
                                }
                                ,
                                texture.promise.resolve(),
                            texture.onload && (texture.onload(),
                                texture.onload = null)
                        }
                            , imgPath = cacheBust ? path + "?" + Date.now() : path;
                        ImageDecoder.decode(imgPath, params).then(cb).catch((e=>{
                                texture.promise.reject(e)
                            }
                        ))
                    }
                    return _textures[path]
                }
                ,
                this.getLookupTexture = function(path) {
                    let texture = _this.getTexture(path);
                    return texture.minFilter = texture.magFilter = Texture.NEAREST,
                        texture.generateMipmaps = !1,
                        texture
                }
                ,
                this.clearTextureCache = function() {
                    for (let key in _textures)
                        _textures[key].destroy();
                    _textures = {}
                }
                ,
                this.loadCurve = function(obj) {
                    "string" == typeof obj && ((obj = Assets.JSON[obj]).curves = obj.curves[0]);
                    let data = obj.curves
                        , points = [];
                    for (let j = 0; j < data.length; j += 3)
                        points.push(new Vector3(data[j + 0],data[j + 1],data[j + 2]));
                    if (!window.CatmullRomCurve)
                        throw "loadCurve requires curve3d module";
                    return new CatmullRomCurve(points)
                }
                ,
                this.getEmptyTexture = function() {
                    return _emptyTexture || (_emptyTexture = new Texture),
                        _emptyTexture
                }
                ,
                this.getRepeatTexture = function(src, scale) {
                    let texture = _this.getTexture(src, scale);
                    return texture.wrapS = texture.wrapT = Texture.REPEAT,
                        texture
                }
                ,
                this.findTexturesByPath = function(path) {
                    let array = [];
                    for (let key in _textures)
                        key.includes(path) && array.push(_textures[key]);
                    return array
                }
                ,
                this.getHeightFromCamera = function(camera, dist) {
                    camera = camera.camera || camera,
                    dist || (dist = camera.position.length());
                    let fov = camera.fov;
                    return 2 * dist * Math.tan(.5 * Math.radians(fov))
                }
                ,
                this.getPositionFromCameraSize = function(camera, size) {
                    camera = camera.camera || camera;
                    let fov = Math.radians(camera.fov);
                    return Math.abs(size / Math.sin(fov / 2))
                }
                ,
                this.loadEngineOnThread = function(thread) {
                    ["Base3D", "CameraBase3D", "Mesh", "OrthographicCamera", "PerspectiveCamera", "Geometry", "GeometryAttribute", "Points", "Scene", "BoxGeometry", "CylinderGeometry", "PlaneGeometry", "PolyhedronGeometry", "IcosahedronGeometry", "SphereGeometry", "Box2", "Box3", "Face3", "Color", "Cylindrical", "Euler", "Frustum", "Line3", "Matrix3", "Matrix4", "Plane", "Quaternion", "Ray", "Sphere", "Spherical", "Triangle", "Vector2", "Vector3", "Vector4", "RayManager", "Vector3D", "Group"].forEach((name=>{
                            thread.importES6Class(name)
                        }
                    )),
                        thread.importCode(`Class(${zUtils3D.constructor.toString()}, 'static')`)
                }
                ,
                this.billboard = function(mesh, camera=World.CAMERA) {
                    _q || (_q = new Quaternion),
                        mesh._parent ? (mesh._parent.getWorldQuaternion(_q).inverse(),
                            _q.multiply(camera.quaternion),
                            mesh.quaternion.copy(_q)) : mesh.quaternion.copy(camera.quaternion)
                }
                ,
                this.getQuad = function() {
                    let geom = new Geometry
                        , position = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
                        , uv = new Float32Array([0, 0, 2, 0, 0, 2]);
                    return geom.addAttribute("position", new GeometryAttribute(position,3)),
                        geom.addAttribute("uv", new GeometryAttribute(uv,2)),
                        geom
                }
        }
    ), "static"),
window.WebGLRenderingContext && function() {
    "use strict";
    var e = {};
    function r(r, t) {
        var i;
        e[r] = !0,
        void 0 !== t && (i = t,
        window.console && window.console.error && window.console.error(i))
    }
    var t = function e(r) {
        var t = r.gl;
        this.ext = r,
            this.isAlive = !0,
            this.hasBeenBound = !1,
            this.elementArrayBuffer = null,
            this.attribs = new Array(r.maxVertexAttribs);
        for (var i = 0; i < this.attribs.length; i++) {
            var a = new e.VertexAttrib(t);
            this.attribs[i] = a
        }
        this.maxAttrib = 0
    };
    (t.VertexAttrib = function(e) {
            this.enabled = !1,
                this.buffer = null,
                this.size = 4,
                this.type = e.FLOAT,
                this.normalized = !1,
                this.stride = 16,
                this.offset = 0,
                this.cached = "",
                this.recache()
        }
    ).prototype.recache = function() {
        this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":")
    }
    ;
    var i = function(r) {
        var t, i, a = this;
        this.gl = r,
            i = (t = r).getError,
            t.getError = function() {
                do {
                    (r = i.apply(t)) != t.NO_ERROR && (e[r] = !0)
                } while (r != t.NO_ERROR);
                for (var r in e)
                    if (e[r])
                        return delete e[r],
                            parseInt(r);
                return t.NO_ERROR
            }
        ;
        var n = this.original = {
            getParameter: r.getParameter,
            enableVertexAttribArray: r.enableVertexAttribArray,
            disableVertexAttribArray: r.disableVertexAttribArray,
            bindBuffer: r.bindBuffer,
            getVertexAttrib: r.getVertexAttrib,
            vertexAttribPointer: r.vertexAttribPointer
        };
        r.getParameter = function(e) {
            return e == a.VERTEX_ARRAY_BINDING_OES ? a.currentVertexArrayObject == a.defaultVertexArrayObject ? null : a.currentVertexArrayObject : n.getParameter.apply(this, arguments)
        }
            ,
            r.enableVertexAttribArray = function(e) {
                var r = a.currentVertexArrayObject;
                return r.maxAttrib = Math.max(r.maxAttrib, e),
                    r.attribs[e].enabled = !0,
                    n.enableVertexAttribArray.apply(this, arguments)
            }
            ,
            r.disableVertexAttribArray = function(e) {
                var r = a.currentVertexArrayObject;
                return r.maxAttrib = Math.max(r.maxAttrib, e),
                    r.attribs[e].enabled = !1,
                    n.disableVertexAttribArray.apply(this, arguments)
            }
            ,
            r.bindBuffer = function(e, t) {
                switch (e) {
                    case r.ARRAY_BUFFER:
                        a.currentArrayBuffer = t;
                        break;
                    case r.ELEMENT_ARRAY_BUFFER:
                        a.currentVertexArrayObject.elementArrayBuffer = t
                }
                return n.bindBuffer.apply(this, arguments)
            }
            ,
            r.getVertexAttrib = function(e, t) {
                var i = a.currentVertexArrayObject.attribs[e];
                switch (t) {
                    case r.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                        return i.buffer;
                    case r.VERTEX_ATTRIB_ARRAY_ENABLED:
                        return i.enabled;
                    case r.VERTEX_ATTRIB_ARRAY_SIZE:
                        return i.size;
                    case r.VERTEX_ATTRIB_ARRAY_STRIDE:
                        return i.stride;
                    case r.VERTEX_ATTRIB_ARRAY_TYPE:
                        return i.type;
                    case r.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                        return i.normalized;
                    default:
                        return n.getVertexAttrib.apply(this, arguments)
                }
            }
            ,
            r.vertexAttribPointer = function(e, r, t, i, s, A) {
                var o = a.currentVertexArrayObject;
                o.maxAttrib = Math.max(o.maxAttrib, e);
                var c = o.attribs[e];
                return c.buffer = a.currentArrayBuffer,
                    c.size = r,
                    c.type = t,
                    c.normalized = i,
                    c.stride = s,
                    c.offset = A,
                    c.recache(),
                    n.vertexAttribPointer.apply(this, arguments)
            }
            ,
        r.instrumentExtension && r.instrumentExtension(this, "OES_vertex_array_object"),
            r.canvas.addEventListener("webglcontextrestored", (function() {
                    window.console && window.console.log && window.console.log("OESVertexArrayObject emulation library context restored"),
                        a.reset_()
                }
            ), !0),
            this.reset_()
    };
    i.prototype.VERTEX_ARRAY_BINDING_OES = 34229,
        i.prototype.reset_ = function() {
            if (void 0 !== this.vertexArrayObjects)
                for (var e = 0; e < this.vertexArrayObjects.length; ++e)
                    this.vertexArrayObjects.isAlive = !1;
            var r = this.gl;
            this.maxVertexAttribs = r.getParameter(r.MAX_VERTEX_ATTRIBS),
                this.defaultVertexArrayObject = new t(this),
                this.currentVertexArrayObject = null,
                this.currentArrayBuffer = null,
                this.vertexArrayObjects = [this.defaultVertexArrayObject],
                this.bindVertexArrayOES(null)
        }
        ,
        i.prototype.createVertexArrayOES = function() {
            var e = new t(this);
            return this.vertexArrayObjects.push(e),
                e
        }
        ,
        i.prototype.deleteVertexArrayOES = function(e) {
            e.isAlive = !1,
                this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e), 1),
            this.currentVertexArrayObject == e && this.bindVertexArrayOES(null)
        }
        ,
        i.prototype.isVertexArrayOES = function(e) {
            return !!(e && e instanceof t && e.hasBeenBound && e.ext == this)
        }
        ,
        i.prototype.bindVertexArrayOES = function(e) {
            var t = this.gl;
            if (!e || e.isAlive) {
                var i = this.original
                    , a = this.currentVertexArrayObject;
                this.currentVertexArrayObject = e || this.defaultVertexArrayObject,
                    this.currentVertexArrayObject.hasBeenBound = !0;
                var n = this.currentVertexArrayObject;
                if (a != n) {
                    a && n.elementArrayBuffer == a.elementArrayBuffer || i.bindBuffer.call(t, t.ELEMENT_ARRAY_BUFFER, n.elementArrayBuffer);
                    for (var s = this.currentArrayBuffer, A = Math.max(a ? a.maxAttrib : 0, n.maxAttrib), o = 0; o <= A; o++) {
                        var c = n.attribs[o]
                            , b = a ? a.attribs[o] : null;
                        if (a && c.enabled == b.enabled || (c.enabled ? i.enableVertexAttribArray.call(t, o) : i.disableVertexAttribArray.call(t, o)),
                            c.enabled) {
                            var u = !1;
                            a && c.buffer == b.buffer || (s != c.buffer && (i.bindBuffer.call(t, t.ARRAY_BUFFER, c.buffer),
                                s = c.buffer),
                                u = !0),
                            (u || c.cached != b.cached) && i.vertexAttribPointer.call(t, o, c.size, c.type, c.normalized, c.stride, c.offset)
                        }
                    }
                    this.currentArrayBuffer != s && i.bindBuffer.call(t, t.ARRAY_BUFFER, this.currentArrayBuffer)
                }
            } else
                r(t.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject")
        }
        ,
        function() {
            var e = WebGLRenderingContext.prototype.getSupportedExtensions;
            WebGLRenderingContext.prototype.getSupportedExtensions = function() {
                var r = e.call(this) || [];
                return r.indexOf("OES_vertex_array_object") < 0 && r.push("OES_vertex_array_object"),
                    r
            }
            ;
            var r = WebGLRenderingContext.prototype.getExtension;
            WebGLRenderingContext.prototype.getExtension = function(e) {
                return r.call(this, e) || ("OES_vertex_array_object" !== e ? null : (this.__OESVertexArrayObject || (console.log("Setup OES_vertex_array_object polyfill"),
                    this.__OESVertexArrayObject = new i(this)),
                    this.__OESVertexArrayObject))
            }
        }()
}(),
    window.DebugControls = function(object, domElement) {
        var offset, quat, quatInverse, lastPosition, lastQuaternion;
        this.object = object,
            this.domElement = void 0 !== domElement ? domElement : document,
            this.enabled = !0,
            this.target = new Vector3,
            this.minDistance = 0,
            this.maxDistance = 1 / 0,
            this.minZoom = 0,
            this.maxZoom = 1 / 0,
            this.minPolarAngle = 0,
            this.maxPolarAngle = Math.PI,
            this.minAzimuthAngle = -1 / 0,
            this.maxAzimuthAngle = 1 / 0,
            this.enableDamping = !0,
            this.dampingFactor = .1,
            this.enableZoom = !0,
            this.zoomSpeed = 1,
            this.enableRotate = !0,
            this.rotateSpeed = .1,
            this.enablePan = !0,
            this.keyPanSpeed = 7,
            this.autoRotate = !1,
            this.autoRotateSpeed = 2,
            this.enableKeys = !1,
            this.keys = {
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                BOTTOM: 40
            },
            this.mouseButtons = {
                ORBIT: 0,
                ZOOM: 2,
                PAN: 1
            },
            this.target0 = this.target.clone(),
            this.position0 = this.object.position.clone(),
            this.zoom0 = this.object.zoom,
            this.getPolarAngle = function() {
                return spherical.phi
            }
            ,
            this.getAzimuthalAngle = function() {
                return spherical.theta
            }
            ,
            this.reset = function() {
                scope.target.copy(scope.target0),
                    scope.object.position.copy(scope.position0),
                    scope.object.zoom = scope.zoom0,
                    scope.object.updateProjectionMatrix(),
                    scope.update(),
                    state = STATE.NONE
            }
            ,
            this.update = (offset = new Vector3,
                    quat = (new Quaternion).setFromUnitVectors(object.up, new Vector3(0,1,0)),
                    quatInverse = quat.clone().inverse(),
                    lastPosition = new Vector3,
                    lastQuaternion = new Quaternion,
                    function update() {
                        var position = scope.object.position;
                        return offset.copy(position).sub(scope.target),
                            offset.applyQuaternion(quat),
                            spherical.setFromVector3(offset),
                        scope.autoRotate && state === STATE.NONE && rotateLeft(function getAutoRotationAngle() {
                            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed
                        }()),
                            spherical.theta += sphericalDelta.theta,
                            spherical.phi += sphericalDelta.phi,
                            spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta)),
                            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi)),
                            spherical.makeSafe(),
                            spherical.radius *= scale,
                            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)),
                            scope.target.add(panOffset),
                            offset.setFromSpherical(spherical),
                            offset.applyQuaternion(quatInverse),
                            position.copy(scope.target).add(offset),
                            scope.object.lookAt(scope.target),
                            !0 === scope.enableDamping ? (sphericalDelta.theta *= 1 - scope.dampingFactor,
                                sphericalDelta.phi *= 1 - scope.dampingFactor) : sphericalDelta.set(0, 0, 0),
                            scale = 1,
                            panOffset.set(0, 0, 0),
                        !!(zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) && (lastPosition.copy(scope.object.position),
                            lastQuaternion.copy(scope.object.quaternion),
                            zoomChanged = !1,
                            !0)
                    }
            ),
            this.dispose = function() {
                scope.domElement.removeEventListener("contextmenu", onContextMenu, !1),
                    scope.domElement.removeEventListener("mousedown", onMouseDown, !1),
                    scope.domElement.removeEventListener("mousewheel", onMouseWheel, !1),
                    scope.domElement.removeEventListener("MozMousePixelScroll", onMouseWheel, !1),
                    scope.domElement.removeEventListener("touchstart", onTouchStart, !1),
                    scope.domElement.removeEventListener("touchend", onTouchEnd, !1),
                    scope.domElement.removeEventListener("touchmove", onTouchMove, !1),
                    document.removeEventListener("mousemove", onMouseMove, !1),
                    document.removeEventListener("mouseup", onMouseUp, !1),
                    window.removeEventListener("keydown", onKeyDown, !1)
            }
        ;
        var scope = this
            , STATE = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_DOLLY: 4,
            TOUCH_PAN: 5
        }
            , state = STATE.NONE
            , EPS = 1e-6
            , spherical = new Spherical
            , sphericalDelta = new Spherical
            , scale = 1
            , panOffset = new Vector3
            , zoomChanged = !1
            , rotateStart = new Vector2
            , rotateEnd = new Vector2
            , rotateDelta = new Vector2
            , panStart = new Vector2
            , panEnd = new Vector2
            , panDelta = new Vector2
            , dollyStart = new Vector2
            , dollyEnd = new Vector2
            , dollyDelta = new Vector2;
        function getZoomScale() {
            return Math.pow(.95, scope.zoomSpeed)
        }
        function rotateLeft(angle) {
            sphericalDelta.theta -= angle
        }
        function rotateUp(angle) {
            sphericalDelta.phi -= angle
        }
        var v, panLeft = (v = new Vector3,
                function panLeft(distance, objectMatrix) {
                    v.setFromMatrixColumn(objectMatrix, 0),
                        v.multiplyScalar(-distance),
                        panOffset.add(v)
                }
        ), panUp = function() {
            var v = new Vector3;
            return function panUp(distance, objectMatrix) {
                v.setFromMatrixColumn(objectMatrix, 1),
                    v.multiplyScalar(distance),
                    panOffset.add(v)
            }
        }(), pan = function() {
            var offset = new Vector3;
            return function pan(deltaX, deltaY) {
                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                if (scope.object instanceof PerspectiveCamera) {
                    var position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    var targetDistance = offset.length();
                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180),
                        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix),
                        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix)
                } else
                    scope.object instanceof OrthographicCamera ? (panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix),
                        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                        scope.enablePan = !1)
            }
        }();
        function dollyIn(dollyScale) {
            scope.object instanceof PerspectiveCamera ? scale /= dollyScale : scope.object instanceof OrthographicCamera ? (scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale)),
                scope.object.updateProjectionMatrix(),
                zoomChanged = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                scope.enableZoom = !1)
        }
        function dollyOut(dollyScale) {
            scope.object instanceof PerspectiveCamera ? scale *= dollyScale : scope.object instanceof OrthographicCamera ? (scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale)),
                scope.object.updateProjectionMatrix(),
                zoomChanged = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                scope.enableZoom = !1)
        }
        function onMouseDown(event) {
            if (!1 !== scope.enabled) {
                if (event.preventDefault(),
                event.button === scope.mouseButtons.ORBIT) {
                    if (!1 === scope.enableRotate)
                        return;
                    !function handleMouseDownRotate(event) {
                        rotateStart.set(event.clientX, event.clientY)
                    }(event),
                        state = STATE.ROTATE
                } else if (event.button === scope.mouseButtons.ZOOM) {
                    if (!1 === scope.enableZoom)
                        return;
                    !function handleMouseDownDolly(event) {
                        dollyStart.set(event.clientX, event.clientY)
                    }(event),
                        state = STATE.DOLLY
                } else if (event.button === scope.mouseButtons.PAN) {
                    if (!1 === scope.enablePan)
                        return;
                    !function handleMouseDownPan(event) {
                        panStart.set(event.clientX, event.clientY)
                    }(event),
                        state = STATE.PAN
                }
                state !== STATE.NONE && (document.addEventListener("mousemove", onMouseMove, !1),
                    document.addEventListener("mouseup", onMouseUp, !1))
            }
        }
        function onMouseMove(event) {
            if (!1 !== scope.enabled)
                if (event.preventDefault(),
                state === STATE.ROTATE) {
                    if (!1 === scope.enableRotate)
                        return;
                    !function handleMouseMoveRotate(event) {
                        rotateEnd.set(event.clientX, event.clientY),
                            rotateDelta.subVectors(rotateEnd, rotateStart);
                        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed),
                            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed),
                            rotateStart.copy(rotateEnd),
                            scope.update()
                    }(event)
                } else if (state === STATE.DOLLY) {
                    if (!1 === scope.enableZoom)
                        return;
                    !function handleMouseMoveDolly(event) {
                        dollyEnd.set(event.clientX, event.clientY),
                            dollyDelta.subVectors(dollyEnd, dollyStart),
                            dollyDelta.y > 0 ? dollyIn(getZoomScale()) : dollyDelta.y < 0 && dollyOut(getZoomScale()),
                            dollyStart.copy(dollyEnd),
                            scope.update()
                    }(event)
                } else if (state === STATE.PAN) {
                    if (!1 === scope.enablePan)
                        return;
                    !function handleMouseMovePan(event) {
                        panEnd.set(event.clientX, event.clientY),
                            panDelta.subVectors(panEnd, panStart),
                            pan(panDelta.x, panDelta.y),
                            panStart.copy(panEnd),
                            scope.update(),
                        scope.onChange && scope.onChange()
                    }(event)
                }
        }
        function onMouseUp(event) {
            !1 !== scope.enabled && (document.removeEventListener("mousemove", onMouseMove, !1),
                document.removeEventListener("mouseup", onMouseUp, !1),
            scope.onChange && scope.onChange(),
                state = STATE.NONE)
        }
        function onMouseWheel(event) {
            !1 === scope.enabled || !1 === scope.enableZoom || state !== STATE.NONE && state !== STATE.ROTATE || (event.preventDefault(),
                event.stopPropagation(),
                function handleMouseWheel(event) {
                    var delta = 0;
                    void 0 !== event.wheelDelta ? delta = event.wheelDelta : void 0 !== event.detail && (delta = -event.detail),
                        delta > 0 ? dollyOut(getZoomScale()) : delta < 0 && dollyIn(getZoomScale()),
                        scope.update()
                }(event),
            scope.onChange && scope.onChange())
        }
        function onKeyDown(event) {
            !1 !== scope.enabled && !1 !== scope.enableKeys && !1 !== scope.enablePan && function handleKeyDown(event) {
                switch (event.keyCode) {
                    case scope.keys.UP:
                        pan(0, scope.keyPanSpeed),
                            scope.update();
                        break;
                    case scope.keys.BOTTOM:
                        pan(0, -scope.keyPanSpeed),
                            scope.update();
                        break;
                    case scope.keys.LEFT:
                        pan(scope.keyPanSpeed, 0),
                            scope.update();
                        break;
                    case scope.keys.RIGHT:
                        pan(-scope.keyPanSpeed, 0),
                            scope.update()
                }
            }(event)
        }
        function onTouchStart(event) {
            if (!1 !== scope.enabled) {
                switch (event.touches.length) {
                    case 1:
                        if (!1 === scope.enableRotate)
                            return;
                        !function handleTouchStartRotate(event) {
                            rotateStart.set(event.touches[0].pageX, event.touches[0].pageY)
                        }(event),
                            state = STATE.TOUCH_ROTATE;
                        break;
                    case 2:
                        if (!1 === scope.enableZoom)
                            return;
                        !function handleTouchStartDolly(event) {
                            var dx = event.touches[0].pageX - event.touches[1].pageX
                                , dy = event.touches[0].pageY - event.touches[1].pageY
                                , distance = Math.sqrt(dx * dx + dy * dy);
                            dollyStart.set(0, distance)
                        }(event),
                            state = STATE.TOUCH_DOLLY;
                        break;
                    case 3:
                        if (!1 === scope.enablePan)
                            return;
                        !function handleTouchStartPan(event) {
                            panStart.set(event.touches[0].pageX, event.touches[0].pageY)
                        }(event),
                            state = STATE.TOUCH_PAN;
                        break;
                    default:
                        state = STATE.NONE
                }
                STATE.NONE
            }
        }
        function onTouchMove(event) {
            if (!1 !== scope.enabled)
                switch (event.preventDefault(),
                    event.stopPropagation(),
                    event.touches.length) {
                    case 1:
                        if (!1 === scope.enableRotate)
                            return;
                        if (state !== STATE.TOUCH_ROTATE)
                            return;
                        !function handleTouchMoveRotate(event) {
                            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY),
                                rotateDelta.subVectors(rotateEnd, rotateStart);
                            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed),
                                rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed),
                                rotateStart.copy(rotateEnd),
                                scope.update()
                        }(event);
                        break;
                    case 2:
                        if (!1 === scope.enableZoom)
                            return;
                        if (state !== STATE.TOUCH_DOLLY)
                            return;
                        !function handleTouchMoveDolly(event) {
                            var dx = event.touches[0].pageX - event.touches[1].pageX
                                , dy = event.touches[0].pageY - event.touches[1].pageY
                                , distance = Math.sqrt(dx * dx + dy * dy);
                            dollyEnd.set(0, distance),
                                dollyDelta.subVectors(dollyEnd, dollyStart),
                                dollyDelta.y > 0 ? dollyOut(getZoomScale()) : dollyDelta.y < 0 && dollyIn(getZoomScale()),
                                dollyStart.copy(dollyEnd),
                                scope.update()
                        }(event);
                        break;
                    case 3:
                        if (!1 === scope.enablePan)
                            return;
                        if (state !== STATE.TOUCH_PAN)
                            return;
                        !function handleTouchMovePan(event) {
                            panEnd.set(event.touches[0].pageX, event.touches[0].pageY),
                                panDelta.subVectors(panEnd, panStart),
                                pan(panDelta.x, panDelta.y),
                                panStart.copy(panEnd),
                                scope.update()
                        }(event);
                        break;
                    default:
                        state = STATE.NONE
                }
        }
        function onTouchEnd(event) {
            !1 !== scope.enabled && (scope.onChange && scope.onChange(),
                state = STATE.NONE)
        }
        function onContextMenu(event) {}
        scope.domElement.addEventListener("contextmenu", onContextMenu, !1),
            scope.domElement.addEventListener("mousedown", onMouseDown, !1),
            scope.domElement.addEventListener("mousewheel", onMouseWheel, !1),
            scope.domElement.addEventListener("MozMousePixelScroll", onMouseWheel, !1),
            scope.domElement.addEventListener("touchstart", onTouchStart, !1),
            scope.domElement.addEventListener("touchend", onTouchEnd, !1),
            scope.domElement.addEventListener("touchmove", onTouchMove, !1),
            window.addEventListener("keydown", onKeyDown, !1),
            this.update()
    }
    ,
    Class((function GeomThread() {
            Inherit(this, Component);
            const _this = this;
            var _cache = {}
                , _cacheWait = {}
                , _receive = {};
            function computeBounding(data) {
                let geom = new Geometry;
                geom.addAttribute("position", new GeometryAttribute(data.position,3)),
                    geom.computeBoundingBox(),
                    geom.computeBoundingSphere(),
                    data.boundingBox = geom.boundingBox,
                    data.boundingSphere = geom.boundingSphere
            }
            function loadGeometry(e, id) {
                get(e.path).then((data=>{
                        let buffers = [];
                        for (let key in data)
                            Array.isArray(data[key]) ? (data[key] = new Float32Array(data[key]),
                                buffers.push(data[key].buffer)) : data[key].length > 0 && buffers.push(data[key].buffer);
                        computeBounding(data),
                        e.custom && self[e.custom](data),
                            resolve(data, id, buffers)
                    }
                )).catch((er=>{
                        e.preloading || console.error(er)
                    }
                ))
            }
            function loadSkinnedGeometry(e, id) {
                get(e.path).then((data=>{
                        let buffers = [];
                        for (let key in data)
                            "bones" != key && (Array.isArray(data[key]) ? (data[key] = new Float32Array(data[key]),
                                buffers.push(data[key].buffer)) : data[key].length > 0 && buffers.push(data[key].buffer));
                        computeBounding(data),
                        e.custom && self[e.custom](data),
                            resolve(data, id, buffers)
                    }
                ))
            }
            function geom_useFn(e) {
                Global.FNS || (Global.FNS = []),
                    Global.FNS.push(e.name)
            }
            this.caching = !0,
                async function() {
                    await Hydra.ready(),
                        Thread.upload(loadGeometry, loadSkinnedGeometry, geom_useFn, computeBounding)
                }(),
                this.loadGeometry = function(path, custom, preloading) {
                    if (!Device.graphics.gpu)
                        return Promise.resolve(new PlaneGeometry(1,1));
                    if (_cache[path])
                        return Promise.resolve(_cache[path]);
                    if (path.includes("assets/geometry/") || (path = "assets/geometry/" + path),
                    path.includes(".") || (path += ".json"),
                        path = Thread.absolutePath(Assets.getPath(path)),
                        _this.caching) {
                        if (_cacheWait[path])
                            return _cacheWait[path];
                        _cacheWait[path] = Promise.create()
                    }
                    return Thread.shared().loadGeometry({
                        path: path,
                        custom: custom,
                        preloading: preloading
                    }).then((data=>{
                            let geometry;
                            if (custom && _receive[custom])
                                geometry = _receive[custom](data);
                            else {
                                let geom = new Geometry;
                                geom.addAttribute("position", new GeometryAttribute(data.position,3)),
                                    geom.addAttribute("normal", new GeometryAttribute(data.normal || data.position.length,3)),
                                    geom.addAttribute("uv", new GeometryAttribute(data.uv || data.position.length / 3 * 2,2)),
                                data.uv2 && geom.addAttribute("uv2", new GeometryAttribute(data.uv2,2)),
                                    geom.boundingBox = new Box3((new Vector3).set(data.boundingBox.min.x, data.boundingBox.min.y, data.boundingBox.min.z),(new Vector3).set(data.boundingBox.max.x, data.boundingBox.max.y, data.boundingBox.max.z)),
                                    geom.boundingSphere = new Sphere((new Vector3).set(data.boundingSphere.center.x, data.boundingSphere.center.y, data.boundingSphere.center.z),data.boundingSphere.radius),
                                    geometry = geom,
                                    geom._src = path
                            }
                            _this.caching && (_cache[path] = geometry),
                                _cacheWait[path].resolve(geometry)
                        }
                    )),
                        _cacheWait[path]
                }
                ,
                this.loadSkinnedGeometry = function(path, custom) {
                    if (!Device.graphics.webgl)
                        return Promise.resolve(new PlaneGeometry(1,1));
                    if (_cache[path])
                        return Promise.resolve(_cache[path]);
                    if (path.includes("assets/geometry/") || (path = "assets/geometry/" + path),
                    path.includes(".") || (path += ".json"),
                        path = Thread.absolutePath(Assets.getPath(path)),
                        _this.caching) {
                        if (_cacheWait[path])
                            return _cacheWait[path];
                        _cacheWait[path] = Promise.create()
                    }
                    return Thread.shared().loadSkinnedGeometry({
                        path: path,
                        custom: custom
                    }).then((data=>{
                            let geometry;
                            if (custom && _receive[custom])
                                geometry = _receive[custom](data);
                            else {
                                let geom = new Geometry;
                                geom.addAttribute("position", new GeometryAttribute(data.position,3)),
                                    geom.addAttribute("normal", new GeometryAttribute(data.normal || data.position.length,3)),
                                    geom.addAttribute("uv", new GeometryAttribute(data.uv || data.position.length / 3 * 2,2)),
                                    geom.addAttribute("skinIndex", new GeometryAttribute(data.skinIndex,4)),
                                    geom.addAttribute("skinWeight", new GeometryAttribute(data.skinWeight,4)),
                                    geom.bones = (data.rig ? data.rig.bones : data.bones).slice(0),
                                    geom.boundingBox = new Box3((new Vector3).set(data.boundingBox.min.x, data.boundingBox.min.y, data.boundingBox.min.z),(new Vector3).set(data.boundingBox.max.x, data.boundingBox.max.y, data.boundingBox.max.z)),
                                    geom.boundingSphere = new Sphere((new Vector3).set(data.boundingSphere.center.x, data.boundingSphere.center.y, data.boundingSphere.center.z),data.boundingSphere.radius),
                                    geometry = geom,
                                    geom._src = path
                            }
                            _this.caching && (_cache[path] = geometry),
                                _cacheWait[path].resolve(geometry)
                        }
                    )),
                        _cacheWait[path]
                }
                ,
                this.customFunction = function(fn, receive) {
                    let name = Thread.upload(fn);
                    name = name[0],
                        t.geom_useFn({
                            name: name
                        }),
                        _receive[name] = receive
                }
        }
    ), "static"),
    Class((function InstanceMesh(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            const _this = this;
            var _config, _shaderKey;
            function updateShader(shader) {
                let prefetchCode = Shaders.getShader(shader.vsName + ".vs");
                if (prefetchCode && prefetchCode.includes("transformPosition(vec3 position"))
                    return;
                shader.customCompile = `${shader.vsName}|${shader.fsName}|instance`,
                    shader.resetProgram();
                let cached = MeshBatch.shaders[`${shader.vsName}|${shader.fsName}`];
                if (cached)
                    return shader.fragmentShader = cached.fragment,
                        void (shader.vertexShader = cached.vertex);
                let vsSplit = shader.vertexShader.split("__ACTIVE_THEORY_LIGHTS__")
                    , fsSplit = shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__");
                if (!vsSplit[1].includes("vec3 pos = position;"))
                    throw `Shader ${shader.vsName} needs to have "vec3 pos = position;" in order for batching to work`;
                vsSplit[1] = vsSplit[1].replace(/vec3 pos = position;/g, "vec3 pos = transformPosition(position, offset, scale, orientation);"),
                    vsSplit[1] = vsSplit[1].replace(/vNormal = normalMatrix \* normal;/g, "vNormal = normalMatrix * transformNormal(normal, orientation);"),
                    vsSplit[1] = vsSplit[1].replace(/vec3 transformedNormal = normal;/g, "vec3 transformedNormal = transformNormal(normal, orientation);"),
                    vsSplit[0] += "\n",
                    vsSplit[0] += "#define INSTANCED 1\n",
                    vsSplit[0] += "attribute vec3 offset;\n",
                    vsSplit[0] += "attribute vec3 scale;\n",
                    vsSplit[0] += "attribute vec4 orientation;\n",
                    vsSplit[0] += Shaders.getShader("instance.vs") + "\n",
                    vsSplit = vsSplit.join("__ACTIVE_THEORY_LIGHTS__"),
                    fsSplit = fsSplit.join("__ACTIVE_THEORY_LIGHTS__"),
                    shader.vertexShader = vsSplit,
                    shader.fragmentShader = fsSplit,
                    _shaderKey = `${shader.vsName}|${shader.fsName}`,
                    MeshBatch.shaders[_shaderKey] = {
                        fragment: shader.fragmentShader,
                        vertex: shader.vertexShader
                    }
            }
            !function() {
                if ((_config = InputUIL.create("im_" + _input.prefix, _group)).add("json"),
                    _config.setLabel("Instance"),
                !1 === _input.get("visible"))
                    return;
                _mesh.visible = !1,
                    _mesh.instanceMeshReady = Promise.create(),
                    _mesh.instanceMeshBeforeReady = Promise.create();
                let json = _config.get("json");
                json && async function createInstanceMesh(json) {
                    json.includes("assets/geometry") || (json = `assets/geometry/${json}`);
                    json.includes(".json") || (json += ".json");
                    let geom = (new Geometry).instanceFrom(_mesh.geometry)
                        , buffers = await Thread.shared().parseInstanceMesh({
                        url: Thread.absolutePath(Assets.getPath(json))
                    });
                    for (let key in buffers) {
                        let b = buffers[key];
                        geom.addAttribute(key, new GeometryAttribute(b.buffer,b.components,1))
                    }
                    _this.maxInstancedCount = geom.maxInstancedCount;
                    let shader = _mesh.shader;
                    updateShader(shader);
                    let mesh = new Mesh(geom,shader);
                    mesh.renderOrder = _mesh.renderOrder,
                        mesh.castShadow = _mesh.castShadow,
                        mesh.frustumCulled = !1,
                        _mesh._parent.add(mesh),
                        _mesh.instanceMesh = mesh,
                        _mesh.instanceMeshReady.resolve(),
                        _this.startRender((_=>{
                                mesh.renderOrder = _mesh.renderOrder,
                                    mesh.castShadow = _mesh.castShadow,
                                    mesh.geometry.maxInstancedCount = _this.maxInstancedCount
                            }
                        ), 10)
                }(json)
            }(),
                this.applyToShader = function(shader) {
                    updateShader(shader)
                }
                ,
                this.onDestroy = function() {
                    _mesh.instanceMesh && _mesh.instanceMesh.destroy(),
                        delete MeshBatch.shaders[_shaderKey]
                }
                ,
                this.set("frustumCulled", (async _=>{
                        await _mesh.instanceMeshReady;
                        let buffers = []
                            , obj = {};
                        for (let key in _mesh.instanceMesh.geometry.attributes) {
                            if (!key.includes(["position", "scale", "offset", "orientation"]))
                                continue;
                            let attrib = _mesh.instanceMesh.geometry.attributes[key]
                                , array = new Float32Array(attrib.array);
                            obj[key] = array,
                                buffers.push(array.buffer)
                        }
                        let bounding = await Thread.shared().generateBoundingInstanceMesh(obj, buffers);
                        _mesh.instanceMesh.geometry.boundingBox = bounding.boundingBox,
                            _mesh.instanceMesh.geometry.boundingSphere = bounding.boundingSphere,
                            _mesh.instanceMesh.frustumCulled = !0
                    }
                ))
        }
    ), (_=>{
            Thread.upload((function parseInstanceMesh({url: url}, id) {
                    get(url).then((data=>{
                            let buffers = [];
                            for (let key in data)
                                data[key].buffer = new Float32Array(data[key].buffer),
                                    buffers.push(data[key].buffer.buffer);
                            resolve(data, id, buffers)
                        }
                    ))
                }
            )),
                Thread.upload((function generateBoundingInstanceMesh(e, id) {
                        let geom = new Geometry;
                        geom.addAttribute("position", new GeometryAttribute(e.position,3));
                        let box = new Box3
                            , mesh = new Mesh(geom)
                            , count = e.offset.length / 3;
                        for (let i = 0; i < count; i++)
                            mesh.position.fromArray(e.offset, 3 * i),
                                mesh.quaternion.fromArray(e.orientation, 4 * i),
                                mesh.scale.fromArray(e.scale, 3 * i),
                                box.expandByObject(mesh);
                        let boundingBox = box
                            , boundingSphere = box.getBoundingSphere();
                        resolve({
                            boundingBox: boundingBox,
                            boundingSphere: boundingSphere
                        }, id)
                    }
                ))
        }
    )),
    Class((function MeshBatch(_input) {
            Inherit(this, Object3D);
            const _this = this;
            var _geom, _blankShader, _shader, _mesh, _firstRender, _static, _renderOrder = 0, _objects = [], _offset = [], _quaternion = [], _scale = [], _attributes = {}, _uniformToAttrib = [];
            async function initFromSceneLayout() {
                let wildcard = _input.get("wildcard");
                if (!wildcard || !wildcard.length)
                    return;
                let groupName = wildcard.split("|")[0]
                    , group = await _this.parent.getLayer(groupName);
                await _this.wait(group.children, "length");
                let children = [...group.children];
                children.sort(((a,b)=>a.renderOrder - b.renderOrder)),
                    children.forEach((mesh=>_this.add(mesh))),
                wildcard.includes("static") && (_this.static = !0),
                    _this.group.renderOrder = children[0].renderOrder,
                    group.add(_this.group)
            }
            function updateShader(shader) {
                shader.customCompile = `${shader.vsName}|${shader.fsName}|instance`;
                let cached = MeshBatch.shaders[`${shader.vsName}|${shader.fsName}`];
                if (cached)
                    return shader.fragmentShader = cached.fragment,
                        shader.vertexShader = cached.vertex,
                        shader.resetProgram();
                if (shader.vertexShader && shader.vertexShader.includes("transformPosition"))
                    return;
                shader.resetProgram();
                let vsSplit = shader.vertexShader.split("__ACTIVE_THEORY_LIGHTS__")
                    , fsSplit = shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__");
                if (!vsSplit[1].includes("vec3 pos = position;"))
                    throw `Shader ${shader.vsName} needs to have "vec3 pos = position;" in order for batching to work`;
                let definitions = [];
                vsSplit[1].split("\n").forEach((line=>{
                        if (line.includes("uniform")) {
                            if (line.includes("sampler2D"))
                                return;
                            let data = line.split(" ")
                                , uni = data[2].replace(";", "");
                            (function uniformToAttrib(key) {
                                    for (let i = 0; i < _uniformToAttrib.length; i++) {
                                        let val = _uniformToAttrib[i];
                                        if (key.includes(val) || val.includes(key))
                                            return !0
                                    }
                                    return !1
                                }
                            )(uni) && (definitions.push(`${uni} = a_${data[2]}`),
                                vsSplit[1] = vsSplit[1].replace(line, `attribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}`),
                                fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`))
                        }
                    }
                )),
                    vsSplit[1] = vsSplit[1].replace(/vec3 pos = position;/g, "vec3 pos = transformPosition(position, offset, scale, orientation);"),
                    vsSplit[1] = vsSplit[1].replace(/vNormal = normalMatrix \* normal;/g, "vNormal = normalMatrix * transformNormal(normal, orientation);"),
                    vsSplit[1] = vsSplit[1].replace(/vec3 transformedNormal = normal;/g, "vec3 transformedNormal = transformNormal(normal, orientation);");
                let main = vsSplit[1].split("main() {");
                main[1] = "\n" + definitions.join("\n") + main[1],
                    vsSplit[1] = main.join("main() {"),
                    vsSplit[0] += "\n",
                    vsSplit[0] += "attribute vec3 offset;\n",
                    vsSplit[0] += "attribute vec3 scale;\n",
                    vsSplit[0] += "attribute vec4 orientation;\n",
                    vsSplit[0] += Shaders.getShader("instance.vs") + "\n",
                    vsSplit = vsSplit.join("__ACTIVE_THEORY_LIGHTS__"),
                    fsSplit = fsSplit.join("__ACTIVE_THEORY_LIGHTS__"),
                    shader.vertexShader = vsSplit,
                    shader.fragmentShader = fsSplit,
                    MeshBatch.shaders[`${shader.vsName}|${shader.fsName}`] = {
                        fragment: shader.fragmentShader,
                        vertex: shader.vertexShader
                    }
            }
            function dirty(a, b) {
                for (let i = a.length - 1; i > -1; i--)
                    if (a[i] != b[i])
                        return !0;
                return !1
            }
            function loop() {
                _static && _this.stopRender(loop);
                let first = !_firstRender;
                _firstRender = !0;
                for (let i = 0; i < _objects.length; i++) {
                    let mesh = _objects[i];
                    mesh.updateMatrixWorld(first);
                    let pos = mesh.position
                        , scale = mesh.scale
                        , quaternion = mesh.quaternion
                        , i3 = 3 * i
                        , i4 = 4 * i;
                    if (_offset[i3 + 0] = pos.x,
                        _offset[i3 + 1] = pos.y,
                        _offset[i3 + 2] = pos.z,
                        _scale[i3 + 0] = scale.x,
                        _scale[i3 + 1] = scale.y,
                        _scale[i3 + 2] = scale.z,
                        _quaternion[i4 + 0] = quaternion.x,
                        _quaternion[i4 + 1] = quaternion.y,
                        _quaternion[i4 + 2] = quaternion.z,
                        _quaternion[i4 + 3] = quaternion.w,
                        mesh.attributes)
                        for (let key in mesh.attributes) {
                            let value = mesh.attributes[key];
                            value instanceof Color ? (_attributes[key][3 * i + 0] = value.r,
                                _attributes[key][3 * i + 1] = value.g,
                                _attributes[key][3 * i + 2] = value.b) : value instanceof Vector3 ? (_attributes[key][3 * i + 0] = value.x,
                                _attributes[key][3 * i + 1] = value.y,
                                _attributes[key][3 * i + 2] = value.z) : value instanceof Vector2 ? (_attributes[key][2 * i + 0] = value.x,
                                _attributes[key][2 * i + 1] = value.y) : _attributes[key][i] = mesh.attributes[key]
                        }
                }
                if (_mesh) {
                    dirty(_quaternion, _geom.attributes.orientation.array) && (_geom.attributes.orientation.array.set(_quaternion),
                        _geom.attributes.orientation.needsUpdate = !0),
                    dirty(_offset, _geom.attributes.offset.array) && (_geom.attributes.offset.array.set(_offset),
                        _geom.attributes.offset.needsUpdate = !0),
                    dirty(_scale, _geom.attributes.scale.array) && (_geom.attributes.scale.array.set(_scale),
                        _geom.attributes.scale.needsUpdate = !0);
                    for (let key in _attributes)
                        dirty(_attributes[key], _geom.attributes[key].array) && (_geom.attributes[key].array.set(_attributes[key]),
                            _geom.attributes[key].needsUpdate = !0)
                } else
                    !function initMesh() {
                        _geom.addAttribute("offset", new GeometryAttribute(new Float32Array(_offset),3,1)),
                            _geom.addAttribute("scale", new GeometryAttribute(new Float32Array(_scale),3,1)),
                            _geom.addAttribute("orientation", new GeometryAttribute(new Float32Array(_quaternion),4,1));
                        let box = new Box3;
                        _objects.forEach((mesh=>box.expandByObject(mesh, !0))),
                            _geom.boundingBox = box,
                            _geom.boundingSphere = box.getBoundingSphere(),
                            (_mesh = new Mesh(_geom,_shader)).asyncPromise = Promise.resolve(),
                            _this.mesh = _mesh,
                            _this.group.add(_mesh),
                        _renderOrder && (_mesh.renderOrder = _renderOrder),
                            _offset = new Float32Array(_offset),
                            _quaternion = new Float32Array(_quaternion),
                            _scale = new Float32Array(_scale);
                        for (let key in _attributes) {
                            _attributes[key] = new Float32Array(_attributes[key]);
                            let components = 1
                                , mesh = _objects[0];
                            mesh.attributes[key]instanceof Vector3 || mesh.attributes[key]instanceof Color ? components = 3 : mesh.attributes[key]instanceof Vector2 && (components = 2),
                                _geom.addAttribute(key, new GeometryAttribute(new Float32Array(_attributes[key]),components,1))
                        }
                        _this.onMeshCreated && _this.onMeshCreated(_mesh)
                    }()
            }
            _input && _this.parent.ready(!0).then(initFromSceneLayout),
                (_blankShader = Utils3D.getTestShader()).visible = !1,
                this.add = function(mesh) {
                    if (_mesh)
                        throw "Can't add to MeshBatch after it's been compiled";
                    _objects.push(mesh),
                        mesh.uploadIgnore = !0;
                    let shader = mesh.shader;
                    for (let key in shader.uniforms) {
                        let uniform = shader.uniforms[key];
                        (uniform.value instanceof Color || uniform.value instanceof Vector2 || uniform.value instanceof Vector3 || "number" == typeof uniform.value) && uniform.batchUnique && (_uniformToAttrib.push(key),
                        mesh.attributes || (mesh.attributes = {}),
                            mesh.attributes["a_" + key] = uniform.value)
                    }
                    _geom || function initGeometry(mesh) {
                        if (_geom = (new Geometry).instanceFrom(mesh.geometry),
                            _shader = mesh.shader,
                            _this.geom = _geom,
                            updateShader(_shader),
                            mesh.attributes)
                            for (let key in mesh.attributes)
                                _attributes[key] = []
                    }(mesh),
                        mesh.shader = _blankShader,
                        _this.startRender(loop)
                }
                ,
                this.set("static", (b=>{
                        _objects.length ? (loop(),
                            _this.stopRender(loop)) : _static = !0
                    }
                )),
                this.set("renderOrder", (v=>{
                        _renderOrder = v,
                        _mesh && (_mesh.renderOrder = v)
                    }
                )),
                this.get("renderOrder", (_=>_renderOrder)),
                this.set("frustumCulled", (b=>_mesh.frustumCulled = b))
        }
    ), (_=>{
            MeshBatch.shaders = {}
        }
    )),
    Class((function MeshMerge(_input) {
            Inherit(this, Object3D);
            const _this = this;
            var _mesh, _geom, _pending = [];
            async function initFromSceneLayout() {
                let wildcard = _input.get("wildcard");
                if (!wildcard || !wildcard.length)
                    return;
                let groupName = wildcard.split("|")[0]
                    , group = await _this.parent.getLayer(groupName)
                    , children = [...group.children];
                children.sort(((a,b)=>a.renderOrder - b.renderOrder)),
                    children.forEach((mesh=>_this.add(mesh))),
                    group.add(_this.group)
            }
            "object" == typeof _input && _this.parent.ready().then(initFromSceneLayout),
                this.add = function(mesh) {
                    if (mesh.uploadIgnore = !0,
                        !mesh.visible)
                        return;
                    mesh.updateMatrixWorld(!0),
                    _mesh || async function initMesh(mesh) {
                        (_mesh = new Mesh(World.QUAD,mesh.shader)).asyncPromise = Promise.create(),
                            _this.group.add(_mesh),
                            await defer(),
                            (await Promise.all(_pending)).forEach((data=>{
                                    let geom = new Geometry;
                                    for (let key in data)
                                        "components" != key && geom.addAttribute(key, new GeometryAttribute(data[key],data.components[key]));
                                    _geom ? _geom.merge(geom) : _geom = geom
                                }
                            )),
                            _mesh.geometry = _geom,
                            _mesh.asyncPromise.resolve(),
                        _this.onMeshCreated && _this.onMeshCreated(_mesh)
                    }(mesh);
                    let geom = mesh.geometry;
                    if (mesh.attributes)
                        for (let key in mesh.attributes) {
                            let attr = mesh.attributes[key];
                            attr instanceof Vector4 && (attr.isVector4 = !0),
                            attr instanceof Vector3 && (attr.isVector3 = !0),
                            attr instanceof Vector2 && (attr.isVector2 = !0),
                            attr instanceof Color && (attr.isColor = !0)
                        }
                    let data = {}
                        , components = {}
                        , buffers = [];
                    for (let key in geom.attributes)
                        data[key] = new Float32Array(geom.attributes[key].array),
                            buffers.push(data[key].buffer),
                            components[key] = geom.attributes[key].itemSize;
                    data.attributes = mesh.attributes,
                        data.components = components,
                        data.matrix = "world" == _input ? mesh.matrixWorld.elements : mesh.matrix.elements,
                        mesh.visible = !1,
                        _pending.push(Thread.shared().meshMergeTransform(data, buffers))
                }
        }
    ), (_=>{
            Thread.upload((function meshMergeTransform(e, id) {
                    let geom = new Geometry;
                    for (let key in e)
                        !key.includes(["components", "matrix"]) && e[key]instanceof Float32Array && geom.addAttribute(key, new GeometryAttribute(e[key],e.components[key]));
                    if (e.attributes)
                        for (let key in e.attributes) {
                            let components = 1
                                , attr = e.attributes[key];
                            attr.isVector4 ? components = 4 : attr.isVector3 || attr.isColor ? components = 3 : attr.isVector2 && (components = 2);
                            let buffer = new Float32Array(geom.attributes.position.count * components)
                                , step = buffer.length / components;
                            for (let i = 0; i < step; i++)
                                4 == components ? (buffer[3 * i + 0] = attr.x,
                                    buffer[3 * i + 1] = attr.y,
                                    buffer[3 * i + 2] = attr.z,
                                    buffer[3 * i + 3] = attr.w) : 3 == components ? (buffer[3 * i + 0] = attr.x || attr.r || 0,
                                    buffer[3 * i + 1] = attr.y || attr.g || 0,
                                    buffer[3 * i + 2] = attr.z || attr.b || 0) : 2 == components ? (buffer[2 * i + 0] = attr.x,
                                    buffer[2 * i + 1] = attr.y) : buffer[i] = attr;
                            geom.addAttribute(key, new GeometryAttribute(buffer,components))
                        }
                    geom.applyMatrix((new Matrix4).fromArray(e.matrix));
                    let data = {}
                        , buffers = []
                        , components = {};
                    for (let key in geom.attributes)
                        data[key] = geom.attributes[key].array,
                            components[key] = geom.attributes[key].itemSize,
                            buffers.push(data[key].buffer);
                    data.components = components,
                        resolve(data, id, buffers)
                }
            ))
        }
    )),
    Class((function RenderCount() {
            const _this = this;
            var $container, _map = {}, _display = {};
            this.active = Utils.query("renderCount");
            const LOG = _this.active && Utils.query("log");
            _this.active && async function initUIL() {
                await Hydra.ready(),
                    ($container = Stage.create("RenderCount")).css({
                        width: 150,
                        height: "auto",
                        paddingBottom: 5,
                        bottom: 0
                    }).bg("#111").setZ(9999999)
            }(),
                this.add = function(name, detail, amt=1) {
                    if (_this.active) {
                        if (void 0 === _map[name] && (_map[name] = 0,
                            $container)) {
                            let $wrapper = $container.create("wrapper");
                            $wrapper.css({
                                position: "relative",
                                width: "100%",
                                height: 20
                            }),
                                $wrapper.label = $wrapper.create("label"),
                                $wrapper.label.fontStyle("Arial", 12, "#fff").text(name).css({
                                    left: 10
                                }),
                                $wrapper.value = $wrapper.create("value"),
                                $wrapper.value.fontStyle("Arial", 12, "#fff").text(0).css({
                                    right: 10
                                }),
                                _display[name] = $wrapper
                        }
                        LOG && (console.groupCollapsed(name),
                        detail && console.log(detail),
                            console.trace(),
                            console.groupEnd()),
                            _map[name] += amt,
                            _display[name].value.text(_map[name] || "0")
                    }
                }
                ,
                this.remove = function(name, amt=1) {
                    _this.active && _map[name] && (_map[name] -= amt,
                        _display[name].value.text(_map[name] || "0"))
                }
        }
    ), "static"),
    Class((function RenderStats() {
            var _trace, _filter, $container, _map = {}, _stats = {}, _display = {};
            function flush() {
                for (let key in _map)
                    _stats[key] = _map[key],
                    _display[key] && _display[key].value.text(_map[key] || "0"),
                        _map[key] = 0;
                _trace = null
            }
            this.active = Utils.query("renderStats"),
            Utils.query("renderStats") && async function initUIL() {
                await Hydra.ready(),
                    ($container = Stage.create("RenderStats")).css({
                        position: "fixed",
                        width: 150,
                        height: "auto",
                        paddingTop: 5
                    }).bg("#111").setZ(99999)
            }(),
                Render.drawFrame = flush,
                this.update = function(name, amt=1, detail, detail2) {
                    if (_trace == name) {
                        if (_filter && detail) {
                            if (!("string" == typeof detail ? detail : Utils.getConstructorName(detail)).toLowerCase().includes(_filter.toLowerCase()))
                                return
                        }
                        console.groupCollapsed(name),
                        detail && console.log("string" == typeof detail ? detail : Utils.getConstructorName(detail)),
                        detail2 && console.log(detail2),
                            console.trace(),
                            console.groupEnd()
                    }
                    if (void 0 === _map[name] && (_map[name] = 0,
                        $container)) {
                        let $wrapper = $container.create("wrapper");
                        $wrapper.css({
                            position: "relative",
                            width: "100%",
                            height: 20
                        }),
                            $wrapper.label = $wrapper.create("label"),
                            $wrapper.label.fontStyle("Arial", 12, "#fff").text(name).css({
                                left: 10
                            }),
                            $wrapper.value = $wrapper.create("value"),
                            $wrapper.value.fontStyle("Arial", 12, "#fff").text(0).css({
                                right: 10
                            }),
                            _display[name] = $wrapper
                    }
                    _map[name] += amt
                }
                ,
                this.trace = function(name, filter=null) {
                    _trace = name,
                        _filter = filter
                }
                ,
                this.log = function() {
                    for (let key in _stats)
                        console.log(key, _stats[key]);
                    console.log("----")
                }
        }
    ), "static"),
    Class((function Fluid(_simSize=128, _dyeSize=512, _rect=Stage) {
            Inherit(this, Component);
            const _this = this;
            var _fbos = {}
                , _scenes = {}
                , _tmpVec = new Vector2
                , _lastSplat = Render.TIME;
            const DYE_WIDTH = _dyeSize
                , DYE_HEIGHT = _dyeSize
                , SIM_WIDTH = _simSize
                , SIM_HEIGHT = _simSize
                , config = {
                DENSITY_DISSIPATION: .97,
                VELOCITY_DISSIPATION: .98,
                PRESSURE_DISSIPATION: .8,
                PRESSURE_ITERATIONS: 20,
                CURL: 30,
                DEBUG_MOUSE: !0,
                SPLAT_RADIUS: .25
            };
            function loop() {
                config.DEBUG_MOUSE && function drawMouse() {
                    _this.drawInput(Mouse.x, Mouse.y, 10 * Mouse.delta.x, 10 * Mouse.delta.y, new Color("#777777"))
                }(),
                    _scenes.curl.uniforms.uVelocity.value = _fbos.velocity.read,
                    _scenes.curl.render(_fbos.curl.fbo),
                    _scenes.vorticity.uniforms.uVelocity.value = _fbos.velocity.read,
                    _scenes.vorticity.uniforms.uCurl.value = _fbos.curl.fbo,
                    _scenes.vorticity.uniforms.curl.value = config.CURL,
                    _scenes.vorticity.render(_fbos.velocity.write),
                    _fbos.velocity.swap(),
                    _scenes.divergence.uniforms.uVelocity.value = _fbos.velocity.read,
                    _scenes.divergence.render(_fbos.divergence.fbo),
                    _scenes.clear.uniforms.uTexture.value = _fbos.pressure.read,
                    _scenes.clear.uniforms.value.value = config.PRESSURE_DISSIPATION,
                    _scenes.clear.render(_fbos.pressure.write),
                    _fbos.pressure.swap(),
                    _scenes.pressure.uniforms.uDivergence.value = _fbos.divergence.fbo;
                for (let i = 0; i < config.PRESSURE_ITERATIONS; i++)
                    _scenes.pressure.uniforms.uPressure.value = _fbos.pressure.read,
                        _scenes.pressure.render(_fbos.pressure.write),
                        _fbos.pressure.swap();
                _scenes.gradientSubtract.uniforms.uPressure.value = _fbos.pressure.read,
                    _scenes.gradientSubtract.uniforms.uVelocity.value = _fbos.velocity.read,
                    _scenes.gradientSubtract.render(_fbos.velocity.write),
                    _fbos.velocity.swap(),
                    _scenes.advection.uniforms.texelSize.value.set(1 / SIM_WIDTH, 1 / SIM_HEIGHT),
                    _scenes.advection.uniforms.uVelocity.value = _fbos.velocity.read,
                    _scenes.advection.uniforms.uSource.value = _fbos.velocity.read,
                    _scenes.advection.uniforms.dissipation.value = config.VELOCITY_DISSIPATION,
                    _scenes.advection.render(_fbos.velocity.write),
                    _fbos.velocity.swap(),
                    _scenes.advection.uniforms.texelSize.value.set(1 / DYE_WIDTH, 1 / DYE_HEIGHT),
                    _scenes.advection.uniforms.uVelocity.value = _fbos.velocity.read,
                    _scenes.advection.uniforms.uSource.value = _fbos.density.read,
                    _scenes.advection.uniforms.dissipation.value = config.DENSITY_DISSIPATION,
                    _scenes.advection.render(_fbos.density.write),
                    _fbos.density.swap(),
                    _scenes.display.uniforms.uTexture.value = _fbos.density.read,
                    _scenes.display.uniforms.texelSize.value.set(1 / _rect.width, 1 / _rect.height),
                    _scenes.display.render(_this.rt)
            }
            this.rt = Utils3D.createRT(_rect.width, _rect.height),
                this.fbos = _fbos,
                this.additiveBlending = !0,
                _this.rt.disableDepth = !0,
                function initFBOs() {
                    _fbos.density = _this.initClass(FluidFBO, DYE_WIDTH, DYE_HEIGHT, Texture.LINEAR),
                        _fbos.velocity = _this.initClass(FluidFBO, SIM_WIDTH, SIM_HEIGHT, Texture.LINEAR),
                        _fbos.divergence = _this.initClass(FluidFBO, SIM_WIDTH, SIM_HEIGHT, Texture.NEAREST),
                        _fbos.curl = _this.initClass(FluidFBO, SIM_WIDTH, SIM_HEIGHT, Texture.NEAREST),
                        _fbos.pressure = _this.initClass(FluidFBO, SIM_WIDTH, SIM_HEIGHT, Texture.NEAREST)
                }(),
                function initScenes() {
                    _scenes.curl = _this.initClass(FluidScene, "fluidBase", "curlShader", {
                        texelSize: {
                            value: new Vector2(1 / SIM_WIDTH,1 / SIM_HEIGHT)
                        },
                        uVelocity: {
                            value: null
                        },
                        depthWrite: !1
                    }),
                        _scenes.vorticity = _this.initClass(FluidScene, "fluidBase", "vorticityShader", {
                            texelSize: {
                                value: new Vector2(1 / SIM_WIDTH,1 / SIM_HEIGHT)
                            },
                            uVelocity: {
                                value: null
                            },
                            uCurl: {
                                value: null
                            },
                            curl: {
                                value: config.CURL
                            },
                            dt: {
                                value: .016
                            }
                        }),
                        _scenes.divergence = _this.initClass(FluidScene, "fluidBase", "divergenceShader", {
                            texelSize: {
                                value: new Vector2(1 / SIM_WIDTH,1 / SIM_HEIGHT)
                            },
                            uVelocity: {
                                value: null
                            }
                        }),
                        _scenes.clear = _this.initClass(FluidScene, "fluidBase", "clearShader", {
                            uTexture: {
                                value: null
                            },
                            value: {
                                value: config.PRESSURE_DISSIPATION
                            }
                        }),
                        _scenes.pressure = _this.initClass(FluidScene, "fluidBase", "pressureShader", {
                            texelSize: {
                                value: new Vector2(1 / SIM_WIDTH,1 / SIM_HEIGHT)
                            },
                            uPressure: {
                                value: null
                            },
                            uDivergence: {
                                value: null
                            }
                        }),
                        _scenes.gradientSubtract = _this.initClass(FluidScene, "fluidBase", "gradientSubtractShader", {
                            texelSize: {
                                value: new Vector2(1 / SIM_WIDTH,1 / SIM_HEIGHT)
                            },
                            uPressure: {
                                value: null
                            },
                            uVelocity: {
                                value: null
                            }
                        }),
                        _scenes.advection = _this.initClass(FluidScene, "fluidBase", "advectionShader", {
                            texelSize: {
                                value: new Vector2(1 / SIM_WIDTH,1 / SIM_HEIGHT)
                            },
                            uVelocity: {
                                value: null
                            },
                            uSource: {
                                value: null
                            },
                            dt: {
                                value: .016
                            },
                            dissipation: {
                                value: config.VELOCITY_DISSIPATION
                            }
                        }),
                        _scenes.display = _this.initClass(FluidScene, "fluidBase", "displayShader", {
                            texelSize: {
                                value: new Vector2(1 / _rect.width,1 / _rect.height)
                            },
                            uTexture: {
                                value: null
                            }
                        }),
                        _scenes.splat = _this.initClass(FluidScene, "fluidBase", "splatShader", {
                            uTarget: {
                                value: null
                            },
                            aspectRatio: {
                                value: _rect.width / _rect.height
                            },
                            point: {
                                value: new Vector2
                            },
                            prevPoint: {
                                value: new Vector2
                            },
                            color: {
                                value: new Vector3
                            },
                            bgColor: {
                                value: new Color("#000000")
                            },
                            radius: {
                                value: config.SPLAT_RADIUS / 100
                            },
                            canRender: {
                                value: 0
                            },
                            uAdd: {
                                value: 1
                            }
                        })
                }(),
                _this.startRender(loop),
                this.updateConfig = function(key, value) {
                    config[key] = value
                }
                ,
                this.drawInput = function(x, y, dx, dy, color, radius=config.SPLAT_RADIUS) {
                    _scenes.splat.uniforms.uTarget.value = _fbos.velocity.read,
                        _scenes.splat.uniforms.radius.value = radius / 200,
                        _scenes.splat.uniforms.aspectRatio.value = _rect.width / _rect.height,
                        _tmpVec.set(x / _rect.width, 1 - y / _rect.height);
                    let now = Render.TIME
                        , delta = now - _lastSplat;
                    _lastSplat = now,
                        delta > 50 ? _scenes.splat.uniforms.prevPoint.value.copy(_tmpVec) : _scenes.splat.uniforms.prevPoint.value.copy(_scenes.splat.uniforms.point.value),
                        _scenes.splat.uniforms.point.value.copy(_tmpVec),
                        _scenes.splat.uniforms.color.value.set(dx, -dy, 1),
                        _scenes.splat.uniforms.uAdd.value = 1,
                        _scenes.splat.render(_fbos.velocity.write),
                        _fbos.velocity.swap(),
                        _scenes.splat.uniforms.uTarget.value = _fbos.density.read,
                        _scenes.splat.uniforms.color.value.set(color.r, color.g, color.b),
                        _scenes.splat.uniforms.uAdd.value = _this.additiveBlending ? 1 : 0,
                        _scenes.splat.render(_fbos.density.write, !0),
                        _fbos.density.swap(),
                        _scenes.splat.uniforms.canRender.value = 1
                }
        }
    )),
    Class((function FluidFBO(_width, _height, _filter) {
            Inherit(this, Component);
            const _this = this
                , type = Device.mobile || Renderer.type != Renderer.WEBGL1 ? Texture.HALF_FLOAT : Texture.FLOAT;
            var _fbo1 = new RenderTarget(_width,_height,{
                minFilter: _filter,
                magFilter: _filter,
                format: Texture.RGBAFormat,
                type: type
            })
                , _fbo2 = new RenderTarget(_width,_height,{
                minFilter: _filter,
                magFilter: _filter,
                format: Texture.RGBAFormat,
                type: type
            });
            this.fbo = _fbo1,
                this.uniform = {
                    value: _fbo1
                },
                _fbo1.disableDepth = !0,
                _fbo2.disableDepth = !0,
                _fbo1.generateMipmaps = !1,
                _fbo2.generateMipmaps = !1,
                this.swap = function() {
                    let temp = _fbo1;
                    _fbo1 = _fbo2,
                        _fbo2 = temp,
                        _this.uniform.value = _fbo1
                }
                ,
                this.get("read", (_=>_fbo1)),
                this.get("write", (_=>_fbo2))
        }
    )),
    Class((function FluidLayer(_input, _group) {
            Inherit(this, Object3D);
            var _fluid, _config, _this = this;
            !function initConfig() {
                (_config = InputUIL.create(_input.prefix + "fluid", _group)).setLabel("Fluid Config"),
                    _config.add("dyeSize", 512),
                    _config.add("simSize", 128),
                    _config.add("velocity", .98),
                    _config.add("density", .97),
                    _config.add("pressure", .8),
                    _config.add("iterations", 20),
                    _config.add("curl", 30),
                    _config.add("defaultRadius", 25),
                    _config.addToggle("debugMouse", !1)
            }(),
                function initFluid() {
                    _fluid = _this.initClass(Fluid, _config.getNumber("simSize"), _config.getNumber("dyeSize"), Stage),
                        _this.rt = _fluid.rt,
                        _this.fbos = _fluid.fbos,
                        _config.onUpdate = key=>{
                            switch (key) {
                                case "velocity":
                                    _fluid.updateConfig("VELOCITY_DISSIPATION", _config.getNumber(key));
                                    break;
                                case "density":
                                    _fluid.updateConfig("DENSITY_DISSIPATION", _config.getNumber(key));
                                    break;
                                case "pressure":
                                    _fluid.updateConfig("PRESSURE_DISSIPATION", _config.getNumber(key));
                                    break;
                                case "iterations":
                                    _fluid.updateConfig("PRESSURE_ITERATIONS", _config.getNumber(key));
                                    break;
                                case "curl":
                                    _fluid.updateConfig("CURL", _config.getNumber(key));
                                    break;
                                case "defaultRadius":
                                    _fluid.updateConfig("SPLAT_RADIUS", _config.getNumber(key));
                                    break;
                                case "debugMouse":
                                    _fluid.updateConfig("DEBUG_MOUSE", _config.get(key))
                            }
                        }
                        ,
                        ["velocity", "density", "pressure", "iterations", "curl", "defaultRadius", "debugMouse"].forEach(_config.onUpdate)
                }(),
                function initMesh() {
                    let shader = _this.initClass(Shader, "ScreenQuad", {
                        tMap: {
                            value: _fluid.rt
                        }
                    })
                        , mesh = new Mesh(World.QUAD,shader);
                    _this.add(mesh),
                        _this.mesh = mesh
                }(),
                this.get("additiveBlending", (_=>_fluid.additiveBlending)),
                this.set("additiveBlending", (v=>_fluid.additiveBlending = v)),
                this.set("debugMouse", (v=>_config.onUpdate("debugMouse", v))),
                this.drawInput = _fluid.drawInput
        }
    )),
    Class((function FluidScene(_vs, _fs, _uniforms) {
            Inherit(this, Component);
            const _this = this;
            var _scene = new Scene;
            !function() {
                _uniforms.depthWrite = !1;
                let shader = _this.initClass(Shader, _vs, _fs, _uniforms)
                    , mesh = new Mesh(World.QUAD,shader);
                shader.depthWrite = !1,
                    mesh.noMatrices = !0,
                    _scene.add(mesh),
                    _this.uniforms = shader.uniforms
            }(),
                this.render = function(rt) {
                    World.RENDERER.autoClear = !1,
                        World.RENDERER.renderSingle(_scene.children[0], World.CAMERA, rt),
                        World.RENDERER.autoClear = !0
                }
                ,
                this.scene = _scene
        }
    )),
    Class((function Fullscreen() {
            Inherit(this, Events);
            const _this = this;
            function update() {
                const isOpen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
                isOpen !== _this.isOpen && (_this.isOpen = isOpen,
                    _this.events.fire(Events.FULLSCREEN, {
                        fullscreen: _this.isOpen
                    }))
            }
            this.isOpen = !1,
                function addHandlers() {
                    ["onfullscreenchange", "onwebkitfullscreenchange", "onmozfullscreenchange", "onmsfullscreenchange", "onfullscreenerror", "onwebkitfullscreenerror", "onmozfullscreenerror", "onmsfullscreenerror"].forEach((evt=>{
                            void 0 !== document[evt] && (document[evt] = update)
                        }
                    ))
                }(),
                this.open = function(element) {
                    element = element || document.body,
                        ["requestFullscreen", "webkitRequestFullscreen", "mozRequestFullScreen", "msRequestFullscreen"].every((method=>{
                                if (void 0 === element[method])
                                    return !0;
                                element[method]()
                            }
                        ))
                }
                ,
                this.close = function() {
                    ["exitFullscreen", "webkitExitFullscreen", "mozCancelFullScreen", "msExitFullscreen"].every((method=>{
                            if (void 0 === document[method])
                                return !0;
                            document[method]()
                        }
                    ))
                }
        }
    ), "static"),
    Class((function FXAA() {
            Inherit(this, NukePass);
            this.uniforms = {},
                this.init("FXAA", "FXAA")
        }
    )),
    Class((function GameCenter() {
            Inherit(this, Component);
            var _socket, _coords, _this = this, _id = Utils.timestamp();
            function getCoords() {
                if (!_this.useCoordinates)
                    return _coords = [0, 0],
                        Promise.resolve();
                let promise = Promise.create();
                return navigator.geolocation.getCurrentPosition((data=>{
                        _coords = [data.coords.latitude, data.coords.longitude],
                            _this.events.fire(_this.LOCATED),
                            promise.resolve()
                    }
                ), (error=>{
                        _this.events.fire(_this.LOCATION_ERROR)
                    }
                )),
                    promise
            }
            function connected() {
                _this.events.fire(_this.CONNECTED),
                    _this.events.sub(_socket, "server_data", handleServerData),
                    _this.flag("connected", !0)
            }
            function disconnected() {
                _this.flag("connected", !1),
                    _this.events.fire(_this.LOST_CONNECTION, {
                        reconnected: _=>_this.wait("connected")
                    })
            }
            function error() {
                _this.flag("connected", !1),
                    _this.events.fire(_this.LOST_CONNECTION, {
                        reconnected: _=>_this.wait("connected")
                    })
            }
            function broadcast(e) {
                _this.events.fire(_this.BROADCAST, e)
            }
            function handleServerData(e) {
                _this.events.fire(_this.SERVER_DATA, e),
                    _this.events.fire(_this.SERVER_DATA, e)
            }
            this.userData = {},
                this.useCoordinates = !1,
                this.overrideProtocol = null,
                this.ports = 1,
                this.CONNECTED = "gamecenter_connect",
                this.DISCONNECTED = "gamecenter_disconnected",
                this.LOCATION_ERROR = "gamecenter_location_error",
                this.LOCATED = "gamecenter_located",
                this.DATA = "gamecenter_data",
                this.START_GAME = "gamecenter_start_game",
                this.END_GAME = "gamecenter_end_game",
                this.LOST_CONNECTION = "gamecenter_lost_connection",
                this.SERVER_DATA = "gamecenter_server_data",
                this.BROADCAST = "gamecenter_server_data",
                this.connect = function(server) {
                    this.CONNECTION_TYPE = this.overrideProtocol || (Device.media.webrtc ? "rtc" : "ws");
                    Math.random(0, this.ports - 1);
                    _socket = new SocketConnection(server),
                        _this.socket = _socket,
                        _this.events.sub(_socket, SocketConnection.OPEN, connected),
                        _this.events.sub(_socket, SocketConnection.CLOSE, disconnected),
                        _this.events.sub(_socket, SocketConnection.ERROR, error),
                        _this.events.sub(_socket, "broadcast", broadcast)
                }
                ,
                this.disconnect = function() {
                    _this.events.unsub(_socket, SocketConnection.OPEN, connected),
                        _this.events.unsub(_socket, SocketConnection.CLOSE, close),
                        _this.events.unsub(_socket, SocketConnection.ERROR, error),
                        _this.events.unsub(_socket, "broadcast", broadcast),
                        _this.socket = _socket = null,
                        _this.events.fire(_this.DISCONNECTED)
                }
                ,
                this.locateUser = function() {
                    getCoords()
                }
                ,
                this.createRoom = function(id) {
                    let promise = Promise.create()
                        , create = function() {
                        let room = new GameCenterRoom(id || Utils.timestamp(),_socket);
                        room.create(),
                            promise.resolve(room)
                    };
                    return _coords ? create() : getCoords().then(create),
                        promise
                }
                ,
                this.findRoom = function() {
                    let promise = Promise.create()
                        , find = function() {
                        _this.roundTrip("findAny", {
                            coords: _coords,
                            type: _this.CONNECTION_TYPE
                        }, (async data=>{
                                let room = new GameCenterRoom(data.id,_socket);
                                try {
                                    await room.join(),
                                        promise.resolve(room)
                                } catch (e) {
                                    promise.reject()
                                }
                            }
                        ))
                    };
                    return _coords ? find() : getCoords().then(find),
                        promise
                }
                ,
                this.watchAnyRoom = function() {
                    let promise = Promise.create();
                    return _this.roundTrip("findAny", {
                        coords: _coords,
                        type: _this.CONNECTION_TYPE,
                        forceWatcher: !0
                    }, (data=>{
                            try {
                                let room = new GameCenterRoom(data.id,_socket);
                                room.join(!0),
                                    promise.resolve(room)
                            } catch (e) {
                                promise.reject()
                            }
                        }
                    )),
                        promise
                }
                ,
                this.joinRoom = async function(id) {
                    let room = new GameCenterRoom(id,_socket);
                    try {
                        await room.join()
                    } catch (e) {
                        throw "Could not connect to room " + id
                    }
                    return room
                }
                ,
                this.findNearby = function() {
                    let promise = Promise.create();
                    if (!this.useCoordinates)
                        throw "findNearby requires user coords";
                    let find = function() {
                        _this.roundTrip("findNearby", {
                            coords: _coords,
                            type: _this.CONNECTION_TYPE
                        }, (data=>{
                                promise.resolve(data)
                            }
                        ))
                    };
                    return _coords ? find() : getCoords().then(find),
                        promise
                }
                ,
                this.roundTrip = function(evt, data, callback) {
                    let receive = e=>{
                            _this.events.unsub(_socket, `${evt}_response`, receive),
                            callback && callback(e)
                        }
                    ;
                    _this.events.sub(_socket, `${evt}_response`, receive),
                    _socket.send && _socket.send(evt, data)
                }
                ,
                this.sendData = function(data={}) {
                    _socket && (data.id = _id,
                        _socket.send("server_data", data))
                }
                ,
                this.broadcast = function(data={}) {
                    _socket.send("broadcast", data)
                }
                ,
                this.set("coords", (v=>{
                        _coords = v
                    }
                )),
                this.get("coords", (_=>_coords))
        }
    ), "static"),
    Class((function GameCenterPlayer(_id, _socket, _data, _initiator) {
            Inherit(this, Component);
            var _this = this
                , _evt = {
                target: _this,
                id: _id
            }
                , _results = []
                , _messages = {};
            this.connection = new GameCenterRTC(_id,_socket,_initiator,_data),
                this.id = _id,
                this.data = _data,
                this.offset = 0;
            const DEBUG = Utils.query("addDebug");
            function sendPing() {
                if (_results.length >= 3)
                    return;
                let message = {
                    _ping: !0
                };
                message.id = Utils.timestamp(),
                    message.outTime = Date.now(),
                    _messages[message.id] = message,
                    _this.connection.emit(message),
                DEBUG && console.log("GCPlayer::SendPing")
            }
            function handlePing(data) {
                if (_messages[data.id]) {
                    let difference = Date.now() - data.inTime;
                    _results.unshift(difference),
                        _this.offset = difference,
                        _results.length < 3 ? _this.delayedCall(sendPing, 50) : function calculate() {
                            _results.length > 3 && (_results = _results.slice(0, 3)),
                                _results.sort(((a,b)=>a - b)),
                                _this.offset = _results[1]
                        }()
                } else
                    data.inTime = Date.now(),
                        _this.connection.emit(data),
                    DEBUG && console.log("GCPlayer::connection emit", data)
            }
            function onMessage(data) {
                if (data._ping)
                    return handlePing(data);
                _evt.player = _this,
                    _evt.data = data,
                    _this.events.fire(GameCenter.DATA, _evt)
            }
            function ready() {
                _this.delayedCall((()=>{
                        sendPing(),
                            _this.events.fire(Events.READY)
                    }
                ), 100)
            }
            !function addListeners() {
                _this.events.sub(_this.connection, Events.READY, ready),
                    _this.events.bubble(_this.connection, Events.ERROR),
                    _this.connection.onMessage = onMessage
            }(),
                this.emit = function(data) {
                    _this.connection.emit(data)
                }
                ,
                this.disconnect = function() {
                    _this.connection.close(),
                        _this.events.fire(GameCenter.DISCONNECTED)
                }
        }
    )),
    Class((function GameCenterRTC(_id, _socket, _initiator) {
            Inherit(this, Component);
            var _peer, _data, _this = this, _fallbackSocket = !1;
            const DEBUG = Utils.query("addDebug");
            function sendNegotiation(type, sdp) {
                let data = {
                    to: _id,
                    type: type,
                    sdp: sdp
                };
                DEBUG && console.log("GC::send negotiation", data),
                    _socket.send("establish_rtc", data)
            }
            function dataMessage(e) {
                _this.onMessage && _this.onMessage(JSON.parse(e.data))
            }
            function dataOpen(e) {
                _this.events.fire(Events.READY),
                DEBUG && console.log("GC::data open", e)
            }
            function dataClose(e) {
                _socket.send("report_disconnect", _id),
                    _this.events.fire(Events.ERROR, {
                        gcID: _id
                    }),
                DEBUG && console.log("GC::data close", e)
            }
            function dataError(e) {
                _this.events.fire(Events.ERROR, {
                    gcID: _id
                }),
                DEBUG && console.log("GC::data error", e)
            }
            !function initPeerConnection() {
                (_peer = new RTCPeerConnection({
                    iceServers: [{
                        urls: "stun:stun.l.google.com:19302"
                    }]
                })).onicecandidate = e=>{
                    if (DEBUG && console.log("GC::onicecandidate try", e),
                        !(_peer && e && e.candidate && e.candidate.candidate))
                        return console.warn("failed ice candidate");
                    sendNegotiation("candidate", e.candidate),
                    DEBUG && console.log("GC::onicecandidate", e)
                }
                    ,
                    _peer.onicecandidateerror = e=>{
                        DEBUG && console.log("GC::onicecandidateerror", e)
                    }
                    ,
                    _peer.onconnectionstatechange = e=>{
                        switch (DEBUG && console.log("GC::onconnectionstatechange", e),
                        DEBUG && console.log(_peer.iceConnectionState),
                            _peer.iceConnectionState) {
                            case "connected":
                                Global.CONNECTED = !0,
                                    _this.events.fire(MultiplayerUI.CONNECTED);
                                break;
                            case "disconnected":
                                Global.CONNECTED = !1,
                                    _this.events.fire(MultiplayerUI.DISCONNECTED)
                        }
                    }
                    ,
                    _peer.onicegatheringstatechange = e=>{
                        DEBUG && console.log("GC::onicegatheringstatechange", e)
                    }
                    ,
                    _peer.oniceconnectionstatechange = e=>{
                        DEBUG && console.log("GC::oniceconnectionstatechange", e),
                        "failed" == _peer.iceConnectionState && function fallbackToSocket() {
                            _this.events.fire(MultiplayerUI.CONNECTED),
                                _socket.send("ws_data", {
                                    from: GameCenter.GCID,
                                    fallbackToSocket: !0
                                }),
                                _fallbackSocket = !0
                        }()
                    }
                    ,
                    _peer.onsignalingstatechange = e=>{
                        DEBUG && console.log("GC::onsignalingstatechange", e)
                    }
                    ,
                    _peer.onnegotiationneeded = e=>{
                        DEBUG && console.log("GC::onnegotiationneeded", e)
                    }
                    ,
                    (_data = _peer.createDataChannel("gamecenter", {
                        ordered: !1,
                        negotiated: !0,
                        id: 7
                    })).onmessage = dataMessage,
                    _data.onopen = dataOpen,
                    _data.onclose = dataClose,
                    _data.onerror = dataError,
                DEBUG && console.log("GC::init peer connection", _peer),
                    _peer.ondatachannel = e=>{
                        DEBUG && console.log("GC::on data channel"),
                            e.channel.onmessage = dataMessage,
                            e.channel.onclose = dataClose,
                            e.channel.onerror = dataError
                    }
            }(),
            _initiator && async function initConnection() {
                let sdp;
                DEBUG && console.log("GC::init connection");
                try {
                    sdp = await _peer.createOffer()
                } catch (e) {
                    console.error(e)
                }
                DEBUG && console.log("GC::after create offer"),
                    _peer.setLocalDescription(sdp),
                    sendNegotiation("offer", sdp)
            }(),
                this.establish = function(data) {
                    if (_peer)
                        switch (DEBUG && console.log("GC::establish", data),
                            data.type) {
                            case "candidate":
                                !function processIce(iceCandidate) {
                                    try {
                                        _peer.addIceCandidate(new RTCIceCandidate(iceCandidate)),
                                        DEBUG && console.log("GC::processIce addIceCandidate", iceCandidate)
                                    } catch (e) {
                                        _this.events.fire(Events.ERROR, {
                                            gcID: _id
                                        })
                                    }
                                }(data.sdp);
                                break;
                            case "offer":
                                !async function processOffer(offer) {
                                    try {
                                        DEBUG && console.log("GC::process offser", offer),
                                            await _peer.setRemoteDescription(new RTCSessionDescription(offer));
                                        let sdp = await _peer.createAnswer();
                                        DEBUG && console.log("GC::create answer"),
                                            _peer.setLocalDescription(sdp).catch((e=>_this.events.fire(Events.ERROR, {
                                                gcID: _id
                                            }))),
                                            sendNegotiation("answer", sdp)
                                    } catch (e) {
                                        console.log("offer", offer),
                                            console.error("process offer", e)
                                    }
                                }(data.sdp);
                                break;
                            case "answer":
                                !async function processAnswer(answer) {
                                    try {
                                        await _peer.setRemoteDescription(new RTCSessionDescription(answer)),
                                        DEBUG && console.log("GC::processAnswer", answer)
                                    } catch (e) {
                                        _this.events.fire(Events.ERROR, {
                                            gcID: _id
                                        })
                                    }
                                    return !0
                                }(data.sdp)
                        }
                }
                ,
                this.emit = function(data={}) {
                    if (_fallbackSocket)
                        data.from = GameCenter.GCID,
                            _socket.send("ws_data", data);
                    else {
                        if ("open" != _data.readyState)
                            return;
                        data.from = GameCenter.GCID;
                        try {
                            _data.send(JSON.stringify(data))
                        } catch (e) {
                            console.log(e)
                        }
                    }
                }
                ,
                this.wsData = function(data) {
                    if (data.fallbackToSocket)
                        return _fallbackSocket = !0,
                            void _this.events.fire(Events.READY);
                    _this.onMessage && _this.onMessage(data)
                }
                ,
                this.close = function() {
                    _peer && _peer.close(),
                        _peer = null,
                    DEBUG && console.log("GC::close")
                }
        }
    )),
    Class((function GameCenterUser() {
            Inherit(this, Component);
            this.connection = new GameCenterConnection,
                this.me = !0,
                this.data = GameCenter.userData,
                this.id = GameCenter.GCID,
                this.emit = function() {}
                ,
                this.disconnect = function() {}
        }
    )),
    Class((function GameCenterConnection() {
            Inherit(this, Component);
            this.establish = function() {}
                ,
                this.emit = function() {}
                ,
                this.wsData = function() {}
        }
    )),
    Class((function GameCenterRoom(_id, _socket) {
            Inherit(this, Component);
            var _this = this
                , _aliveTime = Date.now();
            this.id = _id,
                this.host = !1,
                this.players = [];
            var _playerMap = new Map
                , _players = _this.players;
            function createPlayer(id, data, init) {
                let player = new GameCenterPlayer(id,_socket,data,init);
                return _this.events.sub(player, GameCenter.DATA, playerData),
                    _this.events.sub(player, Events.ERROR, playerDisconnect),
                    _this.events.sub(player, Events.READY, (async()=>{
                            await defer(),
                                _this.events.fire(GameCenterRoom.PLAYER_READY, {
                                    player: player
                                })
                        }
                    )),
                    player
            }
            function keepAlive() {
                Date.now() - _aliveTime > 999 && (_aliveTime = Date.now(),
                    _socket.send("alive"))
            }
            function forceDisconnect(e) {
                _this.events.fire(GameCenterRoom.ERROR)
            }
            function closeRoom() {
                _this.destroy()
            }
            function startGame(e) {
                _this.events.fire(GameCenter.START_GAME, e)
            }
            function endGame(e) {
                _this.events.fire(GameCenter.END_GAME, e)
            }
            function establishRTC(e) {
                let found = !1;
                if (_players.forEach((player=>{
                        player.id == e.from && (found = !0,
                            player.connection.establish(e))
                    }
                )),
                    !found) {
                    let player = createPlayer(e.from, e.data);
                    _players.push(player),
                        _playerMap.set(e.gcID, player),
                        player.connection.establish(e)
                }
            }
            function playerDisconnect(e) {
                _playerMap.delete(e.gcID),
                    _players.forEach((player=>{
                            player.id == e.gcID && (player.disconnect(),
                                _players.remove(player),
                                _this.events.fire(GameCenterRoom.PLAYER_DISCONNECT, {
                                    player: player
                                }))
                        }
                    ))
            }
            function becomeHost(e) {
                _this.host = !0,
                    _this.events.fire(GameCenterRoom.BECOME_HOST)
            }
            function openConnection(e) {
                let player = createPlayer(e.gcID, e.data, !0);
                _playerMap.set(e.gcID, player),
                    _players.push(player),
                    _this.events.fire(GameCenterRoom.PLAYER_JOIN, {
                        player: player
                    })
            }
            function playerData(e) {
                _this.events.fire(GameCenter.DATA, e)
            }
            function websocketData(e) {
                let player = _playerMap.get(e.from);
                player && player.connection.wsData(e)
            }
            this.onDestroy = function() {
                this.leave()
            }
                ,
                this.create = function() {
                    _this.host = !0,
                        GameCenter.roundTrip("create", {
                            id: _id,
                            coords: GameCenter.coords,
                            type: GameCenter.CONNECTION_TYPE
                        }, _this.join)
                }
                ,
                this.join = function(force) {
                    if (_this.flag("joined"))
                        return Promise.resolve();
                    _this.flag("joined", !0);
                    let promise = Promise.create();
                    return GameCenter.roundTrip("join", {
                        id: _id,
                        user: GameCenter.userData,
                        force: force
                    }, (e=>{
                            if (!e.success)
                                return _this.events.fire(Events.ERROR),
                                    promise.reject();
                            e.host && (_this.host = !0),
                                GameCenter.GCID = e.myID,
                                function handlePlayers(players) {
                                    var player;
                                    players.forEach(((obj,i)=>{
                                            obj.id == GameCenter.GCID ? player = new GameCenterUser : (player = _playerMap.get(obj.id)) || (player = createPlayer(obj.id, obj.data),
                                                _playerMap.set(obj.id, player)),
                                                _players[i] = player
                                        }
                                    ))
                                }(e.players),
                                function addListeners() {
                                    _this.events.sub(_socket, "player_disconnect", playerDisconnect),
                                        _this.events.sub(_socket, "become_host", becomeHost),
                                        _this.events.sub(_socket, "open_connection", openConnection),
                                        _this.events.sub(_socket, "establish_rtc", establishRTC),
                                        _this.events.sub(_socket, "ws_data", websocketData),
                                        _this.events.sub(_socket, "start_game", startGame),
                                        _this.events.sub(_socket, "end_game", endGame),
                                        _this.events.sub(_socket, "force_disconnect", forceDisconnect),
                                        _this.events.sub(GameCenter.LOST_CONNECTION, closeRoom)
                                }(),
                                _this.startRender(keepAlive, 10),
                                promise.resolve()
                        }
                    )),
                        promise
                }
                ,
                this.leave = function() {
                    _this.stopRender(keepAlive),
                        _this.flag("joined", !1),
                        _players.forEach((player=>player.disconnect())),
                        GameCenter.roundTrip("leave", {
                            id: _id,
                            user: GameCenter.userData
                        })
                }
                ,
                this.broadcast = function(data) {
                    for (var i = 0; i < _players.length; i++)
                        _players[i].connection.emit(data)
                }
                ,
                this.start = function(data) {
                    _this.host && _socket.send("start_game", data)
                }
                ,
                this.end = function(data) {
                    _this.host && _socket.send("end_game", data)
                }
        }
    ), (()=>{
            GameCenterRoom.PLAYER_DISCONNECT = "gc_room_player_dc",
                GameCenterRoom.BECOME_HOST = "gc_become_host",
                GameCenterRoom.PLAYER_JOIN = "gc_player_join",
                GameCenterRoom.PLAYER_READY = "gc_player_ready",
                GameCenterRoom.ERROR = "gc_room_error"
        }
    )),
    Class((function JoystickInteraction(_config={}) {
            Inherit(this, Events);
            const _this = this;
            var _joystick, _hitObject;
            function loop(t, delta) {
                if (!_joystick)
                    return;
                let e = {
                    target: {}
                };
                Math.abs(_joystick.x) < .001 && Math.abs(_joystick.y) < .001 ? (e.x = _this.move.x,
                    e.y = _this.move.y,
                    _this.delta.x = 0,
                    _this.delta.y = 0,
                    _this.move.x = 0,
                    _this.move.y = 0,
                _this.isTouching && (_this.isTouching = !1,
                    _this.events.fire(Interaction.END, e, !0))) : _this.isTouching ? (_this.delta.x = _joystick.x * delta,
                    _this.delta.y = _joystick.y * delta,
                    _this.move.x += _this.delta.x,
                    _this.move.y += _this.delta.y,
                    e.x = _this.move.x,
                    e.y = _this.move.y,
                    _this.velocity.x = Math.abs(_this.delta.x) / delta,
                    _this.velocity.y = Math.abs(_this.delta.y) / delta,
                    _this.events.fire(Interaction.MOVE, e, !0),
                    _this.events.fire(Interaction.DRAG, e, !0)) : (_this.isTouching = !0,
                    e.x = _this.move.x = 0,
                    e.y = _this.move.y = 0,
                    _this.delta.x = 0,
                    _this.delta.y = 0,
                    _this.events.fire(Interaction.START, e, !0))
            }
            this.delta = new Vector2,
                this.move = new Vector2,
                _this.velocity = new Vector2,
                function() {
                    if (Device.system.xr.vr) {
                        if (_config && _config.raycast ? (_hitObject = _config,
                            World.CAMERA) : _config && (_hitObject = _config.hit,
                        _config.hitCamera || World.CAMERA),
                            !_hitObject)
                            throw "JoystickInteraction requires a Mesh for hit testing";
                        !async function addHandlers() {
                            await VRInput.ready(),
                                _joystick = {
                                    x: 0,
                                    y: 0
                                },
                                VRInput.controllers.forEach((controller=>_this.events.sub(controller, VRInput.JOYSTICK, (e=>{
                                        !function handleJoystick(e, controller) {
                                            !function checkHit(controller) {
                                                return _hitObject.interaction.checkObjectFromValues(_hitObject, controller.group.worldPos, controller.pointer, _config.hitCamera)
                                            }(controller) ? (_joystick.x = 0,
                                                _joystick.y = 0) : (_joystick.x = e.x,
                                                _joystick.y = e.y)
                                        }(e, controller)
                                    }
                                ))))
                        }(),
                            Render.start(loop)
                    }
                }()
        }
    )),
    Interaction.Class((function Renderer(_object) {
            var _hydraObject = _object instanceof HydraObject;
            this.needsUpdate = !!_hydraObject,
            _hydraObject && (_object.x = _object.x || 0,
                _object.y = _object.y || 0,
                _object.z = _object.z || 0,
                _object.pos = {
                    x: 0,
                    y: 0,
                    z: 0
                }),
                this.update = function() {
                    _object.transform()
                }
        }
    )),
    Class((function GLScreenProjection(_camera=World.CAMERA, _target=new Vector2) {
            Inherit(this, Object3D);
            var _this = this
                , _projection = new ScreenProjection(_camera)
                , _m0 = new Matrix4
                , _m1 = new Matrix4;
            function loop() {
                _this.pos.set(_target.x, _target.y),
                    _this.pos3D.copy(_projection.unproject(_this.pos)),
                    _this.group.updateMatrixWorld(),
                    _m0.copy(_camera.projectionMatrix),
                    _m1.getInverse(_camera.matrixWorld),
                    _this.matrix.multiplyMatrices(_m0, _m1),
                    _this.uniforms.normalMatrix.value.copy(_camera.matrixWorld),
                    _this.uniforms.modelMatrix.value.copy(_this.group.matrixWorld)
            }
            this.resolution = new Vector2,
                this.pos = new Vector2,
                this.pos3D = new Vector3,
                this.matrix = new Matrix4,
                this.uniforms = {
                    projMatrix: {
                        type: "m4",
                        value: this.matrix
                    },
                    pos: {
                        type: "v2",
                        value: this.pos
                    },
                    pos3D: {
                        type: "v3",
                        value: this.pos3D
                    },
                    normalMatrix: {
                        type: "m4",
                        value: new Matrix4
                    },
                    modelMatrix: {
                        type: "m4",
                        value: new Matrix4
                    }
                },
                this.set("camera", (v=>{
                        _camera = v,
                            _projection.camera = _camera
                    }
                )),
                this.set("target", (v=>{
                        _target = v
                    }
                )),
                this.update = loop,
                this.start = function() {
                    _this.startRender(loop)
                }
                ,
                this.stop = function() {
                    _this.stopRender(loop)
                }
        }
    )),
    Class((function GLText({font: font, italic: italic=!1, bold: bold=!1, text: text, width: width=1 / 0, align: align="left", size: size=1, direction: direction="ltr", letterSpacing: letterSpacing=0, lineHeight: lineHeight=1.4, wordSpacing: wordSpacing=0, wordBreak: wordBreak=!1, langBreak: langBreak=!1, paragraphSpacing: paragraphSpacing=1, color: color=new Color("#000000"), alpha: alpha=1, shader: shader="DefaultText"}) {
            const _this = this;
            var _override, _promise = Promise.create();
            const config = GLText.FONT_CONFIG[font];
            function overrideParams() {
                if (GLText.overrideParams) {
                    _override = {
                        letterSpacing: letterSpacing,
                        size: size,
                        wordSpacing: wordSpacing,
                        lineHeight: lineHeight
                    };
                    let obj = GLText.overrideParams({
                        letterSpacing: letterSpacing,
                        size: size,
                        wordSpacing: wordSpacing,
                        lineHeight: lineHeight
                    });
                    letterSpacing = obj.letterSpacing,
                        size = obj.size,
                        wordSpacing = obj.wordSpacing,
                        lineHeight = obj.lineHeight
                }
            }
            function resetOverride() {
                _override && (letterSpacing = _override.letterSpacing,
                    size = _override.size,
                    wordSpacing = _override.wordSpacing,
                    lineHeight = _override.lineHeight)
            }
            !function init() {
                overrideParams(),
                    _this.charLength = text.length,
                    _this.text = new GLTextGeometry({
                        font: font,
                        italic: italic,
                        bold: bold,
                        text: text,
                        width: width,
                        align: align,
                        direction: direction,
                        wordSpacing: wordSpacing,
                        letterSpacing: letterSpacing,
                        paragraphSpacing: paragraphSpacing,
                        size: size,
                        lineHeight: lineHeight,
                        wordBreak: wordBreak,
                        langBreak: langBreak,
                        config: config
                    }),
                    _this.string = text,
                    resetOverride(),
                    _this.text.loaded.then((({buffers: buffers, image: image, imageBold: imageBold, imageItalic: imageItalic, height: height, numLines: numLines})=>{
                            _this.texture = GLText.getTexture(image),
                            bold && (_this.textureBold = GLText.getTexture(imageBold)),
                            italic && (_this.textureItalic = GLText.getTexture(imageItalic)),
                                _this.shader = new Shader(shader,{
                                    tMap: {
                                        value: _this.texture,
                                        ignoreUIL: !0
                                    },
                                    tMapBold: {
                                        value: _this.textureBold || Utils3D.getEmptyTexture(),
                                        ignoreUIL: !0
                                    },
                                    tMapItalic: {
                                        value: _this.textureItalic || Utils3D.getEmptyTexture(),
                                        ignoreUIL: !0
                                    },
                                    uColor: {
                                        value: color,
                                        ignoreUIL: !0
                                    },
                                    uAlpha: {
                                        value: alpha,
                                        ignoreUIL: !0
                                    },
                                    transparent: !0
                                }),
                            _this.onCreateShader && _this.onCreateShader(_this.shader),
                                function createGeometry(buffers) {
                                    _this.geometry = new Geometry,
                                        _this.geometry.addAttribute("position", new GeometryAttribute(buffers.position,3)),
                                        _this.geometry.addAttribute("uv", new GeometryAttribute(buffers.uv,2)),
                                        _this.geometry.addAttribute("animation", new GeometryAttribute(buffers.animation,3)),
                                        _this.geometry.addAttribute("weight", new GeometryAttribute(buffers.weight,1)),
                                        _this.geometry.setIndex(new GeometryAttribute(buffers.index,1)),
                                        _this.geometry.boundingBox = buffers.boundingBox,
                                        _this.geometry.letterCount = buffers.letterCount + 1,
                                        _this.geometry.wordCount = buffers.wordCount + 1,
                                        _this.geometry.lineCount = buffers.lineCount + 1
                                }(buffers),
                                _this.mesh = new Mesh(_this.geometry,_this.shader),
                                _this.height = height,
                                _promise.resolve()
                        }
                    ))
            }(),
                this.onDestroy = function() {
                    _this.mesh.destroy()
                }
                ,
                this.ready = this.loaded = function() {
                    return _promise
                }
                ,
                this.centerY = function() {
                    _this.mesh.position.y = .5 * _this.height,
                        _this.needsCenterY = !0
                }
                ,
                this.resize = function(options) {
                    return this.setText(text, options)
                }
                ,
                this.tweenColor = function(c, time=300, ease="easeOutCubic") {
                    c && color.tween(c, time, ease)
                }
                ,
                this.setColor = function(c) {
                    c && color.set(c)
                }
                ,
                this.setText = function(txt, options) {
                    if ((text != txt || !function match(options) {
                        return !options || options.font == font && options.italic == italic && options.bold == bold && options.width == width && options.align == align && options.direction == direction && !(options.wordSpacing > 0 && options.wordSpacing != wordSpacing) && options.letterSpacing == letterSpacing && options.paragraphSpacing == paragraphSpacing && options.size == size && options.lineHeight == lineHeight && !(!0 === options.wordBreak && !options.wordBreak || 0 == options.wordBreak && options.wordBreak)
                    }(options)) && (text = txt))
                        return function setVars(options) {
                            font = options.font || font,
                                bold = options.bold || bold,
                                italic = options.italic || italic,
                                width = options.width || width,
                                align = options.align || align,
                                wordSpacing = options.wordSpacing || wordSpacing,
                                letterSpacing = options.letterSpacing || letterSpacing,
                                paragraphSpacing = options.paragraphSpacing || paragraphSpacing,
                                size = options.size || size,
                                lineHeight = options.lineHeight || lineHeight,
                                wordBreak = options.wordBreak || wordBreak,
                                langBreak = options.langBreak || langBreak,
                                direction = options.direction || direction
                        }(options || {}),
                            overrideParams(),
                            _this.string = text,
                            _this.charLength = text.length,
                            _this.text = new GLTextGeometry({
                                font: font,
                                italic: italic,
                                bold: bold,
                                text: text,
                                width: width,
                                align: align,
                                direction: direction,
                                wordSpacing: wordSpacing,
                                letterSpacing: letterSpacing,
                                paragraphSpacing: paragraphSpacing,
                                size: size,
                                lineHeight: lineHeight,
                                wordBreak: wordBreak,
                                langBreak: langBreak,
                                config: config
                            }),
                            resetOverride(),
                            _promise = Promise.create(),
                            _this.text.loaded.then((({buffers: buffers, image: image, imageBold: imageBold, imageItalic: imageItalic, height: height, numLines: numLines})=>{
                                    !function updateGeometry(buffers) {
                                        _this.geometry.attributes.position.setArray(buffers.position),
                                            _this.geometry.attributes.uv.setArray(buffers.uv),
                                            _this.geometry.attributes.animation.setArray(buffers.animation),
                                            _this.geometry.attributes.weight.setArray(buffers.weight),
                                            _this.geometry.index = buffers.index,
                                            _this.geometry.indexNeedsUpdate = !0,
                                            _this.geometry.boundingBox = buffers.boundingBox,
                                            _this.geometry.letterCount = buffers.letterCount + 1,
                                            _this.geometry.wordCount = buffers.wordCount + 1,
                                            _this.geometry.lineCount = buffers.lineCount + 1
                                    }(buffers),
                                        _this.height = height,
                                    _this.needsCenterY && _this.centerY(),
                                        _promise.resolve()
                                }
                            )),
                            _promise
                }
                ,
                this.getData = function() {
                    return {
                        font: font,
                        italic: italic,
                        bold: bold,
                        text: text,
                        width: width,
                        align: align,
                        direction: direction,
                        wordSpacing: wordSpacing,
                        letterSpacing: letterSpacing,
                        paragraphSpacing: paragraphSpacing,
                        size: size,
                        lineHeight: lineHeight,
                        wordBreak: wordBreak,
                        langBreak: langBreak,
                        color: color
                    }
                }
        }
    ), (_=>{
            GLText.FONT_CONFIG = {};
            var _map = new Map;
            GLText.getTexture = function(image) {
                if (!_map.get(image)) {
                    let texture = new Texture(image);
                    texture.generateMipmaps = !1,
                        texture.minFilter = Texture.LINEAR,
                        _map.set(image, texture)
                }
                return _map.get(image)
            }
        }
    )),
    Class((function GLTextGeometry({font: font, italic: italic, bold: bold, text: text, width: width=1 / 0, align: align="left", size: size=1, direction: direction="ltr", letterSpacing: letterSpacing=0, paragraphSpacing: paragraphSpacing=1, lineHeight: lineHeight=1.4, wordSpacing: wordSpacing=0, wordBreak: wordBreak=!1, langBreak: langBreak=!1, config: config={}}) {
            let json, image, glyphs, bJson, bImage, bGlyphs, iJson, iImage, iGlyphs, _this = this;
            _this.loaded = Promise.create(),
                async function init() {
                    await async function loadFont() {
                        [json,image,glyphs] = await GLTextGeometry.loadFont(font),
                        bold && ([bJson,bImage,bGlyphs] = await GLTextGeometry.loadFont(bold));
                        italic && ([iJson,iImage,iGlyphs] = await GLTextGeometry.loadFont(italic))
                    }(),
                        async function createGeometry() {
                            let buffers = await GLTextThread.generate({
                                font: font,
                                bold: bold,
                                italic: italic,
                                text: text,
                                width: width,
                                align: align,
                                size: size,
                                direction: direction,
                                letterSpacing: letterSpacing,
                                paragraphSpacing: paragraphSpacing,
                                lineHeight: lineHeight,
                                wordSpacing: wordSpacing,
                                wordBreak: wordBreak,
                                langBreak: langBreak,
                                json: json,
                                glyphs: glyphs,
                                bJson: bJson,
                                bGlyphs: bGlyphs,
                                iJson: iJson,
                                iGlyphs: iGlyphs,
                                config: config
                            });
                            _this.buffers = buffers,
                                _this.image = image,
                                _this.imageBold = bImage,
                                _this.imageItalic = iImage,
                                _this.numLines = buffers.lineLength,
                                _this.height = _this.numLines * size * lineHeight,
                            _this.onLayout && _this.onLayout(buffers, image, _this.height, _this.numLines),
                                _this.loaded.resolve({
                                    buffers: buffers,
                                    image: image,
                                    imageBold: bImage,
                                    imageItalic: iImage,
                                    height: _this.height,
                                    numLines: _this.numLines
                                })
                        }()
                }()
        }
    ), (_=>{
            async function loadJSON(font) {
                return await get(getPathTo(font, "json"))
            }
            async function loadImage(font) {
                return await new Promise((resolve=>{
                        let img = new Image;
                        img.onload = ()=>resolve(img),
                            img.crossOrigin = "anonymous",
                            img.src = getPathTo(font, "png")
                    }
                ))
            }
            function getPathTo(font, ext) {
                let mapped = !1
                    , fontName = function() {
                    for (let key in GLTextGeometry.fontMapping) {
                        let mapping = GLTextGeometry.fontMapping[key];
                        if (key == font)
                            return mapped = !0,
                                mapping
                    }
                    return font
                }()
                    , path = mapped && GLTextGeometry.fontPath ? GLTextGeometry.fontPath : "assets/fonts/";
                return Assets.getPath(path + fontName + "." + ext + `?${window._CACHE_ || Date.now()}`)
            }
            let _promises = {};
            GLTextGeometry.fontMapping = {},
                GLTextGeometry.chars = {},
                GLTextGeometry.loadFont = function(font) {
                    if (!_promises[font]) {
                        let promise = Promise.create();
                        _promises[font] = promise,
                            async function() {
                                let[json,image] = await Promise.all([loadJSON(font), loadImage(font)]);
                                glyphs = {},
                                    json.chars.forEach((d=>glyphs[d.char] = d)),
                                    promise.resolve([json, image, glyphs]),
                                    GLTextGeometry.chars[font] = json.chars
                            }()
                    }
                    return _promises[font]
                }
        }
    )),
    Class((function GLTextThread() {
            var _list = Thread.shared(!0);
            function loadTextGeometry({font: font, bold: bold, italic: italic, text: text, width: width, align: align, size: size, direction: direction, letterSpacing: letterSpacing, paragraphSpacing: paragraphSpacing, lineHeight: lineHeight, wordSpacing: wordSpacing, wordBreak: wordBreak, langBreak: langBreak, json: json, glyphs: glyphs, bJson: bJson, bGlyphs: bGlyphs, iJson: iJson, iGlyphs: iGlyphs, config: config}, pid) {
                const newline = /\n/
                    , whitespace = /\s/
                    , langbreak = !!langBreak && new RegExp(langBreak)
                    , dir = "rtl" === direction ? -1 : 1;
                config || (config = {}),
                    config.boldBaseOffset = config.boldBaseOffset ? config.boldBaseOffset : 0,
                    config.italicBaseOffset = config.italicBaseOffset ? config.italicBaseOffset : 0;
                let weights = []
                    , weight = {
                    0: glyphs,
                    1: bGlyphs,
                    2: iGlyphs
                };
                var buffers;
                function getKernPairOffset(id1, id2) {
                    for (let i = 0; i < json.kernings.length; i++) {
                        let k = json.kernings[i];
                        if (!(k.first < id1) && !(k.second < id2))
                            return k.first > id1 || k.first === id1 && k.second > id2 ? 0 : k.amount
                    }
                    return 0
                }
                !function setWeights() {
                    let i = 0
                        , w = 0;
                    for (; i < text.length; ) {
                        let code = text.substring(i, i + 3)
                            , endcode = text.substring(i, i + 4);
                        "<b>" !== code && "<i>" !== code || (w = "<b>" === code ? 1 : 2,
                            text = text.substr(0, i) + text.substr(i + 3)),
                        "</b>" !== endcode && "</i>" !== endcode || (w = 0,
                            text = text.substr(0, i) + text.substr(i + 4)),
                            weights.push(w),
                            i++
                    }
                }(),
                    function createGeometry() {
                        fontHeight = json.common.lineHeight,
                            baseline = json.common.base,
                            scale = size / baseline;
                        let numChars = text.replace(/[ \n]/g, "").length;
                        buffers = {
                            position: new Float32Array(4 * numChars * 3),
                            uv: new Float32Array(4 * numChars * 2),
                            animation: new Float32Array(3 * numChars * 4),
                            index: new Uint16Array(6 * numChars),
                            weight: new Float32Array(4 * numChars)
                        };
                        for (let i = 0; i < numChars; i++)
                            buffers.index.set([4 * i, 4 * i + 2, 4 * i + 1, 4 * i + 1, 4 * i + 2, 4 * i + 3], 6 * i);
                        !function layout() {
                            const lines = [];
                            let cursor = 0
                                , wordCursor = 0
                                , wordWidth = 0
                                , line = newLine();
                            function newLine(br=!1) {
                                const line = {
                                    width: 0,
                                    glyphs: []
                                };
                                return lines.last() && (lines.last().br = br),
                                    lines.push(line),
                                    wordCursor = cursor,
                                    wordWidth = 0,
                                    line
                            }
                            for (; cursor < text.length; ) {
                                let prev = text[cursor - 1]
                                    , char = text[cursor];
                                text[cursor + 1];
                                if (!line.width && whitespace.test(char) && !(prev && newline.test(char) && newline.test(prev))) {
                                    cursor++,
                                        wordCursor = cursor,
                                        wordWidth = 0;
                                    continue
                                }
                                if (newline.test(char)) {
                                    cursor++,
                                        line = newLine(!0);
                                    continue
                                }
                                let style = weight[weights[cursor]] || weight[0]
                                    , glyph = style[char];
                                if (glyph || (glyph = style.a),
                                    glyph.weight = weights[cursor],
                                    line.glyphs.length) {
                                    const prevGlyph = line.glyphs[line.glyphs.length - 1][0];
                                    let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;
                                    line.width += kern,
                                        wordWidth += kern * dir
                                }
                                let gl = Object.assign({}, glyph);
                                gl.weight = weights[cursor],
                                    line.glyphs.push([gl, line.width]);
                                let advance = 0;
                                if (whitespace.test(char) ? (gl.whitespace = !0,
                                    wordCursor = cursor,
                                    wordWidth = 0,
                                    advance += wordSpacing * size) : advance += letterSpacing * size,
                                    advance += glyph.xadvance * scale,
                                    line.width += advance,
                                    wordWidth += advance,
                                line.width > width) {
                                    if ((wordBreak || char && langBreak && !langbreak.test(char)) && line.glyphs.length > 1) {
                                        line.width -= advance,
                                            line.glyphs.pop(),
                                            line = newLine();
                                        continue
                                    }
                                    if (!wordBreak && wordWidth !== line.width) {
                                        let numGlyphs = cursor - wordCursor + 1;
                                        line.glyphs.splice(-numGlyphs, numGlyphs),
                                            cursor = wordCursor,
                                            line.width -= wordWidth,
                                            line = newLine();
                                        continue
                                    }
                                }
                                cursor++
                            }
                            line.width || lines.pop();
                            if ("justify" === align) {
                                let max = -1 / 0;
                                lines.forEach((l=>{
                                        l.whitespaces = 0,
                                        max < l.width && (max = l.width),
                                            l.glyphs.forEach((g=>{
                                                    g[0].whitespace && l.whitespaces++
                                                }
                                            ))
                                    }
                                )),
                                    lines.forEach((l=>{
                                            let totalToAdd = max - l.width
                                                , addToWhitespace = 0 === l.whitespaces ? 0 : totalToAdd / l.whitespaces;
                                            l.width = max;
                                            let additionalOffset = 0;
                                            l.glyphs.forEach((g=>{
                                                    g[1] += additionalOffset,
                                                    g[0].whitespace && (additionalOffset += addToWhitespace)
                                                }
                                            ))
                                        }
                                    ))
                            }
                            !function populateBuffers(lines) {
                                const texW = json.common.scaleW
                                    , texH = json.common.scaleH;
                                let geom, y = (config.baseOffset ? config.baseOffset : .07) * size, j = 0, glyphIndex = 0, wordIndex = -1, lineId = -1;
                                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                                    let line = lines[lineIndex];
                                    wordIndex++,
                                        lineId++;
                                    for (let i = 0; i < line.glyphs.length; i++) {
                                        const glyph = line.glyphs[i][0];
                                        let x = line.glyphs[i][1];
                                        if (-1 === dir && (x = line.width - x),
                                            "center" === align || "justify" === align ? x -= .5 * line.width : "right" === align && (x -= line.width * dir),
                                            whitespace.test(glyph.char)) {
                                            wordIndex++;
                                            continue
                                        }
                                        1 === glyph.weight && (y += config.boldBaseOffset * scale),
                                        2 === glyph.weight && (y += config.italicBaseOffset * scale),
                                            x += glyph.xoffset * scale * dir,
                                            y -= glyph.yoffset * scale,
                                            buffers.weight.set([glyph.weight, glyph.weight, glyph.weight, glyph.weight], 4 * glyphIndex);
                                        let w = glyph.width * scale
                                            , h = glyph.height * scale;
                                        -1 === dir ? buffers.position.set([x - w, y - h, 0, x - w, y, 0, x, y - h, 0, x, y, 0], 4 * j * 3) : buffers.position.set([x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0], 4 * j * 3),
                                            buffers.animation.set([glyphIndex, wordIndex, lineId, glyphIndex, wordIndex, lineId, glyphIndex, wordIndex, lineId, glyphIndex, wordIndex, lineId], 3 * glyphIndex * 4),
                                            glyphIndex++;
                                        let u = glyph.x / texW
                                            , uw = glyph.width / texW
                                            , v = 1 - glyph.y / texH
                                            , vh = glyph.height / texH;
                                        buffers.uv.set([u, v - vh, u, v, u + uw, v - vh, u + uw, v], 4 * j * 2),
                                        1 === glyph.weight && (y -= config.boldBaseOffset * scale),
                                        2 === glyph.weight && (y -= config.italicBaseOffset * scale),
                                            y += glyph.yoffset * scale,
                                            j++
                                    }
                                    y -= size * lineHeight * (line.br ? paragraphSpacing : 1)
                                }
                                window.zUtils3D && (geom = new Geometry,
                                    geom.addAttribute("position", new GeometryAttribute(buffers.position,3)),
                                    geom.computeBoundingBox());
                                let backing = [];
                                for (let key in buffers)
                                    backing.push(buffers[key].buffer);
                                buffers.lineLength = lines.length,
                                geom && (buffers.boundingBox = geom.boundingBox);
                                buffers.letterCount = glyphIndex,
                                    buffers.lineCount = lineId,
                                    buffers.wordCount = wordIndex,
                                    resolve(buffers, pid, backing)
                            }(lines)
                        }()
                    }()
            }
            Thread.upload(loadTextGeometry),
                this.generate = async function(obj) {
                    let thread = _list.get();
                    thread.queue && await thread.queue,
                        thread.queue = Promise.create();
                    let data = await thread.loadTextGeometry(obj);
                    return thread.queue.resolve(),
                        data
                }
        }
    ), "static"),
    Class((function GLUI() {
            Inherit(this, Component);
            const _this = this;
            function loop() {
                window.Metal || (window.AURA_AR && AURA_AR.active && (World.NUKE.postRender = null,
                    AURA_AR.postRender = loop),
                _this.Scene && _this.Scene.render(),
                _this.Stage && _this.Stage.render())
            }
            window.$gl = function(width, height, map) {
                return new GLUIObject(width,height,map)
            }
                ,
                window.$glText = function(text, fontName, fontSize, options) {
                    return new GLUIText(text,fontName,fontSize,options)
                }
                ,
                this.init = async function(is2D, is3D) {
                    _this.initialized || (void 0 === is2D && (is2D = !0,
                        is3D = !0),
                        await AssetLoader.waitForLib("zUtils3D"),
                        _this.initialized = !0,
                    is2D && (_this.Stage = new GLUIStage),
                    is3D && (_this.Scene = new GLUIStage3D,
                        _this.Scene.interaction.input = Mouse),
                        _this.wait(World, "NUKE", (_=>{
                                _this.Scene && (World.NUKE.onBeforeRender = _this.Scene.mark),
                                    World.NUKE.postRender = loop
                            }
                        )))
                }
                ,
                this.ready = function() {
                    return _this.wait(_this, "initialized")
                }
                ,
                this.renderDirect = function(render) {
                    _this.Scene && _this.Scene.renderDirect(render),
                    _this.Stage && _this.Stage.renderDirect(render)
                }
        }
    ), "static"),
    Class((function GLUIElement() {
            Inherit(this, Component);
            this.element = $gl(),
                this.create = function(w, h, t) {
                    return this.element.create(w, h, t)
                }
        }
    )),
    Class((function GLUIBatch(globalUniforms={}) {
            Inherit(this, Component);
            const _this = this;
            var _timer, _geometry, _shader, _objects = [];
            function loop() {
                if (_geometry)
                    for (let i = 0; i < _objects.length; i++) {
                        let obj = _objects[i];
                        obj.mesh.onBeforeRender(),
                            obj._buffers.forEach((buffer=>{
                                    let dirty = !1;
                                    if (dirty = !buffer.value.equals(buffer.lookup),
                                        buffer.value.copy(buffer.lookup),
                                        dirty) {
                                        let attribute = _geometry.attributes[buffer.key]
                                            , array = attribute.array;
                                        switch (buffer.key) {
                                            case "scale":
                                                array[2 * i + 0] = obj.group.scale.x * obj.mesh.scale.x,
                                                    array[2 * i + 1] = obj.group.scale.y * obj.mesh.scale.y;
                                                break;
                                            case "rotation":
                                                array[i] = buffer.lookup.z;
                                                break;
                                            default:
                                                array[2 * i + 0] = obj.group.position.x,
                                                    array[2 * i + 1] = obj.group.position.y
                                        }
                                        attribute.needsUpdate = !0
                                    }
                                }
                            )),
                            obj._uniforms.forEach((uniform=>{
                                    let dirty = !1;
                                    if ("f" == uniform.type ? (dirty = obj.mesh.shader.uniforms[uniform.key].value != uniform.value,
                                        uniform.value = obj.mesh.shader.uniforms[uniform.key].value) : (dirty = !obj.mesh.shader.uniforms[uniform.key].value.equals(uniform.value),
                                        uniform.value.copy(obj.mesh.shader.uniforms[uniform.key].value)),
                                        dirty) {
                                        let attribute = _geometry.attributes["a_" + uniform.key]
                                            , array = attribute.array;
                                        "f" == uniform.type ? array[i] = uniform.value : uniform.value.toArray(array, i * uniform.components),
                                            attribute.needsUpdate = !0
                                    }
                                }
                            ))
                    }
            }
            function getTypeFromSize(size) {
                switch (size) {
                    case 1:
                        return "float";
                    case 2:
                        return "vec2";
                    case 3:
                        return "vec3";
                    case 4:
                        return "vec4"
                }
            }
            function createMesh() {
                let shader = _objects[0].mesh.shader;
                _geometry = (new Geometry).instanceFrom(_objects[0].mesh.geometry.clone());
                let map = {}
                    , arrays = {};
                _objects.forEach(((obj,i)=>{
                        obj.mesh.onBeforeRender();
                        let buffers = []
                            , uniforms = [];
                        for (let key in shader.uniforms) {
                            let uniform = shader.uniforms[key];
                            uniform.value instanceof Color && uniforms.push({
                                key: key,
                                type: "c",
                                components: 3
                            }),
                            uniform.value instanceof Vector3 && uniforms.push({
                                key: key,
                                type: "v3",
                                components: 3
                            }),
                            uniform.value instanceof Vector2 && uniforms.push({
                                key: key,
                                type: "v",
                                components: 2
                            }),
                            "number" == typeof uniform.value && uniforms.push({
                                key: key,
                                type: "f",
                                components: 1
                            })
                        }
                        buffers.push({
                            key: "offset",
                            lookup: obj.group.position,
                            components: 2
                        }),
                            buffers.push({
                                key: "scale",
                                lookup: obj.group.scale,
                                components: 2
                            }),
                            buffers.push({
                                key: "rotation",
                                lookup: obj.group.rotation,
                                components: 1
                            }),
                            uniforms.forEach((uniform=>{
                                    arrays["a_" + uniform.key] || (arrays["a_" + uniform.key] = []),
                                    map["a_" + uniform.key] || (map["a_" + uniform.key] = uniform);
                                    let value = shader.uniforms[uniform.key].value;
                                    "object" == typeof value ? (uniform.value = value.clone(),
                                        uniform.value.toArray(arrays["a_" + uniform.key], i * uniform.components)) : (uniform.value = shader.uniforms[uniform.key].value,
                                        arrays["a_" + uniform.key].push(uniform.value))
                                }
                            )),
                            buffers.forEach((buffer=>{
                                    switch (arrays[buffer.key] || (arrays[buffer.key] = []),
                                    map[buffer.key] || (map[buffer.key] = buffer),
                                        buffer.value = buffer.lookup.clone(),
                                        buffer.key) {
                                        case "scale":
                                            arrays[buffer.key].push(obj.group.scale.x * obj.mesh.scale.x, obj.group.scale.y * obj.mesh.scale.y);
                                            break;
                                        case "rotation":
                                            arrays[buffer.key].push(buffer.lookup.z);
                                            break;
                                        default:
                                            arrays[buffer.key].push(buffer.lookup.x, buffer.lookup.y)
                                    }
                                }
                            )),
                            obj._buffers = buffers,
                            obj._uniforms = uniforms,
                            obj.shader.neverRender = !0
                    }
                ));
                let attributes = []
                    , defines = [];
                for (let key in map)
                    key.includes("a_") && (attributes.push(`% ${getTypeFromSize(map[key].components)} ${key};`),
                        defines.push(`${key.replace("a_", "v_")} = ${key};`));
                attributes = attributes.join("\n"),
                    defines = defines.join("\n");
                for (let key in arrays)
                    _geometry.addAttribute(key, new GeometryAttribute(new Float32Array(arrays[key]),map[key].components,1));
                let vsSplit = (_shader = _this.initClass(Shader, "GLUIBatch", shader.fsName, Object.assign({}, {
                    transparent: !0
                }, globalUniforms))).vertexShader.split("__ACTIVE_THEORY_LIGHTS__")
                    , fsSplit = _shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__")
                    , definitions = [];
                fsSplit[1].split("\n").forEach((line=>{
                        if (line.includes("uniform")) {
                            if (line.includes("sampler2D"))
                                return;
                            let data = line.split(" ");
                            definitions.push(`${data[2].replace(";", "")} = a_${data[2]}`),
                                vsSplit[1] = `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}` + vsSplit[1],
                                vsSplit[1] = vsSplit[1].replace(line, ""),
                                fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`)
                        }
                    }
                )),
                    vsSplit[1] = vsSplit[1].replace("//vdefines", "\n" + definitions.join("\n")),
                    _shader.vertexShader = vsSplit.join("__ACTIVE_THEORY_LIGHTS__"),
                    _shader.fragmentShader = fsSplit.join("__ACTIVE_THEORY_LIGHTS__"),
                    shader.copyUniformsTo(_shader),
                    _this.mesh = new Mesh(_geometry,_shader),
                    _this.mesh.frustumCulled = !1,
                    _this.group.add(_this.mesh)
            }
            this.group = new Group,
                _this.startRender(loop),
                this.add = function(obj) {
                    clearTimeout(_timer),
                        _timer = _this.delayedCall(createMesh, 50),
                        _this.parent.add(obj),
                        _objects.push(obj)
                }
                ,
                this.onDestroy = function() {
                    _this.mesh.destroy()
                }
        }
    )),
    Class((function GLUIBatchText(globalUniforms={}) {
            Inherit(this, Component);
            const _this = this;
            var _geometry, _shader, _timer, _forceUpdate, _promises = [], _toSplice = [], _objects = [], _offset = 0;
            function loop() {
                if (!_geometry)
                    return;
                let updated = !1;
                for (let key in _geometry.attributes) {
                    let attrib = _geometry.attributes[key];
                    attrib.updateRange.length && (attrib.updateRange.length = 0)
                }
                let len = _objects.length;
                for (let i = 0; i < len; i++) {
                    let obj = _objects[i];
                    obj.mesh.onBeforeRender();
                    let offset = obj._offset
                        , count = obj._count
                        , end = offset + count;
                    obj._buffers.forEach((buffer=>{
                            let dirty = !1;
                            if (dirty = !buffer.value.equals(buffer.lookup),
                                buffer.value.copy(buffer.lookup),
                                dirty) {
                                let array = _geometry.attributes[buffer.key].array;
                                for (let j = offset; j < end; j++)
                                    switch (buffer.components) {
                                        case 2:
                                            array[2 * j + 0] = buffer.lookup.x,
                                                array[2 * j + 1] = buffer.lookup.y;
                                            break;
                                        case 1:
                                            array[j] = buffer.lookup.z
                                    }
                                updated = !0,
                                    buffer.updateRange.offset = offset * buffer.components,
                                    buffer.updateRange.count = count * buffer.components,
                                    _geometry.attributes[buffer.key].updateRange.push(buffer.updateRange),
                                    _geometry.attributes[buffer.key].needsUpdate = !0
                            }
                        }
                    )),
                        obj._uniforms.forEach((uniform=>{
                                let dirty = !1;
                                if ("f" == uniform.type ? (dirty = obj.mesh.shader.uniforms[uniform.key].value != uniform.value,
                                    uniform.value = obj.mesh.shader.uniforms[uniform.key].value) : (dirty = !obj.mesh.shader.uniforms[uniform.key].value.equals(uniform.value),
                                    uniform.value.copy(obj.mesh.shader.uniforms[uniform.key].value)),
                                dirty || _forceUpdate) {
                                    let array = _geometry.attributes["a_" + uniform.key].array;
                                    for (let j = offset; j < end; j++)
                                        "f" == uniform.type ? array[j] = obj.mesh.shader.uniforms[uniform.key].value : obj.mesh.shader.uniforms[uniform.key].value.toArray(array, j * uniform.components);
                                    updated = !0,
                                        uniform.updateRange.offset = offset * uniform.components,
                                        uniform.updateRange.count = count * uniform.components,
                                        _geometry.attributes["a_" + uniform.key].updateRange.push(uniform.updateRange),
                                        _geometry.attributes["a_" + uniform.key].needsUpdate = !0
                                }
                            }
                        ))
                }
                if (updated)
                    for (let key in _geometry.attributes) {
                        let bottom, attrib = _geometry.attributes[key];
                        if (!attrib.updateRange.length)
                            continue;
                        let toSplice = _toSplice;
                        toSplice.length = 0;
                        for (let i = 0; i < attrib.updateRange.length; i++) {
                            let current = attrib.updateRange[i]
                                , prev = attrib.updateRange[i - 1];
                            prev ? prev.offset + prev.count == current.offset ? (bottom.count += current.count,
                                toSplice.push(i)) : bottom = current : bottom = current
                        }
                        for (let i = toSplice.length - 1; i > -1; i--)
                            attrib.updateRange.splice(toSplice[i], 1)
                    }
                _forceUpdate = !1
            }
            async function createMesh() {
                if (_this.flag("mesh"))
                    return;
                _this.flag("mesh", !0),
                    await Promise.all(_promises),
                    await _this.wait(100);
                let mesh = new Mesh(_geometry,_shader);
                _this.mesh = mesh,
                    mesh.frustumCulled = !1,
                    _this.group.add(mesh)
            }
            this.group = new Group,
                _this.flag("canLoad", !0),
                _this.startRender(loop),
                _this.add = async function(obj) {
                    await _this.flag("canLoad"),
                        _this.flag("canLoad", !1),
                        await obj.loaded(),
                        obj.mesh.shader.neverRender = !0,
                        _promises.push(obj.loaded()),
                        function addAttributes(obj, mesh) {
                            let {geometry: geometry, shader: shader} = mesh
                                , count = geometry.attributes.uv.count;
                            mesh.onBeforeRender();
                            let buffers = []
                                , uniforms = [];
                            for (let key in shader.uniforms) {
                                let uniform = shader.uniforms[key];
                                uniform.value instanceof Color && uniforms.push({
                                    key: key,
                                    type: "c",
                                    components: 3
                                }),
                                uniform.value instanceof Vector3 && uniforms.push({
                                    key: key,
                                    type: "v3",
                                    components: 3
                                }),
                                uniform.value instanceof Vector2 && uniforms.push({
                                    key: key,
                                    type: "v",
                                    components: 2
                                }),
                                "number" == typeof uniform.value && uniforms.push({
                                    key: key,
                                    type: "f",
                                    components: 1
                                })
                            }
                            buffers.push({
                                key: "offset",
                                lookup: obj.group.position,
                                components: 2
                            }),
                                buffers.push({
                                    key: "scale",
                                    lookup: obj.group.scale,
                                    components: 2
                                }),
                                buffers.push({
                                    key: "rotation",
                                    lookup: obj.group.rotation,
                                    components: 1
                                }),
                                uniforms.forEach((uniform=>{
                                        uniform.updateRange = {},
                                            uniform.value = shader.uniforms[uniform.key].value,
                                        "object" == typeof uniform.value && (uniform.value = uniform.value.clone()),
                                            uniform.buffer = new Float32Array(count * uniform.components)
                                    }
                                )),
                                buffers.forEach((buffer=>{
                                        buffer.updateRange = {},
                                            buffer.value = buffer.lookup.clone(),
                                            buffer.buffer = new Float32Array(count * buffer.components)
                                    }
                                ));
                            for (let i = 0; i < count; i++)
                                buffers.forEach((buffer=>{
                                        switch (buffer.components) {
                                            case 2:
                                                buffer.buffer[2 * i + 0] = buffer.lookup.x,
                                                    buffer.buffer[2 * i + 1] = buffer.lookup.y;
                                                break;
                                            case 1:
                                                buffer.buffer[i] = buffer.lookup.z
                                        }
                                    }
                                )),
                                    uniforms.forEach((uniform=>{
                                            "f" == uniform.type ? uniform.buffer[i] = shader.uniforms[uniform.key].value : shader.uniforms[uniform.key].value.toArray(uniform.buffer, i * uniform.components)
                                        }
                                    ));
                            buffers.forEach((buffer=>{
                                    geometry.addAttribute(buffer.key, new GeometryAttribute(buffer.buffer,buffer.components))
                                }
                            )),
                                uniforms.forEach((uniform=>{
                                        geometry.addAttribute("a_" + uniform.key, new GeometryAttribute(uniform.buffer,uniform.components))
                                    }
                                )),
                                obj._offset = _offset,
                                obj._count = count,
                                obj._uniforms = uniforms,
                                obj._buffers = buffers,
                                _objects.push(obj),
                                _offset += count
                        }(obj, obj.mesh),
                        _this.parent.add(obj),
                        _geometry ? _geometry.merge(obj.mesh.geometry) : function initGeometry(mesh) {
                            let vsSplit = (_shader = _this.initClass(Shader, "GLUIBatchText", mesh.shader.fsName, Object.assign({}, {
                                transparent: !0
                            }, globalUniforms))).vertexShader.split("__ACTIVE_THEORY_LIGHTS__")
                                , fsSplit = _shader.fragmentShader.split("__ACTIVE_THEORY_LIGHTS__")
                                , definitions = [];
                            fsSplit[1].split("\n").forEach((line=>{
                                    if (line.includes("uniform")) {
                                        if (line.includes("sampler2D"))
                                            return;
                                        let data = line.split(" ");
                                        definitions.push(`${data[2].replace(";", "")} = a_${data[2]}`),
                                            vsSplit[1] = `\nattribute ${data[1]} a_${data[2]}\nvarying ${data[1]} ${data[2]}` + vsSplit[1],
                                            vsSplit[1] = vsSplit[1].replace(line, ""),
                                            fsSplit[1] = fsSplit[1].replace(line, `varying ${data[1]} ${data[2]}`)
                                    }
                                }
                            )),
                                vsSplit[1] = vsSplit[1].replace("//vdefines", "\n" + definitions.join("\n")),
                                _shader.vertexShader = vsSplit.join("__ACTIVE_THEORY_LIGHTS__"),
                                _shader.fragmentShader = fsSplit.join("__ACTIVE_THEORY_LIGHTS__"),
                                mesh.shader.copyUniformsTo(_shader),
                                _geometry = mesh.geometry.clone();
                            for (let key in _geometry.attributes)
                                _geometry.attributes[key].updateRange = []
                        }(obj.mesh),
                        _this.flag("canLoad", !0),
                        clearTimeout(_timer),
                        _timer = _this.delayedCall(createMesh, 50)
                }
                ,
                _this.forceUpdate = function() {
                    _forceUpdate = !0
                }
                ,
                _this.onDestroy = function() {
                    _this.mesh && _this.mesh.destroy()
                }
        }
    )),
    Class((function GLUIStageInteraction2D(_camera, _scene, _stage) {
            Inherit(this, Component);
            const _this = this;
            var _ray, _over, _click, _customTest, _test = [], _objects = this.objects = [], _hold = new Vector2, _calc = new Vector2, _lastTestedPoint = new Vector2;
            function cacheTopScene(obj) {
                let p = obj;
                for (; p; )
                    p instanceof Scene && (obj.interactionScene = p),
                        p = p._parent
            }
            function externalStart() {
                _this._invisible || start(_lastTestedPoint)
            }
            function externalRelease() {
                _this._invisible || end(_lastTestedPoint)
            }
            function move(e) {
                if (GLUI.PREVENT_INTERACTION || _this._invisible)
                    return;
                _ray || ((_ray = new Raycaster(_camera)).testVisibility = !1);
                let objects = function testObjects() {
                    let objects = GLUI.Stage.interaction.objects;
                    _test.length = 0;
                    for (let i = objects.length - 1; i > -1; i--) {
                        let obj = objects[i];
                        obj.interactionScene || cacheTopScene(obj),
                        obj.determineVisible() && _scene == obj.interactionScene && _test.push(obj)
                    }
                    return _test
                }();
                if (!objects.length)
                    return;
                let hit = _ray.checkHit(objects, e, _stage);
                if (hit[0]) {
                    GLUI.HIT = !0;
                    let obj = hit[0].object.glui;
                    _over || ((_over = obj)._onOver({
                        action: "over",
                        object: obj
                    }),
                        Stage.css("cursor", "pointer")),
                    _over != obj && (_over._onOver({
                        action: "out",
                        object: _over
                    }),
                        (_over = obj)._onOver({
                            action: "over",
                            object: obj
                        }),
                        Stage.css("cursor", "pointer"))
                } else
                    GLUI.HIT = !1,
                    _over && (_over._onOver({
                        action: "out",
                        object: _over
                    }),
                        _over = null,
                        Stage.css("cursor", "auto"))
            }
            function start(e) {
                GLUI.PREVENT_INTERACTION || _this._invisible || (Device.mobile && RenderManager.type != RenderManager.WEBVR && move(e),
                _over && !_click && (_click = _over,
                    _hold.copy(e),
                    _hold.time = Date.now()))
            }
            function end(e) {
                if (!GLUI.PREVENT_INTERACTION && !_this._invisible) {
                    if (_customTest && Device.mobile && (e = _lastTestedPoint),
                        GLUI.HIT = !1,
                        _click) {
                        if (Date.now() - _hold.time > 750 || _calc.subVectors(e, _hold).length() > 50)
                            return _click = null;
                        _click == _over && (_click._onClick({
                            action: "click",
                            object: _click
                        }),
                        Device.mobile && _over && (_over._onOver({
                            action: "out",
                            object: _over
                        }),
                            _over = null,
                            Stage.css("cursor", "auto")))
                    }
                    _click = null
                }
            }
            !function addListeners() {
                _this.events.sub(Mouse.input, Interaction.MOVE, move),
                    _this.events.sub(Mouse.input, Interaction.START, start),
                    _this.events.sub(Mouse.input, Interaction.END, end),
                    _this.events.sub(Interaction3D.EXTERNAL_PRESS, externalStart),
                    _this.events.sub(Interaction3D.EXTERNAL_RELEASE, externalRelease)
            }(),
                _this.startRender((_=>{}
                )),
                this.add = function(obj) {
                    _objects.push(obj.mesh || obj)
                }
                ,
                this.remove = function(obj) {
                    _objects.remove(obj.mesh || obj)
                }
                ,
                this.testWith = function(point) {
                    point.customTest = !0,
                        _lastTestedPoint.copy(point),
                        _lastTestedPoint.customTest = !0,
                        move(point),
                    Device.mobile && RenderManager.type != RenderManager.WEBVR && _over && start(point),
                    _customTest || (_customTest = !0,
                        _this.events.unsub(Mouse.input, Interaction.MOVE, move))
                }
        }
    )),
    Class((function GLUIStageInteraction3D() {
            Inherit(this, Component);
            function onHover(e) {
                e.mesh.glui._onOver({
                    action: e.action,
                    object: e.mesh.glui
                })
            }
            function onClick(e) {
                e.mesh.glui._onClick({
                    action: e.action,
                    object: e.mesh.glui
                })
            }
            this.add = function(obj, camera=World.CAMERA) {
                Interaction3D.find(camera).add(obj.mesh || obj, onHover, onClick)
            }
                ,
                this.remove = function(group, camera=World.CAMERA) {
                    Interaction3D.find(camera).remove(obj.mesh || obj)
                }
        }
    )),
    Class((function GLUICornerPin($obj) {
            Inherit(this, Component);
            const _this = this;
            var _geom, _vertices, _last;
            function loop() {
                _vertices[0] = _this.tl.x,
                    _vertices[1] = -_this.tl.y,
                    _vertices[3] = _vertices[9] = _this.bl.x,
                    _vertices[4] = _vertices[10] = -_this.bl.y,
                    _vertices[6] = _vertices[15] = _this.tr.x,
                    _vertices[7] = _vertices[16] = -_this.tr.y,
                    _vertices[12] = _this.br.x,
                    _vertices[13] = -_this.br.y,
                function dirty() {
                    let a = _vertices
                        , b = _last;
                    for (let i = a.length - 1; i > -1; i--)
                        if (a[i] != b[i])
                            return !0;
                    return !1
                }() && (_geom.attributes.position.needsUpdate = !0),
                    _last.set(_vertices)
            }
            this.tl = new Vector2(0,0),
                this.tr = new Vector2($obj.width,0),
                this.bl = new Vector2(0,$obj.height),
                this.br = new Vector2($obj.width,$obj.height),
                function initGeometry() {
                    _geom = $obj.mesh.geometry.toNonIndexed(),
                        $obj.useGeometry(_geom),
                        $obj.mesh.scale.set(1, 1, 1),
                        _vertices = _geom.attributes.position.array,
                        _last = new Float32Array(_vertices)
                }(),
                _this.startRender(loop),
                this.update = function() {
                    this.tl.set(0, 0),
                        this.tr.set($obj.width, 0),
                        this.bl.set(0, $obj.height),
                        this.br.set($obj.width, $obj.height)
                }
                ,
                this.tween = function(type, val, time, ease, delay) {
                    return val = val instanceof Vector2 ? val : new Vector2(val.x,val.y),
                        tween(_this[type], val, time, ease, delay)
                }
        }
    ));
class GLUIObject {
    constructor(width, height, map) {
        let shader = this.textureShader = new Shader("GLUIObject",{
            tMap: {
                value: null
            },
            uAlpha: {
                type: "f",
                value: 1
            },
            transparent: !0,
            depthTest: !1
        });
        shader.persists = !0,
        map || (shader.visible = !1),
            this.usingMap = null != map && "empty" != map && "" != map,
            this.tMap = shader.uniforms.tMap,
            this.group = new Group,
            this.alpha = 1,
            this._x = 0,
            this._y = 0,
            this._z = 0,
            this._scaleX = 1,
            this._scaleY = 1,
            this._scale = 1,
            this._rotation = 0,
            this.multiTween = !0,
            this.children = [],
            this.dimensions = new Vector3(width,height,1),
            this._shader = shader,
            this.mesh = new Mesh(GLUIObject.getGeometry("2d"),shader),
            this.mesh.glui = this,
            this.group.add(this.mesh),
        window.GLSEO && GLSEO.objectNode(this),
            this.bg("string" == typeof map ? map.includes(["#", "0x"]) ? map : "empty" === map || "" === map ? null : Utils3D.getTexture(map, {
                premultiplyAlpha: !1
            }) : map);
        const _this = this;
        this.mesh.onBeforeRender = _=>{
            if (!_this.mesh.determineVisible() && !_this.firstRender)
                return;
            let alpha = _this.getAlpha();
            if (_this.mesh.shader.uniforms.uAlpha && (_this.mesh.shader.uniforms.uAlpha.value = alpha),
                _this.usingMap) {
                if (0 == alpha)
                    return void (_this.mesh.shader.visible = !1);
                _this.mesh.shader.visible = !0
            }
            if (!_this.isDirty && _this.firstRender)
                return;
            RenderStats.active && RenderStats.update("GLUIObject", 1, _this.mesh.shader.vsName + "|" + _this.mesh.shader.fsName, _this.mesh),
                _this.group.position.x = _this._x,
                _this.group.position.y = _this._3d ? _this._y : -_this._y,
                _this.group.position.z = _this._z,
            1 != _this.scale && (_this.group.position.x += (_this.dimensions.x - _this.dimensions.x * _this.scale) / 2,
                _this.group.position.y -= (_this.dimensions.y - _this.dimensions.y * _this.scale) / 2);
            _this.mesh.shader;
            if (_this.calcMask) {
                let v = _this.isMasked;
                v.copy(v.origin),
                    _this.group.localToWorld(v),
                    v.z = v.width,
                    v.w = v.height
            }
            map ? _this.corners || (_this.mesh.scale.set(1, 1, 1).multiply(_this.dimensions),
                _this.group.scale.x = _this._scaleX * _this._scale,
                _this.group.scale.y = _this._scaleY * _this._scale) : _this.group.scale.set(_this._scaleX * _this._scale, _this._scaleY * _this._scale, 1),
            _this._3d || (_this.group.rotation.z = Math.radians(_this._rotation)),
                _this.anchor && _this.anchor._parent ? (_this.anchor.position.copy(_this.group.position),
                    _this.anchor.scale.copy(_this.group.scale),
                    _this.anchor.quaternion.setFromEuler(_this._rotation),
                    _this.anchor.isDirty = !0) : (_this.group.quaternion.setFromEuler(_this._rotation),
                    _this.group.matrixDirty = !0),
            _this.firstRender || (_this.group.updateMatrixWorld(!0),
                _this.firstRender = !0),
                _this.isDirty = !1
        }
            ,
            _this.isDirty = !0
    }
    get width() {
        return this.dimensions.x
    }
    set width(w) {
        this.dimensions.x = w,
            this.isDirty = !0,
        this.__internalDirty && this.__internalDirty()
    }
    get height() {
        return this.dimensions.y
    }
    set height(h) {
        this.dimensions.y = h,
            this.isDirty = !0,
        this.__internalDirty && this.__internalDirty()
    }
    get x() {
        return this._x
    }
    set x(v) {
        this._x = v,
            this.isDirty = !0,
        this.__internalDirty && this.__internalDirty()
    }
    get y() {
        return this._y
    }
    set y(v) {
        this._y = v,
            this.isDirty = !0,
        this.__internalDirty && this.__internalDirty()
    }
    get z() {
        return this._z
    }
    set z(v) {
        this._z = v,
            this.isDirty = !0,
        this.__internalDirty && this.__internalDirty()
    }
    get scale() {
        return this._scale
    }
    set scale(v) {
        this._scale = v,
            this.isDirty = !0,
        this.__internalDirty && this.__internalDirty()
    }
    get scaleX() {
        return this._scaleX
    }
    set scaleX(v) {
        this._scaleX = v,
            this.isDirty = !0,
        this.__internalDirty && this.__internalDirty()
    }
    get scaleY() {
        return this._scaleY
    }
    set scaleY(v) {
        this._scaleY = v,
            this.isDirty = !0,
        this.__internalDirty && this.__internalDirty()
    }
    get rotation() {
        return this._rotation
    }
    set rotation(v) {
        this._rotation = v,
            this.isDirty = !0,
        this.__internalDirty && this.__internalDirty()
    }
    style(props) {
        for (let prop in props)
            void 0 !== this[prop] && (this[prop] = props[prop]);
        return this
    }
    size(w, h) {
        return this.width = w,
            this.height = h,
        this.corners && this.corners.update(),
            this
    }
    add($obj) {
        return $obj.parent = this,
            this.group.add($obj.group),
            this.children.push($obj),
        this.isMasked && $obj.mask(this.isMasked, this.maskShader),
        this._3d && !$obj._3d && $obj.enable3D(),
        this.deferred && ($obj.deferRender(!0),
        $obj.anchor && this.anchor && this.anchor.add($obj.anchor)),
            this
    }
    interact(over, click, camera=World.CAMERA, url, label) {
        "string" == typeof camera && (label = url,
            url = camera,
            camera = World.CAMERA),
            this._onOver = over,
            this._onClick = click,
            this._interactCamera = camera;
        let stage = this._3d ? GLUI.Scene : GLUI.Stage;
        if (over ? stage.interaction.add(this, camera) : stage.interaction.remove(this, camera),
        "string" == typeof url && "string" == typeof label) {
            const _this = this;
            defer((_=>{
                    !_this.seo && window.GLSEO && GLSEO.objectNode(_this),
                    _this.seo && _this.seo.aLink(url, label)
                }
            ))
        }
        return this
    }
    clearInteract() {
        return delete this._onOver,
            delete this._onClick,
            (this._3d ? GLUI.Scene : GLUI.Stage).interaction.remove(this, this._interactCamera),
            this
    }
    remove() {
        this.clearInteract(),
        this.parent && (this.parent.children ? this.parent.children.remove(this) : GLUI.Stage.remove(this)),
            this.mesh.parent ? this.group.parent.remove(this.group) : this._3d ? GLUI.Scene.remove(this) : GLUI.Stage.remove(this)
    }
    create(width, height, map) {
        let $obj = $gl(width, height, map);
        return this.add($obj),
        this._3d && $obj.enable3D(),
            $obj
    }
    removeChild(obj) {
        return this.group.remove(obj.group),
            this
    }
    tween(obj, time, ease, delay) {
        return tween(this, obj, time, ease, delay)
    }
    enable3D(style2d) {
        this._3d = !0,
            this.mesh.geometry = GLUIObject.getGeometry(style2d ? "2d" : "3d"),
            this.mesh.shader.depthTest = !0,
            this._rotation = new Euler;
        const _this = this;
        return _this._rotation.onChange((_=>{
                _this.isDirty = !0
            }
        )),
            this
    }
    loaded() {
        return !0
    }
    setZ(z) {
        return this.mesh.renderOrder = z,
            this
    }
    bg(path) {
        if (void 0 !== path)
            return "string" == typeof path ? path.includes(["#", "0x"]) ? (this.colorShader || (this.colorShader = new Shader("GLUIColor",{
                transparent: !0,
                uAlpha: {
                    type: "f",
                    value: 1
                },
                uColor: {
                    value: new Color(path)
                }
            })),
                this.colorShader.set("uColor", new Color(path)),
            this._shader != this.colorShader && this.useShader(this.colorShader)) : (this.textureShader.uniforms.tMap.value = Utils3D.getTexture(path, {
                premultiplyAlpha: !1
            }),
            this._shader != this.textureShader && this.useShader(this.textureShader)) : this._shader.uniforms.tMap.value = path,
                this
    }
    show() {
        return this.group.matrixDirty = !0,
            this.mesh.matrixDirty = !0,
            this.group.visible = !0,
            this
    }
    hide() {
        return this.group.visible = !1,
            this
    }
    useShader(shader) {
        return shader && (shader != this.textureShader && shader != this.colorShader && (shader.uniforms.tMap = this.mesh.shader.uniforms.tMap,
            shader.uniforms.uAlpha = this.mesh.shader.uniforms.uAlpha),
            shader.depthTest = !1,
            shader.transparent = !0),
            this._shader = shader,
            this.mesh.shader = shader || this._shader,
            this
    }
    depthTest(bool) {
        this.mesh.shader.depthTest = bool
    }
    useGeometry(geom) {
        return this.mesh.geometry = geom,
            this
    }
    updateMap(src) {
        this._shader.uniforms.tMap.value = "string" == typeof src ? Utils3D.getTexture(src) : src
    }
    mask(d, shaderName) {
        var v;
        if (d instanceof Vector4 ? (this.isMasked = !0,
            v = d) : ((v = new Vector4(d.x,d.y,0,1)).origin = (new Vector4).copy(v),
            v.width = d.width,
            v.height = d.height,
            this.calcMask = !0,
            this.isMasked = v),
            this.maskShader = shaderName,
            this.usingMap) {
            let shader = new Shader(shaderName || "GLUIObjectMask",{
                tMap: this.tMap,
                uAlpha: {
                    value: 1
                },
                mask: {
                    type: "v4",
                    value: v
                },
                transparent: !0,
                depthWrite: !1,
                depthTest: !1
            });
            this.useShader(shader)
        }
        return this.group.traverse((obj=>{
                obj.glui && obj.glui != this && obj.glui.mask(v, shaderName)
            }
        )),
            v
    }
    deferRender(parent) {
        this.deferred = !0,
        parent || (this.anchor = new Group,
            GLUI.Scene.addDeferred(this))
    }
    clearTween() {
        return this._mathTweens && this._mathTweens.forEach((t=>{
                t.tween.stop()
            }
        )),
            this
    }
    createCorners() {
        this.corners = new GLUICornerPin(this)
    }
    getAlpha() {
        if (this._gluiParent) {
            let alpha = this._gluiParent.getAlpha();
            return this.alpha = alpha,
                alpha
        }
        let alpha = this.alpha
            , $parent = this.parent;
        for (; $parent; )
            alpha *= $parent.alpha,
                $parent = $parent.parent;
        return alpha
    }
    get shader() {
        return this._shader
    }
    _divFocus() {
        this._onOver && this._onOver({
            action: "over",
            object: this
        }),
        this.onDivFocus && this.onDivFocus()
    }
    _divBlur() {
        this._onOver && this._onOver({
            action: "out",
            object: this
        }),
        this.onDivBlur && this.onDivBlur()
    }
    _divSelect() {
        this._onClick && this._onClick({
            action: "click",
            object: this
        }),
        this.onDivBlurSelect && this.onDivSelect()
    }
    get _parent() {
        return this.parent
    }
}
!function() {
    var _geom2d, _geom3d;
    GLUIObject.getGeometry = function(type) {
        return "2d" == type ? (_geom2d || (_geom2d = new PlaneGeometry(1,1)).applyMatrix((new Matrix4).makeTranslation(.5, -.5, 0)),
            _geom2d) : (_geom3d || (_geom3d = World.PLANE),
            _geom3d)
    }
        ,
        GLUIObject.clear = function() {
            _geom2d = _geom3d = null
        }
}();
class GLUIText {
    constructor(text, fontName, fontSize, options={}) {
        options.font = fontName || options.font,
            options.text = text,
            options.width = options.width,
            options.align = options.align || "left",
            options.size = fontSize || options.size,
            options.lineHeight = options.lineHeight,
            options.letterSpacing = options.letterSpacing,
            options.wordSpacing = options.wordSpacing,
            options.wordBreak = options.wordBreak,
            options.langBreak = options.langBreak,
            options.color = new Color(options.color),
            this.text = new GLText(options),
            this.group = new Group,
            this.alpha = 1,
            this._x = 0,
            this._y = 0,
            this._z = 0,
            this._scaleX = 1,
            this._scaleY = 1,
            this._scale = 1,
            this._rotation = 0,
            this.multiTween = !0;
        const _this = this;
        defer((_=>text && _this.seoText(text))),
            this.text.ready().then((_=>{
                    let mesh = _this.text.mesh;
                    mesh.glui = _this,
                        mesh.shader.visible = !1,
                        _this.mesh = mesh,
                        _this.group.add(mesh),
                    _this._3d && !_this._style2d && _this.text.centerY(),
                    _this._3d || (_this.text.mesh.shader.depthTest = !1),
                        mesh.onBeforeRender = _=>{
                            if (!mesh.determineVisible() && !_this.firstRender)
                                return;
                            let alpha = _this.getAlpha();
                            mesh.shader.uniforms.uAlpha && (mesh.shader.uniforms.uAlpha.value = alpha),
                                0 != alpha ? (mesh.shader.visible = !0,
                                !_this.isDirty && _this.firstRender || (RenderStats.active && RenderStats.update("GLUIText", 1, mesh.shader.vsName + "|" + mesh.shader.fsName, mesh),
                                    _this.group.position.x = _this._x,
                                    _this.group.position.y = _this._3d ? _this._y : -_this._y,
                                    _this.group.position.z = _this._z,
                                    _this.group.scale.set(_this._scaleX * _this._scale, _this._scaleY * _this._scale, 1),
                                    _this._3d ? _this.anchor && _this.anchor._parent ? (_this.anchor.position.copy(_this.group.position),
                                        _this.anchor.scale.copy(_this.group.scale),
                                        _this.anchor.quaternion.setFromEuler(_this._rotation)) : _this.group.quaternion.setFromEuler(_this._rotation) : _this.group.rotation.z = Math.radians(_this._rotation),
                                _this.firstRender || (_this.group.updateMatrixWorld(!0),
                                    _this.firstRender = !0,
                                    mesh.shader.visible = !0),
                                _this.onInternalUpdate && _this.onInternalUpdate(),
                                    _this.isDirty = !1)) : mesh.shader.visible = !1
                        }
                }
            ))
    }
    get x() {
        return this._x
    }
    set x(v) {
        this._x = v,
            this.isDirty = !0
    }
    get y() {
        return this._y
    }
    set y(v) {
        this._y = v,
            this.isDirty = !0
    }
    get z() {
        return this._z
    }
    set z(v) {
        this._z = v,
            this.isDirty = !0
    }
    get scale() {
        return this._scale
    }
    set scale(v) {
        this._scale = v,
            this.isDirty = !0
    }
    get scaleX() {
        return this._scaleX
    }
    set scaleX(v) {
        this._scaleX = v,
            this.isDirty = !0
    }
    get scaleY() {
        return this._scaleY
    }
    set scaleY(v) {
        this._scaleY = v,
            this.isDirty = !0
    }
    get rotation() {
        return this._rotation
    }
    set rotation(v) {
        this._rotation = v,
            this.isDirty = !0
    }
    get dimensions() {
        return this._dimensions || (this._dimensions = {}),
        this.text && this.text.geometry && !this._dimensions.max && (this._dimensions = this.text.geometry.boundingBox,
            this._dimensions.width = Math.abs(this._dimensions.min.x - this._dimensions.max.x),
            this._dimensions.height = Math.abs(this._dimensions.min.y - this._dimensions.max.y)),
            this._dimensions
    }
    interact(over, click, camera=World.CAMERA, seoLink) {
        "string" == typeof camera && (seoLink = camera,
            camera = World.CAMERA),
            this._onOver = over,
            this._onClick = click,
            this._interactCamera = camera;
        let stage = this._3d ? GLUI.Scene : GLUI.Stage;
        const _this = this;
        return _this.text.ready().then((_=>{
                if (over) {
                    if (_this.text.geometry.boundingBox || _this.text.geometry.computeBoundingBox(),
                        !_this.hitArea) {
                        let bb = _this.text.geometry.boundingBox
                            , shader = Utils3D.getTestShader();
                        if (shader.visible = !1,
                            _this.hitArea = new Mesh(World.PLANE,shader),
                            _this.hitArea.glui = _this,
                            _this.hitArea.scale.set(Math.abs(bb.min.x) + Math.abs(bb.max.x), Math.abs(bb.min.y) + Math.abs(bb.max.y), 1),
                        _this._3d && !_this._style2d || (_this.hitArea.position.x = (bb.max.x - bb.min.x) / 2),
                            _this.hitArea.position.y = (bb.min.y - bb.max.y) / 2,
                            _this._3d)
                            switch (_this.text.getData().align) {
                                case "center":
                                    _this.hitArea.position.x = 0;
                                    break;
                                case "right":
                                    _this.hitArea.position.x = (bb.min.x - bb.max.x) / 2
                            }
                        else
                            switch (_this.text.getData().align) {
                                case "center":
                                    _this.hitArea.position.x = 0;
                                    break;
                                case "right":
                                    _this.hitArea.position.x = -(bb.max.x - bb.min.x) / 2
                            }
                        _this.text.mesh.add(_this.hitArea)
                    }
                    stage.interaction.add(_this.hitArea, camera)
                } else
                    stage.interaction.remove(_this.hitArea, camera)
            }
        )),
            defer((_=>{
                    seoLink && _this.seo && _this.seo.aLink(seoLink)
                }
            )),
            this
    }
    remove() {
        let stage = this._3d ? GLUI.Scene : GLUI.Stage;
        this.mesh && this.mesh.parent ? this.group.parent.remove(this.group) : stage.remove(this),
        this.hitArea && stage.interaction.remove(this.hitArea, this._interactCamera),
        this.text && this.text.destroy && this.text.destroy()
    }
    tween(obj, time, ease, delay) {
        return tween(this, obj, time, ease, delay)
    }
    enable3D(style2d) {
        this._3d = !0,
            this._style2d = style2d,
            this._rotation = new Euler;
        const _this = this;
        return _this._rotation.onChange((_=>{
                _this.isDirty = !0
            }
        )),
            _this.text.ready().then((_=>{
                    _this.text.mesh.shader.depthTest = !0
                }
            )),
            _this.isDirty = !0,
            this
    }
    depthTest(bool) {
        const _this = this;
        return _this.text.ready().then((_=>{
                _this.text.mesh.shader.depthTest = bool
            }
        )),
            this
    }
    setZ(z) {
        const _this = this;
        return _this.text.ready().then((_=>{
                _this.text.mesh.renderOrder = z
            }
        )),
            this
    }
    height() {
        return this.mesh ? this.text.height : 0
    }
    setText(text, options) {
        text = text.toString();
        const _this = this;
        return this._dimensions = null,
            this.seoText(text),
            _this.text.ready().then((_=>_this.text.setText(text, options))),
            this
    }
    seoText(text) {
        window.GLSEO && GLSEO.textNode(this, text)
    }
    getTextString() {
        return this.text.string
    }
    setColor(color) {
        const _this = this;
        return _this.text.ready().then((_=>_this.text.setColor(color))),
            this
    }
    tweenColor(color, time, ease, delay) {
        const _this = this;
        return _this.text.ready().then((_=>_this.text.tweenColor(color, time, ease, delay))),
            this
    }
    resize(options) {
        const _this = this;
        _this.text.ready().then((_=>_this.text.resize(options)))
    }
    show() {
        return this.text.ready().then((_=>{
                this.text.mesh.visible = !0,
                    this.text.mesh.updateMatrixWorld(!0)
            }
        )),
            this
    }
    hide() {
        const _this = this;
        return _this.text.ready().then((_=>_this.text.mesh.visible = !1)),
            this
    }
    loaded() {
        return this.text.ready()
    }
    length() {
        return this.text.charLength
    }
    deferRender(parent) {
        this.deferred = !0,
        parent || (this.anchor || (this.anchor = new Group),
            GLUI.Scene.addDeferred(this))
    }
    getAlpha() {
        if (this._gluiParent) {
            let alpha = this._gluiParent.getAlpha();
            return this.alpha = alpha,
                alpha
        }
        let alpha = this.alpha
            , $parent = this.parent;
        for (; $parent; )
            alpha *= $parent.alpha,
                $parent = $parent.parent;
        return alpha
    }
    size() {}
    upload() {
        const _this = this;
        return _this.text.ready().then((_=>_this.text.mesh.upload())),
            this
    }
    _divFocus() {
        this._onOver && this._onOver({
            action: "over",
            object: this
        }),
        this.onDivFocus && this.onDivFocus()
    }
    _divBlur() {
        this._onOver && this._onOver({
            action: "out",
            object: this
        }),
        this.onDivBlur && this.onDivBlur()
    }
    _divSelect() {
        this._onClick && this._onClick({
            action: "click",
            object: this
        }),
        this.onDivBlurSelect && this.onDivSelect()
    }
    get _parent() {
        return this.parent
    }
    async useShader(shader) {
        await this.text.ready(),
            shader.uniforms.tMap = this.text.shader.uniforms.tMap,
            shader.uniforms.uAlpha = this.text.shader.uniforms.uAlpha,
            shader.uniforms.uColor = this.text.shader.uniforms.uColor,
            shader.transparent = !0,
        (!this._3d || this._3d || this.parent) && (shader.depthTest = !1),
            this.text.mesh.shader = shader || text.shader
    }
}
Class((function GLUIStage() {
        Inherit(this, Component);
        const _this = this;
        var _scene = new Scene
            , _camera = new OrthographicCamera(1,1,1,1,.1,1);
        function resizeHandler() {
            _camera.left = Stage.width / -2,
                _camera.right = Stage.width / 2,
                _camera.top = Stage.height / 2,
                _camera.bottom = Stage.height / -2,
                _camera.near = .01,
                _camera.far = 1e3,
                _camera.updateProjectionMatrix(),
                _camera.position.x = Stage.width / 2,
                _camera.position.y = -Stage.height / 2
        }
        this.interaction = new GLUIStageInteraction2D(_camera,_scene,Stage),
            this.alpha = 1,
            this.scene = _scene,
            _scene.disableAutoSort = !0,
            _camera.position.z = 1,
            function addListeners() {
                _this.events.sub(Events.RESIZE, resizeHandler)
            }(),
            resizeHandler(),
            this.add = function($obj) {
                $obj.parent = _this,
                    _scene.add($obj.group || $obj.mesh)
            }
            ,
            this.remove = function($obj) {
                $obj.parent = null,
                    _scene.remove($obj.group)
            }
            ,
            this.renderToRT = function(scene, rt) {
                let clearAlpha;
                rt.fxscene && rt.fxscene.clearAlpha > -1 && (clearAlpha = World.RENDERER.getClearAlpha(),
                    World.RENDERER.setClearAlpha(0));
                let autoClear = World.RENDERER.autoClear;
                World.RENDERER.autoClear = !1,
                    World.RENDERER.render(scene, _camera, rt),
                    World.RENDERER.autoClear = autoClear,
                clearAlpha && World.RENDERER.setClearAlpha(clearAlpha)
            }
            ,
            this.render = function loop() {
                if (!_scene.children.length)
                    return;
                let clear = World.RENDERER.autoClear;
                World.RENDERER.autoClear = !1,
                    World.RENDERER.render(_scene, _camera, null, !0),
                    World.RENDERER.autoClear = clear
            }
            ,
            this.renderDirect = callback=>{
                _scene.children.length && (_scene.traverse((obj=>{
                        obj.shader && (obj.shader.depthTest = !1)
                    }
                )),
                    callback(_scene, _camera))
            }
    }
)),
    Class((function GLUIStage3D() {
            Inherit(this, Object3D);
            const _this = this;
            var _camera, _externalRenders = [], _scene = new Scene, _list = new LinkedList;
            this.alpha = 1,
                this.interaction = new GLUIStageInteraction3D,
                this.add = function(obj, parent) {
                    obj.parent = _this,
                        obj._gluiParent = parent,
                    obj._3d || obj.enable3D(),
                        obj.deferRender()
                }
                ,
                this.addDeferred = function(obj) {
                    _list.push(obj),
                        _scene.add(obj.group || obj.mesh)
                }
                ,
                this.remove = function(obj) {
                    _scene.remove(obj.group || obj.mesh),
                        _list.remove(obj)
                }
                ,
                this.disableAutoSort = function() {
                    _scene.disableAutoSort = !0
                }
                ,
                this.renderToRT = function(scene, camera) {
                    camera = camera.camera || camera,
                        scene.traverse((mesh=>{
                                let obj = mesh.glui;
                                obj && obj.anchor.determineVisible() && Utils3D.decompose(obj.anchor, obj.group)
                            }
                        )),
                        scene._textRenderCamera = camera,
                        _externalRenders.push(scene)
                }
                ,
                this.renderToRT2 = function(scene, rt, camera) {
                    let clearAlpha;
                    rt.fxscene && rt.fxscene.clearAlpha > -1 && (clearAlpha = World.RENDERER.getClearAlpha(),
                        World.RENDERER.setClearAlpha(0));
                    let autoClear = World.RENDERER.autoClear;
                    World.RENDERER.autoClear = !1,
                        World.RENDERER.render(scene, camera, rt),
                        World.RENDERER.autoClear = autoClear,
                    clearAlpha && World.RENDERER.setClearAlpha(clearAlpha)
                }
                ,
                this.render = function loop() {
                    if (!window.Metal) {
                        if (_list.length) {
                            let obj = _list.start();
                            for (; obj; )
                                obj._marked && (obj._marked = !1,
                                    Utils3D.decompose(obj.anchor, obj.group)),
                                    obj = _list.next();
                            let clear = World.RENDERER.autoClear;
                            Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT),
                                World.RENDERER.autoClear = !1,
                                World.RENDERER.render(_scene, _camera || World.CAMERA),
                                World.RENDERER.autoClear = clear
                        }
                        if (_externalRenders.length)
                            for (; _externalRenders.length; ) {
                                let scene = _externalRenders.shift()
                                    , camera = scene._textRenderCamera
                                    , clear = World.RENDERER.autoClear;
                                Renderer.context.clear(Renderer.context.DEPTH_BUFFER_BIT),
                                    World.RENDERER.autoClear = !1,
                                    World.RENDERER.render(scene, camera),
                                    World.RENDERER.autoClear = clear
                            }
                    }
                }
                ,
                this.mark = function mark() {
                    let obj = _list.start();
                    for (; obj; )
                        obj.anchor._parent && (obj.group.visible = obj.anchor.determineVisible()),
                        obj.mesh && obj.mesh.determineVisible() && obj.anchor._parent && (obj._marked = !0),
                            obj = _list.next()
                }
                ,
                this.renderDirect = function(callback) {
                    if (_list.length) {
                        let obj = _list.start();
                        for (; obj; )
                            obj._marked && (obj._marked = !1,
                                Utils3D.decompose(obj.anchor, obj.group)),
                                obj = _list.next();
                        _scene.traverse((obj=>{
                                obj.shader && (obj.shader.depthTest = !1)
                            }
                        )),
                            callback(_scene, _camera || World.CAMERA)
                    }
                }
                ,
                this.set("camera", (c=>{
                        _camera = c.camera || c
                    }
                ))
        }
    )),
    Class((function GPU() {
            Inherit(this, Component);
            var _this = this
                , _split = {};
            Hydra.ready((async()=>{
                    for (var key in _this.detect = function(match) {
                        if (Device.graphics.gpu)
                            return Device.graphics.gpu.detect(match)
                    }
                        ,
                        _this.detectAll = function() {
                            if (Device.graphics.gpu) {
                                for (var match = !0, i = 0; i < arguments.length; i++)
                                    Device.graphics.gpu.detect(arguments[i]) || (match = !1);
                                return match
                            }
                        }
                        ,
                        _this.matchGPU = function(str, min, max=99999) {
                            let num = function splitGPU(string) {
                                if (_split[string])
                                    return _split[string];
                                if (!_this.detect(string))
                                    return -1;
                                try {
                                    var num = Number(_this.gpu.split(string)[1].split(" ")[0]);
                                    return _split[string] = num,
                                        num
                                } catch (e) {
                                    return -1
                                }
                            }(str);
                            return num >= min && num < max
                        }
                        ,
                        _this.gpu = Device.graphics.gpu ? Device.graphics.gpu.identifier : "",
                    "ios" == Device.system.os && "apple gpu" == _this.gpu && require("iOSGPUTest")(),
                        _this.BLACKLIST = require("GPUBlacklist").match(),
                        _this.T0 = !(Device.mobile || !_this.BLOCKLIST && !_this.detect("radeon(tm) r5") && !_this.detect("radeon r9 200") && !_this.detect("hd graphics family") && !_this.detect("intel(r) uhd graphics direct") && !_this.matchGPU("hd graphics ", 1e3, 5001) && !(_this.matchGPU("hd graphics ", 0, 618) && Device.pixelRatio > 1) && !(_this.detect(["hd graphics", "iris"]) && Math.max(Stage.width, Stage.height) > 1800) && !_this.detect(["intel iris opengl engine"]) && !_this.matchGPU("iris(tm) graphics ", 1e3)),
                        _this.T1 = !(_this.BLOCKLIST || Device.mobile || _this.T0 || !_this.matchGPU("iris(tm) graphics ", 540, 1e3) && !_this.matchGPU("hd graphics ", 514, 1e3) && !_this.matchGPU("intel(r) uhd graphics ", 600, 1e3) && _this.detect(["nvidia", "amd", "radeon", "geforce", "apple"]) && !_this.detect(["vega 8"])),
                        _this.T2 = !_this.BLOCKLIST && !Device.mobile && !(!_this.detect(["nvidia", "amd", "radeon", "geforce"]) || _this.T1 || _this.T0),
                        _this.T3 = !(_this.BLOCKLIST || Device.mobile || !_this.detect(["titan", "amd radeon pro", "quadro"]) && !_this.matchGPU("gtx ", 940) && !_this.matchGPU("radeon (tm) rx ", 400) && !_this.detect("amd radeon(tm) graphics direct3d11 vs_5_0") && !_this.matchGPU("radeon rx ", 400) && !_this.matchGPU("radeon pro ", 420)),
                        _this.T4 = !(_this.BLOCKLIST || Device.mobile || !_this.detect(["titan", "quadro", "radeon vii", "apple m"]) && !_this.matchGPU("gtx ", 1060) && !_this.matchGPU("rtx") && !_this.matchGPU("radeon rx ", 500) && !_this.matchGPU("vega ", 50) && !_this.detect(["radeon pro 5300m", "radeon pro 5500m", "radeon pro 5600m", "amd radeon unknown prototype"])),
                        _this.T5 = !(_this.BLOCKLIST || Device.mobile || !_this.detect(["titan", "radeon vii"]) && !_this.matchGPU("gtx ", 1080) && !_this.matchGPU("rtx ", 2060) && !_this.matchGPU("radeon rx ", 5500) && (!_this.detect("apple m") || !_this.detect("max"))),
                        _this.MT0 = !!Device.mobile && (!!_this.BLOCKLIST || !("ios" != Device.system.os || !_this.detect("a7")) || !("android" != Device.system.os || !_this.detect("sgx")) || (_this.detect("adreno") ? _this.matchGPU("adreno (tm) ", 0, 415) : _this.detect("mali") ? _this.matchGPU("mali-t", 0, 628) : !("ios" != Device.system.os || !_this.detect(["a8", "a9"])) || !!_this.detect("mali-g") || !!_this.matchGPU("adreno (tm) ", 420))),
                        _this.MT1 = function() {
                            if (!Device.mobile)
                                return !1;
                            if (_this.BLOCKLIST)
                                return !1;
                            if ("ios" == Device.system.os && _this.detect("a10"))
                                return !0;
                            if ("android" == Device.system.os && !_this.MT0)
                                return !0;
                            if (_this.detect("nvidia tegra") && Device.detect("pixel c"))
                                return !0;
                            if (_this.detect("mali-g"))
                                return _this.matchGPU("mali-g", 73);
                            if (_this.detect("adreno")) {
                                if (_this.matchGPU("adreno (tm) ", 600, 616))
                                    return !0;
                                if (_this.matchGPU("adreno (tm) ", 530, 600))
                                    return !0
                            }
                            return !1
                        }(),
                        _this.MT2 = !!Device.mobile && !_this.BLOCKLIST && (!("ios" != Device.system.os || !_this.detect(["a11", "a12"])) || (_this.detect("adreno") ? _this.matchGPU("adreno (tm) ", 630) : _this.detect("mali-g") ? _this.matchGPU("mali-g", 74) : !(!navigator.platform.toLowerCase().includes(["mac", "windows"]) || "chrome" != Device.system.browser))),
                        _this.MT3 = !!Device.mobile && !_this.BLOCKLIST && (!("ios" != Device.system.os || !_this.detect(["a12", "a13", "a14", "a15", "a16", "a17", "a18"])) || (_this.detect("adreno") ? _this.matchGPU("adreno (tm) ", 640) : _this.detect("mali-g") ? _this.matchGPU("mali-g", 76) : !(!navigator.platform.toLowerCase().includes(["mac", "windows"]) || "chrome" != Device.system.browser))),
                        _this.MT4 = !!Device.mobile && !_this.BLOCKLIST && (!("ios" != Device.system.os || !_this.detect(["a14", "a15", "a16", "a17", "a18", "a19", "a20", "apple m"])) || (_this.detect("adreno") ? _this.matchGPU("adreno (tm) ", 650) : _this.detect("mali-g") ? _this.matchGPU("mali-g", 78) : !(!navigator.platform.toLowerCase().includes(["mac", "windows"]) || "chrome" != Device.system.browser))),
                        _this.lt = function(num) {
                            return _this.TIER > -1 && _this.TIER <= num
                        }
                        ,
                        _this.gt = function(num) {
                            return _this.TIER > -1 && _this.TIER >= num
                        }
                        ,
                        _this.eq = function(num) {
                            return _this.TIER > -1 && _this.TIER == num
                        }
                        ,
                        _this.mobileEq = function(num) {
                            return _this.M_TIER > -1 && _this.M_TIER == num
                        }
                        ,
                        _this.mobileLT = function(num) {
                            return _this.M_TIER > -1 && _this.M_TIER <= num
                        }
                        ,
                        _this.mobileGT = function(num) {
                            return _this.M_TIER > -1 && _this.M_TIER >= num
                        }
                        ,
                        _this)
                        "T" == key.charAt(0) && !0 === _this[key] && (_this.TIER = Number(key.charAt(1))),
                        "MT" == key.slice(0, 2) && !0 === _this[key] && (_this.M_TIER = Number(key.charAt(2)));
                    !1 !== Utils.query("gpu") && (Device.mobile || Utils.query("gpu").toString().includes("m") ? (_this.TIER = -1,
                        _this.M_TIER = Number(Utils.query("gpu").slice(1))) : _this.TIER = Number(Utils.query("gpu"))),
                        _this.OVERSIZED = !Device.mobile && _this.TIER <= 0 && Math.max(window.innerWidth, window.innerHeight) > 1400 || !Device.mobile && _this.TIER <= 1 && Math.max(window.innerWidth, window.innerHeight) > 1600,
                    "ie" == Device.system.browser && (_this.OVERSIZED = !0),
                        _this.initialized = !0
                }
            )),
                this.ready = function() {
                    return this.wait("initialized")
                }
        }
    ), "static"),
    Module((function iOSGPUTest() {
            function test() {
                let results = [];
                function getPrime() {
                    return function largest_prime_factor(n) {
                        return factors(n).filter(primep).pop()
                    }(1e11)
                }
                function factors(n) {
                    var i, out = [], sqrt_n = Math.sqrt(n);
                    for (i = 2; i <= sqrt_n; i++)
                        n % i == 0 && out.push(i);
                    return out
                }
                function primep(n) {
                    return 0 === factors(n).length
                }
                for (let i = 0; i < 3; i++) {
                    let time = performance.now();
                    getPrime(),
                        results.push(10 * (performance.now() - time))
                }
                return results.sort(((a,b)=>a - b)),
                    results[0]
            }
            this.exports = function() {
                let res = Math.min(screen.width, screen.height) + "x" + Math.max(screen.width, screen.height)
                    , time = test();
                switch (res) {
                    case "320x480":
                        Device.graphics.webgl.gpu = "legacy";
                        break;
                    case "320x568":
                        Device.graphics.webgl.gpu = time <= 400 ? "apple a8" : time <= 500 ? "apple a7" : "legacy";
                        break;
                    case "375x812":
                    case "414x896":
                        Device.graphics.webgl.gpu = time <= 160 ? "apple a13" : time <= 180 ? "apple a12" : "apple a11";
                        break;
                    default:
                    case "414x736":
                    case "375x667":
                        Device.pixelRatio >= 3 ? Device.graphics.webgl.gpu = time <= 160 ? "apple a13" : time <= 180 ? "apple a12" : time <= 220 ? "apple a11" : time <= 250 ? "apple a10" : time <= 360 ? "apple a9" : time <= 400 ? "apple a8" : time <= 600 ? "apple a7" : "legacy" : Device.graphics.webgl.gpu = time <= 400 ? "apple a8" : time <= 600 ? "apple a7" : "legacy";
                        break;
                    case "768x1024":
                        Device.graphics.webgl.gpu = "apple a8";
                        break;
                    case "834x1112":
                        Device.graphics.webgl.gpu = time <= 160 ? "apple a13" : time <= 180 ? "apple a12" : time <= 220 ? "apple a11" : "apple a10";
                        break;
                    case "834x1194":
                        Device.graphics.webgl.gpu = "apple a12";
                        break;
                    case "1024x1366":
                        Device.graphics.webgl.gpu = time <= 160 ? "apple a13" : time <= 180 ? "apple a12" : time <= 220 ? "apple a11" : time <= 250 ? "apple a10" : "apple a9"
                }
            }
        }
    )),
    Module((function GPUBlacklist() {
            this.exports = {
                match: function() {
                    return !Device.graphics.gpu || Device.graphics.gpu.detect(["radeon hd 6970m", "radeon hd 6770m", "radeon hd 6490m", "radeon hd 6630m", "radeon hd 6750m", "radeon hd 5750", "radeon hd 5670", "radeon hd 4850", "radeon hd 4870", "radeon hd 4670", "geforce 9400m", "geforce 320m", "geforce 330m", "geforce gt 130", "geforce gt 120", "geforce gtx 285", "geforce 8600", "geforce 9600m", "geforce 9400m", "geforce 8800 gs", "geforce 8800 gt", "quadro fx 5", "quadro fx 4", "radeon hd 2600", "radeon hd 2400", "radeon hd 2600", "radeon r9 200", "mali-4", "mali-3", "mali-2", "google swiftshader", "sgx543", "legacy", "sgx 543"])
                }
            }
        }
    )),
    Class((function Initializer3D() {
            Inherit(this, Component);
            const _this = this;
            let _loader, _working, _promises = [], _queue = [];
            async function resolve() {
                await Promise.all(_promises),
                    clearTimeout(_this.fire),
                    _this.fire = _this.delayedCall((_=>{
                            _this.events.fire(_this.READY),
                                _this.resolved = !0,
                                Utils3D.onTextureCreated = null,
                            _loader && _loader.trigger(50)
                        }
                    ), 100)
            }
            async function workQueue() {
                clearTimeout(_this.warningTimer),
                    _working = !0;
                let promise = _queue.shift();
                if (!promise)
                    return _working = !1;
                promise.resolve(workQueue),
                Hydra.LOCAL && (_this.warningTimer = _this.delayedCall((_=>{
                        console.warn("Long running queue has taken more than 5 seconds.")
                    }
                ), 5e3))
            }
            function incCompleted() {
                _loader && _loader.trigger(1)
            }
            this.READY = "initializer_ready",
                this.bundle = function() {
                    return new function PromiseBundler() {
                        const promises = []
                            , ready = Promise.create();
                        let timer;
                        function run() {
                            clearTimeout(timer),
                                timer = _this.delayedCall((_=>{
                                        Promise.all(promises).then((_=>ready.resolve()))
                                    }
                                ), 100)
                        }
                        this.capture = function(promise) {
                            promises.push(promise),
                                run()
                        }
                            ,
                            this.ready = function() {
                                return run(),
                                    ready
                            }
                    }
                }
                ,
                this.promise = this.capture = function(promise) {
                    return _loader && _loader.add(1),
                        promise.then(incCompleted),
                        _promises.push(promise),
                        clearTimeout(_this.timer),
                        _this.timer = _this.delayedCall(resolve, 100),
                        promise
                }
                ,
                this.ready = this.loaded = function() {
                    return _this.wait(_this, "resolved")
                }
                ,
                this.createWorld = async function() {
                    await Promise.all([AssetLoader.waitForLib("zUtils3D"), Shaders.ready(), UILStorage.ready()]),
                        World.instance()
                }
                ,
                this.linkSceneLayout = function(loader) {
                    _this.captureTextures(),
                        SceneLayout.initializer = _this.capture,
                        _loader = loader
                }
                ,
                this.queue = function(immediate) {
                    if (immediate)
                        return Promise.resolve((_=>{}
                        ));
                    let promise = Promise.create();
                    return _queue.push(promise),
                    _working || workQueue(),
                        promise
                }
                ,
                this.captureTextures = function() {
                    Utils3D.onTextureCreated = texture=>{
                        _this.promise(texture.promise)
                    }
                }
                ,
                this.uploadAll = async function(group) {
                    if (!group)
                        throw "Undefined passed to uploadAll";
                    group instanceof SceneLayout && (await group.ready(),
                        group = group.group);
                    let promises = []
                        , layouts = [];
                    group.traverse((obj=>{
                            if (obj.sceneLayout && obj != group && layouts.push(obj.sceneLayout),
                                !obj.uploadIgnore) {
                                if (obj.shader)
                                    for (let key in obj.shader.uniforms) {
                                        let uniform = obj.shader.uniforms[key];
                                        uniform.value instanceof Texture && uniform.value.promise && promises.push(uniform.value.promise.then((_=>uniform.value.upload.bind(uniform.value))).catch((e=>{}
                                        )))
                                    }
                                obj.asyncPromise ? promises.push(obj.asyncPromise.then((_=>obj.upload.bind(obj)))) : obj.upload && obj.upload()
                            }
                        }
                    )),
                        await Promise.catchAll(promises);
                    for (let i = 0; i < layouts.length; i++)
                        await _this.uploadAll(layouts[i])
                }
                ,
                this.uploadAllDistributed = this.uploadAllAsync = async function(group) {
                    if (!group)
                        throw "Undefined passed to uploadAllDistributed";
                    group instanceof SceneLayout && (await group.ready(),
                        group = group.group);
                    let uploads = []
                        , _async = []
                        , promises = []
                        , layouts = [];
                    group.traverse((obj=>{
                            if (obj.sceneLayout && obj != group && layouts.push(obj.sceneLayout),
                            !obj.uploadIgnore && 0 != obj.visible) {
                                if (obj.shader)
                                    for (let key in obj.shader.uniforms) {
                                        let uniform = obj.shader.uniforms[key];
                                        uniform.value instanceof Texture && uniform.value.promise && promises.push(uniform.value.promise.then((_=>uploads.push(uniform.value.upload.bind(uniform.value)))).catch((e=>{}
                                        )))
                                    }
                                obj.asyncPromise ? promises.push(obj.asyncPromise.then((_=>{
                                        obj.geometry && (obj.geometry.distributeBufferData = !0),
                                            uploads.push(obj.upload.bind(obj)),
                                        obj.geometry && _async.push(obj.geometry.uploadBuffersAsync.bind(obj.geometry))
                                    }
                                ))) : obj.upload && (obj.geometry && (obj.geometry.distributeBufferData = !0),
                                    uploads.push(obj.upload.bind(obj)),
                                obj.geometry && _async.push(obj.geometry.uploadBuffersAsync.bind(obj.geometry)))
                            }
                        }
                    ));
                    let canFinish = !1
                        , promise = Promise.create()
                        , worker = new Render.Worker((_=>{
                            let upload = uploads.shift();
                            upload ? upload() : canFinish ? ((async _=>{
                                    for (let i = 0; i < _async.length; i++)
                                        await _async[i]();
                                    for (let i = 0; i < layouts.length; i++)
                                        await _this.uploadAllAsync(layouts[i]);
                                    promise.resolve()
                                }
                            )(),
                                worker.stop()) : worker.pause()
                        }
                    ),1);
                    return Promise.catchAll(promises).then((_=>{
                            worker.resume(),
                                canFinish = !0
                        }
                    )),
                        promise
                }
                ,
                this.detectUploadAll = function(group, sync) {
                    return sync ? _this.uploadAll(group) : _this.uploadAllDistributed(group)
                }
                ,
                this.set("loader", (loader=>{
                        _loader = loader
                    }
                ))
        }
    ), "static"),
    Class((function AreaLightUtil() {
            Inherit(this, Component);
            var _init, _loaded = Promise.create(), _textures = [];
            this.append = async function(shader) {
                Lighting.fallbackAreaToPoint || (_init || async function load() {
                    _init = !0;
                    let data = await fetch(Assets.getPath("assets/images/_lighting/arealights.json"))
                        , json = await data.json();
                    _textures[0] = new DataTexture(new Float32Array(json.LTC1),64,64,Texture.RGBAFormat,Texture.FLOAT),
                        _textures[1] = new DataTexture(new Float32Array(json.LTC2),64,64,Texture.RGBAFormat,Texture.FLOAT),
                        _loaded.resolve()
                }(),
                    shader.uniforms.tLTC1 = {
                        type: "t",
                        value: null
                    },
                    shader.uniforms.tLTC2 = {
                        type: "t",
                        value: null
                    },
                    await _loaded,
                    shader.set("tLTC1", _textures[0]),
                    shader.set("tLTC2", _textures[1]))
            }
        }
    ), "static"),
    Class((function Light(_input, _group) {
            Inherit(this, Object3D);
            const _this = this;
            var _config, _folder, _debug, prefix = `L_${_input.prefix}`, _light = this.light = new BaseLight;
            function loop() {
                _light.position.copy(_this.group.position),
                    _light.rotation.copy(_this.group.rotation)
            }
            function initNumber(key) {
                let initValue = UILStorage.get(`${prefix}${key}`) || _light[key];
                if (_folder) {
                    let number = new UILControlNumber(`${prefix}${key}`,{
                        label: key,
                        value: initValue,
                        step: .05
                    });
                    number.onChange((e=>{
                            _light[key] = e,
                                _this.events.fire(Light.UPDATE, {
                                    prefix: prefix,
                                    key: key,
                                    val: e,
                                    group: _this
                                })
                        }
                    )),
                        number.onFinishChange((e=>UILStorage.set(`${prefix}${key}`, e))),
                        _folder.add(number)
                }
                _light[key] = initValue
            }
            function update(e) {
                e.prefix == prefix && e.group != _this && (e.color ? _light[e.key].set(e.val) : _light[e.key] = e.val)
            }
            !function() {
                !async function initConfig() {
                    (_config = InputUIL.create(prefix + "_config", _group)).setLabel("Config"),
                        _config.addSelect("type", [{
                            label: "Null",
                            value: "-1"
                        }, {
                            label: "Directional",
                            value: "0"
                        }, {
                            label: "Point",
                            value: "1"
                        }, {
                            label: "Spot",
                            value: "2"
                        }, {
                            label: "Area",
                            value: "3"
                        }]),
                        await defer();
                    let setup = _=>{
                            _light.properties.w = _config.getNumber("type") + 1,
                            _group && Utils.query("debugLight") && (_debug && _debug.destroy(),
                                _debug = _this.initClass(LightDebug, _config.getNumber("type"), _light, _folder))
                        }
                    ;
                    setup(),
                        function initSpecificUIL(type) {
                            switch (type) {
                                case 0:
                                    break;
                                case 2:
                                    _light.radius = 1,
                                        _light.feather = 0,
                                        _light.rotation.set(0, Math.radians(90), 0),
                                        initNumber("radius"),
                                        initNumber("feather"),
                                        _light.data.set(_light.rotation.z, _light.rotation.y, _light.rotation.x, _light.radius),
                                        _light.data2.x = _light.feather,
                                    _group && _this.startRender((_=>{
                                            _light.data2.x = _light.feather,
                                                _light.data.set(_light.rotation.z, _light.rotation.y, _light.rotation.x, _light.radius)
                                        }
                                    ));
                                    break;
                                case 3:
                                    _light._overridePos = new Vector3,
                                        _light.width = 1,
                                        _light.height = 1,
                                        _light.roughness = .5,
                                        _light.isAreaLight = !0,
                                        initNumber("width"),
                                        initNumber("height"),
                                        initNumber("roughness");
                                    let pos = new Vector3
                                        , matrix4 = new Matrix4
                                        , matrix42 = new Matrix4
                                        , halfWidth = new Vector3
                                        , halfHeight = new Vector3
                                        , camera = World.CAMERA
                                        , p = _this.group._parent;
                                    for (; p; )
                                        p instanceof Scene && p.nuke && (camera = p.nuke.camera),
                                            p = p._parent;
                                    let updateProperties = _=>{
                                            _light.updateMatrixWorld(!0),
                                                pos.setFromMatrixPosition(_light.matrixWorld),
                                                pos.applyMatrix4(camera.matrixWorldInverse),
                                                _light.data.x = pos.x,
                                                _light.data.y = pos.y,
                                                _light.data.z = pos.z,
                                                _light.data.w = _light.roughness,
                                                matrix42.identity(),
                                                matrix4.copy(_light.matrixWorld),
                                                matrix4.premultiply(camera.matrixWorldInverse),
                                                matrix42.extractRotation(matrix4),
                                                halfWidth.set(.5 * _light.width, 0, 0),
                                                halfHeight.set(0, .5 * _light.height, 0),
                                                halfWidth.applyMatrix4(matrix42),
                                                halfHeight.applyMatrix4(matrix42),
                                                _light.data2.x = halfWidth.x,
                                                _light.data2.y = halfWidth.y,
                                                _light.data2.z = halfWidth.z,
                                                _light.data3.x = halfHeight.x,
                                                _light.data3.y = halfHeight.y,
                                                _light.data3.z = halfHeight.z
                                        }
                                    ;
                                    RenderManager.type == RenderManager.WEBVR ? _this.events.sub(RenderManager.EYE_RENDER, (e=>{
                                            _this.invisible || (camera = e.camera,
                                                updateProperties())
                                        }
                                    )) : _this.startRender(updateProperties)
                            }
                        }(_config.getNumber("type")),
                        _config.onUpdate = setup
                }(),
                _group && (_folder = function createFolder() {
                    if (!UIL.sidebar)
                        return null;
                    let folder = new UILFolder(prefix,{
                        label: "Params",
                        closed: !0
                    });
                    return _group.add(folder),
                        folder
                }(),
                    function addListeners() {
                        _this.events.sub(Light.UPDATE, update)
                    }()),
                    initNumber("intensity"),
                    initNumber("distance"),
                    initNumber("bounce"),
                    function initColor(key) {
                        let initValue = UILStorage.get(`${prefix}${key}`);
                        if (_folder) {
                            let color = new UILControlColor(`${prefix}${key}`,{
                                label: key,
                                value: initValue
                            });
                            color.onChange((e=>{
                                    _light[key].set(e),
                                        _this.events.fire(Light.UPDATE, {
                                            prefix: prefix,
                                            key: key,
                                            val: e,
                                            color: !0,
                                            group: _this
                                        })
                                }
                            )),
                                color.onFinishChange((e=>UILStorage.set(`${prefix}${key}`, e))),
                                _folder.add(color)
                        }
                        initValue && _light[key].set(initValue)
                    }("color");
                let p = _this.parent.group._parent;
                for (; p; )
                    p instanceof Scene && p._lightingData && (_light._lightingData = p._lightingData),
                        p = p._parent;
                Lighting.add(_light),
                    _this.startRender(loop)
            }()
        }
    ), (_=>{
            Light.UPDATE = "light_update"
        }
    )),
    Class((function LightDebug(_type, _light, _folder) {
            Inherit(this, Object3D);
            const _this = this;
            function createLight() {
                let geom = World.SPHERE
                    , shader = Utils3D.getTestShader(_light.color);
                shader.set("color", _light.color),
                    shader.depthTest = !1,
                    shader.transparent = !0;
                let mesh = new Mesh(geom,shader);
                mesh.scale.setScalar(.5),
                    _this.add(mesh)
            }
            !function() {
                switch (_type) {
                    case -1:
                    case 1:
                        !function initPoint() {
                            createLight();
                            let geom = new IcosahedronGeometry(1,1)
                                , shader = Utils3D.getTestShader(_light.color);
                            shader.set("color", _light.color),
                                shader.wireframe = !0,
                                shader.transparent = !0,
                                shader.set("alpha", .2);
                            let mesh = new Mesh(geom,shader);
                            mesh.scale.setScalar(_light.distance),
                                _this.add(mesh),
                                _this.startRender((_=>mesh.scale.setScalar(_light.distance)))
                        }();
                        break;
                    case 2:
                        !function initSpot() {
                            createLight()
                        }();
                        break;
                    case 3:
                        !function initArea() {
                            let geom = World.PLANE
                                , shader = Utils3D.getTestShader(_light.color);
                            shader.set("color", _light.color),
                                shader.transparent = !0,
                                shader.side = Shader.DOUBLE_SIDE;
                            let mesh = new Mesh(geom,shader);
                            _this.add(mesh),
                                _this.startRender((_=>mesh.scale.set(_light.width, _light.height, 1)))
                        }()
                }
            }(),
                this.onDestroy = function() {
                    _this.parent.group.remove(_this.group)
                }
        }
    )),
    Class((function ShadowLight(_input, _group) {
            Inherit(this, Object3D);
            const _this = this;
            var _light, _timer;
            !async function() {
                (_light = new BaseLight).prefix = _input.prefix,
                    _this.add(_light),
                    _light.silentShadow = ShadowLight.LOCKED,
                    _this.light = _light;
                let p = _this.parent.group._parent;
                for (; p; )
                    p instanceof Scene && p._lightingData && (_light._lightingData = p._lightingData),
                        p = p._parent;
                if (_light.castShadow = !0,
                    ShadowUIL.add(_light, _group).setLabel("Shadows"),
                    ShadowLight.LOCKED)
                    return;
                _this.startRender((_=>{}
                )),
                    await defer();
                let scene = function findScene() {
                    let p = _this.group._parent;
                    for (; p; ) {
                        if (p instanceof Scene)
                            return p;
                        p = p._parent
                    }
                }();
                if (!scene)
                    return console.warn("Shadow light has no parent scene");
                scene.hasShadowLight = !0,
                    scene.bindSceneChange((_=>{
                            _light.static && (_light.shadow.frozen = !1,
                                clearTimeout(_timer),
                                _timer = _this.delayedCall((_=>_light.shadow.frozen = !0), 250))
                        }
                    ))
            }(),
                this.onVisible = async function() {
                    await defer(),
                    _light.static && (_light.shadow.frozen = !1,
                        clearTimeout(_timer),
                        _timer = _this.delayedCall((_=>_light.shadow.frozen = !0), 250))
                }
        }
    )),
    Class((function Line3D(_params={}) {
            Inherit(this, Object3D);
            const _this = this;
            let _geometry, _shader, _mesh, _vs, _fs, _index = _params.index || 0, _points = _params.points || [], _pressure = _params.pressure || [];
            function initMesh() {
                _points.length < 6 || _mesh || (_mesh = new Mesh(_geometry.geometry,_shader),
                    _mesh.frustumCulled = !1,
                    _this.add(_mesh),
                    _this.mesh = _mesh)
            }
            !function initGeometry() {
                _geometry = _this.initClass(LineGeometry, {
                    index: _index,
                    points: _points,
                    pressure: _pressure
                })
            }(),
                function initShader() {
                    _shader = _this.initClass(Shader, "Line", {
                        uLineWidth: {
                            value: _params.width || Line3D.defaultLineWidth
                        },
                        uBaseWidth: Line3D.BASE_WIDTH,
                        uColor: {
                            value: new Color(_params.color || Line3D.defaultColor)
                        },
                        uOpacity: {
                            value: _params.opacity || Line3D.defaultOpacity
                        },
                        transparent: !0
                    }),
                        _vs = _shader.vertexShader,
                        _fs = _shader.fragmentShader,
                        _this.shader = _shader
                }(),
                initMesh(),
                this.get("data", (()=>({
                    geometry: {
                        points: _points,
                        pressure: _pressure,
                        index: _index
                    },
                    meta: {
                        fs: _shader.fsName,
                        vs: _shader.vsName,
                        width: _shader.uniforms.uLineWidth.value,
                        opacity: _shader.uniforms.uOpacity.value,
                        color: _shader.uniforms.uColor.value.getHex()
                    }
                }))),
                this.get("geometry", (()=>_geometry.geometry)),
                this.set("lineWidth", (v=>{
                        _shader.set("uLineWidth", v)
                    }
                )),
                this.set("color", (hex=>{
                        _shader.uniforms.uColor.value.set(hex)
                    }
                )),
                this.set("opacity", (value=>{
                        _shader.uniforms.uOpacity.value = value
                    }
                )),
                this.useShader = function(shader) {
                    shader.uniforms.uLineWidth = _shader.uniforms.uLineWidth,
                        shader.uniforms.uBaseWidth = _shader.uniforms.uBaseWidth,
                        shader.uniforms.uColor = _shader.uniforms.uColor,
                        shader.uniforms.uOpacity = _shader.uniforms.uOpacity,
                        shader.transparent = !0,
                        _this.shader = shader,
                        _shader = shader,
                    _mesh && (_mesh.shader = shader)
                }
                ,
                this.draw = function(pos, pressure=1, skip=!1) {
                    _points.push(pos.x, pos.y, pos.z),
                        _pressure.push(pressure),
                    _points.length < 6 || (_points.length > 3 * _params.length && (_points.splice(0, 3),
                        _pressure.shift()),
                    skip || _geometry.update(),
                        initMesh())
                }
                ,
                this.onDestroy = function() {
                    _geometry.geometry.dispose(),
                    _this.parent.group && _this.parent.group.remove(_this.group)
                }
        }
    ), (()=>{
            Line3D.defaultLineWidth = 1,
                Line3D.defaultOpacity = 1,
                Line3D.defaultColor = "#ffffff",
                Line3D.BASE_WIDTH = {
                    value: .2
                },
                Line3D.MAX_LINE_LENGTH = 500
        }
    )),
    Class((function LineGeometry({index: index=0, points: points=[], taperFunction: taperFunction=(()=>1), defaultCount: defaultCount=200}) {
            Inherit(this, Component);
            const _this = this;
            _this.index = index,
                _this.points = points,
                _this.taperFunction = taperFunction;
            const _geometry = _this.geometry = new Geometry
                , _attr = _geometry.attributes;
            let _prev = new Vector3
                , _curr = new Vector3
                , _length = 0
                , _count = 0;
            function initBuffers(count) {
                _geometry.addAttribute("position", new GeometryAttribute(new Float32Array(3 * count * 2),3)),
                    _geometry.addAttribute("previous", new GeometryAttribute(new Float32Array(3 * count * 2),3)),
                    _geometry.addAttribute("next", new GeometryAttribute(new Float32Array(3 * count * 2),3)),
                    _geometry.addAttribute("side", new GeometryAttribute(new Float32Array(1 * count * 2),1)),
                    _geometry.addAttribute("lineIndex", new GeometryAttribute(new Float32Array(1 * count * 2),1)),
                    _geometry.addAttribute("width", new GeometryAttribute(new Float32Array(1 * count * 2),1)),
                    _geometry.addAttribute("uv", new GeometryAttribute(new Float32Array(2 * count * 2),2)),
                    _geometry.addAttribute("uv2", new GeometryAttribute(new Float32Array(2 * count * 2),2)),
                    _geometry.setIndex(new GeometryAttribute(new Uint16Array(3 * (count - 1) * 2),1)),
                    _length = 0,
                    _count = 0,
                    function setStaticBuffers(count) {
                        for (let i = 0; i < count; i++) {
                            if (_attr.side.setXY(2 * i, 1, -1),
                                _attr.lineIndex.setXY(2 * i, _this.index, _this.index),
                            i === count - 1)
                                continue;
                            let ind = 2 * i;
                            _geometry.index[3 * (ind + 0) + 0] = ind + 0,
                                _geometry.index[3 * (ind + 0) + 1] = ind + 1,
                                _geometry.index[3 * (ind + 0) + 2] = ind + 2,
                                _geometry.index[3 * (ind + 1) + 0] = ind + 2,
                                _geometry.index[3 * (ind + 1) + 1] = ind + 1,
                                _geometry.index[3 * (ind + 1) + 2] = ind + 3
                        }
                    }(count)
            }
            function getPos(index) {
                let i = 3 * index;
                return [points[i], points[i + 1], points[i + 2]]
            }
            function update() {
                let newLength = points.length / 3;
                2 * newLength > _attr.position.count && function increaseBuffers() {
                    initBuffers(_attr.position.count / 2 + defaultCount)
                }();
                for (let i = 0; i < newLength; i++) {
                    _attr.position.setXYZ(2 * i + 0, points[3 * i + 0], points[3 * i + 1], points[3 * i + 2]),
                        _attr.position.setXYZ(2 * i + 1, points[3 * i + 0], points[3 * i + 1], points[3 * i + 2]);
                    let prv = getPos(Math.max(0, i - 1));
                    _attr.previous.setXYZ(2 * i + 0, prv[0], prv[1], prv[2]),
                        _attr.previous.setXYZ(2 * i + 1, prv[0], prv[1], prv[2]);
                    let nxt = getPos(Math.min(newLength - 1, i + 1));
                    _attr.next.setXYZ(2 * i + 0, nxt[0], nxt[1], nxt[2]),
                        _attr.next.setXYZ(2 * i + 1, nxt[0], nxt[1], nxt[2]),
                        _prev.fromArray(prv),
                        _curr.fromArray(getPos(i)),
                        _length += _prev.distanceTo(_curr),
                        _attr.uv2.setX(2 * i + 0, _length),
                        _attr.uv2.setX(2 * i + 1, _length)
                }
                for (let i = 0; i < newLength; i++) {
                    _attr.uv.setXY(2 * i + 0, i / newLength, 0),
                        _attr.uv.setXY(2 * i + 1, i / newLength, 1),
                        _attr.uv2.setY(2 * i + 0, _length),
                        _attr.uv2.setY(2 * i + 1, _length);
                    let w = _this.taperFunction(i / (newLength - 1), i, newLength);
                    _attr.width.setXY(2 * i, w, w)
                }
                _attr.position.needsUpdate = !0,
                    _attr.previous.needsUpdate = !0,
                    _attr.next.needsUpdate = !0,
                    _attr.width.needsUpdate = !0,
                    _attr.uv.needsUpdate = !0,
                    _attr.uv2.needsUpdate = !0,
                    _count = newLength
            }
            initBuffers(points.length ? points.length / 3 : defaultCount),
            points.length && update(),
                this.update = update
        }
    )),
    Namespace("FX"),
    FX.Class((function Mirror(_mesh, _params={}) {
            Inherit(this, FXScene);
            const _this = this;
            var _renderer;
            function loop({stage: stage, camera: camera}) {
                _this.visible && _this.enabled && (stage && (_renderer.camera = camera,
                    _this.nuke.camera = camera,
                    _this.nuke.stage = stage),
                    _this.draw(),
                    _mesh.matrixWorld.decompose(_renderer.position, _renderer.quaternion, _renderer.scale),
                    World.RENDERER.overridePreventShadows = !0,
                _this.onBeforeRender && _this.onBeforeRender(),
                    _renderer.render(_this.scene),
                _this.onAfterRender && _this.onAfterRender(),
                    World.RENDERER.overridePreventShadows = !1,
                _this.postRender && _this.postRender())
            }
            this.visible = !0,
                this.enabled = "boolean" != typeof _params.enabled || _params.enabled,
            _params.shader || (_params.shader = _mesh.shader),
                _this.create(_params.nuke || World.NUKE),
                _this.preventRTDraw = !0,
                function initMirror() {
                    let width = _params.width || 512
                        , height = _params.height || 512;
                    _params.size && (width = height = _params.size),
                        _renderer = new MirrorRenderer(_this.nuke.camera,{
                            width: width,
                            height: height,
                            clipBias: _params.clipBias || .01,
                            format: _params.format
                        })
                }(),
                function decorateShader() {
                    if (!_mesh)
                        throw "Mesh passed to Mirror needs a shader";
                    _params.shader.uniforms.tMirrorReflection = {
                        value: _renderer.renderTarget.texture
                    },
                        _params.shader.uniforms.uMirrorMatrix = {
                            value: _renderer.textureMatrix
                        }
                }(),
                this.onDestroy = function() {
                    _renderer.destroy()
                }
                ,
                this.start = function() {
                    RenderManager.type != RenderManager.VR ? _this.startRender(loop) : _this.events.sub(RenderManager.RENDER, loop)
                }
                ,
                this.stop = function() {
                    RenderManager.type != RenderManager.VR ? _this.stopRender(loop) : _this.events.unsub(RenderManager.RENDER, loop)
                }
                ,
                this.decorate = function(shader) {
                    shader.uniforms.tMirrorReflection = {
                        value: _renderer.renderTarget.texture
                    },
                        shader.uniforms.uMirrorMatrix = {
                            value: _renderer.textureMatrix
                        }
                }
                ,
                this.useCamera = function(camera) {
                    camera = camera.camera || camera,
                        _renderer.camera = camera,
                        _this.nuke.camera = camera
                }
                ,
                this.set("clipBias", (v=>_renderer.clipBias = v)),
                this.loop = loop,
                this.texture = _renderer.renderTarget.texture
        }
    ));
class MirrorRenderer extends Base3D {
    constructor(camera, options={}) {
        super(),
            this._camera = camera,
            this.width = options.width || 512,
            this.height = options.height || 512,
            this.clipBias = options.clipBias || 0,
            this.renderer = World.RENDERER,
            this.mirrorPlane = new Plane,
            this.normal = new Vector3(0,0,1),
            this.mirrorWorldPosition = new Vector3,
            this.cameraWorldPosition = new Vector3,
            this.rotationMatrix = new Matrix4,
            this.lookAtPosition = new Vector3(0,0,-1),
            this.clipPlane = new Vector4,
            this.textureMatrix = new Matrix4,
            this.mirrorCamera = this._camera.clone(),
            this.renderTarget = new RenderTarget(this.width,this.height,{
                minFilter: Texture.LINEAR,
                magFilter: Texture.LINEAR,
                format: options.format || Texture.RGBFormat
            }),
            this.viewVec = new Vector3,
            this.targetVec = new Vector3,
            this.q = new Quaternion,
            this.updateTextureMatrix()
    }
    updateTextureMatrix() {
        this.updateMatrixWorld(),
            this._camera.updateMatrixWorld(),
            this.mirrorWorldPosition.setFromMatrixPosition(this.matrixWorld),
            this.cameraWorldPosition.setFromMatrixPosition(this._camera.matrixWorld),
            this.rotationMatrix.extractRotation(this.matrixWorld),
            this.normal.set(0, 0, 1),
            this.normal.applyMatrix4(this.rotationMatrix),
            this.viewVec.copy(this.mirrorWorldPosition).sub(this.cameraWorldPosition),
            this.viewVec.reflect(this.normal).negate(),
            this.viewVec.add(this.mirrorWorldPosition),
            this.rotationMatrix.extractRotation(this._camera.matrixWorld),
            this.lookAtPosition.set(0, 0, -1),
            this.lookAtPosition.applyMatrix4(this.rotationMatrix),
            this.lookAtPosition.add(this.cameraWorldPosition),
            this.targetVec.copy(this.mirrorWorldPosition).sub(this.lookAtPosition),
            this.targetVec.reflect(this.normal).negate(),
            this.targetVec.add(this.mirrorWorldPosition),
            this.up.set(0, -1, 0),
            this.up.applyMatrix4(this.rotationMatrix),
            this.up.reflect(this.normal).negate(),
            this.mirrorCamera.position.copy(this.viewVec),
            this.mirrorCamera.up = this.up,
            this.mirrorCamera.lookAt(this.targetVec),
            this.mirrorCamera.updateMatrixWorld(),
            this.mirrorCamera.projectionMatrix.copy(this._camera.projectionMatrix),
            this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix),
            this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse),
            this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal, this.mirrorWorldPosition),
            this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse),
            this.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant);
        let projectionMatrix = this.mirrorCamera.projectionMatrix
            , q = this.q;
        q.x = (Math.sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0],
            q.y = (Math.sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5],
            q.z = -1,
            q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
        let c = this.clipPlane.multiplyScalar(2 / this.clipPlane.dot(q));
        projectionMatrix.elements[2] = c.x,
            projectionMatrix.elements[6] = c.y,
            projectionMatrix.elements[10] = c.z + 1 - this.clipBias,
            projectionMatrix.elements[14] = c.w
    }
    render(scene) {
        this.updateTextureMatrix(),
            this.renderer.render(scene, this.mirrorCamera, this.renderTarget)
    }
    destroy() {
        this.renderTarget.destroy()
    }
    set camera(c) {
        this._camera = c,
            this.mirrorCamera = c.clone()
    }
}
function keyCode(searchInput) {
    if (searchInput && "object" == typeof searchInput) {
        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
        hasKeyCode && (searchInput = hasKeyCode)
    }
    if ("number" == typeof searchInput)
        return names[searchInput];
    var foundNamedKey, search = String(searchInput);
    return (foundNamedKey = codes[search.toLowerCase()]) ? foundNamedKey : (foundNamedKey = aliases[search.toLowerCase()]) || (1 === search.length ? search.charCodeAt(0) : void 0)
}
Class((function MouseFlowMapRenderer(_size) {
        Inherit(this, Component);
        const _this = this;
        let _shader;
        const _scene1 = new Scene
            , _scene2 = new Scene
            , _camera = new OrthographicCamera(0,1,1,0,.1,2);
        let _count = 0;
        const _rtPing = Utils3D.createRT(_size, _size)
            , _rtPong = Utils3D.createRT(_size, _size);
        this.rt = Utils3D.createRT(_size, _size, null, Texture.RGBAFormat),
            this.textureUniform = {
                type: "t",
                value: null,
                ignoreUIL: !0
            },
            function init() {
                _camera.position.z = 1
            }(),
            _scene1.disableAutoSort = !0,
            _scene2.disableAutoSort = !0,
            this.add = function(mesh) {
                _scene1.add(mesh)
            }
            ,
            this.setShader = function(shader) {
                _shader = shader;
                let mesh = new Mesh(World.QUAD,shader);
                _scene2.add(mesh)
            }
            ,
            this.draw = function() {
                if (!_shader)
                    return;
                let autoClear = World.RENDERER.autoClear;
                World.RENDERER.autoClear = !1,
                    World.RENDERER.renderSingle(_scene1.children[0], _camera, _this.rt),
                    World.RENDERER.autoClear = autoClear,
                    _this.textureUniform.value = _this.rt.texture
            }
            ,
            this.clear = function() {
                if (!_shader)
                    return;
                _count++;
                const clearAlphaCache = Renderer.CLEAR[3];
                Renderer.CLEAR[3] = 0,
                    _count % 2 == 0 ? (_shader.uniforms.uTexture.value = _rtPing.texture,
                        World.RENDERER.renderSingle(_scene2.children[0], _camera, _rtPong),
                        _this.textureUniform.value = _rtPong.texture) : (_shader.uniforms.uTexture.value = _rtPong.texture,
                        World.RENDERER.renderSingle(_scene2.children[0], _camera, _rtPing),
                        _this.textureUniform.value = _rtPing.texture),
                    _shader.uniforms.uFirstDraw.value = 0,
                    Renderer.CLEAR[3] = clearAlphaCache,
                    Renderer.context.bindFramebuffer(Renderer.context.FRAMEBUFFER, _this.rt._gl),
                    Renderer.context.clear(Renderer.context.COLOR_BUFFER_BIT),
                    Renderer.context.bindFramebuffer(Renderer.context.FRAMEBUFFER, null)
            }
            ,
            this.upload = async function() {
                let uploads = [_rtPing, _rtPong, _this.rt];
                _shader && uploads.push(_shader);
                for (let i = 0; i < uploads.length; i++)
                    uploads[i].upload(),
                        await defer()
            }
    }
)),
    Class((function MouseFlowMapTouch() {
            Inherit(this, Component);
            const _this = this;
            new Vector2;
            var _touch = new Vector2
                , _touchLast = new Vector2
                , _touchStep = new Vector2
                , _velocity = new Vector2
                , _current = new Vector2
                , _delta = {
                x: 0,
                y: 0
            }
                , _last = new Vector2;
            this.velocity = new Vector2,
                this.ticks = 0,
                this.render = function(decay, numStamps) {
                    _velocity.multiplyScalar(decay),
                        _this.velocity.lerp(_velocity, .5),
                        _touch.lerp(_current, .4),
                        _touchStep.copy(_touch).sub(_touchLast).multiplyScalar(1 / numStamps),
                        _touchLast.copy(_touch)
                }
                ,
                this.move = function(e, hitMesh) {
                    _this.isMouseLeft && (_this.isMouseLeft = !1,
                        _touch.copy(Mouse.inverseNormal),
                        _touchLast.copy(_touch)),
                    e.x != _last.x && (hitMesh ? (_current.x = e.x,
                        _current.y = e.y) : (_current.x = e.x / Stage.width,
                        _current.y = 1 - e.y / Stage.height),
                        _delta.x = e.x - _last.x,
                        _delta.y = e.y - _last.y,
                        _last.x = e.x,
                        _last.y = e.y,
                        _velocity.copy(_delta).multiplyScalar(.03 / 16))
                }
                ,
                this.get("step", (_=>_touchStep)),
                this.get("pos", (_=>_touch))
        }
    )),
    Class((function MouseFluid(_params={
            active: !0
        }) {
            Inherit(this, Object3D);
            const _this = this;
            var _fluid;
            this.scale = 1;
            var _scale = 1
                , _last = new Vector2
                , _mouse = new Vector2
                , _white = new Color("#ffffff");
            function loop() {
                _scale = Math.lerp(_this.scale, _scale, .05),
                    _mouse.copy(Mouse);
                let len = _mouse.distanceTo(_last)
                    , size = _this.scaleBasedOnVelocity ? Math.range(len, 0, 5, 5, 40, !0) : 25
                    , delta = Math.range(len, 0, 15, 0, 10, !0);
                len > .01 && _fluid.drawInput(Mouse.x, Mouse.y, (_mouse.x - _last.x) * delta, (_mouse.y - _last.y) * delta, _white, size * _scale),
                    _last.copy(_mouse)
            }
            this.scaleBasedOnVelocity = !0,
                async function() {
                    let layout = _this.initClass(SceneLayout, "mousefluid");
                    _fluid = await layout.getLayer("fluid"),
                        _this.flag("fluid", !0),
                        _params.active ? _this.startRender(loop) : _fluid.visible = !1
                }(),
                this.applyTo = async function(shader) {
                    await _this.wait("fluid"),
                        shader.uniforms.tFluid = _fluid.fbos.velocity.uniform,
                        shader.uniforms.tFluidMask = {
                            value: _fluid
                        }
                }
        }
    ), "singleton"),
    Class((function ParticleDistributor() {
            Inherit(this, Component);
            var _initialized;
            function distributeParticles(e, id) {
                let {position: position, count: count} = e
                    , vertices = position.length / 3
                    , v3 = new Vector3
                    , output = new Float32Array(3 * count);
                for (let i = 0; i < count; i++) {
                    let j = 3 * Math.random(0, vertices / 3);
                    v3.set(Math.random(0, 100), Math.random(0, 100), Math.random(0, 100));
                    let m = 1 / (v3.x + v3.y + v3.z);
                    v3.set(v3.x * m, v3.y * m, v3.z * m),
                        output[3 * i + 0] = position[3 * j + 0] * v3.x + position[3 * j + 3] * v3.y + position[3 * j + 6] * v3.z,
                        output[3 * i + 1] = position[3 * j + 1] * v3.x + position[3 * j + 4] * v3.y + position[3 * j + 7] * v3.z,
                        output[3 * i + 2] = position[3 * j + 2] * v3.x + position[3 * j + 5] * v3.y + position[3 * j + 8] * v3.z
                }
                resolve({
                    output: output
                }, id, [output.buffer])
            }
            this.generate = async function(geom, count) {
                _initialized || (_initialized = !0,
                    Thread.upload(distributeParticles));
                let position = new Float32Array(geom.attributes.position.array);
                return (await Thread.shared().distributeParticles({
                    transfer: !0,
                    msg: {
                        position: position,
                        count: count,
                        buffer: [position.buffer]
                    }
                })).output
            }
        }
    ), "static"),
    Class((function PBRShader(_vertexShader, _fragmentShader, _params) {
            const _this = this;
            function defineSetter(prop) {
                Object.defineProperty(_this, prop, {
                    set: function(v) {
                        _this.shader[prop] = v
                    },
                    get: function() {
                        return _this.shader[prop]
                    }
                })
            }
            "object" == typeof _vertexShader && (_params = _vertexShader,
                _vertexShader = _fragmentShader = "PBR"),
            "object" == typeof _fragmentShader && (_params = _fragmentShader,
                _fragmentShader = _vertexShader),
            _vertexShader || (_vertexShader = _fragmentShader = "PBR"),
                function initShader() {
                    _this.shader = new Shader(_vertexShader,_fragmentShader,Utils.mergeObject(_params || {}, {
                        tBaseColor: {
                            value: null,
                            getTexture: Utils3D.getRepeatTexture
                        },
                        tMRO: {
                            value: null,
                            getTexture: Utils3D.getRepeatTexture
                        },
                        tNormal: {
                            value: null,
                            getTexture: Utils3D.getRepeatTexture
                        },
                        tEnvDiffuse: {
                            value: null,
                            premultiplyAlpha: !1
                        },
                        tEnvSpecular: {
                            value: null,
                            premultiplyAlpha: !1
                        },
                        uMRO: {
                            value: new Vector3(1,1,1)
                        },
                        uHDR: {
                            value: 0,
                            ignoreUIL: !0
                        },
                        uNormalScale: {
                            value: new Vector2(1,1)
                        },
                        tLUT: {
                            value: Utils3D.getLookupTexture("assets/images/pbr/lut.png"),
                            ignoreUIL: !0
                        },
                        uEnv: {
                            value: new Vector2(1,0)
                        },
                        uLight: {
                            value: new Vector4(1,1,1,1)
                        },
                        receiveLight: !0
                    })),
                        _this.lights = _this.shader.lights,
                        _this.uniforms = _this.shader.uniforms,
                        ["side", "blending", "polygonOffset", "polygonOffsetFactor", "polygonOffsetUnits", "receiveShadow", "vertexShader", "fragmentShader", "depthTest", "depthWrite", "wireframe", "transparent", "visible", "persists", "material", "customShadowShader"].forEach(defineSetter)
                }()
        }
    ), (_=>{
            const prototype = PBRShader.prototype;
            prototype.set = function(key, value) {
                return void 0 !== value && (this.shader.uniforms[key].value = value),
                    this.shader.uniforms[key].value
            }
                ,
                prototype.get = function(key) {
                    return this.shader.uniforms[key].value
                }
                ,
                prototype.tween = function(key, value, time, ease, delay, callback, update) {
                    return tween(this.shader.uniforms[key], {
                        value: value
                    }, time, ease, delay, callback, update)
                }
                ,
                prototype.setPBR = prototype.setOverride = function(key, value, src) {
                    switch (this.set(key, value),
                        key) {
                        case "tEnvDiffuse":
                        case "tEnvSpecular":
                        case "tLUT":
                            value.generateMipmaps = !1,
                                value.minFilter = Texture.LINEAR
                    }
                    value.wrapS = value.wrapT = Texture.REPEAT,
                    src || (src = value.src),
                    src && src.toLowerCase().includes("rgbm") && this.shader.set("uHDR", 1)
                }
                ,
                prototype.destroy = function() {
                    this.shader.destroy()
                }
                ,
                prototype.copyUniformsTo = function(shader, linked) {
                    for (let key in this.uniforms)
                        shader.uniforms[key] = linked ? this.uniforms[key] : {
                            type: this.uniforms[key].type,
                            value: this.uniforms[key].value
                        }
                }
                ,
                prototype.addUniforms = function(uniforms) {
                    uniforms.UILPrefix && (this.UILPrefix = uniforms.UILPrefix,
                        delete uniforms.UILPrefix);
                    for (let key in uniforms)
                        this.uniforms[key] = uniforms[key]
                }
        }
    )),
    Class((function Performance() {
            Inherit(this, Component);
            var _overrides = Storage.get("performance_override") || {};
            function save(key, value) {
                _overrides[key] = value,
                    Storage.set("performance_override", _overrides)
            }
            function convert(tier) {
                if (GPU.BLACKLIST)
                    return "F";
                switch (tier) {
                    case 5:
                        return "A++";
                    case 4:
                        return "A+";
                    case 3:
                        return "A";
                    case 2:
                        return "B";
                    case 1:
                        return "C";
                    case 0:
                        return "D"
                }
            }
            !async function() {
                if (Utils.query("performance") && Utils.query("edit") || Utils.query("custom")) {
                    await Hydra.ready();
                    for (let key in _overrides)
                        Tests[key] = _=>_overrides[key]
                }
            }(),
                this.displayResults = async function() {
                    let editing = Utils.query("edit");
                    await GPU.ready(),
                        __body.bg("#000");
                    let $results = __body.create("PerformanceResults");
                    __body.css({
                        overflowY: "scroll"
                    }),
                        $results.fontStyle("Arial", 18, "#fff").css({
                            marginLeft: 50,
                            marginRight: 50,
                            "user-select": "auto"
                        }),
                        Mobile.allowNativeScroll(),
                        CSS.style(".PerformanceResults *", {
                            position: "relative",
                            "user-select": "auto"
                        });
                    Tests.constructor.toString();
                    let tests = "";
                    for (let key in Tests) {
                        let result = Tests[key]();
                        tests += `<p><b>${key}:</b> `,
                            editing ? ("number" == typeof result && (tests += `<input class="${key}" value="${result.toString()}" /></p>`),
                            "boolean" == typeof result && (tests += `<input class="${key}" type="checkbox" ${result ? "checked" : ""}/></p>`)) : tests += result + "</p>"
                    }
                    let html = `<h1>Performance Results</h1>\n                    <p><b>GPU:</b> ${Device.graphics.webgl ? Device.graphics.webgl.gpu : "WEBGL UNAVAILABLE"}</p>\n                    <p><b>WebGL Version:</b> ${Device.graphics.webgl ? Device.graphics.webgl.version : "WEBGL UNAVAILABLE"}</p>\n                    <p><b>GPU Tier:</b> ${Device.mobile ? convert(GPU.M_TIER) : convert(GPU.TIER)} [${Device.mobile ? GPU.M_TIER : GPU.TIER}]</p>\n                    <p><b>Mobile:</b> ${Device.mobile}</p>\n                    <p><b>User Agent:</b> ${Device.agent}</p>\n                    <p><b>DPR:</b> ${Device.pixelRatio}</p>\n                    <p><b>Screen Size:</b> ${screen.width} x ${screen.height}</p>\n                    <p><b>Stage Size:</b> ${Stage.width} x ${Stage.height}</p>\n                    \n                    <h2>Project-Specific Tests</h2>\n                    ${editing ? '<button class="resetBtn">Reset All</button>' : ""}\n                    ${tests}\n        `;
                    if ($results.html(html),
                        editing) {
                        await defer(),
                            document.querySelector(".resetBtn").onclick = _=>{
                                Storage.set("performance_override", null),
                                    location.reload()
                            }
                        ;
                        for (let key in Tests) {
                            !function(div, key) {
                                div.onchange = _=>{
                                    let value = div.value;
                                    value = isNaN(value) ? div.checked : Number(value),
                                        save(key, value)
                                }
                            }(document.querySelector(`.${key}`), key)
                        }
                    }
                }
        }
    ), "static"),
    Class((function Proton(_input, _group) {
            Inherit(this, Object3D);
            const _this = this;
            var _config, _size, _antimatter, _behaviorInput;
            const prefix = this.prefix = `P_${_input.prefix}`;
            async function initConfig() {
                (_config = _this.uilConfig = InputUIL.create(prefix + "_config", _group)).setLabel("Config"),
                    _config.addButton("load-values", {
                        label: "Values",
                        actions: [{
                            title: "Load",
                            callback: loadValues
                        }, {
                            title: "Save",
                            callback: saveValues
                        }]
                    }).addButton("save", {
                        label: "Configuration",
                        actions: [{
                            title: "Load",
                            callback: loadConfig
                        }, {
                            title: "Save",
                            callback: saveConfig
                        }]
                    }).addButton("load-shader", {
                        label: "Shader",
                        actions: [{
                            title: "Load",
                            callback: ()=>loadShader()
                        }]
                    }).addButton("load-behavior", {
                        label: "Behavior",
                        actions: [{
                            title: "Load",
                            callback: ()=>loadBehavior()
                        }]
                    });
                _config.addSelect("type", [{
                    label: "Permanent",
                    value: "permanent"
                }, {
                    label: "Lifecycle",
                    value: "lifecycle"
                }]),
                    _config.add("particleCount", 1e3);
                let output = [{
                    label: "Particles",
                    value: "particles"
                }, {
                    label: "Custom",
                    value: "custom"
                }];
                window.ProtonTubes && output.push({
                    label: "Tubes",
                    value: "tubes"
                }),
                    _config.addSelect("output", output),
                    _config.add("shader"),
                _config.get("shader") && _config.addTextarea("uniforms"),
                    _config.add("class");
                _config.get("type");
                try {
                    if (!1 === _input.get("visible"))
                        throw "Layer set to invisible";
                    _this.particleCount = _size = getSize(),
                        initAntimatter()
                } catch (e) {
                    console.warn("Proton skipped", e),
                        _this.disabled = !0
                }
            }
            function loadValues() {
                const name = prompt("Name of values to be loaded");
                if (null === name)
                    return;
                let data = UILStorage.get(`proton_values_${name}`);
                data || alert(`No values ${name} found`),
                    data = JSON.parse(data);
                let apply = (shader,obj)=>{
                        for (let key in obj)
                            UILStorage.set(shader.UILPrefix + key, obj[key])
                    }
                ;
                apply(_this.behavior, data.behavior),
                    apply(_this.shader, data.shader),
                _this.customClass && _this.customClass.saveValues && apply(_this.customClass.saveValues(), data.custom),
                    alert("Values imported. Save and refresh.")
            }
            function saveValues() {
                const name = prompt("Name of values to be saved");
                if (null === name)
                    return;
                let store = (shader,to)=>{
                    for (let key in shader.uniforms) {
                        if (shader.uniforms[key].ignoreUIL)
                            continue;
                        let uilValue = UILStorage.get(shader.UILPrefix + key);
                        void 0 !== uilValue && (to[key] = uilValue)
                    }
                }
                    , output = {
                    behavior: {},
                    shader: {}
                };
                store(_this.behavior, output.behavior),
                    store(_this.shader, output.shader),
                _this.customClass && _this.customClass.saveValues && (output.custom = {},
                    store(_this.customClass.saveValues(), output.custom)),
                    UILStorage.setWrite(`proton_values_${name}`, JSON.stringify(output))
            }
            function loadConfig() {
                const name = prompt("Name of configuration to be loaded");
                if (null === name)
                    return;
                let toLoad = UILStorage.get(`proton_config_${name}`);
                loadBehavior(toLoad),
                    loadShader(toLoad),
                    alert("Loaded. Save and refresh")
            }
            function saveConfig() {
                let name = prompt("Name of configuration to be saved");
                null !== name && UILStorage.setWrite(`proton_config_${name}`, prefix)
            }
            function loadShader(toLoad) {
                let shouldNotify = !toLoad;
                if (!toLoad) {
                    const name = prompt("Name of shader to be loaded");
                    if (null === name)
                        return;
                    toLoad = UILStorage.get(`proton_config_${name}`)
                }
                let copyConfig = InputUIL.create(toLoad + "_config", null);
                _config.copyFrom(copyConfig, ["shader", "uniforms"]),
                    (_config.get("uniforms") || "").split("\n").forEach((line=>{
                            if (!line.includes(":"))
                                return;
                            let name = (line = line.replace(/ /g, "")).split(":")[0]
                                , shaderName = copyConfig.get("shader")
                                , store = `${shaderName}/${shaderName}/${prefix}/`
                                , lookup = `${shaderName}/${shaderName}/${toLoad}/`
                                , val = UILStorage.get(lookup + name);
                            val ? UILStorage.set(store + name, val) : (val = UILStorage.get(lookup + "_tx_" + name),
                            val && UILStorage.set(store + "_tx_" + name, val))
                        }
                    )),
                shouldNotify && alert("Loaded. Save and refresh")
            }
            function loadBehavior(toLoad) {
                let shouldNotify = !toLoad;
                if (!toLoad) {
                    const name = prompt("Name of behavior to be loaded");
                    if (null === name)
                        return;
                    toLoad = UILStorage.get(`proton_config_${name}`)
                }
                let copyConfig = InputUIL.create(toLoad + "_config", null);
                _config.copyFrom(copyConfig, ["type", "particleCount", "output", "class"]);
                let copyBehavior = InputUIL.create(toLoad + "_behavior", null);
                InputUIL.create(prefix + "_behavior", null).copyFrom(copyBehavior, ["uniforms", "data", "codeCount"]);
                let data = copyBehavior.get("data") || []
                    , buniformString = copyBehavior.get("uniforms") + "\n";
                ListUIL.create(prefix + "_code", null).internalAddItems(data.length),
                    data.forEach((postfix=>{
                            let toCode = InputUIL.create(prefix + postfix, null)
                                , fromCode = InputUIL.create(toLoad + postfix, null);
                            toCode.copyFrom(fromCode, ["name", "code", "uniforms", "preset"]),
                                buniformString += fromCode.get("uniforms") + "\n"
                        }
                    )),
                    buniformString.split("\n").forEach((line=>{
                            if (!line.includes(":"))
                                return;
                            let name = (line = line.replace(/ /g, "")).split(":")[0]
                                , lookup = "am_ProtonAntimatter_" + toLoad
                                , store = "am_ProtonAntimatter_" + prefix
                                , val = UILStorage.get(lookup + name);
                            val && UILStorage.set(store + name, val)
                        }
                    ));
                let className = copyConfig.get("class");
                className && (_this.customClass = _this.parent.initClass(window[className], _this, _group, _input),
                _this.customClass.loadConfig && _this.customClass.loadConfig(toLoad, prefix)),
                shouldNotify && alert("Loaded. Save and refresh")
            }
            function getSize() {
                if (_this.parent.data && _this.parent.data.particleCount)
                    return "string" == typeof _this.parent.data.particleCount ? eval(_this.parent.data.particleCount) : _this.parent.data.particleCount;
                let size = _config.getNumber("particleCount");
                if (isNaN(size))
                    try {
                        size = eval(_config.get("particleCount"))
                    } catch (e) {
                        throw "Proton particleCount is not a number or valid test function"
                    }
                if (isNaN(size))
                    throw "Proton particleCount is falsy!";
                return _this.particleCount = size,
                    size
            }
            async function initCustomClass() {
                _this.shader.addUniforms({
                    DPR: {
                        value: World.DPR,
                        ignoreUIL: !0
                    }
                });
                let className = _config.get("class");
                className && (_this.customClass = _this.parent.initClass(window[className], _this, _group, _input))
            }
            function parseUniforms(text, predefined) {
                if (!text)
                    return {};
                let split = text.split("\n")
                    , output = {};
                return split.forEach((line=>{
                        if (!(line = line.replace(/ /g, "")).length || !line.includes(":"))
                            return;
                        let split = line.split(":")
                            , name = split[0]
                            , val = split[1];
                        if (val.includes("[")) {
                            let array = JSON.parse(val);
                            switch (array.length) {
                                case 2:
                                    output[name] = {
                                        value: (new Vector2).fromArray(array)
                                    };
                                    break;
                                case 3:
                                    output[name] = {
                                        value: (new Vector3).fromArray(array)
                                    };
                                    break;
                                case 4:
                                    output[name] = {
                                        value: (new Vector4).fromArray(array)
                                    };
                                    break;
                                default:
                                    throw `Unknown uniform type ${line}`
                            }
                        } else
                            "C" == val.charAt(0) ? predefined[name] = val.slice(1) : "T" === val ? output[name] = {
                                value: null
                            } : "OEST" === val ? output[name] = {
                                value: null,
                                oes: !0
                            } : val.includes(["0x", "#"]) ? output[name] = {
                                value: new Color(val)
                            } : output[name] = {
                                value: Number(val)
                            }
                    }
                )),
                    output
            }
            function getUniformGLSLType(obj) {
                return "number" == typeof obj.value ? "float" : obj.oes ? "samplerExternalOES" : null === obj.value || obj.value instanceof Texture ? "sampler2D" : obj.value instanceof Vector2 ? "vec2" : obj.value instanceof Vector3 || obj.value instanceof Vector3D ? "vec3" : obj.value instanceof Vector4 ? "vec4" : obj.value instanceof Color ? "vec3" : void 0
            }
            async function initBehavior(behavior) {
                let glsl = [], predefinedUniforms = {
                    HZ: "float"
                }, input;
                _behaviorInput ? input = _behaviorInput : (input = InputUIL.create(prefix + "_behavior", _group),
                    input.setLabel("Behavior Uniforms"),
                    input.addTextarea("uniforms"),
                    input.add("data", "hidden"),
                    input.add("codeCount", "hidden"),
                    _behaviorInput = input);
                let map = {}
                    , list = []
                    , count = input.getNumber("codeCount") || 0
                    , data = input.get("data") || []
                    , panel = ListUIL.create(prefix + "_code", _group);
                panel.setLabel("Behavior Code"),
                    panel.onAdd(((name,input,index)=>{
                            list[index] || addCode(),
                                input.group.add(list[index].group),
                                list[index].mapId = name,
                                map[name] = list[index],
                                input.setLabel(map[name].get("name") || "Code")
                        }
                    )),
                    panel.onRemove((name=>{
                            let postfix = map[name].postfix;
                            list.remove(map[name]),
                                data.remove(postfix),
                                input.setValue("data", JSON.stringify(data))
                        }
                    )),
                    panel.onSort((array=>{
                            let arr = [];
                            array.forEach((name=>{
                                    arr.push(map[name].postfix)
                                }
                            )),
                                data = arr,
                                input.setValue("data", JSON.stringify(data))
                        }
                    ));
                let uniforms = parseUniforms(input.get("uniforms"))
                    , createCode = postfix=>{
                        let input = InputUIL.create(prefix + postfix, _group, !0);
                        if (input.prefix = prefix + postfix,
                            input.postfix = postfix,
                            input.setLabel("Editor"),
                            input.add("name", "hidden"),
                        Proton.ignorePresets && Proton.ignorePresets.includes(input.get("name")))
                            return;
                        ProtonPresets.bind(input),
                        input.customPresetCallback && input.customPresetCallback(_this);
                        let code = input.get("code") || "";
                        if (!input.disabled && code.length) {
                            for (uniforms = Utils.mergeObject(uniforms, parseUniforms(input.get("uniforms"), predefinedUniforms)); code.includes("#test "); )
                                try {
                                    let test = code.split("#test ")[1]
                                        , name = test.split("\n")[0]
                                        , glsl = code.split("#test " + name + "\n")[1].split("#endtest")[0];
                                    eval(name) || (code = code.replace(glsl, "")),
                                        code = code.replace("#test " + name + "\n", ""),
                                        code = code.replace("#endtest", "")
                                } catch (e) {
                                    throw "Error parsing test :: " + e
                                }
                            glsl.push(code)
                        }
                        list.push(input)
                    }
                ;
                data.forEach(createCode);
                let addCode = _=>{
                        count++,
                            data.push(`code_${count}`),
                            input.setValue("data", JSON.stringify(data)),
                            input.setValue("codeCount", count),
                            createCode(`code_${count}`)
                    }
                ;
                behavior instanceof AntimatterPass && (behavior.addInput("tOrigin", _antimatter.vertices),
                    behavior.addInput("tAttribs", _antimatter.attribs),
                    behavior.addUniforms(uniforms));
                let filledRequire = []
                    , insertUniform = (code,line)=>code.split("//uniforms").join(line + "\n//uniforms")
                    , insertCode = (code,line)=>code.split("//code").join(line + "\n//code")
                    , insertRequire = (code,line)=>{
                        let name = line.split("require(")[1].split(")")[0];
                        return filledRequire.includes(name) ? code : (filledRequire.push(name),
                            code.split("//require").join(Shaders.getShader(name) + "\n//require"))
                    }
                    , insertGLSL = (code,line)=>{
                        if (line.includes("#require")) {
                            let split = line.split("\n");
                            for (let l of split)
                                code = l.includes("#require") ? insertRequire(code, l) : insertCode(code, l);
                            return code
                        }
                        return insertCode(code, line)
                    }
                ;
                behavior.onCreateShader = code=>{
                    for (let name in uniforms)
                        code = insertUniform(code, `uniform ${getUniformGLSLType(uniforms[name])} ${name};`);
                    for (let name in predefinedUniforms)
                        code = insertUniform(code, `uniform ${predefinedUniforms[name]} ${name};`);
                    for (let str of glsl)
                        code = insertGLSL(code, str);
                    return _this.tubes && (code = _this.tubes.overrideShader(code)),
                    Renderer.type == Renderer.WEBGL2 && (code = code.replace(/gl_FragColor/g, "FragColor")),
                    code.includes("samplerExternalOES") && window.AURA && "android" == Device.system.os && (code = "#version 300 es\n#extension GL_OES_EGL_image_external_essl3 : require\n" + code.replace("#version 300 es", "")),
                        code
                }
                    ,
                    behavior.uniforms.uMaxCount = {
                        value: _this.particleCount,
                        ignoreUIL: !0
                    },
                    ShaderUIL.add(behavior, _group).setLabel("Behavior Shader"),
                    behavior.uniforms.HZ = {
                        value: 1
                    },
                    _this.startRender((_=>{
                            behavior.uniforms.HZ.value = Render.HZ_MULTIPLIER
                        }
                    ), 10),
                    ProtonPresets.onCodeEdit = rebuildShader
            }
            async function rebuildShader() {
                let lifecycle = "lifecycle" == _config.get("type")
                    , behavior = _this.initClass(AntimatterPass, "ProtonAntimatter" + (lifecycle ? "Lifecycle" : ""), {
                    unique: prefix,
                    customCompile: prefix + Utils.uuid()
                });
                await initBehavior(behavior),
                    behavior.initialize(64),
                    behavior.upload(),
                _this.behavior.shader._gl && (_this.behavior.shader._gl = behavior.shader._gl),
                _this.behavior.shader._metal && (_this.behavior.shader._metal = behavior.shader._metal),
                _this.behavior.shader._gpu && (_this.behavior.shader._gpu = behavior.shader._gpu)
            }
            function completeShader(shader) {
                let transparent = _input.get("transparent")
                    , depthWrite = _input.get("depthWrite")
                    , depthTest = _input.get("depthTest")
                    , blending = _input.get("blending")
                    , castShadow = _input.get("castShadow")
                    , receiveShadow = _input.get("receiveShadow");
                "boolean" == typeof depthWrite && (shader.depthWrite = depthWrite),
                "boolean" == typeof depthTest && (shader.depthTest = depthTest),
                "boolean" == typeof transparent && (shader.transparent = transparent),
                "boolean" == typeof castShadow && (_this.mesh.castShadow = castShadow),
                "boolean" == typeof receiveShadow && (shader.receiveShadow = receiveShadow),
                blending && (shader.blending = blending),
                    shader.uniforms.tRandom = {
                        value: _antimatter.attribs
                    }
            }
            function update() {
                _this.preventUpdate || _antimatter.update()
            }
            async function initAntimatter() {
                let lifecycle = "lifecycle" == _config.get("type");
                _config.addVector("width", [-1, 1]),
                    _config.addVector("height", [-1, 1]),
                    _config.addVector("depth", [-1, 1]);
                let dimensions = {
                    w: _config.get("width") || [-1, 1],
                    h: _config.get("height") || [-1, 1],
                    d: _config.get("depth") || [-1, 1]
                };
                _antimatter = _this.initClass(Antimatter, _size, dimensions),
                Proton.forceCloneVertices.includes(_config.get("class")) && (_antimatter.cloneVertices = !0),
                    _this.antimatter = _antimatter,
                    await _antimatter.ready();
                let output = _config.get("output");
                "tubes" == output && (_this.tubes = _this.initClass(ProtonTubes, _this));
                let overrideShader, wildcard = _input.get("wildcard");
                if (wildcard && wildcard.includes(".behavior")) {
                    let layer = await _this.parent.getLayer(wildcard.split(".")[0]);
                    await _this.wait(layer, "behavior"),
                        _this.behavior = layer.behavior
                } else {
                    let behavior = _this.initClass(AntimatterPass, "ProtonAntimatter" + (lifecycle ? "Lifecycle" : ""), {
                        unique: prefix,
                        customCompile: prefix
                    });
                    _this.behavior = behavior,
                        initBehavior(behavior)
                }
                let shaderName = _config.get("shader");
                if (shaderName)
                    if (shaderName.includes(".shader")) {
                        let layer = await _this.parent.getLayer(shaderName.split(".")[0]);
                        await _this.wait(layer, "shader"),
                            overrideShader = layer.shader
                    } else {
                        let uniforms = parseUniforms(_config.get("uniforms"));
                        uniforms.unique = prefix + (_this.onGenerateUniqueShader ? _this.onGenerateUniqueShader() : ""),
                            _antimatter.useShader(shaderName, uniforms)
                    }
                _antimatter.addPass(_this.behavior),
                    _this.mesh = _antimatter.getMesh(),
                _this.onCreateMesh && _this.onCreateMesh(_this.mesh),
                output && "particles" != output || _this.delayedCall((_=>{
                        _this.add(_antimatter.mesh)
                    }
                ), 480),
                Utils.query("uilOnly") || _this.startRender(update, RenderManager.AFTER_LOOPS),
                shaderName && !shaderName.includes(".shader") && (ShaderUIL.add(_antimatter.shader, _group).setLabel("Shader"),
                    completeShader(_antimatter.shader)),
                overrideShader && _antimatter.overrideShader(overrideShader),
                    _this.shader = _antimatter.shader,
                    _this.initialized = !0,
                lifecycle && (_this.spawn = _this.initClass(AntimatterSpawn, _this, _group, _input)),
                    initCustomClass()
            }
            this.uilInput = _input,
                this.uilGroup = _group,
                this.prefix = prefix,
                initConfig(),
                this.parseUniforms = parseUniforms,
                this.ready = function() {
                    return this.wait(this, "initialized")
                }
                ,
                this.applyToInstancedGeometry = function(geometry) {
                    geometry.addAttribute("lookup", new GeometryAttribute(_antimatter.getLookupArray(),3,1)),
                        geometry.addAttribute("random", new GeometryAttribute(_antimatter.getRandomArray(),4,1))
                }
                ,
                this.applyToShader = function(shader) {
                    shader.addUniforms({
                        tPos: _antimatter.getOutput(),
                        tPrevPos: _antimatter.getPrevOutput()
                    })
                }
                ,
                this.upload = async function() {
                    _this.disabled || (_this.group.visible = !1,
                        await this.ready(),
                        await _antimatter.upload(),
                    _this.spawn && await _this.spawn.upload(),
                    _this.tubes && await _this.tubes.upload(),
                        _this.group.visible = !0)
                }
                ,
                this.uploadSync = async function() {
                    _this.disabled || (await this.ready(),
                        await _antimatter.uploadSync(),
                    _this.spawn && await _this.spawn.upload(),
                    _this.tubes && await _this.tubes.uploadSync())
                }
                ,
                this.stopUpdating = function() {
                    _this.stopRender(update)
                }
                ,
                this.set("renderOrder", (async v=>{
                        await _this.ready(),
                            await _antimatter.ready(),
                            _antimatter.mesh.renderOrder = v
                    }
                )),
                this.get("renderOrder", (v=>_antimatter.mesh.renderOrder))
        }
    ), (_=>{
            Proton.forceCloneVertices = [],
                Proton.ignore = function(name) {
                    Proton.ignorePresets || (Proton.ignorePresets = []),
                        Proton.ignorePresets.push(name)
                }
        }
    )),
    Class((function ProtonPresets() {
            const _this = this
                , LIST = [{
                label: "Custom Code",
                value: "custom"
            }, {
                label: "Curl Noise",
                value: "curl"
            }, {
                label: "Plane Shape",
                value: "planeshape"
            }, {
                label: "3D Shape",
                value: "3dshape"
            }, {
                label: "Point Cloud",
                value: "pointcloud"
            }, {
                label: "Force",
                value: "force"
            }, {
                label: "Follow",
                value: "follow"
            }, {
                label: "Mouse Fluid",
                value: "fluid"
            }]
                , CALLBACKS = {
                custom: function customCode(input) {
                    input.setValue("name", "Custom Code"),
                        input.setLabel("Custom Code")
                },
                curl: function curlNoise(input) {
                    input.setValue("name", "Curl Noise"),
                        input.setLabel("Curl Noise");
                    input.setValue("uniforms", "\n        uCurlNoiseScale: 1\n        uCurlTimeScale: 0\n        uCurlNoiseSpeed: 0\n        "),
                        setPresetCodeIfRequired(input, "#require(curl.glsl)\n\nvec3 curl = curlNoise(pos * uCurlNoiseScale*0.1 + (time * uCurlTimeScale * 0.1));\npos += curl * uCurlNoiseSpeed * 0.01;", "uCurlNoise")
                },
                planeshape: function planeShape(input) {
                    input.setValue("name", "Plane Shape"),
                        input.setLabel("Plane Shape");
                    input.setValue("uniforms", "\n        uTakePlaneShape: 1\n        uPlaneScale: 1\n        tPlaneTexture: Csampler2D\n        "),
                        setPresetCodeIfRequired(input, "vec2 planeLookup = texture2D(tPlaneTexture, uv).xy;\nvec3 plane;\nplane.x = uPlaneScale * 0.5 * range(planeLookup.x, 0.0, 1.0, -1.0, 1.0);\nplane.y = uPlaneScale * 0.5 * -range(planeLookup.y, 0.0, 1.0, -1.0, 1.0);\nif (uTakePlaneShape > 0.5) pos = plane;", "uPlaneScale"),
                        input.customPresetCallback = proton=>{
                            proton.behavior.addUniforms({
                                tPlaneTexture: {
                                    value: null
                                }
                            })
                        }
                },
                "3dshape": function shape3D(input) {
                    input.setValue("name", "3D Shape"),
                        input.setLabel("3D Shape"),
                        input.add("geometry");
                    let geometry = input.get("geometry");
                    input.setValue("uniforms", "\n        tShape3D: Csampler2D\n        "),
                        setPresetCodeIfRequired(input, "vec3 shape3d = texture2D(tShape3D, uv).xyz;", "tShape3D"),
                        input.customPresetCallback = proton=>{
                            let create = async g=>{
                                    let geom = await GeomThread.loadGeometry(g)
                                        , distribution = await ParticleDistributor.generate(geom, proton.antimatter.particleCount)
                                        , attribute = new AntimatterAttribute(distribution,3);
                                    proton.behavior.addInput("tShape3D", attribute)
                                }
                            ;
                            geometry && create(geometry),
                                proton.set3DShape = create
                        }
                },
                pointcloud: function pointCloud(input) {
                    input.setValue("name", "Point Cloud"),
                        input.setLabel("Point Cloud"),
                        input.add("file");
                    let file = input.get("file");
                    input.setValue("uniforms", "\n        tPointCloud: Csampler2D\n        "),
                        setPresetCodeIfRequired(input, "vec3 pointShape = texture2D(tPointCloud, uv).xyz;", "tPointCloud"),
                        input.customPresetCallback = proton=>{
                            let create = async filePath=>{
                                    let data;
                                    "string" == typeof filePath ? (filePath += "-" + proton.antimatter.textureSize,
                                        data = await ParticleDistributor.generatePointCloud(filePath)) : data = filePath,
                                    proton.behavior.shader.uniforms.tPointCloud && (proton.behavior.shader.uniforms.tPointCloud.value.destroy(),
                                        proton.shader.uniforms.tPointColor.value.destroy()),
                                        proton.behavior.addInput("tPointCloud", data.positions),
                                        proton.shader.addUniforms({
                                            tPointColor: {
                                                value: data.colors
                                            }
                                        })
                                }
                            ;
                            file || (file = proton.parent.data ? proton.parent.data.pointCloudFile : void 0),
                            file && create(file),
                                proton.setPointCloud = create
                        }
                },
                force: function force(input) {
                    input.setValue("name", "Force"),
                        input.setLabel("Force");
                    input.setValue("uniforms", "\n        uForceDir: [0, 1, 0]\n        uForceScale: 1\n        "),
                        setPresetCodeIfRequired(input, "vec3 force = normalize(uForceDir) * uForceScale * 0.1;\npos += force;", "uForceDir")
                },
                follow: function follow(input) {
                    input.setValue("name", "Follow"),
                        input.setLabel("Follow");
                    input.setValue("uniforms", "\n        uFollowPos: [0, 0, 0]\n        uFollowRadius: 2\n        uFollowLerp: 0.7\n        "),
                        setPresetCodeIfRequired(input, "float speed = range(random.x, 0.0, 1.0, 0.5, 1.5);\nvec3 followPos = uFollowPos;\nfollowPos.x += range(random.y, 0.0, 1.0, -1.0, 1.0) * uFollowRadius;\nfollowPos.y += range(random.z, 0.0, 1.0, -1.0, 1.0) * uFollowRadius;\nfollowPos.z += range(random.w, 0.0, 1.0, -1.0, 1.0) * uFollowRadius;\npos += (followPos - pos) * (uFollowLerp*0.1*speed);", "followPos")
                },
                fluid: function fluid(input) {
                    input.setValue("name", "Mouse Fluid"),
                        input.setLabel("Mouse Fluid");
                    input.setValue("uniforms", "\n        uProjMatrix: Cmat4\n        uProjNormalMatrix: Cmat4\n        uModelMatrix: Cmat4\n        tFluidMask: Csampler2D\n        tFluid: Csampler2D\n        uMouseStrength: 1\n        "),
                        setPresetCodeIfRequired(input, "#require(glscreenprojection.glsl)\n\nvec3 mpos = vec3(uModelMatrix * vec4(pos, 1.0));\nvec2 screenUV = getProjection(mpos, uProjMatrix);\nvec3 flow = vec3(texture2D(tFluid, screenUV).xy, 0.0);\napplyNormal(flow, uProjNormalMatrix);\npos += flow * 0.0001 * uMouseStrength * texture2D(tFluidMask, screenUV).r;", "glscreenprojection");
                    input.customPresetCallback = async proton=>{
                        if (!("MouseFluid"in window))
                            return void alert("'mousefluid' module not found. To use Mouse Fluid preset, import module, load the MouseFluid class, and add a layer named 'fluid' with customCLass FluidLayer.");
                        let camera = (proton=>{
                                let camera = World.CAMERA
                                    , p = proton.group._parent;
                                for (; p; )
                                    p instanceof Scene && p.nuke && (camera = p.nuke.camera),
                                        p = p._parent;
                                return camera
                            }
                        )(proton)
                            , projection = proton.initClass(GLScreenProjection, camera);
                        projection.start(),
                            proton.projection = projection,
                            proton.wait("behavior").then((_=>{
                                    proton.behavior.addUniforms({
                                        uProjMatrix: projection.uniforms.projMatrix,
                                        uModelMatrix: projection.uniforms.modelMatrix,
                                        uProjNormalMatrix: projection.uniforms.normalMatrix
                                    }),
                                        MouseFluid.instance().applyTo(proton.behavior)
                                }
                            ))
                    }
                }
            };
            function setPresetCodeIfRequired(input, presetCode, keyShaderComponentString) {
                const editorCode = input.get("code");
                editorCode && editorCode.includes(keyShaderComponentString) || input.setValue("code", presetCode)
            }
            this.register = function(name, callback) {
                let key = name.replace(/ /g, "").toLowerCase();
                LIST.push({
                    label: name,
                    value: key
                }),
                    CALLBACKS[key] = callback
            }
                ,
                this.bind = function(input) {
                    input.add("code", "hidden");
                    input.add("uniforms", "hidden"),
                        input.addSelect("preset", LIST);
                    let callback = CALLBACKS[input.get("preset")];
                    callback && callback(input),
                        input.addButton("btn", {
                            actions: [{
                                title: "Edit Code",
                                callback: _=>{
                                    let editor = new UILExternalEditor(input.get("name") || "Code",300);
                                    editor.setCode(input.get("code"), "c"),
                                        editor.onSave = value=>{
                                            input.setValue("code", value),
                                                _this.onCodeEdit?.()
                                        }
                                        ,
                                        UIL.add(editor)
                                }
                            }],
                            hideLabel: !0
                        })
                }
        }
    ), "static"),
    Class((function RenderManager() {
            Inherit(this, Component);
            const _this = this;
            let _dpr = null;
            function resizeHandler() {
                _this.renderer && _this.renderer.setSize(Stage.width, Stage.height)
            }
            function getDPR() {
                let dpr = Math.min(Device.pixelRatio, 2.5);
                return window.AURA ? dpr : GPU.OVERSIZED || Device.mobile && Device.mobile.tablet && GPU.mobileLT(1) || GPU.lt(0) ? 1 : GPU.lt(1) ? Math.min(1.5, dpr) : GPU.mobileLT(0) ? Math.min(1, dpr) : GPU.mobileLT(2) || GPU.gt(4) ? Math.min(1.5, dpr) : Math.max(1.25, dpr)
            }
            function directRenderCallback(render) {
                window.GLUI && window.Metal && GLUI.renderDirect(render)
            }
            this.NORMAL = "normal",
                this.MAGIC_WINDOW = "magic_window",
                this.VR = this.WEBVR = "webvr",
                this.AR = this.WEBAR = "webar",
                this.RENDER = "RenderManager_render",
                this.POST_RENDER = "RenderManager_post_render",
                this.EYE_RENDER = "RenderManager_eye_render",
                this.READY = "render_gl_ready",
                _this.events.sub(Events.RESIZE, resizeHandler),
                resizeHandler(),
                this.get("DPR", (v=>getDPR())),
                this.initialize = function(type, params={}) {
                    if (_this.camera && _this.camera.destroy(),
                    _this.renderer && _this.renderer.destroy(),
                    type != _this.WEBVR && type != _this.WEBAR || (params.xrCompatible = !0),
                        !_this.gl) {
                        let camera = new PerspectiveCamera(45,Stage.width / Stage.height,.01,200);
                        _this.gl = function() {
                            "safari" == Device.system.browser && Device.system.browserVersion < 13 && delete params.powerPreference,
                            Utils.query("compat") && (params.forceWebGL1 = !0);
                            let renderer = new (window.Metal ? MetalRenderer : Renderer)(params);
                            return renderer.setSize(Stage.width, Stage.height),
                                renderer.setPixelRatio(getDPR()),
                                renderer
                        }(),
                            _this.scene = new Scene,
                            _this.nuke = _this.initClass(Nuke, Stage, Object.assign({
                                renderer: _this.gl,
                                scene: _this.scene,
                                camera: camera,
                                dpr: World.DPR
                            }, params))
                    }
                    switch (_dpr = _dpr || World.DPR || 1,
                        type) {
                        case _this.WEBVR:
                            _this.renderer = _this.initClass(VRRenderer, _this.gl, _this.nuke),
                                _this.camera = _this.initClass(VRCamera);
                            break;
                        case _this.WEBAR:
                            _this.renderer = _this.initClass(window.Metal ? MetalARRenderer : ARRenderer, _this.gl, _this.nuke),
                                _this.camera = _this.initClass(ARCamera);
                            break;
                        case _this.MAGIC_WINDOW:
                            _this.renderer = _this.initClass(MagicWindowRenderer, _this.gl, _this.nuke),
                                _this.camera = _this.initClass(VRCamera);
                            break;
                        case _this.NORMAL:
                            _this.renderer = _this.initClass(RenderManagerRenderer, _this.gl, _this.nuke),
                                _this.camera = _this.initClass(RenderManagerCamera)
                    }
                    _this.type = type,
                        _this.nuke.camera = _this.camera.worldCamera
                }
                ,
                this.render = function(scene, camera, renderTarget, forceClear) {
                    _this.renderer.render(scene || _this.scene, camera || _this.camera.worldCamera, renderTarget, forceClear, directRenderCallback),
                        _this.events.fire(_this.POST_RENDER)
                }
                ,
                this.startRender = function() {
                    Render.start(_this.render)
                }
                ,
                this.stopRender = function() {
                    Render.stop(_this.render)
                }
                ,
                this.requestPresent = function(bool) {
                    _this.renderer.requestPresent && _this.renderer.requestPresent(bool)
                }
                ,
                this.setSize = function(width, height) {
                    _this.events.unsub(Events.RESIZE, resizeHandler),
                        _this.renderer.setSize(width, height)
                }
                ,
                this.set("onRenderEye", (callback=>{
                        _this.renderer.onRenderEye = callback
                    }
                ))
        }
    ), "static"),
    Class((function RenderManagerCamera() {
            Inherit(this, Component);
            const _this = this;
            this.worldCamera = window.THREE ? new THREE.PerspectiveCamera(30,Stage.width / Stage.height,.1,1e3) : new PerspectiveCamera(30,Stage.width / Stage.height,.1,1e3),
                _this.events.sub(Events.RESIZE, (()=>{
                        _this.worldCamera.aspect = Stage.width / Stage.height,
                            _this.worldCamera.updateProjectionMatrix()
                    }
                ))
        }
    )),
    Class((function RenderManagerRenderer(_renderer, _nuke) {
            Inherit(this, Component);
            const _this = this;
            var _evt = {};
            _nuke.onBeforeProcess = _=>{
                _evt.stage = Stage,
                    _evt.camera = _nuke.camera,
                    _this.events.fire(RenderManager.RENDER, _evt)
            }
                ,
                this.render = function(scene, camera, _1, _2, directRender) {
                    _nuke.camera = camera,
                        _nuke ? _nuke.render(directRender) : _renderer.render(scene, camera, null, null, directRender)
                }
                ,
                this.setSize = function(width, height) {
                    _renderer.setSize(width, height)
                }
        }
    )),
    Class((function SceneLayout(_name, _options={}) {
            Inherit(this, Object3D);
            const _this = this;
            var _dataStore, _data, _timeline, _breakpoint;
            const ZERO = new Vector3;
            var _promises = [], _breakpoints = [], _folders = {}, _groups = {}, _custom = {}, _meshes = {}, _exists = {}, _layers = {}, _uil = UIL.sidebar, _graph, _config, _groupIndex = 0;
            function initialize(promise) {
                _promises.push(promise)
            }
            function createFolder(name) {
                let folder = new UILFolder(`sl_${_name}_${name}`,{
                    label: name,
                    closed: !0
                });
                return folder.hide(),
                    _folders[`sl_${_name}_${name}`] = folder,
                    folder
            }
            async function initConfig() {
                let input = InputUIL.create(`CONFIG_sl_${_name}`, _uil);
                input.add("Animation"),
                    input.add("Layout"),
                    input.add("Cinema Config"),
                _graph && _graph.addSpecial("Config", `Config (${_name})`, "Config"),
                    input.setLabel("Config");
                let animation = input.get("Animation")
                    , layout = input.get("Layout");
                if (animation) {
                    if (await ready(),
                        animation = animation.replace(/^\//g, ""),
                        _this.animation = _this.initClass(HierarchyAnimation, animation, linkObjects),
                        _timeline)
                        _this.startRender((_=>{
                                _this.animation.elapsed = _timeline.elapsed,
                                    _this.animation.update()
                            }
                        ));
                    else if (_uil) {
                        let range = new UILControlRange("Animation",{
                            min: 0,
                            max: 1,
                            step: .001
                        });
                        range.onChange((val=>{
                                _this.animation.elapsed = val,
                                    _this.animation.update()
                            }
                        )),
                            _uil.add(range)
                    }
                    await _this.animation.ready(),
                        _this.animation.update()
                }
                layout && (await ready(),
                    _this.layout = _this.initClass(HierarchyLayout, layout, linkObjects),
                    await _this.layout.ready()),
                    _config = input,
                    await defer(),
                    _this.configured = !0
            }
            async function linkObjects(data) {
                let array = [];
                for (let i = 0; i < data.length; i++) {
                    let name = data[i].name
                        , exists = _this.exists(name);
                    exists || "null" == name.toLowerCase() || console.warn(`linkAnimation :: ${name} does not exist`);
                    let group = new Group
                        , mesh = exists ? await _this.getLayer(name) : null;
                    mesh && (_this.layout && mesh instanceof Mesh ? (mesh._parent.add(group),
                        group.add(mesh)) : group = mesh.group || mesh),
                        group.name = name,
                        array.push(group)
                }
                return array
            }
            async function initGraph() {
                if (_options.noGraph || !window.UILGraph || SceneLayout.noGraph)
                    return _uil = null;
                (_graph = UILGraph.instance().getGraph(_name, _this)) && (UIL.sidebar.element.show(),
                    await _this.ready(),
                    _graph.syncVisibility(_layers),
                    _graph.syncGroupNames(_groups, _folders),
                Global.PLAYGROUND && Utils.getConstructorName(_this.parent) == Global.PLAYGROUND && _graph.open())
            }
            function initParams() {
                if (_options.rootPath ? "/" != _options.rootPath.charAt(_options.rootPath.length - 1) && (_options.rootPath += "/") : _options.rootPath = "",
                    _this.timeline = _timeline = _options.timeline,
                _timeline && (_timeline.add({
                    v: 0
                }, {
                    v: 1
                }, 100, "linear"),
                    _uil)) {
                    let range = new UILControlRange("Timeline",{
                        min: 0,
                        max: 1,
                        step: .001
                    });
                    range.onChange((val=>{
                            _timeline.elapsed = val,
                                _timeline.update()
                        }
                    )),
                        _uil.add(range),
                        range.hide(),
                    _graph && _graph.addSpecial("Timeline", "Timeline")
                }
                _this.baseRenderOrder = _options.baseRenderOrder || 0,
                    _this.data = _options.data,
                    _breakpoint = _options.breakpoint || SceneLayout.breakpoint,
                _options.breakpoint && (_this.localBreakpoint = !0),
                _options.uil && (_uil = _options.uil)
            }
            async function initData() {
                if (await UILStorage.ready(),
                    _dataStore = InputUIL.create(`scenelayout_${_name}`, null),
                void 0 === (_data = JSON.parse(_dataStore.get("data") || "{}")).layers && (_data.layers = -1),
                    _options.perFrame)
                    _data.layers > 0 && createLayers();
                else {
                    for (let i = 0, c = _data.layers + 1; i < c; i++)
                        initialize(createLayer(i));
                    _this.loaded = !0
                }
            }
            function createLayers() {
                let index = 0
                    , renderWorker = new Render.Worker((function() {
                        initialize(createLayer(index)),
                        index++ == _data.layers && (renderWorker.stop(),
                            _this.loaded = !0)
                    }
                ),_options.perFrame)
            }
            function getGroup(name) {
                if (!name)
                    return _this.group;
                if (name == _name)
                    return _this.group;
                if (!_groups[name]) {
                    let uilGroup = _uil ? createFolder(name) : null;
                    uilGroup && (uilGroup.setLabel(`${name} (Group)`),
                        _uil.add(uilGroup),
                    _graph && _graph.addGroup(uilGroup.id, name));
                    let config = InputUIL.create(`GROUP_${_name}_${name}`, uilGroup);
                    config.setLabel("Parameters"),
                    _timeline && config.add("tween"),
                        config.addToggle("billboard"),
                        config.add("breakpoints"),
                        config.add("name", "hidden");
                    let breakpoints = config.get("breakpoints");
                    breakpoints && (breakpoints = breakpoints.replace(/ /g, "").split(","));
                    let breakpoint = breakpoints && _breakpoint ? "-" + _breakpoint : "";
                    "-" == breakpoint.charAt(breakpoint.length - 1) && (breakpoint = "");
                    let group = new Group;
                    _groups[name] = group,
                        _layers[name] = group,
                        _exists[name] = "group",
                        group.prefix = `${name}_${_name}${breakpoint}`,
                        MeshUIL.add(group, uilGroup).setLabel("Mesh"),
                        _this.add(group),
                    uilGroup && (uilGroup.params = config),
                    breakpoints && _breakpoints.push(group),
                    config.get("billboard") && _this.startRender((_=>Utils3D.billboard(group))),
                    config.get("tween") && applyTween(group, name, uilGroup)
                }
                return _groupIndex++,
                    _groups[name]
            }
            async function applyTween(mesh, id, group, shader) {
                let config = TweenUIL.create(`Element_${id}_${_name}`, group)
                    , a = config.add(tween(mesh.position, mesh.position.clone(), 100, "linear", 0, null, !0), "position")
                    , b = config.add(tween(mesh.rotation, mesh.rotation.clone(), 100, "linear", 0, null, !0), "rotation")
                    , c = config.add(tween(mesh.scale, mesh.scale.clone(), 100, "linear", 0, null, !0), "scale")
                    , d = shader && shader.uniforms.uAlpha ? config.add(tween(shader.uniforms.uAlpha, {
                    value: 1
                }, 100, "linear", 0, null, !0), "alpha") : null;
                await defer(),
                    await defer(),
                    config.setLabel("Tween"),
                mesh.position.equals(a.props) || 0 == a.props.x && 0 == a.props.y && 0 == a.props.z || _timeline.add(a),
                mesh.rotation.equals(b.props) || 0 == b.props.x && 0 == b.props.y && 0 == b.props.z || _timeline.add(b),
                mesh.scale.equals(c.props) || 1 == c.props.x && 1 == c.props.y && 1 == c.props.z || _timeline.add(c),
                d && shader.uniforms.uAlpha.value != d.props.uAlpha && _timeline.add(d),
                    mesh.tweens = {
                        position: a,
                        rotation: b,
                        scale: c,
                        alpha: d
                    }
            }
            async function createLayer(index, groupName) {
                let id = "number" == typeof index ? index : ++_data.layers
                    , graphGroupName = groupName;
                if (graphGroupName) {
                    let nameLabel = UILStorage.get(`INPUT_GROUP_${_name}_${groupName}_name`);
                    nameLabel && (groupName = nameLabel)
                }
                if (UILStorage.get(`sl_${_name}_${id}_deleted`))
                    return;
                if (_this.preventLayerCreation && _this.preventLayerCreation(UILStorage.get(`INPUT_Config_${id}_${_name}_name`)))
                    return;
                let group = _uil ? createFolder(id) : null, shader, mesh, input = InputUIL.create(`Config_${id}_${_name}`, group);
                input.setLabel("Parameters"),
                    input.add("name", "hidden").add("geometry").addToggle("visible", !0).addToggle("transparent").addToggle("depthWrite", !0).addToggle("depthTest", !0).addToggle("castShadow").addToggle("receiveShadow").addToggle("receiveLight").addToggle("billboard").add("shader").add("customClass").add("scriptClass").add("wildcard").add("renderOrder", "hidden").add("group", "hidden").add("breakpoints").addSelect("side", [{
                        label: "Front Side",
                        value: "shader_front_side"
                    }, {
                        label: "Back Side",
                        value: "shader_back_side"
                    }, {
                        label: "Double Side",
                        value: "shader_double_side"
                    }]).addSelect("blending", [{
                        label: "Normal",
                        value: "shader_normal_blending"
                    }, {
                        label: "Additive",
                        value: "shader_additive_blending"
                    }]),
                    input.name = _name,
                    input.prefix = `Element_${id}_${_name}`,
                    input.id = id,
                group && (group.params = input),
                _timeline && input.addToggle("tween"),
                _options.physics && (input.addToggle("physics"),
                    input.add("physicsCode"));
                let name = input.get("name") || id
                    , shaderName = input.get("shader") || "SceneLayout"
                    , geomPath = input.get("geometry")
                    , visible = input.get("visible")
                    , transparent = input.get("transparent")
                    , depthWrite = input.get("depthWrite")
                    , depthTest = input.get("depthTest")
                    , billboard = input.get("billboard")
                    , doTween = input.get("tween")
                    , renderOrder = input.getNumber("renderOrder")
                    , blending = input.get("blending")
                    , side = input.get("side")
                    , physics = input.get("physics")
                    , castShadow = input.get("castShadow")
                    , receiveShadow = input.get("receiveShadow")
                    , receiveLight = input.get("receiveLight")
                    , breakpoints = input.get("breakpoints");
                breakpoints && (breakpoints = breakpoints.replace(/ /g, "").split(","));
                let breakpoint = breakpoints && _breakpoint ? "-" + _breakpoint : "";
                "-" == breakpoint.charAt(breakpoint.length - 1) && (breakpoint = ""),
                name && group && group.setLabel(name),
                groupName && input.setValue("group", groupName);
                let groupParent = getGroup(input.get("group"));
                if (group) {
                    let groupName = input.get("group")
                        , groupId = groupName ? `sl_${_name}_${graphGroupName || groupName}` : void 0;
                    _graph && _graph.addLayer(group.id, name || id + "", groupId)
                }
                if (_uil && _uil.add(group),
                "ignore" == name)
                    return;
                let customClass = input.get("customClass")
                    , scriptClass = input.get("scriptClass");
                if (_exists[name] = customClass ? "custom" : "mesh",
                    customClass) {
                    if (!window[customClass])
                        return console.warn(`Tried to initialize ${customClass} but it doesn't  exist!`);
                    let obj = _this.initClass(window[customClass], input, group, id, null);
                    if (mesh = obj.group,
                    "boolean" == typeof visible && mesh && (mesh.visible = visible),
                    doTween && obj.group && applyTween(obj.group, id, group),
                        _custom[name] = obj,
                        _layers[name] = obj,
                        _this.onCreateLayer) {
                        let capture = cb=>(_this.delayedCall((_=>cb(obj, name, group, input)), 32),
                            !0);
                        if (_this.onCreateLayer(name, capture))
                            return
                    }
                    return obj.group && groupParent.add(obj.group),
                        obj.renderOrder = _this.baseRenderOrder + renderOrder,
                        void (mesh && (mesh.prefix = `Element_${id}_${_name}${breakpoint}`,
                            MeshUIL.add(mesh, group).setLabel("Mesh"),
                            _breakpoints.push(mesh),
                        scriptClass && (scriptClass.includes(",") ? (scriptClass = scriptClass.replace(/ /g, "").split(","),
                            scriptClass.forEach((script=>{
                                    window[script] ? (mesh.scriptClass = mesh.scriptClass || [],
                                        mesh.scriptClass.push(_this.initClass(window[script], mesh, shader, group, input))) : console.warn(`scriptClass ${script} not found`)
                                }
                            ))) : window[scriptClass] ? mesh.scriptClass = _this.initClass(window[scriptClass], mesh, shader, group, input) : console.warn(`scriptClass ${scriptClass} not found`))))
                }
                if (_this.onCreateLayer) {
                    let capture = cb=>{
                            let mesh = new Group;
                            return mesh.prefix = `Element_${id}_${_name}${breakpoint}`,
                                MeshUIL.add(mesh, group),
                            doTween && applyTween(mesh, id, group, {
                                uniforms: {
                                    uAlpha: {
                                        value: 1
                                    }
                                }
                            }),
                                _meshes[name] = mesh,
                                _layers[name] = mesh,
                                defer((()=>{
                                        cb(mesh, name, group, input)
                                    }
                                )),
                                !0
                        }
                    ;
                    if (_this.onCreateLayer(name, capture))
                        return
                }
                let geom = World.PLANE;
                if (geomPath && geomPath.includes(["World", "SceneLayout"]) && (geom = eval(geomPath),
                    geomPath = null),
                    shaderName.includes(".shader")) {
                    let shaderLayer = shaderName.split(".shader")[0];
                    if (_exists[shaderLayer]) {
                        let layer = await _this.getLayer(shaderLayer);
                        shader = layer.shader,
                            shader._copied = layer
                    } else
                        shader = eval(shaderName)
                } else if (shaderName.includes("PBR"))
                    shader = _this.initClass(PBRShader, shaderName, {
                        unique: `Element_${id}_${_name}`
                    });
                else {
                    let texturePath = input.getImage("texture");
                    texturePath ? texturePath.includes("assets/images") || (texturePath = _options.rootPath + texturePath) : texturePath = "assets/images/_scenelayout/uv.jpg",
                        shader = _this.initClass(Shader, shaderName, {
                            unique: `Element_${id}_${_name}`
                        }),
                    "SceneLayout" != shaderName && window[shaderName] || shader.addUniforms({
                        tMap: {
                            value: Utils3D.getTexture(texturePath)
                        },
                        uAlpha: {
                            value: 1
                        }
                    }),
                        defer((_=>{
                                for (let key in shader.uniforms) {
                                    let uniform = shader.uniforms[key];
                                    uniform.value instanceof Texture && initialize(uniform.value.promise)
                                }
                            }
                        ))
                }
                if ("boolean" == typeof depthWrite && (shader.depthWrite = depthWrite),
                "boolean" == typeof depthTest && (shader.depthTest = depthTest),
                "boolean" == typeof transparent && (shader.transparent = transparent),
                geomPath && (geom = await GeomThread.loadGeometry(geomPath)),
                    mesh = new Mesh(geom,shader),
                "boolean" == typeof _options.frustumCulled && (mesh.frustumCulled = _options.frustumCulled),
                "boolean" == typeof visible && (mesh.visible = visible),
                    groupParent.add(mesh),
                    mesh.prefix = `Element_${id}_${_name}${breakpoint}`,
                    MeshUIL.add(mesh, group).setLabel("Mesh"),
                    physics) {
                    let obj = Physics.instance().create(mesh);
                    obj.prefix = `Physics_${id}_${_name}`,
                        PhysicsUIL.add(obj, group).setLabel("Physics");
                    let code = input.get("physicsCode");
                    code && _this.initClass(window[code], obj, mesh, group, input)
                }
                _meshes[name] = mesh,
                    _layers[name] = mesh,
                breakpoints && _breakpoints.push(mesh),
                    mesh.renderOrder = _this.baseRenderOrder + (renderOrder || 0),
                billboard && _this.startRender((_=>Utils3D.billboard(mesh))),
                doTween && applyTween(mesh, id, group, shader),
                "SceneLayout" != shaderName && window[shaderName] && (mesh.shaderClass = _this.initClass(window[shaderName], mesh, shader, group, input)),
                shader._copied || shader !== mesh.shader && !shaderName.includes("PBR") || ShaderUIL.add(shader, group).setLabel("Shader"),
                shader._copied && shader._copied.shaderClass && shader._copied.shaderClass.applyClone && shader._copied.shaderClass.applyClone(mesh),
                "number" != typeof index && _dataStore.setValue("data", JSON.stringify(_data)),
                blending && (shader.blending = blending),
                side && (shader.side = side),
                castShadow && (mesh.castShadow = castShadow),
                receiveShadow && (shader.receiveShadow = receiveShadow),
                receiveLight && (shader.receiveLight = receiveLight),
                scriptClass && (scriptClass.includes(",") ? (scriptClass = scriptClass.replace(/ /g, "").split(","),
                    scriptClass.forEach((script=>{
                            window[script] ? (mesh.scriptClass = mesh.scriptClass || [],
                                mesh.scriptClass.push(_this.initClass(window[script], mesh, shader, group, input))) : console.warn(`scriptClass ${script} not found`)
                        }
                    ))) : window[scriptClass] ? mesh.scriptClass = _this.initClass(window[scriptClass], mesh, shader, group, input) : console.warn(`scriptClass ${scriptClass} not found`)),
                    input.onUpdate = key=>{
                        switch (key) {
                            case "name":
                                group.setLabel(input.get(key));
                                break;
                            case "visible":
                                mesh.visible = input.get(key);
                                break;
                            case "renderOrder":
                                mesh.renderOrder = _this.baseRenderOrder + input.getNumber(key);
                                break;
                            case "transparent":
                                shader.transparent = input.get(key);
                                break;
                            case "depthWrite":
                                shader.depthWrite = input.get(key);
                                break;
                            case "depthTest":
                                shader.depthTest = input.get(key);
                                break;
                            case "side":
                                shader.side = input.get(key);
                                break;
                            case "blending":
                                shader.blending = input.get(key)
                        }
                    }
            }
            function addListeners() {
                _this.events.sub(SceneLayout.BREAKPOINT, (e=>_this.localBreakpoint ? null : setBreakpoint(e)))
            }
            function setBreakpoint({value: value}) {
                value != _breakpoint && (_breakpoint = value,
                    _breakpoints.forEach((mesh=>{
                            mesh.prefix = mesh.prefix.split("-")[0] + "-" + _breakpoint,
                            "-" == mesh.prefix.charAt(mesh.prefix.length - 1) && (mesh.prefix = mesh.prefix.slice(0, -1)),
                                new MeshUILConfig(mesh)
                        }
                    )))
            }
            async function ready() {
                await _this.wait(_this, "loaded"),
                UIL.sidebar && UIL.sidebar.toolbar.hideAll()
            }
            function copyFolderProps(from, to) {
                let mesh, params, shader;
                to.forEachFolder((child=>{
                        switch (child.label) {
                            case "Parameters":
                                params = child;
                                break;
                            case "Mesh":
                                mesh = child;
                                break;
                            case "Shader":
                                shader = child
                        }
                    }
                ));
                let allowed = ["Parameters", "Mesh", "Shader"];
                from.forEachFolder((child=>{
                        if (!(allowed.indexOf(child.label) < 0))
                            switch (child.toClipboard(),
                                child.label) {
                                case "Parameters":
                                    params.fromClipboard();
                                    break;
                                case "Mesh":
                                    mesh.fromClipboard();
                                    break;
                                case "Shader":
                                    shader.fromClipboard()
                            }
                    }
                ))
            }
            this.isSceneLayout = !0,
                this.name = _name,
                async function() {
                    _this.group.sceneLayout = _this,
                        await initialize(defer()),
                    SceneLayout.getTexture || (SceneLayout.getTexture = Utils3D.getTexture),
                        initGraph(),
                        initParams(),
                        initialize(initConfig()),
                        initData(),
                        addListeners(),
                        ready()
                }(),
                this.ready = async function(early) {
                    if (await _this.wait(_this, "loaded"),
                        await _this.wait(_this, "configured"),
                        early)
                        return !0;
                    await defer(),
                        await defer()
                }
                ,
                this.getLayer = async function(name) {
                    let timer;
                    return Hydra.LOCAL && (timer = _this.delayedCall((_=>{
                            _exists[name] || console.warn(`${name} doesn't exist in SceneLayout ${_name}`)
                        }
                    ), 1e3)),
                        await _this.wait(_layers, name),
                    timer && clearTimeout(timer),
                        _layers[name]
                }
                ,
                this.getLayers = async function() {
                    let array = [];
                    for (let i = 0; i < arguments.length; i++)
                        array.push(_this.getLayer(arguments[i]));
                    return Promise.all(array)
                }
                ,
                this.getAllLayers = async function() {
                    return await this.ready(),
                        await this.loadedAllLayers(),
                        _layers
                }
                ,
                this.exists = function(name) {
                    return _exists[name]
                }
                ,
                this._createLayer = function(parentId) {
                    createLayer(null, parentId)
                }
                ,
                this._createGroup = function(parentId) {
                    getGroup(`group_${_groupIndex}`, parentId)
                }
                ,
                this._rename = function(id, name, value) {
                    let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
                    folder && (folder.setLabel(value),
                    folder.params && folder.params.setValue("name", value),
                        [_groups, _custom, _meshes, _exists, _layers].forEach((function(store) {
                                store[name] && (store[value] = store[name],
                                    store[name] = null,
                                    delete store[name])
                            }
                        )))
                }
                ,
                this._deleteLayer = function(id, name) {
                    id.includes("_") && (id = (id = id.split("_"))[id.length - 1]);
                    let folder = _folders[id] || _folders[`sl_${_name}_${id}`]
                        , layer = _layers[id] || _layers[name];
                    return layer && layer.isGroup && layer.length > 1 ? (alert("Can't delete a group that has nested layers."),
                        !1) : !!confirm("Are you sure you want to delete this layer?") && (layer && layer._parent && (layer._parent.remove(layer),
                        layer._parent = null),
                    folder && folder.parent && folder.parent.remove(folder),
                        UILStorage.set(`sl_${_name}_${id}_deleted`, !0),
                        !0)
                }
                ,
                this._changeParent = function(childId, childName, parentId, parentName) {
                    let child = _layers[childId] || _layers[childName]
                        , parent = _layers[parentId] || _layers[parentName] || _this;
                    if (!child)
                        return;
                    let folder = _folders[childId] || _folders[`sl_${_name}_${childName}`];
                    folder && folder.params && folder.params.setValue("group", parentName || null);
                    let parentObject = parent.group || parent
                        , childObject = child.group || child;
                    parentObject.isObject3D && childObject.isObject3D && parentObject.add(childObject),
                    child.updateMatrix && child.updateMatrix()
                }
                ,
                this._visible = function(name, visible) {
                    let mesh = _layers[name];
                    mesh && (mesh.group && (mesh = mesh.group),
                        mesh.visible = visible)
                }
                ,
                this._focus = function(name) {
                    UIL.sidebar.toolbar.filterSingle(name)
                }
                ,
                this._blur = function(name) {
                    let folder = _folders[name] || _folders[`sl_${_name}_${name}`];
                    folder && folder.forEachFolder && (folder.forEachFolder((f=>f.close())),
                        folder.close())
                }
                ,
                this._sort = function(order) {
                    order.forEach(((label,index)=>{
                            label.children && label.children.forEach((function(child, j, all) {
                                    let folder = _folders[child];
                                    if (!folder || !folder.params)
                                        return;
                                    let renderOrder = _this.baseRenderOrder + index + (j + 1) / (all.length + 1);
                                    folder.params.setValue("renderOrder", renderOrder - _this.baseRenderOrder);
                                    let mesh = _layers[child] || _layers[folder.label];
                                    mesh && (mesh.renderOrder = renderOrder)
                                }
                            ));
                            let folder = _folders[label];
                            if (!folder || !folder.params)
                                return;
                            let renderOrder = _this.baseRenderOrder + index;
                            folder.params.setValue("renderOrder", renderOrder - _this.baseRenderOrder);
                            let mesh = _layers[label] || _layers[folder.label];
                            mesh && (mesh.renderOrder = renderOrder)
                        }
                    ))
                }
                ,
                this._duplicateLayer = function(id, parentId) {
                    let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
                    folder && (createLayer(null, parentId),
                        copyFolderProps(folder, Object.values(_folders).last()))
                }
                ,
                this._duplicateGroup = function(id, children) {
                    let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
                    if (!folder)
                        return;
                    let copyId = `group_${_groupIndex + 1}`;
                    getGroup(copyId),
                        copyFolderProps(folder, Object.values(_folders).last()),
                        children.forEach((childId=>{
                                _this._duplicateLayer(childId, copyId)
                            }
                        ))
                }
                ,
                this._getCinemaConfig = async function() {
                    let _cinemaConfig = _config.get("Cinema Config").replace(".json", "");
                    return await get(Assets.getPath(`assets/geometry/${_cinemaConfig}.json`))
                }
                ,
                this._applyCinemaConfig = function(id, params) {
                    let folder = _folders[id] || _folders[`sl_${_name}_${id}`];
                    if (!folder)
                        return;
                    let mesh = folder.getAll().filter((sub=>"Mesh" == sub.label))[0];
                    if (params.geometry && folder.params.setValue("geometry", params.geometry.replace("assets/geometry/", "")),
                        ["position", "quaternion", "scale"].forEach((transform=>{
                                if (params[transform]) {
                                    let value = JSON.parse(params[transform]);
                                    if ("quaternion" == transform) {
                                        let quat = (new Quaternion).fromArray(value);
                                        value = (new Euler).setFromQuaternion(quat).toArray().slice(0, 3).map((angle=>180 * angle / Math.PI)),
                                            transform = "rotation"
                                    }
                                    mesh.getAll().filter((control=>control.label == transform))[0].force(value)
                                }
                            }
                        )),
                    params.visible && "false" === params.visible && !params.geometry && (folder.params.setValue("geometry", "World.PLANE"),
                        folder.params.setValue("side", "shader_double_side"),
                        !Global.PLAYGROUND)) {
                        _meshes[folder.params.get("name")].shader.neverRender = !0
                    }
                    params.shader && folder.params.setValue("shader", params.shader)
                }
                ,
                this.loadedAllLayers = async function() {
                    return await _this.ready(),
                        Promise.all(_promises)
                }
                ,
                this.set("breakpoint", (value=>{
                        _this.localBreakpoint = !0,
                            setBreakpoint({
                                value: value
                            })
                    }
                )),
                this.get("breakpoint", (_=>_breakpoint)),
                this.get("layers", (_=>_layers)),
                this.get("layerCount", (_=>_data.layers))
        }
    ), (_=>{
            SceneLayout.BREAKPOINT = "sl_breakpoint",
                SceneLayout.setBreakpoint = function(value) {
                    SceneLayout.breakpoint !== value && (SceneLayout.breakpoint = value,
                        Events.emitter._fireEvent(SceneLayout.BREAKPOINT, {
                            value: value
                        }))
                }
        }
    )),
    Class((function Scroll(_object, _params) {
            Inherit(this, Component);
            const _this = this;
            this.x = 0,
                this.y = 0,
                this.max = {
                    x: 0,
                    y: 0
                },
                this.delta = {
                    x: 0,
                    y: 0
                },
                this.enabled = !0;
            const _scrollTarget = {
                x: 0,
                y: 0
            }
                , _scrollInertia = {
                x: 0,
                y: 0
            };
            let _axes = ["x", "y"];
            var _lastDelta;
            function loop() {
                _this.object && (Math.round(_this.object.div.scrollLeft) === Math.round(_this.x) && Math.round(_this.object.div.scrollTop) === Math.round(_this.y) || (_this.x = _scrollTarget.x = _this.object.div.scrollLeft,
                    _this.y = _scrollTarget.y = _this.object.div.scrollTop,
                    stopInertia())),
                    _axes.forEach((axis=>{
                            _this.isInertia && (_scrollInertia[axis] *= .9,
                                _scrollTarget[axis] += _scrollInertia[axis]),
                            _this.limit && (_scrollTarget[axis] = Math.max(_scrollTarget[axis], 0)),
                            _this.limit && (_scrollTarget[axis] = Math.min(_scrollTarget[axis], _this.max[axis] / _this.scale)),
                                _this.delta[axis] = _this.flag("block") ? 0 : .5 * (_scrollTarget[axis] * _this.scale - _this[axis]),
                                _this[axis] += _this.delta[axis],
                            Math.abs(_this.delta[axis]) < .01 && (_this.delta[axis] = 0),
                            Math.abs(_this[axis]) < .001 && (_this[axis] = 0),
                            _this.object && ("x" == axis && (_this.object.div.scrollLeft = Math.round(_this.x)),
                            "y" == axis && (_this.object.div.scrollTop = Math.round(_this.y)))
                        }
                    ))
            }
            function stopInertia() {
                _this.isInertia = !1,
                    clearTween(_scrollTarget)
            }
            function edgeScroll(e) {
                "touch" === e.pointerType && _this.enabled && (e.preventDefault && e.preventDefault(),
                    _axes.forEach((axis=>{
                            let dir = axis.toUpperCase()
                                , delta = `offset${dir}`
                                , diff = (_this[`ieDelta${dir}`] || e[delta]) - e[delta];
                            _scrollTarget[axis] += diff,
                                _scrollInertia[axis] = diff,
                                _this.isInertia = !0,
                                _this[`ieDelta${dir}`] = e[delta]
                        }
                    )),
                _this.onUpdate && _this.onUpdate(),
                    _this.events.fire(Events.UPDATE, _scrollInertia))
            }
            function edgeScrollEnd() {
                _this.ieDeltaX = !1,
                    _this.ieDeltaY = !1
            }
            function scroll(e) {
                if (!_this.enabled)
                    return;
                if (!_this.mouseWheel)
                    return;
                stopInertia(),
                    clearTimeout(_this.blockTimer);
                let newDelta = 0;
                _axes.forEach((axis=>{
                        let delta = "delta" + axis.toUpperCase();
                        if ("mac" == Device.system.os) {
                            if ("firefox" == Device.system.browser)
                                return 1 === e.deltaMode ? (_scrollTarget[axis] += 4 * e[delta],
                                    _scrollInertia[axis] = 4 * e[delta],
                                    _this.isInertia = !0,
                                    void (newDelta = _scrollInertia[axis])) : void (_scrollTarget[axis] += e[delta]);
                            if (Device.system.browser.includes(["chrome", "safari"]))
                                return _scrollTarget[axis] += .33 * e[delta],
                                    _scrollInertia[axis] = .33 * e[delta],
                                    _this.isInertia = !0,
                                    void (newDelta = _scrollInertia[axis])
                        }
                        if ("windows" == Device.system.os) {
                            if ("firefox" == Device.system.browser && 1 === e.deltaMode)
                                return _scrollTarget[axis] += 10 * e[delta],
                                    _scrollInertia[axis] = 10 * e[delta],
                                    _this.isInertia = !0,
                                    void (newDelta = _scrollInertia[axis]);
                            if (Device.system.browser.includes(["chrome"])) {
                                let s = .075;
                                return _scrollTarget[axis] += e[delta] * s,
                                    _scrollInertia[axis] = e[delta] * s,
                                    _this.isInertia = !0,
                                    void (newDelta = _scrollInertia[axis])
                            }
                            if ("ie" == Device.system.browser)
                                return _scrollTarget[axis] += e[delta],
                                    _scrollInertia[axis] = e[delta],
                                    _this.isInertia = !0,
                                    void (newDelta = _scrollInertia[axis])
                        }
                        _scrollTarget[axis] += e[delta],
                            newDelta = _scrollInertia[axis]
                    }
                )),
                    newDelta = Math.abs(newDelta),
                newDelta > _lastDelta && _this.flag("block", !1),
                    _lastDelta = newDelta,
                _this.onUpdate && _this.onUpdate(),
                    _this.events.fire(Events.UPDATE, _scrollInertia)
            }
            function down() {
                _this.enabled && stopInertia()
            }
            function drag() {
                _this.enabled && _axes.forEach((axis=>{
                        _scrollTarget[axis] -= Mouse.delta[axis]
                    }
                ))
            }
            function up() {
                if (!_this.enabled || _this.preventInertia)
                    return;
                const m = "android" == Device.system.os ? 35 : 25
                    , obj = {};
                _axes.forEach((axis=>{
                        obj[axis] = _scrollTarget[axis] - Mouse.delta[axis] * m
                    }
                )),
                    tween(_scrollTarget, obj, 2500, "easeOutQuint")
            }
            function resize() {
                if (!_this.enabled)
                    return;
                if (stopInertia(),
                    !_this.object)
                    return;
                const p = {};
                Device.mobile && _axes.forEach((axis=>p[axis] = _this.max[axis] ? _scrollTarget[axis] / _this.max[axis] : 0)),
                void 0 === _params.height && (_this.max.y = _this.object.div.scrollHeight - _this.object.div.clientHeight),
                void 0 === _params.width && (_this.max.x = _this.object.div.scrollWidth - _this.object.div.clientWidth),
                Device.mobile && _axes.forEach((axis=>_this[axis] = _scrollTarget[axis] = p[axis] * _this.max[axis]))
            }
            !function initParams() {
                _object && _object.div || (_params = _object,
                    _object = null),
                _params || (_params = {}),
                    _this.object = _object,
                    _this.hitObject = _params.hitObject || _this.object,
                    _this.max.y = _params.height || 0,
                    _this.max.x = _params.width || 0,
                    _this.scale = _params.scale || 1,
                    _this.drag = void 0 !== _params.drag ? _params.drag : !!Device.mobile,
                    _this.mouseWheel = !1 !== _params.mouseWheel,
                    _this.limit = "boolean" == typeof _params.limit && _params.limit,
                Array.isArray(_params.axes) && (_axes = _params.axes)
            }(),
            _this.object && function style() {
                _this.object.css({
                    overflow: "auto"
                })
            }(),
                function addHandlers() {
                    if (Device.mobile || ("ie" === Device.system.browser && Device.system.browserVersion >= 17 && (document.body.addEventListener("pointermove", edgeScroll, {
                        passive: !1
                    }),
                        document.body.addEventListener("pointerup", edgeScrollEnd, {
                            passive: !1
                        })),
                        "ie" == Device.system.browser ? document.body.addEventListener("wheel", scroll, !0) : __window.bind("wheel", scroll)),
                        _this.drag) {
                        _this.hitObject && _this.hitObject.bind("touchstart", (e=>e.preventDefault()));
                        let input = _this.hitObject ? _this.initClass(Interaction, _this.hitObject) : Mouse.input;
                        _this.events.sub(input, Interaction.START, down),
                            _this.events.sub(input, Interaction.DRAG, drag),
                            _this.events.sub(input, Interaction.END, up)
                    }
                    _this.events.sub(Events.RESIZE, resize)
                }(),
                resize(),
                _this.startRender(loop),
                this.reset = function() {
                    return _this.object && _this.object.div && (_this.object.div.scrollLeft = _this.x = 0,
                        _this.object.div.scrollTop = _this.y = 0),
                        _scrollTarget.x = _scrollTarget.y = 0,
                        _scrollInertia.x = _scrollInertia.y = 0,
                        stopInertia(),
                        this
                }
                ,
                this.onDestroy = function() {
                    __window.unbind("wheel", scroll)
                }
                ,
                this.resize = resize,
                this.scrollTo = function(value, axis="y") {
                    let values = {};
                    values[axis] = value,
                        tween(_scrollTarget, values, 800, "easeInOutCubic")
                }
                ,
                this.blockUntilNewScroll = function() {
                    if (!Device.mobile)
                        return stopInertia(),
                            _this.flag("block", !0),
                            clearTimeout(_this.blockScrollTo),
                            _this.blockScrollTo = _this.delayedCall((()=>{
                                    _scrollTarget.x = _this.x,
                                        _scrollTarget.y = _this.y,
                                        _scrollInertia.x = _scrollInertia.y = 0,
                                        _this.flag("block", !1)
                                }
                            ), 1500),
                            this
                }
                ,
                this.stopInertia = stopInertia
        }
    ), (_=>{
            var _scroll;
            Scroll.createUnlimited = Scroll.getUnlimited = function(options) {
                return _scroll || (_scroll = new Scroll({
                    limit: !1,
                    drag: Device.mobile
                })),
                    _scroll
            }
        }
    )),
    Class((function SentryDebug() {
            !async function() {
                window.Sentry && (await Hydra.ready(),
                    await GPU.ready(),
                    Sentry.configureScope((function(scope) {
                            if (scope.setExtra("gpu", `${Device.graphics.webgl ? Device.graphics.webgl.gpu : "WEBGL UNAVAILABLE"}`),
                                scope.setExtra("gpu_tier", `${Device.mobile ? GPU.M_TIER : GPU.TIER}`),
                                scope.setExtra("webgl_version", `${Device.graphics.webgl ? Device.graphics.webgl.version : "WEBGL UNAVAILABLE"}`),
                                scope.setExtra("mobile", `${JSON.stringify(Device.mobile).split(":").join(": ")}`),
                                scope.setExtra("system", `${JSON.stringify(Device.system).split(":").join(": ")}`),
                                scope.setExtra("user_agent", Device.agent),
                                scope.setExtra("dpr", Device.pixelRatio),
                                scope.setExtra("refresh_rate", Render.REFRESH_RATE),
                                scope.setExtra("user_agent", Device.agent),
                                scope.setExtra("screen_size", `${screen.width} x ${screen.height}`),
                                scope.setExtra("stage_size", `${Stage.width} x ${Stage.height}`),
                                Tests)
                                for (let key in Tests)
                                    scope.setExtra("test_" + key, Tests[key]())
                        }
                    )))
            }()
        }
    ), "static"),
    Class((function Shaders() {
            Inherit(this, Component);
            var _this = this;
            function parseSingleShader(code, fileName) {
                let uniforms = code.split("#!UNIFORMS")[1].split("#!")[0]
                    , varyings = code.split("#!VARYINGS")[1].split("#!")[0]
                    , attributes = code.split("#!ATTRIBUTES")[1].split("#!")[0];
                for (; code.includes("#!SHADER"); ) {
                    let split = (code = code.slice(code.indexOf("#!SHADER"))).split("#!SHADER")[1]
                        , br = split.indexOf("\n")
                        , name = split.slice(0, br).split(": ")[1];
                    name.slice(0, 6).includes("Vertex") && (name = fileName.split(".")[0] + ".vs"),
                    name.slice(0, 8).includes("Fragment") && (name = fileName.split(".")[0] + ".fs");
                    let glsl = split.slice(br);
                    glsl = name.includes(".vs") ? attributes + uniforms + varyings + glsl : uniforms + varyings + glsl;
                    let splitName = name.split(".");
                    _this[splitName[0] + (splitName[1].includes("vs") ? ".vs" : ".fs")] = glsl,
                        code = code.replace("#!SHADER", "$")
                }
            }
            function parseCompiled(shaders) {
                var split = shaders.split("{@}");
                split.shift();
                for (var i = 0; i < split.length; i += 2) {
                    var name = split[i]
                        , text = split[i + 1];
                    text.includes("#!UNIFORMS") ? parseSingleShader(text, name) : _this[name] = text
                }
            }
            function parseRequirements() {
                for (var key in _this) {
                    var obj = _this[key];
                    "string" == typeof obj && (_this[key] = require(obj))
                }
            }
            function require(shader) {
                if (!shader.includes("require"))
                    return shader;
                for (shader = shader.replace(/# require/g, "#require"); shader.includes("#require"); ) {
                    var name = shader.split("#require(")[1].split(")")[0];
                    if (name = name.replace(/ /g, ""),
                        !_this[name])
                        throw "Shader required " + name + ", but not found in compiled shaders.\n" + shader;
                    shader = shader.replace("#require(" + name + ")", _this[name])
                }
                return shader
            }
            this.parse = function(code, file) {
                code.includes("{@}") ? (parseCompiled(code),
                    parseRequirements()) : (file = (file = file.split("/"))[file.length - 1],
                    _this[file] = code),
                    _this.shadersParsed = !0
            }
                ,
                this.onReady = this.ready = function(callback) {
                    let promise = Promise.create();
                    return callback && promise.then(callback),
                        _this.wait((()=>promise.resolve()), _this, "shadersParsed"),
                        promise
                }
                ,
                this.getShader = function(string) {
                    _this.FALLBACKS && _this.FALLBACKS[string] && (string = _this.FALLBACKS[string]);
                    var code = _this[string];
                    if (!code)
                        throw `No shader ${string} found`;
                    for (; code.includes("#test "); )
                        try {
                            var test = code.split("#test ")[1]
                                , name = test.split("\n")[0]
                                , glsl = code.split("#test " + name + "\n")[1].split("#endtest")[0];
                            eval(name) || (code = code.replace(glsl, "")),
                                code = code.replace("#test " + name + "\n", ""),
                                code = code.replace("#endtest", "")
                        } catch (e) {
                            throw "Error parsing test :: " + string
                        }
                    return code
                }
        }
    ), "static"),
    Class((function Text3D(_input, _group) {
            Inherit(this, Object3D);
            const _this = this;
            var _config, _fontObject, $text;
            function initUIL() {
                (_config = InputUIL.create(_input.prefix + "_text3d", _group)).setLabel("Text3D"),
                    _config.addTextarea("text").addTextarea("fontStyle"),
                    _config.addToggle("anchor2D", !1),
                    _config.addToggle("renderRetina", !1),
                    _config.add("data", "hidden"),
                UIL.sidebar && (_config.onUpdate = key=>{
                        if ("data" != key) {
                            let text = parseData(_config.get("text"))
                                , obj = getFontObject();
                            _config.setValue("data", JSON.stringify(obj)),
                            $text && ($text.setText(text, obj),
                            obj.color && $text.setColor(obj.color)),
                            _this.onUpdate && _this.onUpdate()
                        }
                    }
                )
            }
            function parseData(text) {
                if (!text || !text.includes("$DATA"))
                    return text;
                for (; text.includes("$DATA"); ) {
                    let code = text.split("$DATA")[1].split(" ")[0].split("\n")[0]
                        , line = "$DATA" + code;
                    text = text.replace(line, eval(line.replace("$DATA", "_this.parent.data")))
                }
                return text
            }
            function getFontObject() {
                let font = _config.get("fontStyle") || ""
                    , obj = {};
                return font = font.split("\n"),
                    font.forEach((line=>{
                            let key = (line = line.split(":"))[0]
                                , val = line[1];
                            val && (val = val.replace(/ /g, "")),
                            key.length && (obj[key] = isNaN(Number(val)) ? val : Number(val),
                            "false" === val && (obj[key] = !1),
                            "true" === val && (obj[key] = !0))
                        }
                    )),
                    obj
            }
            function initText() {
                if (!(_fontObject = JSON.parse(_config.get("data") || "{}")).size)
                    return;
                Text3D.FONT_CONFIG && (_fontObject.config = Text3D.FONT_CONFIG),
                Text3D.LANG_BREAK && (_fontObject.langBreak = Text3D.LANG_BREAK),
                _fontObject.shader || (_fontObject.shader = "Text3D");
                let text = parseData(_config.get("text"));
                text && createText(text, _fontObject)
            }
            async function overrideLocalize(text, fontObject, cb) {
                if (!text)
                    return;
                _this.localized = !0,
                    fontObject.text = text,
                _this.text && _this.text.destroy && _this.text.destroy(),
                    _this.text = new Text3D.FallbackText,
                    _this.text.setColor(_fontObject.color),
                    _this.text.onSetText = text=>_this.setText(text);
                Text3D.createFallbackTexture(text, fontObject).then((texture=>{
                        _this.text.setColor(fontObject.color);
                        let geom = new PlaneGeometry(texture.width,texture.height);
                        for (geom.computeBoundingBox(),
                             "center" != fontObject.align && geom.applyMatrix((new Matrix4).makeTranslation(texture.width / 2, 0, 0)); _this.group.children.length; )
                            _this.group.remove(_this.group.children[0]);
                        return _this.text.createMesh(geom, texture),
                            _this.add(_this.text.group),
                            _this.text
                    }
                ))
            }
            function createText(text, fontObject) {
                if ((fontObject.localize || _input.forceLocalize) && Text3D.missingChars(text, fontObject))
                    return overrideLocalize(text, fontObject);
                ($text = $glText(text, null, null, fontObject)).enable3D(_config.get("anchor2D")),
                    _config.get("renderRetina") ? ($text.anchor || ($text.anchor = new Group),
                        _this.add($text.anchor),
                        GLUI.Scene.add($text)) : _this.add($text.group),
                    $text.text.onCreateShader = shader=>{
                        let shaderName = _input.get("shader");
                        shaderName && (shader.fragmentShader = shader.fragmentShader.split("void main")[0] + "\n" + Shaders.getShader(shaderName + ".fs"),
                            shader.customCompile = shaderName),
                            $text.text3d = _this,
                        window[shaderName] && (_this.shaderClass = _this.parent.initClass(window[shaderName], $text, shader, _group, _input),
                            ShaderUIL.add(shader, _group).setLabel("Shader"))
                    }
                    ,
                    _this.text = $text;
                let setText = $text.setText.bind($text);
                $text.setText = function(text, obj) {
                    if (obj)
                        for (let key in obj)
                            _fontObject[key] = obj[key];
                    _fontObject.text = text,
                        setText(text, _fontObject),
                        _this.events.fire(Events.UPDATE),
                        defer(setUniforms)
                }
                    ,
                    $text.loaded().then((_=>{
                            $text && (_this.shader = $text.mesh.shader,
                                _this.shader.addUniforms({
                                    uTransition: {
                                        value: 5,
                                        ignoreUIL: !0
                                    },
                                    uTranslate: {
                                        value: _this.translate,
                                        ignoreUIL: !0
                                    },
                                    uRotate: {
                                        value: _this.rotate,
                                        ignoreUIL: !0
                                    },
                                    uWordCount: {
                                        value: 0,
                                        ignoreUIL: !0
                                    },
                                    uLetterCount: {
                                        value: 0,
                                        ignoreUIL: !0
                                    },
                                    uLineCount: {
                                        value: 0,
                                        ignoreUIL: !0
                                    },
                                    uByWord: {
                                        value: 0,
                                        ignoreUIL: !0
                                    },
                                    uByLine: {
                                        value: 0,
                                        ignoreUIL: !0
                                    },
                                    uPadding: {
                                        value: .3,
                                        ignoreUIL: !0
                                    },
                                    uBoundingMin: {
                                        value: (new Vector3).copy($text.dimensions.min)
                                    },
                                    uBoundingMax: {
                                        value: (new Vector3).copy($text.dimensions.max)
                                    }
                                }),
                            Text3D.onCreateShader && Text3D.onCreateShader(_this.shader))
                        }
                    )),
                    setUniforms()
            }
            async function setUniforms() {
                if (await _this.wait(_this, "shader"),
                    await $text.loaded(),
                _input && _input.get) {
                    let depthWrite = _input.get("depthWrite")
                        , depthTest = _input.get("depthTest");
                    "boolean" == typeof depthWrite && ($text.mesh.shader.depthWrite = depthWrite),
                    "boolean" == typeof depthTest && ($text.mesh.shader.depthTest = depthTest);
                    let blending = _input.get("blending");
                    blending && ($text.mesh.shader.blending = blending)
                }
                _this.shader.set("uWordCount", $text.mesh.geometry.wordCount),
                    _this.shader.set("uLetterCount", $text.mesh.geometry.letterCount),
                    _this.shader.set("uLineCount", $text.mesh.geometry.lineCount),
                    _this.shader.set("uBoundingMin", (new Vector3).copy($text.dimensions.min)),
                    _this.shader.set("uBoundingMax", (new Vector3).copy($text.dimensions.max))
            }
            this.translate = new Vector3,
                this.rotate = new Vector3,
                _this.wildcard = _input.get("wildcard"),
                async function() {
                    _this.group.text = _this,
                        initUIL(),
                        initText(),
                    Text3D.onCreate && Text3D.onCreate(_this)
                }(),
                this.get("fontObject", (_=>_fontObject)),
                this.setProperties = function(obj=_fontObject) {
                    return $text ? ($text.setText(obj.text, obj),
                        setUniforms()) : createText(obj.text, obj),
                        _this.text.loaded()
                }
                ,
                this.setPropertiesCheck = function(obj, force) {
                    let applyProperties = !1;
                    for (const key in obj)
                        _fontObject[key] !== obj[key] && (applyProperties = !0,
                            _fontObject[key] = obj[key]);
                    return applyProperties || force ? _this.setProperties() : Promise.resolve()
                }
                ,
                this.setText = function(text) {
                    if (_fontObject.text = text,
                        $text) {
                        if (_fontObject.localize && Text3D.missingChars(text, _fontObject))
                            return _this.group.remove($text.group),
                                _this.shader = void 0,
                                $text = null,
                                void createText(text, _fontObject);
                        $text.setText(text),
                            setUniforms(),
                        $text.mesh && ($text.mesh.onBeforeRender(),
                            $text.mesh.updateMatrixWorld(!0))
                    } else
                        createText(text, _fontObject)
                }
                ,
                this.setColor = function(color) {
                    _fontObject.color = color,
                    _this.text && _this.text.setColor(color)
                }
                ,
                this.set("animateByWord", (async bool=>{
                        _this.localized || (await _this.wait(_this, "shader"),
                            _this.shader.set("uByWord", bool ? 1 : 0))
                    }
                )),
                this.set("animateByLine", (async bool=>{
                        _this.localized || (await _this.wait(_this, "shader"),
                            _this.shader.set("uByLine", bool ? 1 : 0))
                    }
                )),
                this.set("animationPadding", (async p=>{
                        _this.localized || (await _this.wait(_this, "shader"),
                            _this.shader.set("uPadding", p))
                    }
                )),
                this.set("transition", (async v=>{
                        if (_this.localized)
                            return _this.text.alpha = v;
                        await _this.wait(_this, "shader"),
                            _this.shader.set("uTransition", v > 0 ? 1.5 : -.5)
                    }
                )),
                this.tween = async function(val, time, ease, delay) {
                    return _this.localized ? _this.text.tween(val, time, ease, delay) : (await _this.wait(_this, "shader"),
                        _this.shader.tween("uTransition", val > 0 ? 1.5 : -.5, time, ease, delay))
                }
                ,
                this.upload = function() {
                    $text && $text.upload()
                }
                ,
                this.ready = function() {
                    return _this.wait(_this, "shader")
                }
                ,
                this.set("renderOrder", (v=>{
                        $text && $text.setZ(v)
                    }
                )),
                this.getDimensions = async _=>(await $text.loaded(),
                    await $text.text.ready(),
                    $text.dimensions)
        }
    ), (_=>{
            var _projection;
            Text3D.missingChars = function() {
                return !1
            }
                ,
                Text3D.measureScreen = async function($text, camera=World.CAMERA, z=0) {
                    _projection || (_projection = new ScreenProjection(World.CAMERA)),
                    $text instanceof Text3D && ($text = $text.text),
                        await $text.loaded(),
                        $text.mesh.onBeforeRender(),
                        $text.mesh.updateMatrixWorld(!0),
                        await defer(),
                        _projection.camera = camera;
                    let bb = new Box3;
                    bb.setFromObject($text.mesh),
                        bb.min.z = bb.max.z = z;
                    let min = _projection.project(bb.min).clone()
                        , max = _projection.project(bb.max).clone();
                    return {
                        width: Math.abs(min.x - max.x),
                        height: Math.abs(min.y - max.y)
                    }
                }
        }
    )),
    Class((function Track() {
            Inherit(this, Model);
            const DEBUG = Utils.query("debug");
            this.page = function(path, title) {
                let data = {};
                title && (data.page_title = title),
                path && (data.page_path = path),
                window.gtag && gtag("config", Config.ANALYTICS_ID, data),
                DEBUG && (window.gtag || console.log("no gtag"),
                Config.ANALYTICS_ID || console.log("Config.ANALYTICS_ID required"),
                    console.log(`>>> track page: '${JSON.stringify(data)}'`))
            }
                ,
                this.event = function(category, action, label, value, params) {
                    let data = {
                        event: "event",
                        event_category: null,
                        event_action: null,
                        event_label: null,
                        value: null
                    };
                    category && (data.event_category = category),
                    action && (data.event_action = action),
                    label && (data.event_label = label),
                    value && (data.value = value),
                    params && (data = Object.assign(params, data)),
                    window.gtag && gtag("event", action, data),
                    DEBUG && (window.gtag || console.log("no gtag"),
                        console.log(`>>> track event: '${action}', '${JSON.stringify(data)}'`))
                }
        }
    ), "Static"),
    Class((function UIL() {
            Inherit(this, Component);
            const _this = this;
            let _style, $el, _ui = {};
            Hydra.ready((async _=>{
                    if (!Utils.query("editMode") && (!Hydra.LOCAL || Device.mobile || window._BUILT_ || !location.search.includes("uil") && !Device.detect("hydra")))
                        return function doNotLoad() {
                            Hydra.LOCAL && Utils.query("remoteUIL") && (_this.sidebar = _this.global = new UILPanel("null"))
                        }();
                    !function init() {
                        (function initContainer() {
                                $el = $("UIL"),
                                    $el.css({
                                        position: "fixed",
                                        contain: "strict"
                                    }).size("100%", "100%").mouseEnabled(!1),
                                    document.body.insertAdjacentElement("beforeend", $el.div),
                                    $el.setZ(9999)
                            }
                        )(),
                            function initStyle() {
                                let initial = "\n            .UIL ::-webkit-scrollbar { width:2px; }\n            .UIL ::-webkit-scrollbar-track { background:#161616; }\n            .UIL ::-webkit-scrollbar-thumb { background:#37A1EF; }\n        "
                                    , style = document.head.appendChild(document.createElement("style"));
                                style.type = "text/css",
                                    style.id = "uil-style",
                                    style.appendChild(document.createTextNode(initial)),
                                    _style = style
                            }(),
                            function initSidebar() {
                                _this.add(new UILPanel("sidebar")),
                                    _this.add(new UILPanel("global",{
                                        side: "left"
                                    }))
                            }(),
                            function initGraph() {
                                if (!_this.sidebar)
                                    return;
                                let parent = _ui.sidebar.element.div;
                                parent.insertBefore(UILGraph.instance().element.div, parent.firstChild)
                            }()
                    }(),
                        _this.loaded = !0
                }
            )),
                this.ready = function() {
                    return _this.wait(_this, "loaded")
                }
                ,
                this.add = function(panel) {
                    return _ui[panel.id] = panel,
                        _this[panel.id] = panel,
                        $el.add(panel),
                        _this
                }
                ,
                this.remove = function(id) {
                    let $panel = _ui[id];
                    return $panel.eliminate && $panel.eliminate(),
                        $panel.destroy(),
                        delete _ui[id],
                        delete _this[id],
                        _this
                }
                ,
                this.find = function(id) {
                    return Object.values(_ui).reduce(((acc,el)=>acc.concat(el.find(id))), [])
                }
                ,
                this.enableSorting = function(id, enable) {
                    let el = _this.find(id)[0];
                    return el && el.enableSorting && el.enableSorting(enable),
                        _this
                }
                ,
                this.addCSS = function(control, style) {
                    if (control.styled)
                        return;
                    let node = document.createTextNode(style);
                    return _style && _style.appendChild(node),
                        control.styled = !0,
                        _this
                }
                ,
                this.REORDER = "uil_reorder"
        }
    ), "static"),
    Class((function CameraUIL() {
            this.UPDATE = "camera_uil_update",
                this.add = function(light, group) {
                    return new CameraUILConfig(light,null === group ? null : group || UIL.global)
                }
        }
    ), "static"),
    Class((function CameraUILConfig(_camera, _uil) {
            const _this = this;
            if (!_camera.prefix)
                throw "camera.prefix required when using MeshUIL";
            var prefix = "CAMERA_" + _camera.prefix
                , _group = _uil ? function createFolder() {
                if (!UIL.sidebar)
                    return null;
                let folder = new UILFolder(prefix,{
                    label: _camera.prefix,
                    closed: !0
                });
                return _uil.add(folder),
                    folder
            }() : null;
            function initVec(key) {
                let initValue = UILStorage.get(`${prefix}${key}`) || _camera[key].toArray();
                if (_group) {
                    let vector = new UILControlVector(`${prefix}${key}`,{
                        label: key,
                        value: initValue,
                        step: .05
                    });
                    vector.onChange((e=>{
                            _group && Events.emitter._fireEvent(CameraUIL.UPDATE, {
                                prefix: prefix,
                                key: key,
                                val: e,
                                vec: !0,
                                group: _this
                            }),
                                _camera[key].fromArray(e)
                        }
                    )),
                        vector.onFinishChange((e=>UILStorage.set(`${prefix}${key}`, e))),
                        _group.add(vector)
                }
                _camera[key].fromArray(initValue)
            }
            function initNumber(key) {
                let initValue = UILStorage.get(`${prefix}${key}`) || (void 0 === _camera[key] ? 9999 : _camera[key]);
                if (_group) {
                    let number = new UILControlNumber(`${prefix}${key}`,{
                        label: key,
                        value: initValue,
                        step: .05
                    });
                    number.onChange((e=>{
                            _camera[key] = e,
                            _group && Events.emitter._fireEvent(CameraUIL.UPDATE, {
                                prefix: prefix,
                                key: key,
                                val: e,
                                number: !0,
                                group: _this
                            })
                        }
                    )),
                        number.onFinishChange((e=>UILStorage.set(`${prefix}${key}`, e))),
                        _group.add(number)
                }
                _camera[key] = initValue
            }
            function update(e) {
                e.prefix == prefix && e.group != _this && (e.fov && _camera.setFOV(e.val),
                e.number && (_camera[e.key] = e.val),
                e.rotation && _camera.group[e.key].fromArray(e.val),
                e.vec && _camera[e.key].fromArray(e.val))
            }
            _camera.position && initVec("position"),
            _camera.group && (_camera.groupPos = _camera.group.position,
                initVec("groupPos"),
                function initRotation() {
                    let key = "rotation"
                        , toRadians = array=>array ? (array.length = 3,
                        array.map((x=>Math.radians(x)))) : [0, 0, 0]
                        , toDegrees = array=>array ? (array.length = 3,
                        array.map((x=>Math.degrees(x)))) : [0, 0, 0]
                        , initValue = toRadians(UILStorage.get(`${prefix}${key}`));
                    if (_group) {
                        let vector = new UILControlVector(`${prefix}${key}`,{
                            label: key,
                            value: toDegrees(initValue)
                        });
                        vector.onChange((e=>{
                                _group && Events.emitter._fireEvent(CameraUIL.UPDATE, {
                                    prefix: prefix,
                                    key: key,
                                    val: toRadians(e),
                                    rotation: !0,
                                    group: _this
                                }),
                                    _camera.group[key].fromArray(toRadians(e))
                            }
                        )),
                            vector.onFinishChange((e=>UILStorage.set(`${prefix}${key}`, e))),
                            _group.add(vector)
                    }
                    _camera.group[key].fromArray(initValue)
                }()),
                function initFOV(key) {
                    let initValue = UILStorage.get(`${prefix}${key}`) || _camera.camera.fov || 9999;
                    if (_group) {
                        let number = new UILControlNumber(`${prefix}${key}`,{
                            label: key,
                            value: initValue,
                            step: .05
                        });
                        number.onFinishChange((e=>{
                                _group && Events.emitter._fireEvent(CameraUIL.UPDATE, {
                                    prefix: prefix,
                                    key: key,
                                    val: e,
                                    fov: !0,
                                    group: _this
                                }),
                                    _camera.setFOV(e),
                                    UILStorage.set(`${prefix}${key}`, e)
                            }
                        )),
                            _group.add(number)
                    }
                    defer((_=>{
                            _camera.setFOV(initValue)
                        }
                    ))
                }("fov"),
            _camera.moveXY && (initVec("moveXY"),
                initVec("lookAt"),
                initNumber("lerpSpeed"),
                initNumber("lerpSpeed2"),
                initNumber("deltaRotate"),
                initNumber("deltaLerp"),
                initNumber("wobbleSpeed"),
                initNumber("wobbleStrength"),
                initNumber("wobbleZ")),
            _group && function addListeners() {
                Events.emitter._addEvent(CameraUIL.UPDATE, update, _this)
            }(),
                this.setLabel = function(name) {
                    _group && _group.setLabel(name)
                }
        }
    )),
    Class((function InputUIL() {
            this.UPDATE = "inputUil_Update",
                this.create = function(name, group, decoupled) {
                    return new InputUILConfig(name,null === group ? null : group || UIL.global,decoupled)
                }
        }
    ), "static"),
    Class((function InputUILConfig(_name, _uil, _decoupled, _slim) {
            var _this = this;
            const prefix = "INPUT_" + _name;
            var _group = _uil ? function createFolder() {
                if (!UIL.sidebar)
                    return null;
                let folder = new UILFolder(_name,{
                    closed: !0
                });
                _decoupled || (_uil.add(folder),
                _uil == UIL.sidebar && folder.hide());
                return folder
            }() : null
                , _fields = _uil ? {} : null;
            function externalUpdate(e) {
                e.prefix == prefix && e.group != _this && (UILStorage.set(`${prefix}_${e.key}`, e.value),
                _this.onUpdate && _this.onUpdate(e.key))
            }
            _this.group = _group,
            _uil && function addListeners() {
                Events.emitter._addEvent(InputUIL.UPDATE, externalUpdate, _this)
            }(),
                this.get = function(key) {
                    let val = UILStorage.get(`${prefix}_${key}`);
                    return "boolean" == typeof val ? val : val && "" != val ? "true" === val || "false" !== val && (val.charAt && "[" == val.charAt(0) ? JSON.parse(val) : val) : void 0
                }
                ,
                this.getNumber = function(key) {
                    return Number(this.get(key))
                }
                ,
            _slim || (this.add = function(key, initValue, uil=window.UILControlText, options, params={}) {
                    if (!_group || "hidden" == initValue || !UIL.sidebar)
                        return this;
                    let value = UILStorage.get(`${prefix}_${key}`);
                    "true" === value && (value = !0),
                    "false" === value && (value = !1),
                    uil == UILControlVector && "string" == typeof value && (value = JSON.parse(value)),
                    void 0 === value && (value = initValue),
                    "string" == typeof value && uil == UILControlImage && (value = JSON.parse(value));
                    let change = (val,fromInit)=>{
                            val = "string" == typeof val ? val : JSON.stringify(val),
                                UILStorage.set(`${prefix}_${key}`, val),
                            _this.onUpdate && _this.onUpdate(key, val),
                            fromInit || Events.emitter._fireEvent(InputUIL.UPDATE, {
                                prefix: prefix,
                                key: key,
                                value: val,
                                group: _this
                            })
                        }
                    ;
                    "string" != typeof initValue && "number" != typeof initValue && uil != UILControlVector || UILStorage.get(`${prefix}_${key}`) || change(initValue, !0);
                    let opts = Utils.mergeObject(params, {
                        label: key,
                        value: value,
                        options: options
                    });
                    uil == window.UILControlButton && (opts = options);
                    let config = new uil(`${prefix}_${key}`,opts);
                    return config.onFinishChange(change),
                    uil != UILControlVector && uil != UILControlRange || config.onChange(change),
                        _group.add(config),
                        _fields[key] = config,
                        this
                }
                    ,
                    this.addToggle = function(key, initValue) {
                        return UIL.sidebar ? this.add(key, initValue, UILControlCheckbox) : this
                    }
                    ,
                    this.addSelect = function(key, options) {
                        return UIL.sidebar ? this.add(key, null, UILControlSelect, options) : this
                    }
                    ,
                    this.addImage = function(key, options) {
                        return UIL.sidebar ? this.add(key, null, UILControlImage, null, options) : this
                    }
                    ,
                    this.addRange = function(key, initValue, options) {
                        return UIL.sidebar ? this.add(key, initValue, UILControlRange, null, options) : this
                    }
                    ,
                    this.addNumber = function(key, initValue, step) {
                        return UIL.sidebar ? this.add(key, initValue, UILControlNumber, null, {
                            step: step
                        }) : this
                    }
                    ,
                    this.addColor = function(key, initValue=new Color) {
                        return UIL.sidebar ? this.add(key, initValue.getHexString(), UILControlColor) : this
                    }
                    ,
                    this.addTextarea = function(key, initValue) {
                        return UIL.sidebar ? this.add(key, initValue, UILControlTextarea, null, {
                            monospace: !0,
                            rows: 4
                        }) : this
                    }
                    ,
                    this.addButton = function(key, options) {
                        return UIL.sidebar ? this.add(key, null, UILControlButton, options) : this
                    }
                    ,
                    this.addVector = function(key, initValue, options) {
                        return UIL.sidebar ? (options || (options = {
                            step: .05
                        }),
                            this.add(key, initValue, UILControlVector, null, options)) : this
                    }
                    ,
                    this.getImage = function(key) {
                        let data = this.get(key);
                        if (data)
                            return JSON.parse(data).src
                    }
                    ,
                    this.setValue = function(key, value) {
                        if (UILStorage.set(`${prefix}_${key}`, value),
                        _this.onUpdate && _this.onUpdate(key),
                            _fields) {
                            let field = _fields[key];
                            field && (field.value = value,
                            field.update && field.update())
                        }
                        return this
                    }
                    ,
                    this.copyFrom = function(input, fields) {
                        fields.forEach((key=>{
                                let val = input.get(key);
                                void 0 !== val && ("string" != typeof val && (val = JSON.stringify(val)),
                                    _this.setValue(key, val))
                            }
                        ))
                    }
                    ,
                    this.setLabel = function(name) {
                        _group && _group.setLabel(name)
                    }
                    ,
                    this.getField = function(key) {
                        if (_fields)
                            return _fields[key]
                    }
            )
        }
    )),
    Class((function ListUIL() {
            Inherit(this, Component);
            const _this = this;
            var _panel, _created = {};
            function removePanel() {
                _panel && _panel.destroy && (_this.events.unsub(_panel, Events.COMPLETE, removePanel),
                    _panel = _panel.destroy())
            }
            this.create = function(id, version=1, group) {
                "number" != typeof version && (group = version,
                    version = 1);
                let config = new ListUILConfig(id,version,UIL.global && !_created[id]);
                return UIL.global && (_created[id] || (_created[id] = config,
                    config.appendUILGroup(group || UIL.global))),
                    config
            }
                ,
                this.openPanel = function(id, name, template) {
                    return removePanel(),
                        _panel = new ListUILEditor(id,name,template),
                        _this.events.sub(_panel, Events.COMPLETE, removePanel),
                        _panel
                }
                ,
                this.set = function() {}
                ,
                this.get = function() {}
                ,
                this.getPanel = function() {
                    return _panel
                }
        }
    ), "static"),
    Class((function ListUILConfig(_id, _version=1, _store) {
            Inherit(this, Component);
            const _this = this;
            var _items, _folder, _config, _template = {
                onSort: _=>{}
                ,
                onAdd: _=>{}
                ,
                onRemove: _=>{}
            }, _name = "";
            function name() {
                return `LIST_${_id}_config`
            }
            function updateConfig() {
                _config.version = _version,
                    UILStorage.setWrite(name(), _config)
            }
            function edit() {
                let panel = ListUIL.openPanel(_id, _name, _this.template);
                _this.events.bubble(panel, Events.UPDATE),
                    _this.events.fire(ListUIL.OPEN)
            }
            _store && (_items = []),
                function initConfig() {
                    (_config = UILStorage.get(name())) ? _config.version != _version && (updateConfig(),
                        UILStorage.clearMatch(name().split("_config")[0])) : (_config = {},
                        updateConfig())
                }(),
                this.add = function(item) {
                    return _items && _items.push(item),
                        item
                }
                ,
                this.template = function(config) {
                    return "function" == typeof config && (_template = config),
                        _template
                }
                ,
                this.appendUILGroup = function(uil) {
                    let folder = new UILFolder("LIST_" + _id,{
                        closed: !0
                    })
                        , button = new UILControlButton("button",{
                        actions: [{
                            title: "Edit List",
                            callback: edit
                        }],
                        hideLabel: !0
                    });
                    folder.add(button),
                        uil.add(folder),
                        _folder = folder
                }
                ,
                this.setLabel = function(name) {
                    _folder && _folder.setLabel(name),
                        _name = name
                }
                ,
                this.onAdd = function(cb) {
                    _template.onAdd = cb
                }
                ,
                this.onRemove = function(cb) {
                    _template.onRemove = cb
                }
                ,
                this.onSort = function(cb) {
                    _template.onSort = cb
                }
                ,
                this.internalAddItems = function(count) {
                    if (!count)
                        return;
                    let array = [];
                    for (let i = 0; i < count; i++) {
                        let id = `${_id}_${Utils.timestamp()}`;
                        array.push(id)
                    }
                    UILStorage.set(`${_id}_list_items`, JSON.stringify(array))
                }
        }
    ), (_=>{
            ListUIL.OPEN = "list_uil_open"
        }
    )),
    Class((function ListUILEditor(_id, _name, _template) {
            Inherit(this, Component);
            const _this = this
                , PANEL_CONFIG = {
                label: _name || "List",
                width: "400px",
                height: "auto",
                drag: !0
            };
            var _gui, _list, _add, _items, _tabs = [], _index = 0;
            function initList() {
                !function read() {
                    let data = UILStorage.get(`${_id}_list_items`);
                    void 0 === data && (data = "[]");
                    _items = JSON.parse(data)
                }(),
                    (_list = new UILFolder(`${_id}_list`,{
                        hideTitle: !0
                    })).enableSorting(_id),
                    _gui.add(_list);
                for (let id of _items) {
                    let view = new ListUILItem(id,_list,_template,_index++);
                    _this.events.sub(view, Events.UPDATE, reorder),
                        _this.events.sub(view, Events.END, remove),
                        _tabs.push(view)
                }
            }
            function initAdd() {
                !function initButton(title, callback) {
                    _add = new UILControlButton("button",{
                        actions: [{
                            title: title,
                            callback: callback
                        }],
                        hideLabel: !0
                    }),
                        _gui.add(_add)
                }("Add Item", add)
            }
            function add() {
                let id = `${_id}_${Utils.timestamp()}`
                    , view = new ListUILItem(id,_list,_template,_index++);
                _this.events.sub(view, Events.UPDATE, reorder),
                    _this.events.sub(view, Events.END, remove),
                    _tabs.push(view),
                    _items.push(id),
                    write()
            }
            function reorder(e) {
                let order = [];
                for (let item of e.order)
                    order.push(item.split("_folder")[0]);
                _items = order,
                    _template().onSort(_items),
                    write(),
                    _this.events.fire(Events.UPDATE, {
                        order: order
                    })
            }
            function close() {
                _this.events.fire(Events.COMPLETE)
            }
            function remove(e) {
                _items.remove(e.id),
                    write(),
                    refresh()
            }
            function write() {
                let data = JSON.stringify(_items);
                UILStorage.set(`${_id}_list_items`, data)
            }
            function refresh() {
                _index = 0,
                _list && _list.destroy && (_list = _list.destroy()),
                _add && _add.destroy && (_add = _add.destroy()),
                    initList(),
                    initAdd()
            }
            !function initPanel() {
                _this.gui = _gui = new UILWindow(_id,PANEL_CONFIG),
                    _this.gui.onClose = close,
                    UIL.add(_gui)
            }(),
                refresh(),
                this.onDestroy = function() {
                    _gui.destroy()
                }
                ,
                this.add = function() {
                    add()
                }
        }
    )),
    Class((function ListUILItem(_id, _parent, _template, _index) {
            Inherit(this, Component);
            const _this = this;
            var _folder;
            function onDelete() {
                if (!confirm("You sure you want to delete this?"))
                    return;
                let id = _id;
                _template().onRemove(id),
                    _this.events.fire(Events.END, {
                        id: id
                    })
            }
            function onReorder(e) {
                _this.events.fire(Events.UPDATE, e)
            }
            !async function initFolder() {
                (_folder = InputUIL.create(`${_id}_folder`, _parent)).setLabel("Item"),
                    _folder.group.draggable(!0),
                    _this.events.sub(_folder.group, UIL.REORDER, onReorder),
                    _folder.listUILItem = _this
            }(),
                function initTemplate() {
                    let id = _id;
                    (0,
                        _template().onAdd)(id, _folder, _index)
                }(),
                function initUI() {
                    let actions = [{
                        title: "Delete",
                        callback: onDelete
                    }]
                        , hideLabel = !0;
                    _folder.addButton("delete", {
                        actions: actions,
                        hideLabel: hideLabel
                    })
                }(),
                this.setLabel = function(label) {
                    _folder.setLabel(label)
                }
                ,
                this.forceSort = function(index) {
                    _folder.group.forceSort(index)
                }
                ,
                this.open = function() {
                    _folder.group.open(),
                        _folder.group.openChildren()
                }
                ,
                this.close = function() {
                    _folder.group.close()
                }
        }
    )),
    Class((function MeshUIL() {
            Inherit(this, Component);
            this.exists = {},
                this.UPDATE = "mesh_uil_update",
                this.add = function(mesh, group) {
                    return new MeshUILConfig(mesh,null === group ? null : group || UIL.global)
                }
        }
    ), "static"),
    Class((function MeshUILConfig(_mesh, _uil) {
            const _this = this;
            if (!_mesh.prefix)
                throw "mesh.prefix required when using MeshUIL";
            var prefix = "MESH_" + _mesh.prefix
                , _group = _uil && !MeshUIL.exists[prefix] ? function createFolder() {
                if (!UIL.sidebar)
                    return null;
                let folder = new UILFolder(prefix,{
                    label: _mesh.prefix,
                    closed: !0
                });
                return _uil.add(folder),
                    folder
            }() : null
                , _controls = _group ? {} : null;
            function initVec(key) {
                let initValue = UILStorage.get(`${prefix}${key}`) || _mesh[key].toArray();
                if (_group) {
                    let vector = new UILControlVector(`${prefix}${key}`,{
                        label: key,
                        value: initValue,
                        step: .05
                    });
                    vector.onChange((e=>{
                            _mesh[key].fromArray(e),
                            _group && Events.emitter._fireEvent(MeshUIL.UPDATE, {
                                prefix: prefix,
                                key: key,
                                val: e,
                                group: _this
                            })
                        }
                    )),
                        vector.onFinishChange(save),
                        _group.add(vector),
                        _controls[key] = vector
                }
                _mesh[key].fromArray(initValue)
            }
            function save() {
                for (let key in _controls) {
                    let value = _controls[key].value;
                    UILStorage.set(`${prefix}${key}`, value)
                }
            }
            function update(e) {
                e.prefix == prefix && e.group != _this && _mesh[e.key].fromArray(e.val)
            }
            this.group = _group,
                MeshUIL.exists[prefix] = !0,
                initVec("position"),
                initVec("scale"),
                function initRotation() {
                    let key = "rotation"
                        , toRadians = array=>array ? (array.length = 3,
                        array.map((x=>Math.radians(x)))) : [0, 0, 0]
                        , toDegrees = array=>array ? (array.length = 3,
                        array.map((x=>Math.degrees(x)))) : [0, 0, 0]
                        , initValue = toRadians(UILStorage.get(`${prefix}${key}`));
                    if (_group) {
                        let vector = new UILControlVector(`${prefix}${key}`,{
                            label: key,
                            value: toDegrees(initValue)
                        });
                        vector.onChange((e=>{
                                _mesh[key].fromArray(toRadians(e)),
                                _group && Events.emitter._fireEvent(MeshUIL.UPDATE, {
                                    prefix: prefix,
                                    key: key,
                                    val: toRadians(e),
                                    group: _this
                                })
                            }
                        )),
                            vector.onFinishChange(save),
                            _group.add(vector),
                            _controls[key] = vector
                    }
                    _mesh[key].fromArray(initValue)
                }(),
            _group && function addListeners() {
                Events.emitter._addEvent(MeshUIL.UPDATE, update, _this)
            }(),
                this.setLabel = function(name) {
                    _group && _group.setLabel(name)
                }
        }
    )),
    Class((function ShaderUIL() {
            this.exists = {},
                this.UPDATE = "shader_update",
                this.TEXTURE_UPDATE = "shader_texture_update",
                this.add = function(shader, group) {
                    return new ShaderUILConfig(shader.shader || shader,null === group ? null : group || UIL.global)
                }
        }
    ), "static"),
    Class((function ShaderUILConfig(_shader, _uil) {
            var _textures, _this = this;
            const prefix = _shader.UILPrefix;
            var _group = _uil && !ShaderUIL.exists[prefix] ? function createFolder() {
                if (!UIL.sidebar)
                    return null;
                let label = function getName() {
                    let split = _shader.UILPrefix.split("/");
                    return split.length > 2 ? split[0] + "_" + split[2] : split[0]
                }();
                "_" == label.charAt(label.length - 1) && (label = label.slice(0, -1));
                let folder = new UILFolder(prefix + label,{
                    label: label,
                    closed: !0
                });
                return _uil.add(folder),
                    folder
            }() : null;
            function createVector(obj, key) {
                let initValue = UILStorage.get(`${prefix}${key}`) || obj.value.toArray();
                if (_group) {
                    let vector = new UILControlVector(`${prefix}${key}`,{
                        label: key,
                        value: initValue,
                        step: .05
                    });
                    vector.onChange((val=>{
                            obj.value.fromArray(val),
                            _shader.ubo && (_shader.ubo.needsUpdate = !0),
                                Events.emitter._fireEvent(ShaderUIL.UPDATE, {
                                    prefix: prefix,
                                    key: key,
                                    val: val,
                                    group: _this,
                                    vector: !0
                                })
                        }
                    )),
                        vector.onFinishChange((e=>UILStorage.set(`${prefix}${key}`, e))),
                        _group.add(vector)
                }
                obj.value.fromArray(initValue)
            }
            function createTexture(obj, key) {
                _group && !_textures && (_textures = {});
                const getTexture = obj.getTexture || ShaderUIL.getTexture || Utils3D.getTexture
                    , set = _shader.parent && _shader.parent.setOverride ? _shader.parent.setOverride : _shader.set || _shader.setUniform
                    , get = _shader.get || _shader.getUniform;
                let prefix = _shader.UILPrefix + "_tx"
                    , data = UILStorage.get(`${prefix}_${key}`);
                data && (data = JSON.parse(data));
                let value = data ? data.src : null
                    , change = data=>{
                        let val = data.src
                            , cleanPath = val.includes("?") ? val.split("?")[0] : val;
                        data.compressed && (val += "-compressedKtx"),
                        _textures && (_textures[cleanPath] = change),
                            data.src = cleanPath,
                            UILStorage.set(`${prefix}_${key}`, JSON.stringify(data)),
                            set(key, getTexture(val, {
                                premultiplyAlpha: obj.premultiplyAlpha,
                                scale: obj.scale
                            }), _shader),
                        _group && Events.emitter._fireEvent(ShaderUIL.UPDATE, {
                            prefix: _shader.UILPrefix,
                            key: key,
                            val: val,
                            texture: get(key, _shader),
                            group: _this
                        })
                    }
                ;
                if (value && value.length && change(data),
                    _group) {
                    let img = new UILControlImage(prefix + key,{
                        label: key,
                        value: data
                    });
                    img.onFinishChange(change),
                        _group.add(img)
                }
            }
            function createNumber(obj, key) {
                let initValue = UILStorage.get(`${prefix}${key}`);
                if (void 0 === initValue && (initValue = obj.value),
                    _group) {
                    let number = new UILControlNumber(`${prefix}${key}`,{
                        label: key,
                        value: initValue,
                        step: .05
                    });
                    number.onChange((val=>{
                            _shader.ubo && (_shader.ubo.needsUpdate = !0),
                                Events.emitter._fireEvent(ShaderUIL.UPDATE, {
                                    prefix: prefix,
                                    key: key,
                                    val: val,
                                    group: _this
                                }),
                                obj.value = val
                        }
                    )),
                        number.onFinishChange((e=>UILStorage.set(`${prefix}${key}`, e))),
                        _group.add(number)
                }
                obj.value = initValue
            }
            function createColor(obj, key) {
                let initValue = UILStorage.get(`${prefix}${key}`);
                if (_group) {
                    let color = new UILControlColor(`${prefix}${key}`,{
                        label: key,
                        value: initValue
                    });
                    color.onChange((val=>{
                            obj.value.set(val),
                            _shader.ubo && (_shader.ubo.needsUpdate = !0),
                            _group && Events.emitter._fireEvent(ShaderUIL.UPDATE, {
                                prefix: prefix,
                                key: key,
                                val: val,
                                color: !0,
                                group: _this
                            })
                        }
                    )),
                        color.onFinishChange((e=>UILStorage.set(`${prefix}${key}`, e))),
                        _group.add(color)
                }
                initValue && obj.value.set(initValue)
            }
            function textureUpdate(e) {
                if (!_textures)
                    return;
                let cleanPath = e.file.split("?")[0];
                for (let key in _textures)
                    cleanPath == key && _textures[key]({
                        src: e.file
                    })
            }
            function update(e) {
                if (e.prefix == _shader.UILPrefix && e.group != _this)
                    if (e.color) {
                        let val = e.val
                            , obj = _shader.uniforms[e.key];
                        Array.isArray(val) ? obj.value.setRGB(val[0], val[1], val[2]) : obj.value.set(val)
                    } else
                        e.texture ? "remote" != e.texture && _shader.set(e.key, e.texture) : e.vector ? _shader.uniforms[e.key].value.fromArray(e.val) : _shader.uniforms[e.key].value = e.val
            }
            this.group = _group,
                ShaderUIL.exists[_shader.UILPrefix] = !0,
                function initItems() {
                    for (var key in _shader.uniforms) {
                        let obj = _shader.uniforms[key];
                        obj && !obj.ignoreUIL && (obj.value instanceof Color && createColor(obj, key),
                        "number" == typeof obj.value && createNumber(obj, key),
                        (null === obj.value || obj.value instanceof Texture) && createTexture(obj, key),
                        obj.value instanceof Vector2 && createVector(obj, key),
                        obj.value instanceof Vector3 && createVector(obj, key),
                        obj.value instanceof Vector4 && createVector(obj, key))
                    }
                }(),
            _group && function addListeners() {
                Events.emitter._addEvent(ShaderUIL.UPDATE, update, _this),
                    Events.emitter._addEvent(ShaderUIL.TEXTURE_UPDATE, textureUpdate, _this)
            }(),
                this.setLabel = function(name) {
                    _group && _group.setLabel(name)
                }
        }
    )),
    Class((function ShadowUIL() {
            this.add = function(light, group) {
                return new ShadowUILConfig(light,null === group ? null : group || UIL.global)
            }
        }
    ), "static"),
    Class((function ShadowUILConfig(_light, _uil) {
            if (!_light.prefix)
                throw "light.prefix required when using MeshUIL";
            var prefix = "SHADOW_" + _light.prefix
                , _group = _uil ? function createFolder() {
                if (!UIL.sidebar)
                    return null;
                let folder = new UILFolder(prefix,{
                    label: _light.prefix,
                    closed: !0
                });
                return _uil.add(folder),
                    folder
            }() : null;
            function initNumber(key) {
                let initValue = UILStorage.get(`${prefix}${key}`) || _light.shadow[key];
                if (_group) {
                    let number = new UILControlNumber(`${prefix}${key}`,{
                        label: key,
                        value: initValue,
                        step: .05
                    });
                    number.onFinishChange((e=>{
                            _light.shadow[key] = e,
                                UILStorage.set(`${prefix}${key}`, e)
                        }
                    )),
                        _group.add(number)
                }
                _light.shadow[key] = initValue
            }
            function initVec(key) {
                let initValue = UILStorage.get(`${prefix}${key}`) || _light[key].toArray();
                if (_group) {
                    let vector = new UILControlVector(`${prefix}${key}`,{
                        label: key,
                        value: initValue,
                        step: .05
                    });
                    vector.onChange((e=>{
                            _light[key].fromArray(e),
                            "target" == key && _light.shadow.camera.lookAt(_light.target)
                        }
                    )),
                        vector.onFinishChange((e=>UILStorage.set(`${prefix}${key}`, e))),
                        _group.add(vector)
                }
                _light[key].fromArray(initValue)
            }
            _light.target = _light.shadow.target,
                initVec("position"),
                initVec("target"),
                initNumber("fov"),
                initNumber("size"),
                initNumber("area"),
                initNumber("near"),
                initNumber("far"),
                function initTick(key) {
                    let initValue = UILStorage.get(`${prefix}${key}`);
                    if (_group) {
                        let tick = new UILControlCheckbox(`${prefix}${key}`,{
                            label: key,
                            value: initValue
                        });
                        tick.onFinishChange((e=>{
                                _light[key] = e,
                                    UILStorage.set(`${prefix}${key}`, e)
                            }
                        )),
                            _group.add(tick)
                    }
                    _light[key] = initValue
                }("static"),
                this.setLabel = function(name) {
                    _group && _group.setLabel(name)
                }
        }
    )),
    Class((function TimelineUIL() {
            Inherit(this, Component);
            const _this = this;
            var _panel, _created = {};
            function removePanel() {
                _panel && _panel.destroy && (_this.events.unsub(_panel, Events.COMPLETE, removePanel),
                    _panel = _panel.destroy())
            }
            this.create = function(id, version=1, group) {
                "number" != typeof version && (group = version,
                    version = 1),
                    group = null === group ? null : group || UIL.global;
                let config = new TimelineUILConfig(id,version,UIL.global && !_created[id]);
                return UIL.global && (_created[id] || (_created[id] = config,
                null != group && config.appendUILGroup(group || UIL.global))),
                    config
            }
                ,
                this.openPanel = function(id, name, template) {
                    return removePanel(),
                        _panel = new TimelineUILEditor(id,name,template),
                        _this.events.sub(_panel, Events.COMPLETE, removePanel),
                        _panel
                }
                ,
                this.set = function() {}
                ,
                this.get = function() {}
        }
    ), "static"),
    Class((function TimelineUILConfig(_id, _version=1, _store) {
            Inherit(this, Component);
            const _this = this;
            var _items, _folder, _config, _template = {
                onSort: _=>{}
                ,
                onAdd: _=>{}
                ,
                onRemove: _=>{}
            }, _name = "";
            function name() {
                return `TL_${_id}_config`
            }
            function updateConfig() {
                _config.version = _version,
                    UILStorage.setWrite(name(), _config)
            }
            function edit() {
                let panel = TimelineUIL.openPanel(name(), _name, _this.template);
                _this.events.bubble(panel, Events.UPDATE),
                    _this.events.fire(TimelineUIL.OPEN)
            }
            this.model = new TimelineUILModel(name()),
            _store && (_items = []),
                function initConfig() {
                    (_config = UILStorage.get(name())) ? _config.version != _version && (updateConfig(),
                        UILStorage.clearMatch(name().split("_config")[0])) : (_config = {},
                        updateConfig())
                }(),
                this.add = function(item) {
                    return _items && _items.push(item),
                        item
                }
                ,
                this.template = function(config) {
                    return "function" == typeof config && (_template = config),
                        _template
                }
                ,
                this.appendUILGroup = function(uil) {
                    let folder = new UILFolder("TL_" + _id,{
                        closed: !0
                    })
                        , button = new UILControlButton("button",{
                        actions: [{
                            title: "Edit Timeline",
                            callback: edit
                        }],
                        hideLabel: !0
                    });
                    folder.add(button),
                        uil.add(folder),
                        _folder = folder
                }
                ,
                this.setLabel = function(name) {
                    _folder && _folder.setLabel(name),
                        _name = name
                }
                ,
                this.onAdd = function(cb) {
                    _template.onAdd = cb
                }
                ,
                this.onRemove = function(cb) {
                    _template.onRemove = cb
                }
                ,
                this.onSort = function(cb) {
                    _template.onSort = cb
                }
                ,
                this.internalAddItems = function(count) {
                    if (!count)
                        return;
                    let array = [];
                    for (let i = 0; i < count; i++) {
                        let id = `${_id}_${Utils.timestamp()}`;
                        array.push(id)
                    }
                    UILStorage.set(`${_id}_list_items`, JSON.stringify(array))
                }
        }
    ), (_=>{
            TimelineUIL.OPEN = "list_uil_open"
        }
    )),
    Class((function TimelineUILEditor(_id, _name, _template) {
            Inherit(this, Component);
            const _this = this
                , PANEL_CONFIG = {
                label: "Timeline Editor",
                width: "800px",
                height: "auto",
                drag: !0
            };
            var _gui, _list, _add, _config, _items, _tabs = [], _index = 0;
            function initList() {
                !function read() {
                    let data = UILStorage.get(`${_id}_list_items`);
                    void 0 === data && (data = "[]");
                    _items = JSON.parse(data)
                }(),
                    _list = new UILFolder(`${_id}_list`,{
                        hideTitle: !0
                    }),
                    _gui.add(_list);
                for (let id of _items) {
                    let view = _this.initClass(TimelineUILItem, id, _list, _template, _index++);
                    _this.events.sub(view, Events.UPDATE, reorder),
                        _this.events.sub(view, Events.END, remove),
                        _tabs.push(view)
                }
                _config.rails && function attachRails() {
                    _tabs.forEach(((t,i)=>{
                            t.onUpdate = v=>{
                                _tabs.forEach(((t2,j)=>{
                                        t2 != t && (j < i && t.getValue() < t2.getValue() && t2.setValue(t.getValue()),
                                        j > i && t.getValue() > t2.getValue() && t2.setValue(t.getValue()))
                                    }
                                ))
                            }
                        }
                    ))
                }()
            }
            function initButton(title, callback) {
                let btn = new UILControlButton("button",{
                    actions: [{
                        title: title,
                        callback: callback
                    }],
                    hideLabel: !0
                });
                return _gui.add(btn),
                    btn
            }
            function spaceEvenly() {
                _tabs.forEach(((t,i)=>{
                        let perc = Math.range(i, 0, _tabs.length - 1, 0, 1);
                        t.setValue(perc)
                    }
                ))
            }
            function add() {
                let id = `${_id}_${Utils.timestamp()}`
                    , view = new TimelineUILItem(id,_list,_template,_index++);
                _this.events.sub(view, Events.UPDATE, reorder),
                    _this.events.sub(view, Events.END, remove),
                    _tabs.push(view),
                    _items.push(id),
                    write()
            }
            function reorder(e) {
                let order = [];
                for (let item of e.order)
                    order.push(item.split("_folder")[0]);
                _items = order,
                    _template().onSort(_items),
                    write(),
                    _this.events.fire(Events.UPDATE, {
                        order: order
                    })
            }
            function remove(e) {
                _items.remove(e.id),
                    write(),
                    refresh()
            }
            function write() {
                let data = JSON.stringify(_items);
                UILStorage.set(`${_id}_list_items`, data)
            }
            function refresh() {
                _index = 0,
                _list && _list.destroy && (_list = _list.destroy()),
                _add && _add.destroy && (_add = _add.destroy()),
                    initList(),
                    function initAdd() {
                        _config.lock || (_add = initButton("Add Item", add)).element.css({
                            width: "20%"
                        }),
                            initButton("Space Evenly", spaceEvenly).element.css({
                                width: "20%"
                            })
                    }()
            }
            _this.config = _config = JSON.parse(UILStorage.get(`${_id}_config`) || "{}"),
                function initPanel() {
                    _this.gui = _gui = new UILWindow(_id,PANEL_CONFIG),
                        UIL.add(_gui)
                }(),
                refresh(),
                this.onDestroy = function() {
                    _gui.destroy()
                }
        }
    )),
    Class((function TimelineUILItem(_id, _parent, _template, _index) {
            Inherit(this, Component);
            const _this = this;
            var _folder;
            function onDelete() {
                if (!confirm("You sure you want to delete this?"))
                    return;
                let id = _id;
                _template().onRemove(id),
                    _this.events.fire(Events.END, {
                        id: id
                    })
            }
            function onReorder(e) {
                _this.events.fire(Events.UPDATE, e)
            }
            !async function initFolder() {
                (_folder = InputUIL.create(`${_id}_folder`, _parent)).setLabel("Item"),
                _this.parent && _this.parent.config.lock || _folder.group.draggable(!0),
                    _this.events.sub(_folder.group, UIL.REORDER, onReorder),
                    _folder.group.open()
            }(),
                function initTemplate() {
                    let id = _id;
                    (0,
                        _template().onAdd)(id, _folder, _index)
                }(),
                function initUI() {
                    _folder.add("label", _this.parent && _this.parent.config.lock ? "hidden" : void 0),
                        _folder.addRange("keyframe"),
                        _folder.add("percent", "hidden"),
                        _folder.getField("keyframe").force(Math.round(100 * _folder.getNumber("percent")) || 0),
                        _folder.onUpdate = key=>{
                            if ("keyframe" == key) {
                                let val = _folder.getNumber(key) / 100;
                                _folder.setValue("percent", val),
                                _this.onUpdate && _this.onUpdate(val)
                            }
                        }
                    ;
                    let label = _folder.get("label");
                    if (label && _folder.setLabel(label),
                    !_this.parent || !_this.parent.config.lock) {
                        let actions = [{
                            title: "Delete",
                            callback: onDelete
                        }]
                            , hideLabel = !0
                            , btn = (_folder.addButton("delete", {
                            actions: actions,
                            hideLabel: hideLabel
                        }),
                            _folder.getField("delete"));
                        btn && btn.$content.css({
                            width: "20%"
                        })
                    }
                }(),
                this.setLabel = function(label) {
                    _folder.setLabel(label)
                }
                ,
                this.getValue = function(value) {
                    return _folder.getNumber("percent")
                }
                ,
                this.setValue = function(value) {
                    _folder.setValue("percent", value),
                        _folder.getField("keyframe").force(Math.round(100 * value) || 0)
                }
        }
    )),
    Class((function TimelineUILModel(_id) {
            var _items, _config, _data = [], _map = {};
            !function initItems() {
                _config = JSON.parse(UILStorage.get(`${_id}_config`) || "{}"),
                    _items = JSON.parse(UILStorage.get(`${_id}_list_items`) || "[]")
            }(),
                function initData() {
                    _items.forEach(((item,i)=>{
                            let input = InputUIL.create(`${item}_folder`, null, null, !!UIL.global)
                                , data = {};
                            data.label = input.get("label") || "Item",
                                data.value = input.getNumber("percent") || 0,
                                data.arbitrary = input.get("arbitrary"),
                                _data.push(data),
                                _map[data.label] = data,
                            UIL.global && Render.start((_=>{
                                    data.label = input.get("label") || "Item",
                                        data.value = input.getNumber("percent") || 0
                                }
                            ), 10)
                        }
                    ))
                }(),
                this.setState = function(array) {
                    for (let i = 0; i < array.length; i++)
                        _items[i] || _items.push(`${_id}_${Utils.timestamp()}`);
                    _items.length > array.length && (_items = _items.slice(0, array.length)),
                        _items.forEach(((item,i)=>{
                                let data = array[i]
                                    , input = InputUIL.create(`${item}_folder`, null);
                                input.setValue("label", data.label),
                                data.percent && input.setValue("percent", data.percent),
                                data.arbitrary && input.setValue("percent", data.arbitrary)
                            }
                        )),
                        UILStorage.set(`${_id}_list_items`, JSON.stringify(_items))
                }
                ,
                this.lock = function() {
                    return _config.lock || (_config.lock = !0,
                    UIL.global && UILStorage.set(`${_id}_config`, JSON.stringify(_config))),
                        this
                }
                ,
                this.rails = function() {
                    return _config.rails || (_config.rails = !0,
                    UIL.global && UILStorage.set(`${_id}_config`, JSON.stringify(_config))),
                        this
                }
                ,
                this.getData = function() {
                    return _data
                }
                ,
                this.get = function(key) {
                    return _map[key]
                }
        }
    )),
    Class((function TweenUIL() {
            Inherit(this, Component);
            const _this = this;
            var _editor, _data = {}, _created = {};
            function removeEditor() {
                _editor = _editor.destroy()
            }
            this.create = function(name, version=1, group) {
                "number" != typeof version && (group = version,
                    version = 1);
                let config = new TweenUILConfig(name,version,UIL.global && !_created[name]);
                return UIL.global && (_created[name] || (_created[name] = config,
                    config.appendUILGroup(group || UIL.global))),
                    config
            }
                ,
                this.openEditor = function(name, tweens) {
                    _editor && _editor.destroy(),
                        _editor = new TweenUILEditor(name,tweens),
                        _this.events.sub(_editor, Events.COMPLETE, removeEditor)
                }
                ,
                this.set = function(key, value) {
                    _data[key] = value
                }
                ,
                this.get = function(key) {
                    return _data[key]
                }
        }
    ), "static"),
    Class((function TweenUILConfig(_name, _version=1, _store) {
            var _tweens, _folder, _config = UILStorage.get("TWEEN_" + _name + "_config");
            function updateConfig() {
                _config.version = _version,
                    UILStorage.setWrite("TWEEN_" + _name + "_config", _config)
            }
            function override(tween, object, props, time, ease, delay) {
                let key = "TWEEN_" + _name + "_" + tween._id
                    , storage = UILStorage.get(key)
                    , obj = {
                    props: props,
                    time: time,
                    ease: ease,
                    delay: delay
                };
                for (let key in storage)
                    obj[key] = storage[key];
                return TweenUIL.set(key, obj),
                    obj
            }
            function edit() {
                TweenUIL.openEditor(_name, _tweens)
            }
            _store && (_tweens = []),
                _config ? _config.version != _version && (updateConfig(),
                    UILStorage.clearMatch("TWEEN_" + _name)) : (_config = {},
                    updateConfig()),
                this.add = function(tween, name) {
                    return tween._id = name,
                        tween.overrideValues = override,
                    _tweens && _tweens.push(tween),
                        tween
                }
                ,
                this.appendUILGroup = function(uil) {
                    let folder = new UILFolder("TWEEN_" + _name,{
                        closed: !0
                    })
                        , button = new UILControlButton("button",{
                        actions: [{
                            title: "Edit",
                            callback: edit
                        }],
                        hideLabel: !0
                    });
                    folder.add(button),
                        uil.add(folder),
                        _folder = folder
                }
                ,
                this.setLabel = function(name) {
                    _folder && _folder.setLabel(name)
                }
        }
    )),
    Class((function TweenUILEditor(_name, _tweens) {
            Inherit(this, Component);
            const _this = this;
            var _gui = new UILWindow(_name,{
                label: "Tween Editor",
                width: "400px",
                height: "auto",
                drag: !0
            });
            function createGroup(tween) {
                let obj = TweenUIL.get("TWEEN_" + _name + "_" + tween._id)
                    , group = new UILFolder(tween._id);
                _gui.add(group);
                let lookup = "TWEEN_" + _name + "_" + tween._id;
                for (let key in obj)
                    if ("props" == key)
                        switch (tween._id) {
                            case "position":
                            case "scale":
                                createVector(obj, key, group, lookup);
                                break;
                            case "rotation":
                                createRotation(obj, key, group, lookup);
                                break;
                            default:
                                createNumber(obj, key, group, lookup)
                        }
                    else
                        createString(obj, key, group, lookup)
            }
            function createString(obj, key, group, lookup) {
                let value = obj[key]
                    , text = new UILControlText(lookup + key,{
                    label: key,
                    value: value.toString(),
                    monospace: !0
                });
                text.onFinishChange((val=>{
                        "time" != key && "delay" != key || (val = Number(val)),
                            write(lookup, key, val)
                    }
                )),
                    group.add(text)
            }
            function createNumber(obj, key, group, lookup) {
                let {props: props} = obj
                    , keys = Object.keys(props);
                if (keys.length > 1)
                    throw "TweenUIL can't deal with a basic Object with more than one key. Define position/rotation/scale or create a tween for each property.";
                let number = new UILControlNumber(`${lookup}${key}`,{
                    label: key,
                    value: props[keys[0]]
                });
                number.onFinishChange((val=>{
                        let output = {};
                        output[keys[0]] = val,
                            write(lookup, key, output)
                    }
                )),
                    group.add(number)
            }
            function createVector(obj, key, group, lookup) {
                let {props: props} = obj
                    , vector = new UILControlVector(`${lookup}${key}`,{
                    label: key,
                    value: [props.x, props.y, props.z],
                    step: .05
                });
                vector.onFinishChange((val=>{
                        write(lookup, key, {
                            x: val[0],
                            y: val[1],
                            z: val[2]
                        })
                    }
                )),
                    group.add(vector)
            }
            function createRotation(obj, key, group, lookup) {
                let {props: props} = obj
                    , v = (array = [props.x, props.y, props.z]) ? (array.length = 3,
                    array.map((x=>Math.degrees(x)))) : [0, 0, 0];
                var array;
                let vector = new UILControlVector(`${lookup}${key}`,{
                    label: key,
                    value: v
                });
                vector.onFinishChange((val=>{
                        let output = (array=>array ? (array.length = 3,
                            array.map((x=>Math.radians(x)))) : [0, 0, 0])(val);
                        write(lookup, key, {
                            x: output[0],
                            y: output[1],
                            z: output[2]
                        })
                    }
                )),
                    group.add(vector)
            }
            function write(lookup, key, value) {
                let obj = UILStorage.get(lookup) || {};
                obj[key] = value,
                    UILStorage.set(lookup, obj)
            }
            function exit() {
                _this.events.fire(Events.COMPLETE)
            }
            this.gui = _gui,
                function() {
                    UIL.add(_gui);
                    for (let tween of _tweens)
                        createGroup(tween);
                    let button = new UILControlButton("button",{
                        actions: [{
                            title: "Exit",
                            callback: exit
                        }],
                        hideLabel: !0
                    });
                    _gui.add(button)
                }(),
                this.onDestroy = function() {
                    _gui.destroy()
                }
        }
    )),
    Class((function UILFile(_offline) {
            Inherit(this, Component);
            function decode(s) {
                return atob(s)
            }
            this.load = async function() {
                let path = window.UIL_STATIC_PATH || "assets/data/uil.json";
                try {
                    let data = await get(path);
                    if (data._e) {
                        let decodedData = {};
                        for (let key in data)
                            if ("_e" !== key) {
                                let val = data[key];
                                decodedData[decode(key)] = "string" == typeof val ? decode(data[key]) : data[key]
                            }
                        return decodedData
                    }
                    return data
                } catch (e) {
                    return {}
                }
            }
                ,
                this.save = async function(sessionData, data) {
                    if (Dev.writeFile(window.UIL_STATIC_PATH || "assets/data/uil.json", data),
                        _offline) {
                        let partial = {};
                        try {
                            partial = await get("assets/data/uil-partial.json", data);
                            for (let key in sessionData)
                                partial[key] = sessionData[key]
                        } catch (e) {
                            partial = sessionData
                        }
                        Dev.writeFile("assets/data/uil-partial.json", partial),
                            Storage.set("uil_update_partial", !0)
                    }
                }
        }
    )),
    Class((function UILStorage() {
            Inherit(this, Component);
            const _this = this;
            var _fs, _data = {}, _dataSession = {};
            this.SAVE = "uil_save";
            const OFFLINE_FIREBASE = Utils.query("offlineFB");
            function clearOfflineData() {
                Storage.set("uil_update_partial", !1),
                    Dev.writeFile("assets/data/uil-partial.json", {})
            }
            async function init() {
                if (_fs && _fs.destroy(),
                    _fs = _this.initClass(uilFile() ? UILFile : UILRemote, OFFLINE_FIREBASE),
                    _data = await _fs.load(),
                    _this.loaded = !0,
                !OFFLINE_FIREBASE && Storage.get("uil_update_partial") && !uilFile()) {
                    if (!confirm("Looks like you have UIL data captured offline, do you want to sync it to Firebase?"))
                        return clearOfflineData();
                    let data = await get("assets/data/uil-partial.json");
                    for (let key in data)
                        _this.set(key, data[key]);
                    write(!0, !0),
                        clearOfflineData()
                }
            }
            async function write(direct, silent) {
                let prevent = !1
                    , e = {
                    prevent: _=>prevent = !0
                };
                _this.events.fire(_this.SAVE, e),
                !direct && (e.wait && await e.wait(),
                    prevent) || (_fs.save(_dataSession, _data),
                    _dataSession = {},
                silent || (__body.css({
                    display: "none"
                }),
                    _this.delayedCall((()=>{
                            __body.css({
                                display: "block"
                            })
                        }
                    ), 100)))
            }
            function uilFile() {
                return !Utils.query("editMode") && (!Hydra.LOCAL || (!!Device.mobile || (!!OFFLINE_FIREBASE || (!!window._BUILT_ || (!!window.AURA || (!!window._UIL_FILE_ || (!window._FIREBASE_UIL_ && !window.UIL_ID || !Device.detect("hydra") && !location.search.includes("uil"))))))))
            }
            Hydra.ready((async _=>{
                    window.Platform && window.Platform.isPlatform || init(),
                    (Utils.query("editMode") || Hydra.LOCAL && !Device.mobile && !window._BUILT_ && (location.search.includes("uil") || Device.detect("hydra"))) && __window.bind("keydown", (e=>{
                            (e.ctrlKey || e.metaKey) && 83 == e.keyCode && (e.preventDefault(),
                                write())
                        }
                    ))
                }
            )),
                this.reload = function(id, path) {
                    _this.loaded = !1,
                        window.UIL_ID = id,
                        window.UIL_STATIC_PATH = path,
                        init()
                }
                ,
                this.set = function(key, value) {
                    null === value ? (delete _data[key],
                        delete _dataSession[key]) : (_data[key] = value,
                        _dataSession[key] = value)
                }
                ,
                this.setWrite = function(key, value) {
                    this.set(key, value),
                        write(!0)
                }
                ,
                this.clearMatch = function(string) {
                    for (let key in _data)
                        key.includes(string) && delete _data[key];
                    write(!0)
                }
                ,
                this.write = function(silent) {
                    write(!0, silent)
                }
                ,
                this.get = function(key) {
                    return _data[key]
                }
                ,
                this.ready = function() {
                    return _this.wait(_this, "loaded")
                }
                ,
                this.parse = function(key, hint) {
                    let data = _data[key];
                    if (void 0 === data)
                        return null;
                    if (Array.isArray(data)) {
                        if (hint instanceof Vector2)
                            return {
                                value: (new Vector2).fromArray(data)
                            };
                        if (hint instanceof Vector3)
                            return {
                                value: (new Vector3).fromArray(data)
                            };
                        if (hint instanceof Vector4)
                            return {
                                value: (new Vector4).fromArray(data)
                            }
                    } else if ("string" == typeof data && "#" === data.charAt(0))
                        return {
                            value: new Color(data)
                        };
                    return {
                        value: data
                    }
                }
        }
    ), "static"),
    Class((function UILControl() {
            Inherit(this, Element);
            const _this = this;
            let $this, $label, $content, $view, _value, _previous, _label, _opts, _visible = !0, _onChange = ()=>{}
                , _onFinishChange = ()=>{}
            ;
            function isEqual(a, b) {
                return Array.isArray(a) || Array.isArray(b) ? a + "" == b + "" : "object" == typeof a || "object" == typeof b ? JSON.stringify(a) === JSON.stringify(b) : a === b
            }
            function clone(value) {
                return Array.isArray(value) ? [...value] : "object" == typeof value ? Object.assign({}, value) : value
            }
            !function initHTML() {
                $this = _this.element,
                    $this.size("100%", "auto"),
                    $this.css({
                        position: "relative",
                        display: "inline-block",
                        borderBottom: "1px solid #161616",
                        padding: "2px 0",
                        boxSizing: "border-box"
                    }),
                    $this.attr("data-type", "UILControl"),
                    $this.div._this = _this
            }(),
                function initLabel() {
                    $label = $this.create("label"),
                        $label.size("100px", "auto").fontStyle("sans-serif", 12, "#9B9C9B"),
                        $label.css({
                            paddingLeft: 4,
                            paddingTop: 2,
                            boxSizing: "border-box",
                            verticalAlign: "top",
                            float: "left"
                        }),
                        _this.$label = $label
                }(),
                function initContent() {
                    $content = $this.create("content"),
                        $content.size("calc(100% - 100px)", "auto").css({
                            float: "left"
                        }),
                        _this.$content = $content
                }(),
                this.init = function(id, opts={}) {
                    _this.id = id,
                        _opts = opts,
                        _this.setLabel(opts.label || id),
                        _value = clone(opts.value),
                        _previous = clone(_value),
                        $this.attr("data-id", id)
                }
                ,
                this.finish = function(history=!0) {
                    _onFinishChange(_value),
                    isEqual(_value, _previous) || (history && UILHistory.set(_this, _previous),
                        UILLocalStorage.set(_this.id, _value),
                        _previous = clone(_value))
                }
                ,
                this.force = function(value) {
                    _this.value = clone(value),
                        _this.finish(!1)
                }
                ,
                this.debounce = function(callback, time=250) {
                    let interval;
                    return (...args)=>{
                        clearTimeout(interval),
                            interval = setTimeout((()=>{
                                    interval = null,
                                        callback(...args)
                                }
                            ), time)
                    }
                }
                ,
                this.onChange = function(cb) {
                    return _onChange = cb,
                        _this
                }
                ,
                this.onFinishChange = function(cb) {
                    return _onFinishChange = cb,
                        _this
                }
                ,
                this.get("value", (()=>_value)),
                this.set("value", (value=>{
                        isEqual(value, _value) || (_value = clone(value),
                        _this.update && _this.update(_value),
                            _onChange(_value))
                    }
                )),
                this.get("view", (()=>$view)),
                this.set("view", (view=>{
                        $view && $view.destroy(),
                            $view = view,
                            $content.add($view)
                    }
                )),
                this.hide = function() {
                    return _visible = !1,
                        $this.css({
                            display: "none"
                        }),
                        _this
                }
                ,
                this.show = function() {
                    return _visible = !0,
                        $this.css({
                            display: "inline-block"
                        }),
                        _this
                }
                ,
                this.isVisible = function() {
                    return _visible
                }
                ,
                this.setLabel = function(label) {
                    _label = label,
                        _this.label = label,
                        $label.text(label),
                        $label.attr("title", label)
                }
        }
    )),
    Class((function UILFolder(_id, _opts={
            drag: !0
        }) {
            Inherit(this, Element);
            const _this = this;
            let $this, $header, $container, $toggle, $drag, $title, _children = {}, _open = !_opts.closed, _visible = !0, _order = [], _draggable = !1, _sortableChildren = !1, _headerDrag = !1;
            var _hasClipboard = !1;
            _this.id = _id,
                _this.label = `${_opts.label || _id}`,
                _this.level = -1;
            function removeDragHandlers() {
                $this.div.removeEventListener("dragstart", dragStart, !1),
                    $this.div.removeEventListener("dragover", dragOver, !1),
                    $this.div.removeEventListener("drop", drop, !1)
            }
            function matchItem(str, item) {
                return UILFuzzySearch.search(str, item.id.toLowerCase()) || UILFuzzySearch.search(str, item.label.toLowerCase())
            }
            function dragStart(e) {
                if (!UILFolder.DragLock) {
                    if (!_headerDrag)
                        return e.preventDefault(),
                            void e.stopPropagation();
                    UILFolder.DragLock = _this.id,
                        e.dataTransfer.setData("text/plain", _this.id),
                        e.dataTransfer.effectAllowed = "move",
                        $this.css({
                            opacity: .5
                        })
                }
            }
            function dragOver(e) {
                e.preventDefault(),
                    e.dataTransfer.dropEffect = "move"
            }
            function drop(e) {
                if (!UILFolder.DragLock)
                    return;
                if (e.dataTransfer.items)
                    for (var i = 0; i < e.dataTransfer.items.length; i++)
                        if ("file" === e.dataTransfer.items[i].kind)
                            return;
                e.preventDefault(),
                    _headerDrag = !1;
                let target = e.currentTarget._this
                    , dragging = _this.parent.get(UILFolder.DragLock);
                UILFolder.DragLock = null,
                target && target.parent && dragging && (dragging.element.css({
                    opacity: 1
                }),
                dragging.parent.get(target.id) && (e.stopPropagation(),
                    target.parent.container.insertBefore(dragging.element.div, target.element.div),
                    _order = [...target.parent.container.childNodes].map((el=>el._this.id)),
                    _this.events.fire(UIL.REORDER, {
                        order: [..._order]
                    }),
                    function saveSort() {
                        UILStorage.set(`UIL_${UIL.sortKey}_${_this.parent.id}_order`, JSON.stringify(_order))
                    }()))
            }
            function getUrlID() {
                return `${Global.PLAYGROUND || "Global"}_folder_${_id}`
            }
            function saveFolderState() {
                sessionStorage.setItem(getUrlID(), JSON.stringify({
                    open: _open
                }))
            }
            function open(keepClosed=!1) {
                _open = !0,
                    $container.css({
                        display: "flex"
                    }),
                $toggle && $toggle.text("▼"),
                1 != keepClosed && forEachFolder((f=>f.close())),
                    saveFolderState(),
                _this.onOpen && _this.onOpen()
            }
            function close() {
                _open = !1,
                    $container.css({
                        display: "none"
                    }),
                $toggle && $toggle.text("▶"),
                    saveFolderState()
            }
            function onToggle(e) {
                _open ? close() : open()
            }
            function onMouseDown(e) {
                _headerDrag = !0,
                    $header.div.addEventListener("mouseup", onMouseUp)
            }
            function onMouseUp(e) {
                _headerDrag = !1,
                    $header.div.removeEventListener("mouseup", onMouseUp)
            }
            function onKeydown(e) {
                13 === e.which && (_open ? close() : open())
            }
            function onKeyup(e) {
                _hasClipboard && ("c" == e.key && e.metaKey ? function onCopy() {
                    UILClipboard.copy(_children)
                }() : "v" == e.key && e.metaKey && function onPaste() {
                    UILClipboard.paste(_children)
                }())
            }
            function onFocus() {
                $this.css({
                    border: "1px solid #37a1ef"
                }),
                    $this.div.classList.add("active"),
                    _hasClipboard = !0
            }
            function onBlur() {
                $this.css({
                    border: "none",
                    border: "1px solid #161616"
                }),
                    $this.div.classList.remove("active"),
                    _hasClipboard = !1
            }
            function forEachFolder(cb) {
                return Object.values(_children).forEach((el=>{
                        el instanceof UILFolder && (cb(el),
                            el.forEachFolder(cb))
                    }
                )),
                    _this
            }
            !function init() {
                $this = _this.element,
                    $this.size("100%", "auto").bg(_opts.background || "#272727"),
                    $this.css({
                        position: "relative",
                        border: "1px solid #161616",
                        boxSizing: "border-box",
                        maxHeight: _opts.maxHeight || "none"
                    }),
                    $this.attr("data-id", _id),
                    $this.attr("data-type", "UILFolder"),
                    $this.div._this = _this
            }(),
                function style() {
                    UIL.addCSS(UILFolder, "\n            .UILFolder *:focus { outline: none; }\n            .UILFolder input:focus { border-color:#37a1ef!important; }\n            .UILFolder button:focus { border-color:#37a1ef!important; }\n            .UILFolder .UILFolder .UILFolder .toggle {margin-left:8px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:16px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:24px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:32px; }\n            .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .UILFolder .toggle {margin-left:40px; }\n        ")
                }(),
                function initHeader() {
                    _opts.hideTitle || ($header = $this.create("title", "a"),
                        $header.attr("tabindex", "0"),
                        $header.size("100%", "auto").bg("#272727"),
                        $header.css({
                            display: "block",
                            padding: "4px 4px",
                            boxSizing: "border-box",
                            fontWeight: "bold",
                            userSelect: "none",
                            borderBottom: "1px solid #161616"
                        }),
                        $header.fontStyle("sans-serif", 11, "#B1B1B1"),
                        $header.div.addEventListener("keydown", onKeydown, !1),
                        $header.div.addEventListener("click", onToggle, !1),
                        $header.div.addEventListener("mousedown", onMouseDown),
                        $header.div.addEventListener("focus", onFocus, !1),
                        $header.div.addEventListener("blur", onBlur, !1),
                        $header.div.addEventListener("keydown", onKeyup, !1),
                        $toggle = $header.create("toggle"),
                        $toggle.text(_open ? "▼" : "▶").css({
                            fontSize: 8,
                            display: "inline-block",
                            verticalAlign: "middle"
                        }),
                        $drag = $header.create("drag"),
                        $drag.text("☰").css({
                            position: "absolute",
                            right: 7,
                            top: 3,
                            display: "inline-block",
                            pointerEvents: "none"
                        }),
                        $drag.hide(),
                        $title = $header.create("title"),
                        $title.text(_this.label).css({
                            display: "inline-block",
                            marginLeft: 4
                        }))
                }(),
                function initContainer() {
                    $container = $this.create("container"),
                        $container.size("100%", "100%").css({
                            display: "flex",
                            flexDirection: "column",
                            position: "relative",
                            overflowY: "auto"
                        }),
                    _open || $container.css({
                        display: "none"
                    }),
                        _this.container = $container.div
                }(),
                function restoreFolderState() {
                    let json = JSON.parse(sessionStorage.getItem(getUrlID()));
                    json && (json.open ? open() : close())
                }(),
                this.add = function(child) {
                    return child.draggable && child.draggable(_sortableChildren),
                        child.parent = _this,
                        _children[child.id] = child,
                        $container.add(child),
                        _this
                }
                ,
                this.remove = function(x) {
                    let id = "string" == typeof x ? x : x.id
                        , child = _children[id];
                    return child.eliminate && child.eliminate(),
                        child.destroy(),
                    _order && (_order = _order.filter((child=>child !== id))),
                        delete _children[id],
                        _this
                }
                ,
                this.get = function(id) {
                    return _children[id]
                }
                ,
                this.getAll = function() {
                    return Object.values(_children)
                }
                ,
                this.getVisible = function() {
                    return Object.values(_children).filter((x=>x.isVisible()))
                }
                ,
                this.find = function(id) {
                    return id === _id ? _this : Object.values(_children).reduce(((acc,item)=>item.id === id ? acc.concat(item) : item instanceof UILFolder ? acc.concat(item.find(id)) : acc), [])
                }
                ,
                this.filter = function(str) {
                    return function filter(str, match=!1) {
                        str = str.toLowerCase();
                        let result = []
                            , haystack = Object.values(_children);
                        for (let el of haystack)
                            if (el instanceof UILFolder) {
                                let matches = el.filter(str, !0);
                                matches.length ? (result.concat(matches),
                                    el.show(),
                                    el.open()) : matchItem(str, el) ? (result.push(el),
                                    el.show(),
                                    el.showChildren(),
                                    el.close()) : el.getVisible().length ? el.show() : el.hide()
                            } else
                                matchItem(str, el) ? (result.push(el),
                                    el.show()) : el.hide();
                        return result
                    }(str)
                }
                ,
                this.filterSingle = function filterSingle(str) {
                    str = str.toLowerCase();
                    let haystack = Object.values(_children);
                    for (let el of haystack)
                        el instanceof UILFolder ? (el.filterSingle(str),
                            str == el.label.toLowerCase() || str == el.id.toLowerCase() ? (el.show(),
                                el.showChildren(),
                                el.open(!0)) : el.getVisible().length ? el.show() : el.hide()) : matchItem(str, el) ? (el.show(),
                        el.open && el.open(!0)) : el.hide();
                    return []
                }
                ,
                this.open = function(keepClosed) {
                    return open(keepClosed),
                        _this
                }
                ,
                this.close = function() {
                    return close(),
                        _this
                }
                ,
                this.setLabel = function(label) {
                    return _this.label = `${label}`,
                        $title.text(label),
                        _this
                }
                ,
                this.hide = function() {
                    return _visible = !1,
                        $this.css({
                            display: "none"
                        }),
                        _this
                }
                ,
                this.show = function() {
                    return _visible = !0,
                        $this.css({
                            display: "block"
                        }),
                        _this
                }
                ,
                this.showChildren = function() {
                    return Object.values(_children).forEach((el=>el instanceof UILFolder ? el.showChildren() : el.show())),
                        _this.show(),
                        _this
                }
                ,
                this.isOpen = function() {
                    return _open
                }
                ,
                this.isVisible = function() {
                    return _visible
                }
                ,
                this.forEachFolder = function(cb) {
                    return forEachFolder(cb)
                }
                ,
                this.forEachControl = function(cb) {
                    return Object.values(_children).forEach((el=>{
                            el instanceof UILFolder ? el.forEachControl(cb) : cb(el)
                        }
                    )),
                        _this
                }
                ,
                this.enableSorting = function(key) {
                    _sortableChildren = !0,
                        UIL.sortKey = key,
                        Object.values(_children).forEach((el=>{
                                el instanceof UILFolder && el.draggable(!0)
                            }
                        ));
                    let order = function getSort() {
                        let sort = UILStorage.get(`UIL_${UIL.sortKey}_${_id}_order`);
                        if (sort)
                            return JSON.parse(sort)
                    }();
                    return order && (_order = order,
                        function restoreSort() {
                            _order.forEach((id=>{
                                    _children[id] && $container.add(_children[id])
                                }
                            ))
                        }()),
                        _this
                }
                ,
                this.draggable = function(enable) {
                    _draggable = enable,
                        $this.attr("draggable", enable),
                        enable ? (!function addDragHandlers() {
                            $this.div.addEventListener("dragstart", dragStart, !1),
                                $this.div.addEventListener("dragover", dragOver, !1),
                                $this.div.addEventListener("drop", drop, !1)
                        }(),
                        $drag && $drag.show()) : (removeDragHandlers(),
                        $drag && $drag.hide())
                }
                ,
                this.toClipboard = function() {
                    UILClipboard.copy(_children)
                }
                ,
                this.fromClipboard = function() {
                    UILClipboard.paste(_children)
                }
                ,
                this.eliminate = function() {
                    _opts.hideTitle || ($header.div.removeEventListener("keydown", onToggle, !1),
                        $header.div.removeEventListener("click", onToggle, !1),
                        $header.div.removeEventListener("mousedown", onMouseDown),
                        $header.div.removeEventListener("focus", onFocus, !1),
                        $header.div.removeEventListener("blur", onBlur, !1)),
                    _draggable && removeDragHandlers()
                }
                ,
                this.forceSort = function(index) {
                    _this.parent.container.insertBefore(_this.element.div, _this.parent.container.children[index]),
                        _order = [..._this.parent.container.childNodes].map((el=>el._this.id)),
                        _this.events.fire(UIL.REORDER, {
                            order: [..._order]
                        })
                }
                ,
                this.openChildren = function() {
                    Object.values(_children).forEach((el=>el instanceof UILFolder ? el.open() : null))
                }
        }
    )),
    Class((function UILPanel(_title, _opts={}) {
            Inherit(this, Element);
            const _this = this;
            let $this, _folder, _toolbar, _hidden = !1;
            function onKeydown(e) {
                if (e.ctrlKey || e.metaKey) {
                    if (72 == e.keyCode && e.shiftKey) {
                        if (`${document.activeElement.type}`.includes(["textarea", "input", "number"]))
                            return;
                        e.preventDefault(),
                            _hidden ? function show() {
                                $this.visible(),
                                    _hidden = !1
                            }() : function hide() {
                                $this.invisible(),
                                    _hidden = !0
                            }()
                    }
                    37 == e.keyCode && e.shiftKey && (e.preventDefault(),
                        $this.css({
                            left: 0,
                            right: "auto"
                        })),
                    39 == e.keyCode && e.shiftKey && (e.preventDefault(),
                        $this.css({
                            left: "auto",
                            right: 0
                        })),
                    67 == e.which && e.shiftKey && (e.preventDefault(),
                        _folder.forEachFolder((f=>f.close()))),
                    79 == e.which && e.shiftKey && (e.preventDefault(),
                        _folder.forEachFolder((f=>f.open())))
                }
            }
            function undim() {
                $this.css({
                    opacity: 1
                })
            }
            function dim() {
                $this.css({
                    opacity: .3
                })
            }
            _this.id = _title,
                function initHTML() {
                    $this = _this.element,
                        $this.size(_opts.width || "300px", _opts.height || "auto").bg("#161616").mouseEnabled(!0),
                        "left" === _opts.side ? $this.css({
                            left: 0
                        }) : $this.css({
                            right: 0
                        }),
                        $this.css({
                            top: 0,
                            maxHeight: _opts.maxHeight || "100%",
                            position: "absolute",
                            userSelect: "none",
                            padding: 4,
                            overflowY: "auto",
                            borderRadius: 4
                        }),
                        $this.hide()
                }(),
                function initToolbar() {
                    _toolbar = _this.toolbar = _this.initClass(UILPanelToolbar)
                }(),
                function initGroup() {
                    _folder = _this.initClass(UILFolder, _title, {
                        hideTitle: !0,
                        drag: !1,
                        background: "#161616"
                    }),
                        _this.folder = _folder
                }(),
                function addHandlers() {
                    document.addEventListener("keydown", onKeydown, !1),
                    _opts.hide && ($this.div.addEventListener("mouseover", undim, !1),
                        $this.div.addEventListener("mouseleave", dim, !1))
                }(),
                this.add = function(child) {
                    return $this.show(),
                        _folder.add(child),
                        _this
                }
                ,
                this.remove = function(x) {
                    return _folder.remove(x.id),
                        _this
                }
                ,
                this.get = function(id) {
                    return _folder.get(id)
                }
                ,
                this.find = function(id) {
                    return _folder.find(id)
                }
                ,
                this.filter = function(str) {
                    return _folder.filter(str)
                }
                ,
                this.enableSorting = function(key) {
                    return _folder.enableSorting && _folder.enableSorting(key),
                        _this
                }
                ,
                this.eliminate = function() {
                    _toolbar.eliminate(),
                        $this.div.removeEventListener("mouseover", undim, !1),
                        $this.div.removeEventListener("mouseleave", dim, !1),
                        document.removeEventListener("keydown", onKeydown, !1)
                }
        }
    )),
    Class((function UILControlButton(_id, _opts={}) {
            Inherit(this, UILControl);
            const _this = this;
            let $view, _buttons = [];
            !function init() {
                _this.init(_id, _opts),
                _opts.hideLabel && (_this.$label.css({
                    display: "none"
                }),
                    _this.$content.css({
                        width: "100%"
                    }))
            }(),
                function initActions() {
                    $view = $("inputs");
                    let config = [].concat(_opts.actions);
                    _buttons = [].concat(_opts.actions).map((({title: title, callback: callback})=>{
                            let btn = $view.create(`btn btn-${title}`, "button");
                            return btn.text(title).bg("#1d1d1d"),
                                btn.css({
                                    width: `calc(100% / ${config.length || 1}`,
                                    border: "1px solid #2e2e2e",
                                    color: "#37a1ef",
                                    position: "relative"
                                }),
                                btn.interact((e=>function hover(btn, e) {
                                    "over" === e.action ? btn.css({
                                        border: "1px solid #9b9c9b"
                                    }) : btn.css({
                                        border: "1px solid #2e2e2e"
                                    })
                                }(btn, e))),
                                btn.click((e=>function click(e, title, callback) {
                                    _this.value = title,
                                    callback && callback(title, e),
                                        _this.finish()
                                }(e, title, callback))),
                                btn
                        }
                    )),
                        _this.view = $view
                }(),
                this.setTitle = function(text) {
                    _buttons.forEach((btn=>{
                            btn.text(text)
                        }
                    ))
                }
        }
    )),
    Class((function UILControlCheckbox(_id, _opts={}) {
            Inherit(this, UILControl);
            const _this = this;
            let $view, $label, $checkbox, $slider;
            function toggle() {
                $checkbox.attr("checked", _this.value),
                    $slider.css({
                        right: _this.value ? 0 : "auto"
                    }),
                    $label.bg(_this.value ? "#37a1ef" : "#1d1d1d")
            }
            function click() {
                _this.value = !_this.value,
                    toggle(),
                    _this.finish()
            }
            function focus() {
                $label.css({
                    border: "1px solid #37a1ef"
                })
            }
            function blur() {
                $label.css({
                    border: "1px solid #2e2e2e"
                })
            }
            !function init() {
                _opts.value = _opts.value || !1,
                    _this.init(_id, _opts)
            }(),
                function initView() {
                    $view = $("view"),
                        $label = $view.create("label", "label"),
                        $label.size(30, 15).css({
                            position: "relative",
                            display: "inline-block",
                            borderRadius: 15,
                            border: "1px solid #2e2e2e"
                        }).bg(_this.value ? "#37a1ef" : "#1d1d1d"),
                        $checkbox = $label.create("checkbox", "input"),
                        $checkbox.attr("type", "checkbox"),
                        $checkbox.attr("checked", _this.value),
                        $checkbox.css({
                            opacity: 0,
                            width: "100%",
                            position: "absolute"
                        }),
                        $slider = $label.create("slider"),
                        $slider.size(15, 15).css({
                            borderRadius: 15,
                            position: "absolute",
                            right: _this.value ? 0 : "auto",
                            boxSizing: "border-box"
                        }).bg("#ffffff"),
                        _this.view = $view
                }(),
                function addHandlers() {
                    $checkbox.div.addEventListener("focus", focus, !1),
                        $checkbox.div.addEventListener("blur", blur, !1),
                        $checkbox.div.addEventListener("click", click, !1),
                        $checkbox.div.addEventListener("keypress", click, !1)
                }(),
                this.update = function() {
                    toggle()
                }
                ,
                this.onDestroy = function() {
                    $checkbox.div.removeEventListener("focus", focus, !1),
                        $checkbox.div.removeEventListener("blur", blur, !1),
                        $checkbox.div.removeEventListener("click", click, !1),
                        $checkbox.div.removeEventListener("keypress", click, !1)
                }
        }
    )),
    Class((function UILControlColor(_id, _opts={}) {
            Inherit(this, UILControl);
            const _this = this;
            var $display, _input;
            function onDisplayClick() {
                _input && (_this.events.unsub(_input, Events.UPDATE, onChange),
                    _input = _input.destroy()),
                    _input = _this.initClass(UILExternalColor, _opts.label || _id, _this.value),
                    _this.events.sub(_input, Events.UPDATE, onChange)
            }
            function onChange({value: value}) {
                _this.value = value,
                    $display.bg(_this.value),
                    $display.hex.css({
                        color: _this.value
                    }).text(_this.value),
                    finishChange()
            }
            function finishChange() {
                _this.finish()
            }
            !function init() {
                _opts.value = _opts.value || "#ffffff",
                    _this.init(_id, _opts)
            }(),
                function initInput() {
                    let $view = $("color");
                    $view.css({
                        position: "relative"
                    }).css({
                        padding: 1
                    }),
                        ($display = $view.create("color")).size("100%", "100%").bg(_this.value),
                        $display.css({
                            border: "1px solid #2E2E2E",
                            boxSizing: "border-box"
                        }),
                        $display.hex = $display.create("hex"),
                        $display.hex.text(_this.value),
                        $display.hex.css({
                            color: _this.value,
                            filter: "invert(100%)",
                            fontSize: 12,
                            fontFamily: "sans-serif",
                            padding: 1
                        }),
                        _this.view = $view
                }(),
                function addHandlers() {
                    $display.interact(null, onDisplayClick),
                        finishChange = _this.debounce(finishChange, 250)
                }(),
                this.update = function() {
                    $display.bg(_this.value),
                        $display.hex.css({
                            color: _this.value
                        }).text(_this.value)
                }
                ,
                this.onDestroy = function() {}
        }
    )),
    Class((function UILControlFile(_id, _opts={
            value: {}
        }) {
            Inherit(this, UILControl);
            const _this = this;
            let $view, $picker, $preview, $img, $input, $$copy, _value;
            async function change(e) {
                let file = $picker.div.files[0];
                file && (_value.filename = file.name,
                    _value.relative = function getRelative() {
                        return _value.relative.includes(_value.prefix) ? _value.relative.replace(`${_value.prefix}`, "") : _value.relative
                    }(),
                    _value.src = function getSrc() {
                        return `${_value.prefix ? _value.prefix + "/" : ""}${_value.relative ? _value.relative + "/" : ""}${_value.filename}`
                    }(),
                    await function fileExists(url) {
                        return fetch(url).then((e=>404 != e.status)).catch((e=>console.warn("UILControlImage image url validation failed", e)))
                    }(_value.src) ? (_this.value = Object.assign({}, _value),
                        $img.attr("title", _value.src),
                        $$copy.text(_value.filename),
                        _this.finish()) : ($picker.div.value = "",
                        console.warn("UIL: Could not find file", _value),
                        alert(`"${_value.src}" not found!\nMake sure "relative path" is correct.`)))
            }
            function focus() {
                $img.css({
                    border: "1px solid #37a1ef"
                })
            }
            function blur() {
                $img.css({
                    border: "1px dotted #2e2e2e"
                })
            }
            function inputChange() {
                _value.relative = $input.div.value
            }
            !function init() {
                _opts.value = Object.assign({
                    src: "",
                    relative: _opts.relative || "",
                    prefix: _opts.prefix,
                    filename: ""
                }, _opts.value),
                    _value = Object.assign({}, _opts.value),
                    _this.init(_id, _opts)
            }(),
                function initView() {
                    $view = $("view"),
                        $view.css({
                            position: "relative",
                            padding: 5
                        }),
                        $input = $view.create("path", "input"),
                        $input.size("100%").bg("#1D1D1D"),
                        $input.css({
                            boxSizing: "border-box",
                            border: "1px solid #2E2E2E",
                            color: "#37A1EF",
                            marginBottom: 5
                        }),
                        _this.value.relative ? $input.div.value = _this.value.relative : $input.attr("placeholder", "Relative Path"),
                        $preview = $view.create("preview"),
                        $preview.size("100%", 60),
                        $preview.css({
                            boxSizing: "border-box",
                            position: "relative",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            overflow: "hidden"
                        }),
                        $img = $preview.create("img"),
                        $img.size("100%"),
                        $img.css({
                            position: "absolute",
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0,
                            backgroundSize: "cover",
                            backgroundRepeat: "no-repeat",
                            backgroundPosition: "center",
                            border: "1px dotted #2e2e2e",
                            boxSizing: "border-box"
                        }),
                        $picker = $preview.create("picker", "input"),
                        $picker.attr("type", "file"),
                        $picker.css({
                            opacity: 0,
                            position: "absolute",
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }),
                        $$copy = $preview.create("copy"),
                        $$copy.html("Drag file here<br><small>or Click to Select</small>"),
                        $$copy.fontStyle("sans-serif", 11, "#9B9C9B").css({
                            textAlign: "center"
                        }),
                        _this.view = $view
                }(),
                function addHandlers() {
                    $picker.div.addEventListener("change", change, !1),
                        $picker.div.addEventListener("focus", focus, !1),
                        $picker.div.addEventListener("blur", blur, !1),
                        $input.div.addEventListener("change", inputChange, !1)
                }(),
                this.force = function(value) {
                    _value = Object.assign({}, value),
                        $input.div.value = _value.relative,
                        $img.attr("title", _value.src),
                        $$copy.text(_value.filename)
                }
                ,
                this.onDestroy = function() {
                    $picker.div.removeEventListener("change", change, !1),
                        $picker.div.removeEventListener("focus", focus, !1),
                        $picker.div.removeEventListener("blur", blur, !1),
                        $input.div.removeEventListener("change", inputChange, !1)
                }
        }
    )),
    Class((function UILControlImage(_id, _opts={
            value: {}
        }) {
            Inherit(this, UILControl);
            const _this = this;
            let $view, $picker, $preview, $img, $input, $check, $compress, _value;
            async function compressClick() {
                if (_value.src && !_this.flag("compressPending")) {
                    _this.flag("compressPending", !0),
                        $compress.bg("#f4ee42").text("---");
                    try {
                        "Error" == await Dev.execUILScript("compressktx", {
                            src: _value.src
                        }) ? $compress.bg("#f44141").html("Failed") : $compress.bg("#46f441").html("Success")
                    } catch (e) {
                        $compress.bg("#f44141").html("Failed"),
                            console.error(e)
                    }
                    _this.flag("compressPending", !1)
                }
            }
            function checkChange() {
                _this.value.compressed = _value.compressed = !!$check.div.checked,
                    _this.finish(!1)
            }
            async function change(e) {
                let file = $picker.div.files[0];
                file && (_value.filename = file.name,
                    _value.relative = function getRelative() {
                        return _value.relative.includes(_value.prefix) ? _value.relative.replace(`${_value.prefix}`, "") : _value.relative
                    }(),
                    _value.src = function getSrc() {
                        return `${_value.prefix ? _value.prefix + "/" : ""}${_value.relative ? _value.relative + "/" : ""}${_value.filename}`
                    }(),
                    _value.compressed = !!$check.div.checked,
                    await function imageExists(url) {
                        return fetch(url).then((e=>404 != e.status)).catch((e=>console.warn("UILControlImage image url validation failed", e)))
                    }(_value.src) ? (_this.value = Object.assign({}, _value),
                        $img.attr("title", _value.src),
                        $img.css({
                            backgroundImage: `url(${_value.src})`
                        }),
                        _this.finish()) : ($picker.div.value = "",
                        console.warn("UIL: Could not find image", _value),
                        alert(`"${_value.src}" not found!\nMake sure "relative path" is correct.`)))
            }
            function focus() {
                $img.css({
                    border: "1px solid #37a1ef"
                })
            }
            function blur() {
                $img.css({
                    border: "1px dotted #2e2e2e"
                })
            }
            function inputChange() {
                _value.relative = $input.div.value
            }
            !function init() {
                _opts.value = Object.assign({
                    src: "",
                    relative: _opts.relative || "",
                    prefix: _opts.prefix || "assets/images",
                    filename: ""
                }, _opts.value),
                    _value = Object.assign({}, _opts.value),
                    _this.init(_id, _opts)
            }(),
                function initView() {
                    $view = $("view"),
                        $view.css({
                            position: "relative",
                            padding: 5
                        }),
                        $input = $view.create("path", "input"),
                        $input.size("100%").bg("#1D1D1D"),
                        $input.css({
                            boxSizing: "border-box",
                            border: "1px solid #2E2E2E",
                            color: "#37A1EF",
                            marginBottom: 5
                        }),
                        _this.value.relative ? $input.div.value = _this.value.relative : $input.attr("placeholder", "Relative Path"),
                        $compress = $view.create("compress"),
                        $compress.text("Compress").bg("#fff").css({
                            top: 3,
                            width: 70,
                            height: 15,
                            textAlign: "center",
                            borderRadius: 5,
                            position: "relative",
                            float: "left",
                            paddingTop: 2
                        }).fontStyle("sans-serif", 11, "#000"),
                        $check = $view.create("#compressed", "input"),
                        $check.attr("type", "checkbox"),
                        $check.size(20, 20),
                        $check.css({
                            boxSizing: "border-box",
                            position: "relative"
                        }),
                        $check.div.checked = !!_this.value.compressed;
                    let $label = $view.create("compressed-label", "label");
                    $label.attr("for", "compressed"),
                        $label.text("Use Compressed").fontStyle("sans-serif", 9, "#9B9C9B").css({
                            top: -6,
                            position: "relative"
                        }),
                        $preview = $view.create("preview"),
                        $preview.size("100%", 60),
                        $preview.css({
                            boxSizing: "border-box",
                            position: "relative",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            overflow: "hidden"
                        }),
                        $img = $preview.create("img"),
                        $img.size("100%"),
                        $img.css({
                            position: "absolute",
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0,
                            backgroundSize: "cover",
                            backgroundRepeat: "no-repeat",
                            backgroundPosition: "center",
                            border: "1px dotted #2e2e2e",
                            boxSizing: "border-box"
                        }),
                    _this.value.src && $img.css({
                        backgroundImage: `url('${_this.value.src}')`
                    }),
                        $picker = $preview.create("picker", "input"),
                        $picker.attr("type", "file"),
                        $picker.attr("accept", "image/*"),
                        $picker.css({
                            opacity: 0,
                            position: "absolute",
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        });
                    let copy = $preview.create("copy");
                    copy.html("Drag image here<br><small>or Click to Select</small>"),
                        copy.fontStyle("sans-serif", 11, "#9B9C9B").css({
                            textAlign: "center"
                        }),
                        _this.view = $view
                }(),
                function addHandlers() {
                    $picker.div.addEventListener("change", change, !1),
                        $picker.div.addEventListener("focus", focus, !1),
                        $picker.div.addEventListener("blur", blur, !1),
                        $input.div.addEventListener("change", inputChange, !1),
                        $compress.div.onclick = compressClick,
                        $check.div.onchange = checkChange
                }(),
                this.force = function(value, isClipboard) {
                    _value = Object.assign({}, value),
                    !0 === isClipboard && (_this.value = _value),
                        $input.div.value = _value.relative,
                        $img.attr("title", _value.src),
                        $img.css({
                            backgroundImage: `url('${_value.src}')`
                        }),
                        $check.div.checked = _value.compressed
                }
                ,
                this.onDestroy = function() {
                    $picker.div.removeEventListener("change", change, !1),
                        $picker.div.removeEventListener("focus", focus, !1),
                        $picker.div.removeEventListener("blur", blur, !1),
                        $input.div.removeEventListener("change", inputChange, !1)
                }
        }
    )),
    Class((function UILControlNumber(_id, _opts={}) {
            Inherit(this, UILControl);
            const _this = this;
            let _input;
            !function init() {
                _opts.value = _opts.value || 0,
                    _this.init(_id, _opts)
            }(),
                function initInput() {
                    _input = _this.initClass(UILInputNumber, Object.assign(_opts, {
                        value: _this.value
                    })),
                        _input.onInput((v=>_this.value = v)),
                        _input.onFinish((v=>_this.finish())),
                        _this.view = _input.input
                }(),
                this.update = function(value) {
                    _input.value = _this.value || 0
                }
        }
    )),
    Class((function UILControlRange(_id, _opts={}) {
            Inherit(this, UILControl);
            const _this = this;
            let $view, $slider, _max = _opts.max || 100, _min = _opts.min || 0, _step = _opts.step || 1;
            function change() {
                _this.finish()
            }
            function input(e) {
                _this.value = Number($slider.div.value)
            }
            function focus() {
                $slider.css({
                    border: "1px solid #37a1ef"
                })
            }
            function blur() {
                $slider.css({
                    border: "1px solid #2e2e2e"
                })
            }
            !function init() {
                _opts.value = _opts.value || 0,
                    _this.init(_id, _opts)
            }(),
                function style() {
                    UIL.addCSS(UILControlRange, "\n            .UILControlRange input { -webkit-appearance:none; appearance:none; }\n            .UILControlRange input::-webkit-slider-thumb { -webkit-appearance: none; }\n            .UILControlRange input::-webkit-slider-thumb { \n                -webkit-appearance:none; appearance:none;\n                width:15px; height:15px;\n                background:#FFF;\n                border-radius:15px;\n            }\n            .UILControlRange input::-moz-slider-thumb { \n                -webkit-appearance:none; appearance:none;\n                width:15px; height:15px;\n                background:#FFF;\n                border-radius:15px;\n            }\n        ")
                }(),
                function initView() {
                    $view = $("view"),
                        $slider = $view.create("range", "input"),
                        $slider.attr("type", "range"),
                        $slider.attr("max", _max),
                        $slider.attr("min", _min),
                        $slider.attr("step", _step),
                        $slider.div.value = _this.value,
                        $slider.css({
                            width: "100%",
                            margin: 0,
                            padding: 0,
                            background: "#1d1d1d",
                            height: 4,
                            borderRadius: 15,
                            border: "1px solid #2e2e2e",
                            boxSizing: "border-box"
                        }),
                        _this.view = $view
                }(),
                function addHandlers() {
                    $slider.div.addEventListener("change", change, !1),
                        $slider.div.addEventListener("input", input, !1),
                        $slider.div.addEventListener("focus", focus, !1),
                        $slider.div.addEventListener("blur", blur, !1)
                }(),
                this.force = function(value) {
                    _this.value = value,
                        $slider.div.value = value,
                        _this.finish(!1)
                }
                ,
                this.onDestroy = function() {
                    $slider.div.removeEventListener("change", change, !1),
                        $slider.div.removeEventListener("input", input, !1),
                        $slider.div.removeEventListener("focus", focus, !1),
                        $slider.div.removeEventListener("blur", blur, !1)
                }
        }
    )),
    Class((function UILControlSelect(_id, _opts={}) {
            Inherit(this, UILControl);
            const _this = this;
            let $view, $select, _options;
            function change() {
                _this.finish()
            }
            function input() {
                let i = $select.div.selectedIndex;
                _this.value = _options[i].value
            }
            function focus() {
                $select.css({
                    border: "1px solid #37a1ef"
                })
            }
            function blur() {
                $select.css({
                    border: "1px solid #2e2e2e"
                })
            }
            !function init() {
                if (!_opts.options)
                    throw "UILControlSelect is missing select options";
                _opts.value = _opts.value || _opts.options[0].value,
                    _this.init(_id, _opts)
            }(),
                function style() {
                    UIL.addCSS(UILControlSelect, "\n            .UILControlSelect select { -webkit-appearance:none; appearance:none; }\n        ")
                }(),
                function initView() {
                    $view = $("view"),
                        $view.css({
                            position: "relative"
                        }),
                        $select = $view.create("dropdown", "select"),
                        $select.css({
                            width: "100%",
                            margin: 0,
                            padding: 0,
                            background: "#1d1d1d",
                            height: 15,
                            border: "1px solid #2e2e2e",
                            boxSizing: "border-box",
                            color: "#37a1ef",
                            borderRadius: 0,
                            height: 17
                        }),
                        $select.div.value = _this.value,
                        $view.create("arrow").text("▼").css({
                            color: "#37a1ef",
                            fontSize: 6,
                            position: "absolute",
                            right: 8,
                            top: 7,
                            pointerEvents: "none"
                        }),
                        _this.view = $view
                }(),
                function initOptions() {
                    _options = _opts.options.map((({value: value, label: label})=>{
                            let el = document.createElement("option");
                            return el.setAttribute("value", value),
                            _this.value === value && el.setAttribute("selected", !0),
                                el.text = label || value,
                                el.value = value,
                                $select.add(el),
                                el
                        }
                    ))
                }(),
                function addHandlers() {
                    $select.div.addEventListener("change", change, !1),
                        $select.div.addEventListener("input", input, !1),
                        $select.div.addEventListener("focus", focus, !1),
                        $select.div.addEventListener("blur", blur, !1)
                }(),
                this.force = function(value) {
                    $select.div.value = value,
                        _this.value = value
                }
                ,
                this.onDestroy = function() {
                    $select.div.removeEventListener("change", change, !1),
                        $select.div.removeEventListener("input", input, !1),
                        $select.div.removeEventListener("focus", focus, !1),
                        $select.div.removeEventListener("blur", blur, !1)
                }
        }
    )),
    Class((function UILControlText(_id, _opts={}) {
            Inherit(this, UILControl);
            const _this = this;
            let $input, _timeout;
            function onChange(v) {
                clearTimeout(_timeout),
                    _timeout = setTimeout(onFinishChange, 400),
                    _this.value = $input.div.value
            }
            function onFinishChange() {
                null !== _timeout && (clearTimeout(_timeout),
                    _timeout = null,
                    _this.finish())
            }
            _this.init(_id, _opts),
                function initInput() {
                    $input = $("input", "input"),
                        $input.size("100%").bg("#1D1D1D"),
                        $input.css({
                            boxSizing: "border-box",
                            border: "1px solid #2E2E2E",
                            color: "#37A1EF"
                        }),
                    _this.value && ($input.div.value = _this.value || ""),
                        _this.view = $input
                }(),
                function addHandlers() {
                    $input.div.addEventListener("input", onChange, !1),
                        $input.div.addEventListener("change", onFinishChange, !1)
                }(),
                this.update = function() {
                    $input.div.value = _this.value || ""
                }
                ,
                this.onDestroy = function() {
                    $input.div.removeEventListener("input", onChange, !1),
                        $input.div.removeEventListener("change", onBlur, !1)
                }
        }
    )),
    Class((function UILControlTextarea(_id, _opts={}) {
            Inherit(this, UILControl);
            const _this = this;
            let $input, _timeout;
            function onChange(v) {
                clearTimeout(_timeout),
                    _timeout = setTimeout(onFinishChange, 400),
                    _this.value = $input.div.value
            }
            function onFinishChange() {
                null !== _timeout && (clearTimeout(_timeout),
                    _timeout = null,
                    _this.finish())
            }
            _this.init(_id, _opts),
                function initInput() {
                    $input = $("input", "textarea"),
                        $input.attr("maxlength", _opts.max || 1 / 0),
                        $input.attr("minlength", _opts.min || -1 / 0),
                        $input.attr("rows", _opts.rows || 2),
                        $input.attr("readonly", _opts.readonly || !1),
                        $input.size("100%").bg("#1D1D1D"),
                        $input.css({
                            boxSizing: "border-box",
                            resize: _opts.resize || "vertical",
                            minWidth: _opts.minWidth || 0,
                            border: "1px solid #2E2E2E",
                            color: "#37A1EF"
                        }),
                    (_opts.monospace || _opts.editor) && $input.css({
                        fontFamily: "monospace"
                    }),
                    _this.value && ($input.div.value = _this.value || ""),
                        _this.view = $input
                }(),
            _opts.editor && function enableTab() {
                $input.div.onkeydown = function(e) {
                    if (9 === e.keyCode) {
                        let val = this.value
                            , start = this.selectionStart
                            , end = this.selectionEnd;
                        this.value = val.substring(0, start) + "\t" + val.substring(end),
                            this.selectionStart = this.selectionEnd = start + 1,
                            e.preventDefault()
                    }
                }
            }(),
                function addHandlers() {
                    $input.div.addEventListener("input", onChange, !1),
                        $input.div.addEventListener("change", onFinishChange, !1)
                }(),
                this.update = function() {
                    $input.div.value = _this.value || ""
                }
                ,
                this.onDestroy = function() {
                    $input.div.removeEventListener("input", onChange, !1),
                        $input.div.removeEventListener("change", onBlur, !1)
                }
        }
    )),
    Class((function UILControlVector(_id, _opts={}) {
            Inherit(this, UILControl);
            const _this = this;
            let $view, _length, _inputs = [], _vector = [];
            function onInput(value, index, master) {
                master ? _vector = _vector.map((v=>value)) : _vector[index] = value,
                    _this.value = [..._vector]
            }
            function onFinish(value, index, master) {
                _this.finish()
            }
            !function init() {
                if (_opts.value)
                    _length = _vector.length;
                else {
                    if (!_opts.components)
                        throw 'UILControlVector: Cannot detect vector type. Define "options.components" count or init with a initial value';
                    _opts.value = new Array(_opts.components).fill(0)
                }
                _length = _opts.value.length,
                    _this.init(_id, _opts),
                    _vector = [..._this.value]
            }(),
                function initInputs() {
                    $view = $("inputs");
                    for (let i = 0; i < _length; i++) {
                        let input = _this.initClass(UILInputNumber, _opts);
                        input.value = _this.value[i],
                            input.onInput(((v,m)=>onInput(v, i, m))),
                            input.onFinish(((v,m)=>onFinish(v, i, m))),
                            input.input.css({
                                display: "inline-block",
                                width: `calc(100% / ${_length})`
                            }),
                            _inputs.push(input),
                            $view.add(input.input)
                    }
                    _this.view = $view
                }(),
                this.force = function(value) {
                    _vector = [...value],
                        _this.value = [..._vector],
                        _inputs.forEach(((input,index)=>input.value = _this.value[index])),
                        _this.finish(!1)
                }
                ,
                this.update = function() {
                    _inputs.forEach(((input,index)=>input.value = _this.value[index]))
                }
        }
    )),
    Class((function UILInputNumber(_opts={}) {
            Inherit(this, Component);
            const _this = this;
            let $input, _timeout, _distance, _onMouseDownValue, _editing = !1, _precision = _opts.precision || 3, _step = _opts.step || 1, _min = _opts.min || -1 / 0, _max = _opts.max || 1 / 0, _value = _opts.value || 0, _pointer = [0, 0], _prevPointer = [0, 0], _onInputCB = ()=>{}
                , _onFinishCB = ()=>{}
            ;
            function setValue(value) {
                (value = parseFloat(value) || 0) < _min && (value = _min),
                value > _max && (value = _max),
                    _value = value,
                    _onInputCB(value, _this.master)
            }
            function onBlur() {
                onFinishChange(),
                    $input.div.value = parseFloat(_value).toFixed(_precision)
            }
            function onKeyUp(e) {
                13 === e.keyCode && e.altKey && (_this.master = !0,
                    onInput())
            }
            function onInput(e) {
                _timeout = setTimeout(onFinishChange, 400),
                    _editing = !0,
                    setValue(parseFloat($input.div.value))
            }
            function onFinishChange() {
                _editing && (_editing = !1,
                    clearTimeout(_timeout),
                    _onFinishCB(_value, _this.master),
                    _this.master = !1)
            }
            function onMouseDown(e) {
                (1 === e.button || 0 === e.button && e.metaKey || e.ctrlKey) && (e.preventDefault(),
                    $input.css({
                        cursor: "col-resize"
                    }),
                    _distance = 0,
                    _onMouseDownValue = _value,
                    _prevPointer = [e.screenX, e.screenY],
                    document.addEventListener("mousemove", onMouseMove, !1),
                    document.addEventListener("mouseup", onMouseUp, !1))
            }
            function onMouseMove(e) {
                clearTimeout(_timeout),
                    _editing = !0;
                let currentValue = _value;
                _pointer = [e.screenX, e.screenY],
                    _distance += _pointer[0] - _prevPointer[0] - (_pointer[1] - _prevPointer[1]);
                let value = _onMouseDownValue + _distance / (e.shiftKey ? 5 : 50) * _step;
                value = Math.min(_max, Math.max(_min, value)),
                    _this.master = e.altKey,
                currentValue !== value && function setValueDrag(value) {
                    void 0 === value && value === $input.div.value || (setValue(value),
                        $input.div.value = _value.toFixed(_precision))
                }(value),
                    _prevPointer = [e.screenX, e.screenY]
            }
            function onMouseUp(e) {
                onFinishChange(),
                    $input.css({
                        cursor: ""
                    }),
                    document.removeEventListener("mousemove", onMouseMove, !1),
                    document.removeEventListener("mouseup", onMouseUp, !1)
            }
            !function initInput() {
                $input = $("input", "input"),
                    $input.attr("type", "number"),
                    $input.attr("step", _step),
                    $input.size("100%").bg("#1D1D1D"),
                    $input.css({
                        boxSizing: "border-box",
                        border: "1px solid #2E2E2E",
                        color: "#37A1EF",
                        boxShadow: "none"
                    }),
                    $input.div.value = parseFloat(_value).toFixed(_precision),
                    _this.input = $input
            }(),
                function addHandlers() {
                    $input.div.addEventListener("mousedown", onMouseDown, !1),
                        $input.div.addEventListener("keyup", onKeyUp, !1),
                        $input.div.addEventListener("change", onFinishChange, !1),
                        $input.div.addEventListener("blur", onBlur, !1),
                        $input.div.addEventListener("input", onInput, !1)
                }(),
                this.set("value", (value=>{
                        _value = value,
                        _editing || ($input.div.value = parseFloat(value).toFixed(_precision))
                    }
                )),
                this.get("value", (()=>_value)),
                this.onInput = cb=>_onInputCB = cb,
                this.onFinish = cb=>_onFinishCB = cb,
                this.onDestroy = function() {
                    $input.div.removeEventListener("mousedown", onMouseDown, !1),
                        $input.div.removeEventListener("change", onFinishChange, !1),
                        $input.div.removeEventListener("blur", onBlur, !1),
                        $input.div.removeEventListener("input", onInput, !1)
                }
        }
    )),
    Class((function UILExternalColor(_title, _value) {
            Inherit(this, Component);
            const _this = this;
            var _window;
            function onReload() {
                _this.onDestroy()
            }
            (_window = window.open("http://localhost/hydra/editor/color/index.html", `hydra_color_${_title}`, "width=480,height=220,left=200,top=100,location=no")).window.onload = _=>{
                _window.window.initPicker(_title, _value, _this)
            }
                ,
                window.addEventListener("beforeunload", onReload),
                this.update = function(value) {
                    _this.events.fire(Events.UPDATE, {
                        value: value
                    })
                }
                ,
                this.onDestroy = function() {
                    window.removeEventListener("beforeunload", onReload),
                    _window && _window.window && _window.window.close()
                }
        }
    )),
    Class((function UILExternalEditor(_title, _height=500) {
            Inherit(this, Component);
            const _this = this;
            var _window, _code, _language;
            _window = window.open("http://localhost/hydra/editor/code/index.html", "_blank", `width=700,height=${_height},left=200,top=100`),
                _this.events.sub(Events.UNLOAD, (_=>_window.close())),
                _window.window.onload = _=>{
                    _window.window.initEditor(_title, _code, _language, _this)
                }
                ,
                this.setCode = function(code, language) {
                    _code = code,
                        _language = language
                }
                ,
                this.saved = async function(code) {
                    _this.onSave && _this.onSave(code),
                        await defer(),
                        UILStorage.write()
                }
        }
    )),
    Class((function UILPanelToolbar() {
            Inherit(this, Element);
            const _this = this;
            let $this, $filter, _state = new Map;
            function restoreFolderState() {
                _this.parent.folder.forEachFolder((folder=>{
                        _state.get(folder) ? folder.open() : folder.close()
                    }
                )),
                    _state.clear()
            }
            function onInput(e) {
                if (!$filter.div.value.length)
                    return restoreFolderState(),
                        _this.parent.folder.showChildren();
                _this.parent.folder.filter($filter.div.value)
            }
            function onFocus() {
                !function saveFolderState() {
                    _this.parent.folder.forEachFolder((folder=>{
                            _state.set(folder, folder.isOpen())
                        }
                    ))
                }(),
                    $filter.css({
                        border: "1px solid #37a1ef"
                    })
            }
            function onBlur() {
                $filter.css({
                    border: "1px solid #2e2e2e"
                })
            }
            function onKeyPressed(e) {
                if (27 === e.keyCode)
                    return $filter.div.value = "",
                        restoreFolderState(),
                        _this.parent.folder.showChildren()
            }
            !function initHTML() {
                $this = _this.element,
                    $this.size("100%", "auto").bg("#272727"),
                    $this.css({
                        padding: 4,
                        boxSizing: "border-box",
                        marginBottom: 4
                    })
            }(),
                function initFilter() {
                    $filter = $this.create("filter", "input"),
                        $filter.div.addEventListener("input", onInput, !1),
                        $filter.div.addEventListener("keydown", onKeyPressed, !1),
                        $filter.div.addEventListener("focus", onFocus, !1),
                        $filter.div.addEventListener("blur", onBlur, !1),
                        $filter.size("100%", "auto").bg("#161616"),
                        $filter.css({
                            color: "#B1B1B1",
                            border: "1px solid #2e2e2e",
                            outline: "none",
                            padding: 2,
                            boxSizing: "border-box"
                        })
                }(),
                this.eliminate = function() {
                    $filter.div.removeEventListener("input", onInput, !1),
                        $filter.div.removeEventListener("keydown", onKeyPressed, !1),
                        $filter.div.removeEventListener("focus", onFocus, !1),
                        $filter.div.removeEventListener("blur", onBlur, !1)
                }
                ,
                this.filter = function(text) {
                    $filter.div.value = text,
                        onInput()
                }
                ,
                this.filterSingle = function(text) {
                    $filter.div.value = text,
                        _this.parent.folder.filterSingle($filter.div.value)
                }
                ,
                this.hideAll = function() {
                    _this.flag("init") || (_this.flag("init", !0),
                        this.filterSingle("xxxxxx"))
                }
        }
    )),
    Namespace("FX"),
    FX.Class((function UnrealBloom(_nuke, options, _unique) {
            Inherit(this, Component);
            var _triangleGeometry, _luminosityShader, _compositeShader, _mesh, _this = this;
            "string" == typeof options ? (_unique = _params,
                options = {},
                _nuke = World.NUKE) : "string" == typeof _nuke ? (_unique = _nuke,
                options = {},
                _nuke = World.NUKE) : !_nuke || _nuke instanceof Nuke ? (_nuke = _nuke || World.NUKE,
                options = options || {},
                _unique = _unique || "") : (options = _nuke,
                _nuke = World.NUKE);
            new Color;
            var _renderTargetsHorizontal = []
                , _renderTargetsVertical = []
                , _separableBlurShaders = []
                , _nMips = options.nMips || 5
                , _DPR = _nuke.dpr
                , _blurDirectionX = new Vector2(_DPR,0)
                , _blurDirectionY = new Vector2(0,_DPR)
                , _kernelSizeArray = options.kernelSizeArray || [3, 5, 7, 9, 11]
                , _bloomFactors = options.bloomFactors || [1, .8, .6, .4, .2];
            function render() {}
            function resizeHandler() {
                _this.resolution.set(_nuke.stage.width, _nuke.stage.height).multiplyScalar(_DPR),
                    _blurDirectionX.x = _DPR,
                    _blurDirectionY.y = _DPR;
                let resx = Math.round(_this.resolution.x / 2)
                    , resy = Math.round(_this.resolution.y / 2);
                _this.renderTargetBright.setSize(resx, resy);
                for (var i = 0; i < _nMips; i++)
                    _renderTargetsHorizontal[i].setSize(resx, resy),
                        _renderTargetsVertical[i].setSize(resx, resy),
                        _separableBlurShaders[i].uniforms.texSize.value = new Vector2(resx,resy),
                        resx = Math.round(resx / 2),
                        resy = Math.round(resy / 2)
            }
            this.uniforms = {
                tUnrealBloom: {
                    value: null
                },
                unique: _unique
            },
                this.resolution = new Vector2(_nuke.stage.width * _DPR,_nuke.stage.height * _DPR),
                this.clearColor = new Color(0,0,0),
                this.enabled = !0,
                this.outputTexture = null,
                function initRTs() {
                    let pars = {
                        minFilter: Texture.LINEAR,
                        magFilter: Texture.LINEAR,
                        format: Texture.RGBAFormat
                    }
                        , resx = Math.round(_this.resolution.x / 2)
                        , resy = Math.round(_this.resolution.y / 2);
                    _this.renderTargetBright = new RenderTarget(resx,resy,pars),
                        _this.renderTargetBright.texture.generateMipmaps = !1;
                    for (let i = 0; i < _nMips; i++) {
                        let renderTargetHorizonal = new RenderTarget(resx,resy,pars);
                        renderTargetHorizonal.texture.generateMipmaps = !1,
                            _renderTargetsHorizontal.push(renderTargetHorizonal);
                        let renderTargetVertical = new RenderTarget(resx,resy,pars);
                        renderTargetVertical.texture.generateMipmaps = !1,
                            _renderTargetsVertical.push(renderTargetVertical),
                            resx = Math.round(resx / 2),
                            resy = Math.round(resy / 2)
                    }
                    _this.outputTexture = _renderTargetsHorizontal[0].texture,
                        _this.uniforms.tUnrealBloom.value = _renderTargetsHorizontal[0].texture
                }(),
                function initScene() {
                    _triangleGeometry = World.QUAD,
                        _luminosityShader = _this.initClass(Shader, "UnrealBloomLuminosity", {
                            tDiffuse: {
                                value: null,
                                ignoreUIL: !0
                            },
                            luminosityThreshold: {
                                value: 1
                            },
                            smoothWidth: {
                                value: .01,
                                ignoreUIL: !0
                            },
                            defaultColor: {
                                value: new Color(0),
                                ignoreUIL: !0
                            },
                            defaultOpacity: {
                                value: 0,
                                ignoreUIL: !0
                            },
                            unique: _unique
                        }),
                        (_mesh = new Mesh(_triangleGeometry,_luminosityShader)).frustumCulled = !1
                }(),
                function initBlurShaders() {
                    let resx = Math.round(_this.resolution.x / 2)
                        , resy = Math.round(_this.resolution.y / 2);
                    for (let i = 0; i < _nMips; i++) {
                        let shader = _this.initClass(Shader, "UnrealBloomGaussian", {
                            unique: _unique,
                            colorTexture: {
                                value: null
                            },
                            texSize: {
                                value: new Vector2(resx,resy)
                            },
                            direction: {
                                value: new Vector2(.5,.5)
                            }
                        }, null, (glsl=>`\n#define KERNEL_RADIUS ${_kernelSizeArray[i]}\n#define SIGMA ${_kernelSizeArray[i]}\n${glsl}`), `gaussian${i}`);
                        _separableBlurShaders.push(shader),
                            resx = Math.round(resx / 2),
                            resy = Math.round(resy / 2)
                    }
                }(),
                function initCompositeShader() {
                    let uniforms = {
                        bloomStrength: {
                            value: 1
                        },
                        bloomTintColor: {
                            value: new Color("#ffffff")
                        },
                        bloomRadius: {
                            value: 0
                        },
                        unique: _unique
                    };
                    for (let i = 0; i < _nMips; i++)
                        uniforms[`blurTexture${i + 1}`] = {
                            value: _renderTargetsVertical[i].texture,
                            ignoreUIL: !0
                        };
                    (_compositeShader = _this.initClass(Shader, "UnrealBloomComposite", uniforms, null, ((glsl,type)=>{
                            if ("vs" === type)
                                return glsl;
                            let compositeUniforms = ""
                                , compositeMain = "";
                            for (let i = 0; i < _nMips; i++)
                                compositeUniforms += `uniform sampler2D blurTexture${i + 1};\n`,
                                    compositeMain += `lerpBloomFactor(${_bloomFactors[i].toFixed(4)}) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture${i + 1}, vUv) ${i < _nMips - 1 ? "+ " : ""}`;
                            return (glsl = glsl.replace("uniform sampler2D blurTexture1;", compositeUniforms)).replace("lerpBloomFactor(1.0) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture1, vUv)", compositeMain)
                        }
                    ))).needsUpdate = !0
                }(),
                function initPass() {
                    _this.pass = _this.initClass(NukePass, "UnrealBloomPass", _this.uniforms)
                }(),
                function addListeners() {
                    _this.events.sub(Events.RESIZE, resizeHandler),
                        _this.events.sub(RenderManager.POST_RENDER, render)
                }(),
            Utils.query("bloom") && (ShaderUIL.add(_luminosityShader).setLabel("UnrealBloom Luminosity"),
                ShaderUIL.add(_compositeShader).setLabel("UnrealBloom Composite")),
                this.set("texture", (texture=>{
                        texture
                    }
                )),
                this.set("dpr", (dpr=>{
                        _DPR = dpr,
                            resizeHandler()
                    }
                )),
                this.renderBloom = render,
                this.renderMesh = _mesh
        }
    )),
    Namespace("FX"),
    FX.Class((function UnrealBloomCustom(_nuke, options, _unique) {
            Inherit(this, Component);
            var _triangleGeometry, _luminosityShader, _compositeShader, _mesh, _this = this;
            "string" == typeof options ? (_unique = _params,
                options = {},
                _nuke = World.NUKE) : "string" == typeof _nuke ? (_unique = _nuke,
                options = {},
                _nuke = World.NUKE) : !_nuke || _nuke instanceof Nuke ? (_nuke = _nuke || World.NUKE,
                options = options || {},
                _unique = _unique || "") : (options = _nuke,
                _nuke = World.NUKE);
            var _oldClearColor = new Color
                , _oldClearAlpha = 1
                , _renderTargetsHorizontal = []
                , _renderTargetsVertical = []
                , _separableBlurShaders = []
                , _nMips = options.nMips || 5
                , _DPR = _nuke.dpr
                , _blurDirectionX = new Vector2(_DPR,0)
                , _blurDirectionY = new Vector2(0,_DPR)
                , _kernelSizeArray = options.kernelSizeArray || [3, 5, 7, 9, 11]
                , _bloomFactors = options.bloomFactors || [1, .8, .6, .4, .2]
                , _useRTPool = options.useRTPool || !1;
            function render() {
                if (!_this.enabled || !1 === _this.visible)
                    return;
                let renderer = _nuke.renderer;
                _oldClearColor.copy(renderer.getClearColor()),
                    _oldClearAlpha = renderer.getClearAlpha();
                let oldAutoClear = renderer.autoClear;
                renderer.autoClear = !0,
                    renderer.setClearColor(_this.clearColor, 1),
                    renderer.render(_this.cracksScene, _nuke.camera, _this.renderTargetBright);
                let inputRenderTarget = _this.renderTargetBright;
                for (let i = 0; i < _nMips; i++)
                    _mesh.shader = _separableBlurShaders[i],
                        _separableBlurShaders[i].uniforms.colorTexture.value = inputRenderTarget.texture,
                        _separableBlurShaders[i].uniforms.direction.value = _blurDirectionX,
                        renderer.renderSingle(_mesh, _nuke.camera, _renderTargetsHorizontal[i]),
                        _separableBlurShaders[i].uniforms.colorTexture.value = _renderTargetsHorizontal[i].texture,
                        _separableBlurShaders[i].uniforms.direction.value = _blurDirectionY,
                        renderer.renderSingle(_mesh, _nuke.camera, _renderTargetsVertical[i]),
                        inputRenderTarget = _renderTargetsVertical[i];
                _mesh.shader = _compositeShader,
                    renderer.renderSingle(_mesh, _nuke.camera, _renderTargetsHorizontal[0]),
                    renderer.setClearColor(_oldClearColor, _oldClearAlpha),
                    renderer.autoClear = oldAutoClear
            }
            function resizeHandler() {
                _this.resolution.set(_nuke.stage.width, _nuke.stage.height).multiplyScalar(_DPR),
                    _blurDirectionX.x = _DPR,
                    _blurDirectionY.y = _DPR;
                let resx = Math.round(_this.resolution.x / 2)
                    , resy = Math.round(_this.resolution.y / 2);
                _this.renderTargetBright && _this.renderTargetBright.setSize(resx, resy);
                for (var i = 0; i < _renderTargetsHorizontal.length; i++)
                    _renderTargetsHorizontal[i].setSize(resx, resy),
                        _renderTargetsVertical[i].setSize(resx, resy),
                        _separableBlurShaders[i].uniforms.texSize.value = new Vector2(resx,resy),
                        resx = Math.round(resx / 2),
                        resy = Math.round(resy / 2)
            }
            this.uniforms = {
                tUnrealBloom: {
                    value: null
                },
                unique: _unique
            },
                this.resolution = new Vector2(_nuke.stage.width * _DPR,_nuke.stage.height * _DPR),
                this.clearColor = new Color(0,0,0),
                this.enabled = "boolean" != typeof options.enabled || options.enabled,
                this.outputTexture = null,
                this.cracksScene = new Scene,
                function initRTs() {
                    if (_useRTPool)
                        return void RTPool.instance(null, 3, Texture.RGBAFormat).disableResize();
                    let pars = {
                        minFilter: Texture.LINEAR,
                        magFilter: Texture.LINEAR,
                        format: Texture.RGBAFormat
                    }
                        , resx = Math.round(_this.resolution.x / 2)
                        , resy = Math.round(_this.resolution.y / 2);
                    _this.renderTargetBright = new RenderTarget(resx,resy,pars),
                        _this.renderTargetBright.texture.generateMipmaps = !1;
                    for (let i = 0; i < _nMips; i++) {
                        let renderTargetHorizonal = new RenderTarget(resx,resy,pars);
                        renderTargetHorizonal.texture.generateMipmaps = !1,
                            _renderTargetsHorizontal.push(renderTargetHorizonal);
                        let renderTargetVertical = new RenderTarget(resx,resy,pars);
                        renderTargetVertical.texture.generateMipmaps = !1,
                            _renderTargetsVertical.push(renderTargetVertical),
                            resx = Math.round(resx / 2),
                            resy = Math.round(resy / 2)
                    }
                    _this.outputTexture = _renderTargetsHorizontal[0].texture,
                        _this.uniforms.tUnrealBloom.value = _renderTargetsHorizontal[0].texture
                }(),
                function initScene() {
                    _triangleGeometry = World.QUAD,
                        _luminosityShader = _this.initClass(Shader, "UBLuminosityCustom", {
                            tDiffuse: {
                                value: null,
                                ignoreUIL: !0
                            },
                            luminosityThreshold: {
                                value: 1
                            },
                            smoothWidth: {
                                value: .01,
                                ignoreUIL: !0
                            },
                            defaultColor: {
                                value: new Color(0),
                                ignoreUIL: !0
                            },
                            defaultOpacity: {
                                value: 0,
                                ignoreUIL: !0
                            },
                            unique: _unique
                        }),
                        (_mesh = new Mesh(_triangleGeometry,_luminosityShader)).frustumCulled = !1
                }(),
                function initBlurShaders() {
                    let resx = Math.round(_this.resolution.x / 2)
                        , resy = Math.round(_this.resolution.y / 2);
                    for (let i = 0; i < _nMips; i++) {
                        let shader = _this.initClass(Shader, "UnrealBloomGaussian", {
                            unique: _unique,
                            colorTexture: {
                                value: null
                            },
                            texSize: {
                                value: new Vector2(resx,resy)
                            },
                            direction: {
                                value: new Vector2(.5,.5)
                            }
                        }, null, (glsl=>`\n#define KERNEL_RADIUS ${_kernelSizeArray[i]}\n#define SIGMA ${_kernelSizeArray[i]}\n${glsl}`), `gaussian${i}`);
                        _separableBlurShaders.push(shader),
                            resx = Math.round(resx / 2),
                            resy = Math.round(resy / 2)
                    }
                }(),
                function initCompositeShader() {
                    let uniforms = {
                        bloomStrength: {
                            value: 1
                        },
                        bloomTintColor: {
                            value: new Color("#ffffff")
                        },
                        bloomRadius: {
                            value: 0
                        },
                        unique: _unique
                    };
                    for (let i = 0; i < _nMips; i++)
                        uniforms[`blurTexture${i + 1}`] = {
                            value: _useRTPool ? null : _renderTargetsVertical[i].texture,
                            ignoreUIL: !0
                        };
                    (_compositeShader = _this.initClass(Shader, "UnrealBloomComposite", uniforms, null, ((glsl,type)=>{
                            if ("vs" === type)
                                return glsl;
                            let compositeUniforms = ""
                                , compositeMain = "";
                            for (let i = 0; i < _nMips; i++)
                                compositeUniforms += `uniform sampler2D blurTexture${i + 1};\n`,
                                    compositeMain += `lerpBloomFactor(${_bloomFactors[i].toFixed(4)}) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture${i + 1}, vUv) ${i < _nMips - 1 ? "+ " : ""}`;
                            return (glsl = glsl.replace("uniform sampler2D blurTexture1;", compositeUniforms)).replace("lerpBloomFactor(1.0) * vec4(bloomTintColor, 1.0) * texture2D(blurTexture1, vUv)", compositeMain)
                        }
                    ))).needsUpdate = !0
                }(),
                function initPass() {
                    _this.pass = _this.initClass(NukePass, "UBPassCustom", _this.uniforms)
                }(),
                function addListeners() {
                    _this.events.sub(Events.RESIZE, resizeHandler),
                        _this.events.sub(RenderManager.POST_RENDER, render)
                }(),
                ShaderUIL.add(_luminosityShader).setLabel("UnrealBloom Luminosity"),
                ShaderUIL.add(_compositeShader).setLabel("UnrealBloom Composite"),
                this.set("texture", (texture=>{
                        texture
                    }
                )),
                this.set("dpr", (dpr=>{
                        _DPR = dpr,
                            resizeHandler()
                    }
                )),
                this.get("compositeColor", (_=>_compositeShader.uniforms.bloomTintColor.value)),
                this.set("compositeColor", (c=>{
                        _compositeShader.uniforms.bloomTintColor.value.copy(c)
                    }
                )),
                this.get("compositeSTR", (_=>_compositeShader.uniforms.bloomStrength.value)),
                this.set("compositeSTR", (c=>{
                        _compositeShader.uniforms.bloomStrength.value = c
                    }
                )),
                this.get("compositeRadius", (_=>_compositeShader.uniforms.bloomRadius.value)),
                this.set("compositeRadius", (c=>{
                        _compositeShader.uniforms.bloomRadius.value = c
                    }
                )),
                this.renderBloom = render,
                this.renderMesh = _mesh,
                this.onDestroy = function() {
                    _renderTargetsHorizontal.forEach((r=>r.destroy())),
                        _renderTargetsVertical.forEach((r=>r.destroy())),
                    _this.renderTargetBright && _this.renderTargetBright.destroy()
                }
                ,
                this.getRTs = function() {
                    _this.renderTargetBright = RTPool.instance().getRT();
                    for (let i = 0; i < _nMips; i++)
                        _renderTargetsHorizontal.push(RTPool.instance().getRT()),
                            _renderTargetsVertical.push(RTPool.instance().getRT()),
                            _compositeShader.uniforms[`blurTexture${i + 1}`].value = _renderTargetsVertical[i].texture;
                    _this.outputTexture = _renderTargetsHorizontal[0].texture,
                        _this.uniforms.tUnrealBloom.value = _renderTargetsHorizontal[0].texture,
                        resizeHandler()
                }
                ,
                this.putRTs = function() {
                    _this.renderTargetBright && RTPool.instance().putRT(_this.renderTargetBright),
                        _this.renderTargetBright = null;
                    for (let i = 0; i < _renderTargetsHorizontal.length; i++)
                        RTPool.instance().putRT(_renderTargetsHorizontal[i]),
                            RTPool.instance().putRT(_renderTargetsVertical[i]);
                    _renderTargetsHorizontal = [],
                        _renderTargetsVertical = []
                }
        }
    )),
    Class((function Video(_params) {
            Inherit(this, Component);
            const _this = this;
            let $video, _video, _loadingState, _handlers, _ready = Promise.create(), _loaded = Promise.create(), _initialPlay = !0;
            function startPreload() {
                return _loadingState = !0,
                    _ready
            }
            async function startPlayback() {
                _loadingState = !1,
                    await _ready,
                _initialPlay && (_initialPlay = !1,
                    _video.currentTime = _params.currentTime),
                    _video.play()
            }
            function getSource(src="") {
                return src.includes(["webm", "mp4", "ogv"]) || (src += "." + Device.media.video),
                    src
            }
            function progress(e) {
                _this.events.fire(Video.PROGRESS, e)
            }
            function timeupdate(e) {
                _this.events.fire(Video.UPDATE, e)
            }
            function play(e) {
                if (_loadingState)
                    return _loadingState = !1;
                _this.events.fire(Video.PLAY, e)
            }
            function pause(e) {
                _this.events.fire(Video.PAUSE, e)
            }
            function playing(e) {
                _this.events.fire(Video.PLAYING, e)
            }
            function ended(e) {
                _this.events.fire(Video.ENDED, e)
            }
            function waiting(e) {
                _this.events.fire(Video.WAITING, e)
            }
            function canplay(e) {
                loadeddata(),
                    _this.events.fire(Video.CANPLAY, e)
            }
            function loadeddata(e) {
                _video.readyState >= 2 && _ready.resolve(),
                _video.readyState >= 4 && _loaded.resolve()
            }
            !function initParam() {
                let defaults = {
                    muted: !0,
                    loop: !1,
                    autoplay: !1,
                    inline: !0,
                    controls: !1,
                    currentTime: 0,
                    playback: 1,
                    preload: !1,
                    width: 640,
                    height: 360,
                    events: []
                };
                _params = Object.assign(defaults, _params)
            }(),
                function init() {
                    return _video = document.createElement("video"),
                        _video.src = getSource(_params.src),
                        _video.setAttribute("crossorigin", "anonymous"),
                        _video.autoplay = _params.autoplay,
                        _video.loop = _params.loop,
                        _video.controls = _params.controls,
                        _video.height = _params.height,
                        _video.width = _params.width,
                        _video.defaultMuted = _params.muted,
                        _video.defaultPlaybackRate = _params.playback,
                        _video.preload = _params.preload,
                        _video.muted = _params.autoplay || _params.muted,
                        _video.setAttribute("webkit-playsinline", _params.inline),
                        _video.setAttribute("playsinline", _params.inline),
                        _video.setAttribute("autoplay", _params.autoplay),
                        _video.setAttribute("muted", _params.muted),
                    _params.loop && _video.setAttribute("loop", _params.loop),
                        _this.div = _video,
                        $video = $(_video),
                        _params.autoplay ? startPlayback() : _params.preload ? startPreload() : void 0
                }(),
                function addHandlers() {
                    _params.events.push("loadeddata"),
                        _handlers = {
                            play: play,
                            pause: pause,
                            ended: ended,
                            playing: playing,
                            progress: progress,
                            waiting: waiting,
                            timeupdate: timeupdate,
                            loadeddata: loadeddata,
                            canplay: canplay
                        },
                        _params.events.forEach((ev=>_video.addEventListener(ev, _handlers[ev], !0)))
                }(),
                this.set("loop", (bool=>_video.loop = bool)),
                this.get("loop", (()=>_video.loop)),
                this.set("src", (src=>{
                        src !== _video.src && (_video.src = getSource(src))
                    }
                )),
                this.get("src", (()=>_video.currentSrc)),
                this.set("volume", (v=>{
                        _video.muted = 0 === v,
                            _video.volume = v
                    }
                )),
                this.get("volume", (()=>_video.volume)),
                this.set("muted", (bool=>_video.muted = bool)),
                this.get("muted", (()=>_video.muted)),
                this.set("controls", (bool=>_video.controls = bool)),
                this.get("controls", (()=>_video.controls)),
                this.get("duration", (()=>_video.duration)),
                this.get("ended", (()=>_video.ended)),
                this.get("playback", (()=>_video.playbackRate)),
                this.get("time", (()=>_video.currentTime)),
                this.get("canRender", (()=>_video.readyState >= 2)),
                this.get("canPlayThrough", (()=>_video.readyState >= 4)),
                this.get("paused", (()=>_video.paused)),
                this.get("object", (()=>$video)),
                this.get("element", (()=>$video)),
                this.get("video", (()=>_video)),
                this.get("bufferedSeconds", (_=>_video.readyState < 2 ? 0 : _video.buffered.end(0) - _video.buffered.start(0))),
                this.load = async function() {
                    return startPreload()
                }
                ,
                this.play = async function() {
                    return startPlayback()
                }
                ,
                this.pause = function() {
                    _video.pause()
                }
                ,
                this.stop = function() {
                    _video.pause(),
                        _this.seek(0)
                }
                ,
                this.seek = function(t) {
                    if (_video.fastSeek)
                        return _video.fastSeek(t);
                    _video.currentTime = t
                }
                ,
                this.seekExact = function(t) {
                    _video.currentTime = t
                }
                ,
                this.ready = function() {
                    return _ready
                }
                ,
                this.loaded = function() {
                    return _loaded
                }
                ,
                this.onDestroy = function() {
                    _video.src = "",
                        _this.stop(),
                        function removeListeners() {
                            _params.events.forEach((ev=>_video.removeEventListener(ev, _handlers[ev], !0)))
                        }(),
                        _video = null
                }
        }
    ), (()=>{
            Video.PLAY = "hydra_video_play",
                Video.CANPLAY = "hydra_video_can_play",
                Video.PAUSE = "hydra_video_pause",
                Video.PROGRESS = "hydra_video_progress",
                Video.UPDATE = "hydra_video_update",
                Video.PLAYING = "hydra_video_playing",
                Video.ENDED = "hydra_video_ended",
                Video.WAITING = "hydra_video_waiting",
                Video.supportsVideoType = type=>{
                    let video;
                    return video || (video = document.createElement("video")),
                        video.canPlayType({
                            ogg: 'video/ogg; codecs="theora"',
                            h264: 'video/mp4; codecs="avc1.42E01E"',
                            webm: 'video/webm; codecs="vp8, vorbis"',
                            vp9: 'video/webm; codecs="vp9"',
                            hls: 'application/x-mpegURL; codecs="avc1.42E01E"'
                        }[type] || type)
                }
        }
    )),
    Class((function VideoTexture(_path, {loop: loop=!0, preload: preload=!0, autoplay: autoplay=!0, muted: muted=!0, firstFrame: firstFrame=!1}={}) {
            Inherit(this, Component);
            const _this = this;
            let _video;
            function update() {
                _video.canRender && (_this.videoTexture && (_this.texture.destroy(),
                    _this.texture = _this.videoTexture,
                    delete _this.videoTexture),
                _this.texture.image || (_this.texture.image = _video.video,
                    _this.texture.upload()),
                    _this.texture.loaded = _this.texture.needsUpdate = !0)
            }
            !function() {
                if (_path.includes(["jpg", "png"])) {
                    let noop = _=>{}
                    ;
                    _this.texture = Utils3D.getTexture(_path),
                        _this.video = {
                            play: noop,
                            pause: noop
                        }
                } else
                    _video = _this.initClass(Video, {
                        src: Assets.getPath(_path),
                        loop: loop,
                        preload: preload,
                        autoplay: autoplay,
                        muted: muted,
                        events: ["timeupdate", "playing", "ended"]
                    }),
                        _this.texture = new Texture,
                        _this.texture.format = Texture.RGBFormat,
                        _this.texture.minFilter = _this.texture.magFilter = Texture.LINEAR,
                        _this.texture.generateMipmaps = !1,
                        _this.texture.loaded = !1,
                        _this.video = _video,
                        _this.events.bubble(_video, Video.PLAYING),
                    firstFrame && (_this.videoTexture = _this.texture,
                        _this.texture = Utils3D.getTexture(firstFrame))
            }(),
                this.set("loop", (loop=>_video.loop = loop)),
                this.set("muted", (muted=>_video.muted = muted)),
                this.set("src", (src=>_video.src = Assets.getPath(src))),
                this.start = async function() {
                    _video && (_this.active = !0,
                        await _video.play(),
                        _this.startRender(update))
                }
                ,
                this.stop = function() {
                    _video && (_this.active = !1,
                        _video.pause(),
                        _this.stopRender(update))
                }
                ,
                this.seek = function(time) {
                    _video && _video.seek(time)
                }
                ,
                this.onInvisible = function() {
                    _this.active && _video.pause(),
                        VideoTexture.element().removeChild(_this.video.object, !0)
                }
                ,
                this.onVisible = function() {
                    _this.active && _video.play(),
                        VideoTexture.element().add(_this.video.object)
                }
                ,
                this.onDestroy = function() {
                    _this.texture.destroy(),
                        VideoTexture.element().removeChild(_this.video.object, !0)
                }
        }
    ), (_=>{
            var $element;
            VideoTexture.element = function() {
                return $element || (($element = Stage.create("VideoTextures")).setZ(-1),
                    Stage.add($element)),
                    $element
            }
        }
    )),
    Class((function SocketConnection(_server, _channel) {
            Inherit(this, Component);
            var _socket, _pingPong, _this = this, _fail = 0;
            function connect() {
                _this.pending = !1,
                    (_socket = new WebSocket(_server)).onopen = open,
                    _socket.onmessage = message,
                    _socket.onclose = close,
                    _socket.onerror = close,
                    _pingPong = setInterval(sendPing, 5e3)
            }
            function sendPing() {
                1 == _socket.readyState && _socket.send("ping")
            }
            function open(e) {
                _fail = 0,
                    _this.connected = !0,
                    _this.events.fire(SocketConnection.OPEN, {
                        socket: _this
                    }, !0),
                _channel && _this.send("register", {
                    channel: _channel
                })
            }
            function message(e) {
                if ("pong" == e.data || "ping" == e.data)
                    return;
                let data = JSON.parse(e.data)
                    , evt = data._evt;
                delete data._evt,
                    _this.events.fire(evt, data, !0)
            }
            function close(e) {
                _this.pending || _fail++ > 25 || (_this.connected = !1,
                    _this.pending = !0,
                    _this.events.fire(SocketConnection.CLOSE, {
                        socket: _this
                    }, !0),
                    _this.delayedCall(connect, 250),
                    clearTimeout(_pingPong))
            }
            this.connected = !1,
                async function() {
                    try {
                        connect()
                    } catch (e) {
                        await defer(),
                            _this.events.fire(SocketConnection.ERROR, {
                                socket: _this
                            }),
                            _this.delayedCall(connect, 250)
                    }
                }(),
                this.send = function(evt, data={}) {
                    if (!_this.connected)
                        return _this.delayedCall((_=>_this.send(evt, data)), 100);
                    data._evt = evt,
                    _socket && _socket.send(JSON.stringify(data))
                }
        }
    ), (_=>{
            SocketConnection.OPEN = "socket_connection_open",
                SocketConnection.CLOSE = "socket_connection_close",
                SocketConnection.ERROR = "socket_connection_error"
        }
    )),
    Class((function CalendarUtils() {
            Inherit(this, Component);
            this.formatDate = function(date) {
                return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][date.getMonth()].slice(0, 3) + " - " + date.getDate() + " - " + date.getFullYear()
            }
                ,
                this.formatTime = function(date) {
                    let meridian, hours = date.getHours();
                    hours > 12 ? (hours %= 12,
                        meridian = "PM") : meridian = "AM",
                    hours < 10 && (hours = `0${hours}`);
                    let mins = date.getMinutes();
                    return mins < 10 && (mins = `0${mins}`),
                        `${hours}:${mins} ${meridian} ${date.toLocaleDateString("en-US", {
                            day: "2-digit",
                            timeZoneName: "short"
                        }).slice(4)}`
                }
        }
    ), "static"),
    Class((function CanvasDraw() {
            Inherit(this, Component);
            var _canvas, _context, _this = this;
            let _last = new Vector2(Stage.width / 2,Stage.height / 2)
                , _last2 = new Vector2(Stage.width / 2,Stage.height / 2)
                , _move = new Vector2(Stage.width / 2,Stage.height / 2)
                , _rlast = new Vector2(Stage.width / 2,Stage.height / 2)
                , _rlast2 = new Vector2(Stage.width / 2,Stage.height / 2)
                , _rmove = new Vector2(Stage.width / 2,Stage.height / 2);
            var _rMouse = new Vector2
                , _rMouseConvert = new Vector2
                , _center = new Vector2(Stage.width,Stage.height);
            let _calc = new Vector2;
            var $container, $line, $text, _width = 1 * Stage.width, _height = 1 * Stage.height;
            function initCanvas() {
                _canvas && (_canvas = _canvas.destroy()),
                    _canvas = _this.initClass(Canvas, _width, _height),
                    (_context = _canvas.context).strokeStyle = Global.INVERT ? "#888888" : "#ffffff",
                    _context.lineWidth = 1,
                    _canvas.element.mouseEnabled(!1),
                    $container.add(_canvas.element),
                _this.visible || _canvas.element.hide()
            }
            function loop() {
                let range = _this.multiplayer ? 20 : 40
                    , distance = _calc.subVectors(_last2, Mouse).length();
                distance > range && (_move.copy(Mouse),
                    drawLine(),
                    _last2.copy(_move)),
                _this.multiplayer && (_rMouse.copy(Multiplayer.REMOTE_MOUSE),
                    _rMouseConvert.x = Stage.width * _rMouse.x,
                    _rMouseConvert.y = Stage.height * _rMouse.y,
                    distance = _calc.subVectors(_rlast2, _rMouseConvert).length(),
                distance > range && (_rmove.copy(_rMouseConvert),
                    function drawRemoteLine() {
                        if (!_canvas)
                            return;
                        _context.strokeStyle = Multiplayer.REMOTE_COLOR.getHexString(),
                            _context.beginPath(),
                            _context.moveTo(_rlast.x * (_width / Stage.width), _rlast.y * (_height / Stage.height)),
                            _context.lineTo(_rmove.x * (_width / Stage.width), _rmove.y * (_height / Stage.height)),
                            _context.stroke(),
                            _rlast.copy(_rmove)
                    }(),
                    _rlast2.copy(_rmove)))
            }
            function resize() {
                _width = 1 * Stage.width,
                    _height = 1 * Stage.height,
                _canvas && _canvas.size(Stage.width, _width, _height)
            }
            function start() {
                clearTimeout(_this.autoDelay)
            }
            function end() {
                clearTimeout(_this.autoDelay),
                _this.multiplayer || (_this.autoDelay = _this.delayedCall(randomLine, 3e3))
            }
            function randomLine() {
                _move.x = _last.x + Math.random(-Stage.width * Math.range(_last.x, 0, Stage.width, 0, .3), Stage.width * Math.range(_last.x, 0, Stage.width, .3, 0)),
                    _move.y = _last.y + Math.random(-Stage.height * Math.range(_last.y, 0, Stage.height, 0, .3), Stage.height * Math.range(_last.y, 0, Stage.height, .3, 0)),
                    drawLine(),
                    clearTimeout(_this.autoDelay),
                    _this.autoDelay = _this.delayedCall(randomLine, Math.random(200, 800))
            }
            function drawLine() {
                _canvas && (_context.strokeStyle = Global.INVERT ? "#888888" : _this.multiplayer && Multiplayer.PLAYER_COLOR && Multiplayer.PLAYER_COLOR.getHexString && Multiplayer.PLAYER_COLOR.getHexString() || "#ffffff",
                    _context.beginPath(),
                    _context.moveTo(_last.x * (_width / Stage.width), _last.y * (_height / Stage.height)),
                    _context.lineTo(_move.x * (_width / Stage.width), _move.y * (_height / Stage.height)),
                    _context.stroke(),
                    _last.copy(_move))
            }
            function clear() {
                _canvas.clear()
            }
            !function initContainer() {
                if (($container = Stage.create(".CanvasDraw-Container")).size("100%").hide().mouseEnabled(!1),
                    Config.TEASER)
                    $container.setZ(2).css({
                        opacity: .8
                    });
                else {
                    $container.setZ(5),
                        ($line = $container.create(".line")).size("100%", 2).bg("#fff").css({
                            top: 3
                        }).hide();
                    let size = Device.mobile.phone ? 26 : 30
                        , top = Config.OFFSET - 8;
                    Device.mobile.phone && Stage.width < Stage.height && (top += 50),
                        ($text = $container.create("countdown")).fontStyle(Config.FONTS.serif, size, "#fff"),
                        $text.size(size, size).center(1, 0).css({
                            fontStyle: "italic",
                            top: top
                        })
                }
            }(),
                initCanvas(),
                function addHandlers() {
                    _this.events.sub(Mouse.input, Interaction.START, start),
                        _this.events.sub(Mouse.input, Interaction.END, end),
                        _this.events.sub(Mouse.input, Interaction.MOVE, end),
                        _this.events.sub(Events.RESIZE, resize)
                }(),
                this.animateIn = function(multiplayer) {
                    _this.visible || (_this.visible = !0,
                        _this.multiplayer = multiplayer,
                    Device.mobile || (_last.copy(Mouse),
                        _move.copy(Mouse),
                        _last2.copy(Mouse)),
                    multiplayer && (_center.set(Stage.width / 2, Stage.height / 2),
                        _last.copy(_center),
                        _move.copy(_center),
                        _last2.copy(_center),
                        _rMouse.copy(_center),
                        _rlast.copy(_center),
                        _rmove.copy(_center),
                        _rlast2.copy(_center),
                        $text.time = Config.DRAW_TIMER / 1e3,
                        $text.text($text.time).css({
                            opacity: 0
                        }).tween({
                            opacity: 1
                        }, 1e3, "easeOutSine"),
                        _this.countdown = setInterval((_=>{
                                $text.time -= 1,
                                    $text.text($text.time).css({
                                        opacity: .7
                                    }).tween({
                                        opacity: 1
                                    }, 1e3, "easeOutSine")
                            }
                        ), 1e3),
                        $line.show().transform({
                            scaleX: 1
                        }).tween({
                            scaleX: 0
                        }, Config.DRAW_TIMER, "linear").onComplete((_=>{
                                clearInterval(_this.countdown),
                                    $text.tween({
                                        opacity: 0
                                    }, 500, "easeOutSine")
                            }
                        ))),
                        _this.startRender(loop),
                        clear(),
                        clearTimeout(_this.autoDelay),
                    Device.mobile && !_this.multiplayer && (_this.autoDelay = _this.delayedCall(randomLine, 2e3)),
                        _canvas.element.show(),
                        $container.show(),
                        _canvas.element.css({
                            opacity: 0
                        }).tween({
                            opacity: _this.multiplayer ? 1 : .4
                        }, 2e3, "easeInOutSine"))
                }
                ,
                this.animateOut = function() {
                    _this.visible && (_this.visible = !1,
                        clearTimeout(_this.autoDelay),
                        _this.stopRender(loop),
                        _canvas.element.tween({
                            opacity: 0
                        }, 500, "easeOutSine", (_=>{
                                _canvas.element.hide(),
                                    $container.hide(),
                                    $line.hide()
                            }
                        )))
                }
                ,
                this.resize = function() {
                    clearTimeout(_this.resizeDelay),
                        _this.resizeDelay = _this.delayedCall((_=>{
                                _width = 1 * Stage.width,
                                    _height = 1 * Stage.height,
                                    initCanvas()
                            }
                        ), 200)
                }
                ,
                this.clear = clear,
                this.get("container", (()=>$container))
        }
    ), "singleton"),
    Class((function CurveDistance(_points, _precision=50) {
            Inherit(this, Component);
            const _this = this;
            var _curve = new Curve(_points)
                , _curvePoints = _curve.curve.getPoints(_precision);
            _this.points = _points,
                _this.curvePoints = _curvePoints,
            Utils.query("debugCurve") && _this.parent.scene.add(_curve.debug()),
                this.getPoint = function(t) {
                    return _curve.getPoint(t)
                }
                ,
                this.getNearest = function(position) {
                    return _curvePoints.reduce(((nearest,point,i)=>position.distanceTo(point) < position.distanceTo(nearest) ? point : nearest), _curvePoints[0])
                }
                ,
                this.getNearestDistance = function(position) {
                    return _this.getNearest(position).distanceTo(position)
                }
        }
    )),
    Class((function Keyboard() {
            Inherit(this, Component);
            const _this = this;
            var _pressedKeys = {};
            const config = {
                layouts: {
                    qwerty: {
                        up: [38, 87],
                        down: [40, 83],
                        left: [37, 65],
                        right: [39, 68],
                        panLeft: [81],
                        panRight: [69]
                    },
                    azerty: {
                        up: [38, 90],
                        down: [40, 83],
                        left: [37, 81],
                        right: [39, 68],
                        panLeft: [81],
                        panRight: [69]
                    }
                }
            };
            function getKeyLayout(val) {
                return "number" == typeof val ? keyCodeToKeyName(val) : "string" == typeof val ? function keyNameToKeyCodes(keyName) {
                    let keyCodes = keycode(keyName);
                    const layout = _this.isQwerty ? "qwerty" : "azerty"
                        , multipleKeyCodes = config.layouts[layout][keyName];
                    multipleKeyCodes && (keyCodes = multipleKeyCodes);
                    return isArray(keyCodes) ? keyCodes : [keyCodes]
                }(val) : function isObject(val) {
                    return val === Object(val) && !isArray(val)
                }(val) && void 0 !== val.keyCode ? keyCodeToKeyName(val.keyCode) : void 0
            }
            function keyCodeToKeyName(keyCode) {
                let name = keycode(keyCode);
                const layout = _this.isQwerty ? "qwerty" : "azerty"
                    , keyCodesLayout = config.layouts[layout];
                for (const keyName in keyCodesLayout) {
                    if (-1 !== keyCodesLayout[keyName].indexOf(keyCode)) {
                        name = keyName;
                        break
                    }
                }
                return name
            }
            function isArray(val) {
                return !(!val || val.constructor !== Array)
            }
            function onKeyDown(ev) {
                _this.downNow = (new Date).getTime(),
                    _pressedKeys[event.keyCode] = !0;
                const layoutKey = getKeyLayout(event)
                    , originalKey = keycode(event);
                _this.events.fire(_this.DOWNED, {
                    event: event,
                    layoutKey: layoutKey,
                    originalKey: originalKey
                })
            }
            function onKeyUp(ev) {
                const now = (new Date).getTime();
                _this.pressDuration = now - this.downNow,
                    delete _pressedKeys[event.keyCode];
                const layoutKey = getKeyLayout(event)
                    , originalKey = keycode(event);
                _this.events.fire(_this.UPPED, {
                    event: event,
                    layoutKey: layoutKey,
                    originalKey: originalKey
                })
            }
            function onWindowBlur(e) {
                "blur" == e.type && function resetInputs() {
                    _pressedKeys = {}
                }()
            }
            !async function() {
                Hydra.ready((async _=>{
                        _this.UPPED = "keyboard_upped",
                            _this.DOWNED = "keyboard_downed",
                            _this.binded = !1,
                            _this.isQwerty = !0,
                            _pressedKeys = {},
                            function addListeners() {
                                if (_this.binded)
                                    return;
                                __window.keydown(onKeyDown),
                                    __window.keyup(onKeyUp),
                                    _this.events.sub(Events.VISIBILITY, onWindowBlur),
                                    _this.binded = !0
                            }()
                    }
                ))
            }(),
                _this.isDown = function(name) {
                    let isDown = !1;
                    const keyCodes = getKeyLayout(name);
                    for (let i = 0, l = keyCodes.length; i < l; i++) {
                        const keyCode = keyCodes[i];
                        if (_pressedKeys[keyCode]) {
                            isDown = !0;
                            break
                        }
                    }
                    return isDown
                }
                ,
                _this.update = (time,delta)=>{
                    _this.render()
                }
        }
    ), "static"),
    keyCode.isEventKey = function isEventKey(event, nameOrCode) {
        if (event && "object" == typeof event) {
            var keyCode = event.which || event.keyCode || event.charCode;
            if (null == keyCode)
                return !1;
            if ("string" == typeof nameOrCode) {
                var foundNamedKey;
                if (foundNamedKey = codes[nameOrCode.toLowerCase()])
                    return foundNamedKey === keyCode;
                if (foundNamedKey = aliases[nameOrCode.toLowerCase()])
                    return foundNamedKey === keyCode
            } else if ("number" == typeof nameOrCode)
                return nameOrCode === keyCode;
            return !1
        }
    }
;
var codes = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    "pause/break": 19,
    "caps lock": 20,
    esc: 27,
    space: 32,
    "page up": 33,
    "page down": 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    insert: 45,
    delete: 46,
    command: 91,
    "left command": 91,
    "right command": 93,
    "numpad *": 106,
    "numpad +": 107,
    "numpad -": 109,
    "numpad .": 110,
    "numpad /": 111,
    "num lock": 144,
    "scroll lock": 145,
    "my computer": 182,
    "my calculator": 183,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
}
    , aliases = {
    windows: 91,
    "⇧": 16,
    "⌥": 18,
    "⌃": 17,
    "⌘": 91,
    ctl: 17,
    control: 17,
    option: 18,
    pause: 19,
    break: 19,
    caps: 20,
    return: 13,
    escape: 27,
    spc: 32,
    spacebar: 32,
    pgup: 33,
    pgdn: 34,
    ins: 45,
    del: 46,
    cmd: 91
};
/*!
   * Programatically add the following
   */
for (i = 97; i < 123; i++)
    codes[String.fromCharCode(i)] = i - 32;
for (var i = 48; i < 58; i++)
    codes[i - 48] = i;
for (i = 1; i < 13; i++)
    codes["f" + i] = i + 111;
for (i = 0; i < 10; i++)
    codes["numpad " + i] = i + 96;
var names = {};
for (i in codes)
    names[codes[i]] = i;
for (var alias in aliases)
    codes[alias] = aliases[alias];
window.keycode = keyCode;
const LOGGERS = []
    , keyStyles = color=>`background: ${color}; color: #FFFFFF; padding: 3px 10px; font-weight: bold; border-radius: 10px; font-familly: 'monospace';`
    , forceLog = Utils.query("verbose");
function createLogger(key="Global", color="#007bff", enable=!0) {
    forceLog && (enable = !0);
    const logger = {
        enabled: !!enable,
        key: key,
        color: color,
        log(...args) {
            const finalArgs = [];
            finalArgs.push(`%c${key}`),
                finalArgs.push(keyStyles(color)),
                finalArgs.push(...args),
            enable && Utils.query("addDebug") && console.log.apply(console, finalArgs)
        }
    };
    return LOGGERS.push(logger),
        logger.log
}
function getLogger(key, color, enable=!0) {
    for (let i = 0, l = LOGGERS.length; i < l; i++) {
        const LOGGER = LOGGERS[i];
        if (LOGGER.key === key && LOGGER.color === color)
            return LOGGER.log
    }
    return createLogger(key, color, enable)
}
forceLog && console.log("#### Force log enabled ####"),
    window.getLogger = getLogger,
    Math.modAbs = function(val, length) {
        return val < 0 && (val = length + val % length),
            val >= length ? val % length : val
    }
    ,
    Math.lerpAngle = function(a, b, t) {
        let delta = Math.modAbs(b - a, 2 * Math.PI);
        return delta > Math.PI && (delta -= 2 * Math.PI),
        a + delta * Math.clamp(t, 0, 1)
    }
    ,
    Math.polarToCartesian = function(vectorLength, vectorDirection) {
        return {
            x: vectorLength * Math.cos(vectorDirection),
            y: vectorLength * Math.sin(vectorDirection)
        }
    }
    ,
    Class((function SceneDebug() {
            Inherit(this, Component);
            const _this = this;
            var _config, _current, _quad;
            !async function() {
                Hydra.LOCAL && (await async function initConfig() {
                    await UIL.ready(),
                        (_config = InputUIL.create("SceneDebug")).setLabel("SceneDebug"),
                        _config.group.open(),
                        UIL.add(_config),
                        _config.addButton("reset", {
                            hideLabel: !0,
                            actions: [{
                                title: "Reset",
                                callback: ()=>{
                                    _quad.shader.set("tMap", null),
                                        _quad.visible = !1
                                }
                            }]
                        })
                }(),
                    function initQuad() {
                        (_quad = new Mesh(World.QUAD,new Shader("ScreenQuad",{
                            tMap: {
                                value: null
                            },
                            depthTest: !1,
                            depthWrite: !1
                        }))).renderOrder = 999999,
                            _quad.visible = !1,
                            World.SCENE.add(_quad)
                    }(),
                    _this.isReady = !0)
            }(),
                this.add = async function(name, scene) {
                    if (!Hydra.LOCAL)
                        return;
                    await _this.ready();
                    _config.addButton(name, {
                        hideLabel: !0,
                        actions: [{
                            title: name,
                            callback: ()=>{
                                _quad.visible = _current != scene || !_quad.visible,
                                    _current = scene,
                                    _quad.shader.set("tMap", scene)
                            }
                        }]
                    })
                }
                ,
                this.ready = async function() {
                    await _this.wait(_this, "isReady")
                }
        }
    ), "singleton"),
    Class((function Tests() {
            this.showFallback = function() {
                return !Device.graphics.webgl || !!GPU.BLACKLIST
            }
                ,
                this.getDPR = function() {
                    let dpr = Math.min(Device.pixelRatio, 2.5);
                    return GPU.OVERSIZED ? .8 : GPU.lt(0) ? .75 : GPU.lt(1) ? Math.min(dpr, .9) : GPU.lt(2) ? Math.min(dpr, 1) : GPU.lt(3) ? Math.min(dpr, 1.3) : GPU.lt(4) ? Math.min(dpr, 1.6) : GPU.lt(5) ? Math.min(dpr, 2) : Device.mobile && Device.mobile.tablet && GPU.mobileLT(1) ? .6 : GPU.mobileLT(0) ? 1 : GPU.mobileLT(1) || "linux" == Device.system.os ? Math.min(dpr, 1) : GPU.mobileLT(2) ? Math.min(dpr, 1.1) : GPU.mobileLT(3) ? Math.min(dpr, 1.2) : GPU.mobileLT(4) ? Math.min(dpr, 1.3) : 1
                }
                ,
                this.webglCanvasDraw = function() {
                    return !1
                }
                ,
                this.useBloom = function() {
                    return !1
                }
                ,
                this.useWindGrass = function() {
                    return !1
                }
                ,
                this.getBloomMips = function() {
                    return 2
                }
                ,
                this.getBloomDPR = function() {
                    return 1
                }
                ,
                this.getGrassFar = function() {
                    return GPU.lt(1) ? 45 : GPU.lt(2) ? 50 : GPU.lt(3) ? 60 : GPU.lt(4) ? 70 : GPU.lt(5) ? 80 : 50
                }
                ,
                this.getPreviewDPR = function() {
                    return GPU.lt(0) || GPU.mobileLT(0) ? .6 : Device.mobile && Device.mobile.tablet && GPU.mobileLT(1) ? .55 : GPU.mobileLT(1) ? .6 : GPU.lt(1) ? .65 : .7
                }
                ,
                this.getWaterFloorTesselation = function() {
                    return Device.mobile && Device.mobile.tablet && GPU.mobileLT(1) ? 20 : GPU.lt(1) || GPU.mobileLT(1) ? 25 : GPU.lt(2) || GPU.mobileLT(2) ? 40 : GPU.lt(3) || GPU.mobileLT(3) ? 50 : (GPU.lt(4) || GPU.mobileLT(4),
                        60)
                }
                ,
                this.drawFBM = function() {
                    return !(Device.mobile && Device.mobile.tablet && GPU.mobileLT(1)) && (!GPU.mobileLT(0) && (!GPU.mobileLT(1) && (!GPU.lt(0) && "linux" != Device.system.os)))
                }
                ,
                this.useFlowers = function() {
                    return !GPU.mobileLT(0) && !(Device.mobile && Device.mobile.tablet && GPU.mobileLT(1))
                }
                ,
                this.compassFloorFxEnabled = function() {
                    return !GPU.mobileLT(0) && (!GPU.mobileLT(1) && (!GPU.lt(0) && !GPU.lt(1)))
                }
                ,
                this.lobbyPortalPreview = function() {
                    return !GPU.mobileLT(1) && (!GPU.lt(0) && ("linux" != Device.system.os || "firefox" != Device.system.browser))
                }
                ,
                this.lobbyCanvasEnabled = function() {
                    if (!Device.mobile)
                        return !GPU.mobileLT(0) && (!GPU.lt(3) && (("linux" != Device.system.os || "firefox" != Device.system.browser) && "chrome" === Device.system.browser))
                }
                ,
                this.useFXAA = function() {
                    return !GPU.mobileLT(1) && !GPU.lt(0)
                }
                ,
                this.renderMirror = function() {
                    return !0
                }
                ,
                this.getFluidScenesResolution = function() {
                    return GPU.lt(0) || GPU.mobileLT(0) ? .1 : GPU.lt(1) || GPU.mobileLT(1) ? .18 : GPU.lt(2) || GPU.mobileLT(2) ? .25 : .5
                }
                ,
                this.waterMirrorSize = function() {
                    return GPU.mobileLT(0) || GPU.mobileLT(1) ? 128 : GPU.mobileLT(2) ? 256 : GPU.mobileLT(3) ? 512 : GPU.lt(0) ? 128 : GPU.lt(1) || GPU.lt(2) ? 256 : 512
                }
                ,
                this.useWaterFluid = function() {
                    return !0
                }
                ,
                this.useEnv5Fluid = function() {
                    return !0
                }
                ,
                this.useEnv4Fluid = function() {
                    return !0
                }
                ,
                this.useEnv3Fluid = function() {
                    return !0
                }
                ,
                this.getGrassNumberCoef = function() {
                    return Utils.query("grassCoef") ? parseInt(Utils.query("grassCoef"), 10) : GPU.mobileGT(4) ? 4 : GPU.mobileGT(3) ? 3 : GPU.gt(4) ? 7 : GPU.gt(3) ? 5 : GPU.gt(2) ? 3 : (GPU.gt(1),
                        2)
                }
                ,
                this.env3HasAmbientParticles = function() {
                    return !GPU.mobileLT(1) && !(Device.mobile && Device.mobile.tablet && GPU.mobileLT(1))
                }
                ,
                this.getEnv3AmbientParticlesDensity = function() {
                    return Device.mobile && Device.mobile.tablet && GPU.mobileLT(1) || GPU.mobileLT(0) ? 21666 : GPU.mobileLT(1) ? 32500 : GPU.lt(0) ? 16250 : GPU.lt(1) ? 65e3 / 3 : GPU.lt(2) ? 32500 : 65e3
                }
                ,
                this.getEnv4AmbientParticlesDensity = function() {
                    return Device.mobile && Device.mobile.tablet && GPU.mobileLT(1) || GPU.mobileLT(0) ? 21666 : GPU.mobileLT(1) ? 32500 : GPU.lt(0) ? 16250 : GPU.lt(1) ? 65e3 / 3 : GPU.lt(2) ? 32500 : 65e3
                }
                ,
                this.getPatchDensity = function() {
                    return GPU.lt(0) ? 1 / 60 : GPU.lt(1) ? 1 / 30 : GPU.lt(2) ? 1 / 16 : GPU.mobileLT(0) ? 1 / 60 : GPU.mobileLT(1) ? .02 : GPU.mobileLT(2) ? 1 / 16 : 1 / 8
                }
                ,
                this.getEnv5FarPlane = function() {
                    return GPU.lt(0) || GPU.mobileLT(0) ? 80 : GPU.lt(1) || GPU.mobileLT(1) ? 100 : GPU.lt(2) || GPU.mobileLT(2) ? 120 : 160
                }
                ,
                this.getEnv5RainCount = function() {
                    return GPU.lt(0) ? Math.round(4915.2) : GPU.lt(1) ? Math.round(8192) : GPU.mobileLT(2) ? Math.round(4915.2) : GPU.mobileLT(3) ? Math.round(8192) : 16384
                }
                ,
                this.getEnv5FallingCount = function() {
                    return GPU.lt(0) ? Math.round(1228.8) : GPU.lt(1) ? Math.round(2048) : GPU.mobileLT(2) ? Math.round(1228.8) : GPU.mobileLT(3) ? Math.round(2048) : 4096
                }
                ,
                this.getEnv5DancingSprites = function() {
                    return GPU.lt(0) ? Math.round(25) : GPU.lt(1) ? Math.round(35) : GPU.mobileLT(2) ? Math.round(25) : GPU.mobileLT(3) ? Math.round(35) : 50
                }
                ,
                this.hideEnv5Grass = function() {
                    return !(!GPU.lt(1) && !GPU.mobileLT(1))
                }
                ,
                this.getFlowerGrassDensity = function() {
                    return Device.mobile && Device.mobile.tablet && GPU.mobileLT(1) ? 400 : 600
                }
                ,
                this.hasBirds = function() {
                    return !GPU.lt(1) && !GPU.mobileLT(2)
                }
                ,
                this.hasBlowingLeaves = function() {
                    return !GPU.lt(1) && !GPU.mobileLT(2)
                }
                ,
                this.getBirdsCount = function() {
                    return GPU.mobileLT(3) || GPU.lt(2) ? 30 : 100
                }
                ,
                this.useFireworks = function() {
                    return !GPU.mobileLT(1)
                }
                ,
                this.hasFloorScribble = function() {
                    return !GPU.mobileLT(1) && !GPU.lt(2)
                }
                ,
                this.env5GrassHide = function() {
                    return GPU.lt(0) ? .1 : GPU.lt(1) ? .2 : GPU.lt(2) ? .5 : GPU.lt(3) ? .8 : GPU.mobileLT(2) ? .1 : GPU.mobileLT(3) ? .3 : GPU.mobileLT(4) ? .6 : 1
                }
                ,
                this.env5TreesHide = function() {
                    return GPU.lt(0) ? .25 : GPU.lt(1) ? .4 : GPU.lt(2) ? .6 : GPU.lt(3) ? .8 : GPU.mobileLT(2) ? .1 : GPU.mobileLT(3) ? .4 : GPU.mobileLT(4) ? .8 : 1
                }
        }
    ), "static"),
    Class((function TextAnimationUtil() {
            "_".split("");
            this.animate = function($text) {
                $text.animate = 0,
                    $text.textTo = $text.div.innerHTML,
                    tween($text, {
                        animate: 1
                    }, 1200, "easeOutSine").onUpdate((_=>{
                            let end = Math.ceil($text.textTo.length * $text.animate)
                                , animating = end < $text.textTo.length
                                , text = $text.textTo.slice(0, animating ? end - 1 : end);
                            animating && (text += "_"),
                                $text.html(text)
                        }
                    ))
            }
        }
    ), "Static"),
    Class((function LyricUtil() {
            Inherit(this, Component);
            var _this = this;
            _this.lyric = "",
                _this.typeLyric = "";
            function loop() {
                if (!PlayerController || !PlayerController.mainPlayer)
                    return;
                let room = PlayerController.mainPlayer.currentScene.name;
                if (!Lyrics[room])
                    return void ("⎌ Nurture ⎌" !== document.title && (document.title = "⎌ Nurture ⎌"));
                let lyrics = Lyrics[room];
                _this.color = lyrics.color,
                    _this.textColor = lyrics.text;
                let time = AudioPlayer.time;
                for (var i in "env5" == room && (time = Env5Level.videoTime),
                    lyrics) {
                    let lyric = lyrics[i]
                        , lyricTime = Number(i);
                    if (lyricTime < time && lyricTime + 1 > time && lyric !== _this.lyric) {
                        _this.typeLyric = "",
                            _this.lyric = lyric;
                        let local = !1;
                        _this.lyric.length > 0 && !local && console.log("%c" + _this.lyric, "background: " + _this.color + "; font-family: serif; font-style: italic; color: " + _this.textColor + "; letter-spacing: 0.1em; font-size: 12px; padding: 9px 12px 9px 10px;"),
                            typeLyric()
                    }
                }
                typeLyric()
            }
            function typeLyric() {
                let name = PlayerController.mainPlayer.currentScene.name;
                "clouds" == name && (name = "env4");
                let time = Config.TRACKS[name].trackTimeText;
                _this.typeLyric !== _this.lyric && (_this.typeLyric = _this.typeLyric + _this.lyric.charAt(_this.typeLyric.length)),
                    document.title = time + " " + _this.typeLyric.toString() + (_this.typeLyric !== _this.lyric ? "_" : "")
            }
            this.init = function init() {
                _this.startRender(loop, 12)
            }
        }
    ), "Static"),
    Class((function TrackAudioPlayer() {
            Inherit(this, Component);
            var _video, _this = this;
            async function changeScene({id: id, reset: reset}) {
                let roomID = id;
                switch (reset && (roomID = _this.id),
                _video && (_video.stop(),
                    _video = null),
                    roomID) {
                    case "main_room":
                    case "overlay":
                        tween(_this, {
                            volume: 0
                        }, 500, "easeOutSine").onUpdate(updateVolume).onComplete((_=>{
                                AudioPlayer.pause()
                            }
                        ));
                        break;
                    default:
                        if (AudioPlayer.volume = _this.volume = 0,
                            await defer(),
                        "env5" == roomID)
                            ;
                        else if (Config.TRACKS[roomID] && Config.TRACKS[roomID].audio) {
                            let time = Config.TRACKS[roomID].trackTime;
                            AudioPlayer.volume = _this.volume,
                                updateVolume(),
                                AudioPlayer.loop = !0,
                                AudioPlayer.play(Config.TRACKS[roomID].audio, time)
                        }
                }
                "overlay" !== roomID && (_this.id = roomID)
            }
            async function playTrack() {
                await defer(),
                    _this.volume = 0,
                    tween(_this, {
                        volume: .4
                    }, 3e3, "easeInOutSine", 500).onUpdate(updateVolume)
            }
            function updateVolume() {
                AudioPlayer.volume = _this.volume
            }
            _this.volume = 0,
                this.init = function init() {
                    !function addHandlers() {
                        _this.events.sub(LevelController.CHANGE_SCENE, changeScene),
                            _this.events.sub(AudioPlayer.PLAYING, playTrack)
                    }(),
                        updateVolume()
                }
        }
    ), "static"),
    Class((function TrackTimeUtil() {
            Inherit(this, Component);
            var _this = this
                , _now = new Date(2020,1,1)
                , _start = _now.getTime() + 60 * _now.getTimezoneOffset();
            function setTime() {
                for (var i in Config.TRACKS) {
                    let length = Config.TRACKS[i].trackLength
                        , current = (Date.now() + _start) / 1e3 % length;
                    "env5" == i && Global.ENV5_VIDEO_TIME && (current = Global.ENV5_VIDEO_TIME);
                    let remaining = length - current;
                    var minutes = Math.floor(remaining / 60)
                        , seconds = Math.floor(remaining - 60 * minutes);
                    seconds < 10 && (seconds = "0" + seconds);
                    var text = "-" + minutes + ":" + seconds;
                    Config.TRACKS[i].trackTime = current,
                        Config.TRACKS[i].trackTimeText = text
                }
                _this.events.fire(_this.UPDATE, Config.TRACKS)
            }
            _this.UPDATE = "update_time",
                async function() {
                    Config.TEASER_PRE || Config.TEASER || setInterval(setTime, 1e3)
                }()
        }
    ), "Static"),
    Class((function URLUtil() {
            this.removeParam = function(url, param) {
                let u = url.split("?");
                if (u.length >= 2) {
                    let prefix = encodeURIComponent(param) + "="
                        , pars = u[1].split(/[&;]/g);
                    for (let i = pars.length; i-- > 0; )
                        -1 !== pars[i].lastIndexOf(prefix, 0) && pars.splice(i, 1);
                    return url = u[0] + (pars.length > 0 ? "?" + pars.join("&") : "")
                }
                return url
            }
                ,
                this.addParam = function(url, param, value) {
                    let u = url.split("?")
                        , addedParam = encodeURIComponent(param) + "=" + value
                        , pars = u[1] ? u[1].split(/[&;]/g) : [];
                    return pars.push(addedParam),
                        url = u[0] + (pars.length > 0 ? "?" + pars.join("&") : "")
                }
                ,
                this.randomHash = function() {
                    return "xxxxxx".replace(/[xy]/g, (function(c) {
                            var r = 16 * Math.random() | 0;
                            return ("x" == c ? r : 3 & r | 8).toString(16)
                        }
                    ))
                }
        }
    ), "static"),
    Class((function Geo() {
            Inherit(this, Model);
            const _this = this;
            let _data;
            !async function() {
                await Hydra.ready(),
                    _data = await get(Config.GEO),
                    _this.dataReady = !0
            }(),
                this.data = function() {
                    return _data
                }
        }
    ), "static"),
    Class((function Multiplayer() {
            Inherit(this, Model);
            const _this = this;
            let _room, _prevRoom;
            _this.ROOM_READY = Promise.create(),
                _this.ON_DATA = "multiplayer_on_data",
                _this.PLAYER_JOINED = "multiplayer_player_join",
                _this.CONNECTION_LOST = "multiplayer_lost_connection";
            const info = getLogger("Multiplayer", "#01a3a4", Utils.query("debug") || !0);
            var _changedRoom = !1;
            function start() {
                GameCenter.userData = {
                    arbitrary: Date.now()
                },
                    GameCenter.ports = Config.GAMECENTER_PORTS,
                    GameCenter.connect(Config.GAMECENTER),
                    info("Me", GameCenter.userData)
            }
            async function connectRoom() {
                _this.lastDataNow = Date.now();
                let room = Hydra.LOCAL ? "testroom" : _changedRoom || _this.reconnect ? null : Utils.query("r");
                if (room)
                    try {
                        _room = await GameCenter.joinRoom("debug_" + room)
                    } catch (e) {
                        room && !Hydra.LOCAL && (_this.reconnect = !0,
                            alert(`⎌ The room ${room} is full ⎌`)),
                            window.history.replaceState({}, document.title, URLUtil.removeParam(location.href, "r")),
                            _this.delayedCall(connectRoom, 200)
                    }
                else {
                    async function getRoom() {
                        try {
                            return await GameCenter.findRoom()
                        } catch (e) {
                            return null
                        }
                    }
                    await async function getRoomOrRetry() {
                        let promise = Promise.create()
                            , room = null;
                        for (; !room; ) {
                            if (room)
                                return promise;
                            room = await getRoom(),
                            room && (_room = room,
                                promise.resolve(room))
                        }
                        return promise
                    }()
                }
                info("r", _room.id),
                    _this.lastDataNow = Date.now(),
                    _this.ROOM_READY.resolve(_room),
                PlayerController.mainPlayer && PlayerController.mainPlayer.connectRoom(_room),
                _prevRoom && _prevRoom.events && (_this.events.unsub(_prevRoom, GameCenter.DATA, data),
                    _this.events.unsub(_prevRoom, GameCenterRoom.PLAYER_JOIN, playerJoin),
                    _this.events.unsub(_prevRoom, GameCenterRoom.PLAYER_DISCONNECT, playerLeave),
                    _this.events.unsub(GameCenter.BROADCAST, broadcast)),
                    _this.events.sub(_room, GameCenter.DATA, data),
                    _this.events.sub(_room, GameCenterRoom.PLAYER_JOIN, playerJoin),
                    _this.events.sub(_room, GameCenterRoom.PLAYER_DISCONNECT, playerLeave),
                    _this.events.sub(GameCenter.BROADCAST, broadcast),
                    _this.events.sub(GameCenterRoom.ERROR, reconnect),
                    _prevRoom = _room,
                    _room.players.forEach((player=>{
                            player.me || info("Other player already here", player.data)
                        }
                    ))
            }
            async function reconnect() {
                _this.leave(),
                    await defer(),
                    _this.join()
            }
            function loop() {
                Date.now() - _this.lastDataNow > 5e3 && _this.isConnected && console.log("---------------- NO DATA FOR A WHILE")
            }
            async function lostConnection(e) {
                if (_this.connectionLost)
                    return;
                console.log("---------------------- LOST CONNECTION", e),
                    _this.events.fire(_this.CONNECTION_LOST, e),
                    _this.connectionLost = !0;
                let {reconnected: reconnected} = e;
                _this.events.fire(MultiplayerUI.DISCONNECTED),
                    await reconnected(),
                    await connectRoom(),
                    _this.connectionLost = !1
            }
            function data(e) {
                _this.lastDataNow = Date.now(),
                    _this.events.fire(_this.ON_DATA, e),
                e && e.data && e.data.position && !_this.isConnected && playerJoin(e),
                e.data && e.data.mouse && _this.REMOTE_MOUSE.copy(e.data.mouse),
                e.data && e.data.color && _this.REMOTE_COLOR.copy(e.data.color),
                e.data && e.data.location && (_this.REMOTE_LOCATION = e.data.location),
                e.data && e.data.admin && (_this.REMOTE_ADMIN = e.data.admin)
            }
            function broadcast(e) {}
            function playerJoin(e) {
                _this.isConnected = !0,
                    _this.events.fire(_this.PLAYER_JOINED, e),
                e.data && e.data.currentSceneId && PlayerController.onPlayerJoin(e),
                    _this.lastDataNow = Date.now()
            }
            function playerLeave(e) {
                _this.isConnected = !1,
                    _this.events.fire(_this.CONNECTION_LOST),
                    _this.events.fire(MultiplayerUI.DISCONNECTED)
            }
            function loop() {
                if (!_room)
                    return;
                let {mainPlayer: mainPlayer} = PlayerController;
                if (!mainPlayer)
                    return;
                let worldPos = mainPlayer.group.position
                    , worldRot = mainPlayer.group.getWorldQuaternion();
                _room && _room.broadcast && _room.broadcast({
                    position: {
                        x: worldPos.x,
                        y: worldPos.y,
                        z: worldPos.z
                    },
                    quaternion: {
                        x: worldRot.x,
                        y: worldRot.y,
                        z: worldRot.z,
                        w: worldRot.w
                    },
                    currentSceneId: mainPlayer.currentScene ? mainPlayer.currentScene.name : null,
                    mouse: {
                        x: Mouse.normal.x,
                        y: Mouse.normal.y
                    },
                    color: _this.PLAYER_COLOR,
                    location: _this.LOCATION,
                    admin: _this.PLAYER_ADMIN,
                    waterState: LevelController.getLevelState("water"),
                    grassState: LevelController.getLevelState("grass"),
                    env3State: LevelController.getLevelState("env3"),
                    env4State: LevelController.getLevelState("env4"),
                    env5State: LevelController.getLevelState("env5")
                })
            }
            !async function() {
                if (!Config.TEASER) {
                    if (await Hydra.ready(),
                        await Geo.ready(),
                        _this.LOCATION = Geo.data().location,
                        _this.REMOTE_MOUSE = new Vector2,
                        _this.REMOTE_COLOR = new Color,
                        _this.REMOTE_LOCATION = _this.LOCATION,
                        _this.PLAYER_COLOR = new Color("#ffffff"),
                        !Config.ADMIN) {
                        let hue = Math.random(0, 1, 3);
                        _this.PLAYER_COLOR.setHSL(hue, .88, .88)
                    }
                    if (_this.REMOTE_ADMIN = !1,
                        _this.PLAYER_ADMIN = Config.ADMIN,
                        start(),
                        LevelController.gameStarted.then(connectRoom),
                        function addListeners() {
                            _this.events.sub(GameCenter.LOST_CONNECTION, lostConnection)
                        }(),
                        _this.startRender(loop),
                        Utils.query("localsocket")) {
                        let msg = document.createElement("div");
                        msg.innerHTML = GameCenter.userData.arbitrary,
                            document.body.appendChild(msg),
                            msg.style.position = "fixed",
                            msg.style.left = "50px",
                            msg.style.bottom = "100px",
                            msg.style.color = "red"
                    }
                }
            }(),
                this.broadcast = function(data) {
                    GameCenter.broadcast(data)
                }
                ,
                this.linkMainPlayer = function(player) {
                    player.isLinked = !0,
                        _this.stopRender(loop),
                        _this.startRender(loop)
                }
                ,
                this.leave = function() {
                    _changedRoom = !0,
                    _room && _room.leave && _room.leave(),
                    _room && _room.destroy && _room.destroy(),
                        GameCenter.disconnect()
                }
                ,
                this.join = function() {
                    start(),
                        connectRoom()
                }
                ,
                this.rejoinRoom = function() {
                    _room && _room.leave && _room.leave(),
                        connectRoom()
                }
                ,
                _this.get("room", (_=>_room))
        }
    ), "static"),
    Class((function Container() {
            Inherit(this, Element);
            const _this = this
                , $this = this.element;
            (window.location.href.includes("tour") || Utils.query("tour")) && (Global.LOAD_TOUR = !0,
                Global.IN_TOUR = !0),
                function initHTML() {
                    Stage.add($this),
                        $this.css({
                            position: "static"
                        }),
                    Device.mobile && "ios" === Device.system.os && "chrome" === Device.system.browser && (document.title = "Nurture")
                }(),
                async function loadView() {
                    let loaderView = _this.initClass(LoaderView)
                        , loader = _this.initClass(AssetLoader, Assets.list().filter(["shaders", "data"]));
                    _this.events.sub(loader, Events.PROGRESS, loaderView.progress),
                        _this.events.sub(loader, Events.COMPLETE, (()=>{
                                LevelController.FIRST_SCENE_READY.then((()=>{
                                        Global.IN_TOUR || Container.SHOW_INSTRUCTIONS.resolve(),
                                            Container.LOADDER_HIDDEN.resolve(),
                                            loaderView.animateOut((()=>loaderView = loaderView.destroy()))
                                    }
                                ))
                            }
                        )),
                        await Initializer3D.createWorld(),
                        PlayerController.init(),
                        await PlayerController.ready(),
                        LevelController.init(),
                        await LevelController.ready(),
                        function initView() {
                            World.instance(),
                                $this.add(World.ELEMENT),
                                UI.instance().animateIn(),
                                _this.delayedCall(UI.instance().animateIn, 200),
                                TrackAudioPlayer.init(),
                                LyricUtil.init(),
                            Global.IN_TOUR && _this.delayedCall((_=>{
                                    UIOverlay.instance().animateIn("tour")
                                }
                            ), 500),
                            Global.LOAD_EUROPE && _this.delayedCall((_=>{
                                    UIOverlay.instance().animateIn("europe")
                                }
                            ), 500),
                            Utils.query("page") && _this.delayedCall((_=>{
                                    UIOverlay.instance().animateIn(Utils.query("page"))
                                }
                            ), 2e3)
                        }()
                }()
        }
    ), "singleton", (_=>{
            Container.LOADDER_HIDDEN = Promise.create(),
                Container.SHOW_INSTRUCTIONS = Promise.create()
        }
    )),
    Class((function EP() {
            Inherit(this, Element);
            const _this = this;
            let $this, _logo, _bg, _body, _nav, _link;
            function animateIn() {
                _bg && _bg.animateIn(),
                _body && _body.animateIn(),
                _nav && _nav.animateIn()
            }
            Global.EP = !0,
                function initHTML() {
                    $this = _this.element,
                        $this.css({
                            position: "static"
                        }),
                        Stage.add($this)
                }(),
                async function loadView() {
                    let loaderView = _this.initClass(LoaderView)
                        , loader = _this.initClass(AssetLoader, Assets.list().filter(["shaders", "data"]));
                    _this.events.sub(loader, Events.PROGRESS, loaderView.progress),
                        _this.events.sub(loader, Events.COMPLETE, (()=>{
                                loaderView.animateOut((()=>loaderView = loaderView.destroy()))
                            }
                        )),
                        await Initializer3D.createWorld(),
                        function initView() {
                            World.instance(),
                                $this.add(World.ELEMENT);
                            let index = Config.TEASER_NUM;
                            index = Number(index) - 1;
                            let path = Utils.query("path") ? "/" + Utils.query("path") : window.location.pathname;
                            "/preorder" == path && (path = "/nurture"),
                                Data.TEASER.forEach(((d,i)=>{
                                        d.link == path && (index = i)
                                    }
                                ));
                            let data = Data.TEASER[index];
                            data.link.includes(["musician", "unfold", "everythinggoeson"]) && (Global.INVERT = data.invert = !0);
                            let isSinglePage = data.link.includes(["everythinggoeson"]);
                            isSinglePage && $this.css({
                                overflowX: "hidden",
                                overflowY: "scroll",
                                height: "100%"
                            }),
                                _bg = _this.initClass(EPBackground, data),
                                World.SCENE.add(_bg.group),
                                _body = isSinglePage ? _this.initClass(EPSinglePage, data) : _this.initClass(EPArt, data),
                                _logo = _this.initClass(LogoUI, {
                                    fixed: isSinglePage
                                });
                            let linkIndex = index + 1;
                            "/preorder" == data.link && (linkIndex = -1),
                            "/order" == data.link && (linkIndex = -1),
                            "/nurture" == data.link && (linkIndex = -1),
                            "/lookatthesky" == data.link && (linkIndex = 3),
                            "/unfold" == data.link && (linkIndex = 4),
                            "/everythinggoeson" != data.link && (_nav = _this.initClass(UINav),
                            -1 !== linkIndex && (_link = _this.initClass(EPLink, Data.TEASER[linkIndex], [Stage])),
                            data.invert && (_logo.element.css({
                                filter: "invert(1)"
                            }),
                                _nav.element.css({
                                    filter: "invert(1)"
                                }),
                                Global.LOADER_VIEW.css({
                                    filter: "invert(1)"
                                }),
                                __body.bg("#ffffff")))
                        }(),
                        _this.delayedCall(animateIn, 500)
                }(),
                _this.last = Date.now()
        }
    ), "singleton"),
    Class((function Fallback() {
            Inherit(this, Element);
            const _this = this
                , $this = _this.element;
            var $wrapper;
            function resize() {
                Stage.width < 600 ? $wrapper.css({
                    maxWidth: 300
                }) : $wrapper.css({
                    maxWidth: 600
                })
            }
            !function initHTML() {
                $this.size("100%").css({
                    padding: 40,
                    boxSizing: "border-box",
                    opacity: 0
                }),
                    $this.create(".bg").size(1200, 628).bg("assets/meta/facebook.png").center().css({
                        opacity: .15
                    }),
                    $wrapper = $this.create("wrapper").size("100%").css({
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        justifyContent: "center",
                        maxWidth: 600,
                        textAlign: "center",
                        position: "relative",
                        margin: "0 auto",
                        fontFamily: "Nunito"
                    }),
                    $wrapper.create("title").css({
                        fontSize: 60,
                        position: "relative",
                        color: "white",
                        width: "100%"
                    }).text("Unsupported browser.").fontStyle(Config.FONTS.serif, Device.mobile.phone ? 38 : 50, "#fff"),
                    $wrapper.create("text").css({
                        position: "relative",
                        color: "white",
                        width: "100%",
                        marginTop: 30,
                        letterSpacing: "0.2em",
                        lineHeight: "2em",
                        textTransform: "uppercase"
                    }).html("Your browser or computer is too old.<br/>Please use a recent setup to see this experience.<br/>You may also have hardware acceleration turned off.").fontStyle(Config.FONTS.sansSerif, Device.mobile.phone ? 10 : 13, "#fff"),
                    Stage.add($this)
            }(),
                function addListeners() {
                    _this.onResize(resize)
                }(),
                defer((()=>{
                        UI.instance().animateIn(),
                            _this.animateIn()
                    }
                )),
                this.animateIn = async function() {
                    $this.tween({
                        opacity: 1
                    }, 2e3, "easeInOutSine", 1500)
                }
                ,
                this.animateOut = async function() {
                    $this.tween({
                        opacity: 0
                    }, 400, "easeInOutSine", 0)
                }
                ,
                this.toggle = function(state) {
                    state ? _this.animateIn() : _this.animateOut()
                }
        }
    ), "singleton"),
    Class((function DesktopControls() {
            Inherit(this, Component);
            const _this = this;
            var _panY, _panYTarget, _angleX, _angleXTarget, _isDown, _scroll, _offset = new Vector3, _lookAt = (new Vector3,
                new Vector3), _lookAtOffset = new Vector3, _lookAtOffsetTarget = new Vector3, _radiusSpeedCoef = 1, _lastDir = (new Vector2,
                new Vector2), _radius = 10, _radiusTarget = 10, _gazeConfig_angleX = .1, _gazeConfig_angleXLerp = .3, _gazeConfig_panY = -.05, _gazeAngleX = 0, _gazePanY = 0, _gazeCoef = 0, _yOffset = 1;
            new Vector3;
            function onPointerStart(event) {
                _this.parent.cameraAnimateIn || 0 !== event.button && "ie" !== Device.system.browser || (_isDown = !0,
                    document.body.style.cursor = "grabbing")
            }
            function onPointerEnd(event) {
                _this.parent.cameraAnimateIn || 0 !== event.button && "ie" !== Device.system.browser || (_isDown = !1,
                    document.body.style.cursor = "grab")
            }
            function onPointerLeave(event) {
                _this.parent.cameraAnimateIn || (_isDown = !1,
                    document.body.style.cursor = "grab")
            }
            function onPointerMove(event) {
                if (!_this.parent.cameraAnimateIn && _isDown) {
                    let amount = .01 * Mouse.delta.x * _radiusSpeedCoef;
                    _angleXTarget += amount,
                        _panYTarget += .02 * Mouse.delta.y * _radiusSpeedCoef
                }
            }
            function onKeyDown({layoutKey: layoutKey}) {
                _this.parent.cameraAnimateIn || "space" === layoutKey && _this.events.fire(GameControls.JUMP)
            }
            _panY = _panYTarget = 3,
                _angleX = _angleXTarget = Math.PI / 2,
                _scroll = Scroll.createUnlimited(),
                function addListeners() {
                    _this.events.sub(Mouse.input, Interaction.MOVE, onPointerMove),
                        _this.events.sub(Mouse.input, Interaction.START, onPointerStart),
                        _this.events.sub(Mouse.input, Interaction.END, onPointerEnd),
                        _this.events.sub(Keyboard, Keyboard.DOWNED, onKeyDown),
                        document.body.addEventListener("mouseleave", onPointerLeave, !1),
                    _this.parent.cameraAnimateIn || (document.body.style.cursor = "grab")
                }(),
                _this.updateParentInputs = function() {
                    _this.parent.up = Keyboard.isDown("up"),
                        _this.parent.down = Keyboard.isDown("down"),
                        _this.parent.left = Keyboard.isDown("left"),
                        _this.parent.right = Keyboard.isDown("right"),
                        _this.parent.run = Keyboard.isDown("shift") && Hydra.LOCAL,
                        _this.parent.panLeft = Keyboard.isDown("panLeft"),
                        _this.parent.panRight = Keyboard.isDown("panRight");
                    let {up: up, down: down, right: right, left: left, run: run, direction: direction, panLeft: panLeft, panRight: panRight} = _this.parent;
                    _this.parent.reset = !1,
                        direction.set(0, 0),
                        left ? direction.x = -1 : right && (direction.x = 1),
                        up ? direction.y = -1 : down && (direction.y = 1),
                    (Math.abs(_lastDir.x - direction.x) > 1.8 || Math.abs(_lastDir.y - direction.y) > 1.8) && (_this.parent.dirChange = !0),
                        _this.parent.noDirection = !(up || down || left || right),
                        _lastDir.copy(direction)
                }
                ,
                _this.update = function(time, delta) {
                    let {mainPlayer: mainPlayer} = PlayerController;
                    if (!_this.parent.cameraAnimateIn) {
                        _this.updateParentInputs(),
                            _radiusTarget += .005 * _scroll.delta.y,
                        _this.parent.panRight && (_angleXTarget -= .03),
                        _this.parent.panLeft && (_angleXTarget += .03),
                            _radiusTarget = Math.clamp(_radiusTarget, 3.5, 12),
                        _this.parent.noDirection || (_radiusTarget < 10 && (_radiusTarget += .2),
                            _panYTarget > 4 ? _panYTarget -= .2 : _panYTarget < 2.5 && (_panYTarget += .1),
                        _lookAtOffsetTarget > 0 && (_lookAtOffsetTarget.y = Math.max(_lookAtOffsetTarget.y - .1, 0)));
                        let maxPanY = 12;
                        mainPlayer && mainPlayer.currentScene && mainPlayer.currentScene.playerConfig.maxPanY && (maxPanY = mainPlayer.currentScene.playerConfig.maxPanY),
                            _panYTarget = Math.clamp(_panYTarget, 1.5, maxPanY),
                            _radiusSpeedCoef = Math.range(_radius, 0, 7, .1, 1, !0),
                            _radius = Math.lerp(_radiusTarget, _radius, .1);
                        let {cameraAngle: cameraAngle} = mainPlayer
                            , gazeAngleX = Mouse.tilt.x * _gazeConfig_angleX * _radiusSpeedCoef * _gazeCoef;
                        MultiplayerOverlay.instance().visible && (gazeAngleX = 0),
                            _gazeAngleX = Math.lerp(gazeAngleX, _gazeAngleX, _gazeConfig_angleXLerp),
                            _angleX = Math.lerp(_angleXTarget + _gazeAngleX, _angleX, .1);
                        let gazePanY = Mouse.tilt.y * _gazeConfig_panY * _radiusSpeedCoef * _gazeCoef;
                        MultiplayerOverlay.instance().visible && (gazePanY = 0),
                            _gazePanY = Math.lerp(gazePanY, _gazePanY, _gazeConfig_angleXLerp),
                            _panY = Math.lerp(_panYTarget, _panY, .1),
                            _panY += _gazePanY
                    }
                    _offset.x = _radius * Math.cos(_angleX + _this.endRotationOffset),
                        _offset.z = _radius * Math.sin(_angleX + _this.endRotationOffset),
                        _offset.y = _panY,
                        _lookAt.copy(mainPlayer.group.position),
                        _lookAtOffsetTarget.y = Math.range(_panY, 1.5, 4, 1.5, 0, !0),
                        _lookAtOffsetTarget.y += _yOffset,
                        _lookAtOffset.lerp(_lookAtOffsetTarget, .1),
                        _lookAt.add(_lookAtOffset)
                }
                ,
                _this.forcePanY = val=>{
                    _panYTarget = _panY = val
                }
                ,
                _this.forceAngleX = val=>{
                    _angleX = _angleXTarget = val
                }
                ,
                _this.set("angleX", (val=>{
                        _angleX = val
                    }
                )),
                _this.get("angleX", (_=>_angleX)),
                _this.set("radius", (val=>{
                        _radius = val
                    }
                )),
                _this.get("radius", (_=>_radius)),
                _this.set("panY", (val=>{
                        _panY = val
                    }
                )),
                _this.get("panY", (_=>_panY)),
                _this.set("gazeCoef", (val=>{
                        _gazeCoef = val
                    }
                )),
                _this.get("gazeCoef", (_=>_gazeCoef)),
                _this.set("yOffset", (val=>{
                        _yOffset = val
                    }
                )),
                _this.get("yOffset", (_=>_yOffset)),
                _this.get("offset", (_=>_offset)),
                _this.get("lookAt", (_=>_lookAt))
        }
    )),
    Class((function GameControls() {
            Inherit(this, Component);
            const _this = this;
            const V3 = new Vector3
                , DOWN_V3 = new Vector3(0,-1,0);
            function resize() {
                _this.controls.yOffset = Device.mobile.phone && Stage.width < Stage.height ? 1.5 : 1
            }
            _this.enable = !Utils.query("orbit"),
                _this.cameraAnimateIn = !Global.PLAYGROUND,
                _this.controls = _this.initClass(Device.mobile ? MobileControls : DesktopControls),
                _this.controls.endRotation = Math.radians(90),
                _this.controls.endRotationOffset = Math.radians(-180),
            _this.cameraAnimateIn && (_this.controls.panY = 45,
                _this.controls.angleX = _this.controls.endRotation + Math.radians(90),
                _this.controls.radius = 0,
                _this.controls.yOffset = -2,
                _this.controls.gazeCoef = 0,
                _this.controls.multiTween = !0,
                document.body.style.cursor = "default",
                Container.LOADDER_HIDDEN.then((_=>{
                        !function animateIn() {
                            let delay = Utils.query("skip") ? 1 : 2e3
                                , time = Utils.query("skip") ? 1 : 5e3;
                            LevelController.updateResolution("main_room"),
                                tween(_this.controls, {
                                    panY: 3
                                }, time, "easeInOutCubic", delay),
                                tween(_this.controls, {
                                    yOffset: Device.mobile ? 1.5 : 1
                                }, time, "easeInOutCubic", delay),
                                tween(_this.controls, {
                                    radius: Device.mobile ? 5 : 10
                                }, time, "easeInOutCubic", delay).onComplete((_=>{
                                        _this.cameraAnimateIn = !1,
                                            document.body.style.cursor = "grab"
                                    }
                                )),
                                tween(_this.controls, {
                                    angleX: _this.controls.endRotation
                                }, time + 1e3, "easeInOutQuint", delay - 1e3).onUpdate((_=>{
                                        Global.LINES && (Global.LINES.rotation = -Math.degrees(_this.controls.angleX),
                                            Global.LINES.transform())
                                    }
                                )),
                                tween(_this.controls, {
                                    gazeCoef: 1
                                }, 3e3, "easeInOutSine", delay - 2e3),
                            _this.controls.animateIn && _this.controls.animateIn(),
                                _this.events.fire(GameControls.ANIMATE_IN)
                        }()
                    }
                ))),
                function addListeners() {
                    _this.events.sub(Events.RESIZE, resize)
                }(),
                _this.up = !1,
                _this.down = !1,
                _this.left = !1,
                _this.right = !1,
                _this.direction = new Vector2,
                _this.run = !1,
                _this.noDirection = !0,
                _this.update = function(time, delta) {
                    if (!_this.enable || !_this.canControl)
                        return;
                    let {mainPlayer: mainPlayer} = PlayerController;
                    if (!mainPlayer)
                        return;
                    let camera = World.CAMERA;
                    _this.controls.update(time, delta);
                    let playerPos = mainPlayer.group.position;
                    camera.position.copy(playerPos).add(_this.controls.offset);
                    LevelController.raycaster;
                    if (LevelController.currentScene && LevelController.currentScene.floor) {
                        0;
                        let {floor: floor} = LevelController.currentScene;
                        V3.copy(camera.position),
                            V3.y += 2;
                        let intersects = LevelController.raycaster.checkFromValues([LevelController.currentScene.floor], V3, DOWN_V3);
                        intersects.length && (pt = intersects[0].point,
                        camera.position.y - pt.y < .1 && (camera.position.y = pt.y + .1,
                            _this.controls.forcePanY(camera.position.y - playerPos.y)))
                    }
                    World.CAMERA.lookAt(_this.controls.lookAt)
                }
                ,
                _this.get("canControl", (_=>!MultiplayerOverlay.instance().visible && !UIOverlay.instance().visible))
        }
    ), "singleton", (_=>{
            GameControls.JUMP = "game_controls_jump",
                GameControls.ANIMATE_IN = "animate_in"
        }
    )),
    Class((function MobileControls() {
            Inherit(this, Component);
            const _this = this;
            var _panY, _panYTarget, _angleX, _angleXTarget, _isDown, _ui, _offset = new Vector3, _lookAt = (new Vector3,
                new Vector3), _lastTap = Date.now(), _radiusSpeedCoef = 1, _radius = 5, _radiusTarget = 5, _lastPos = new Vector2, _pinching = !1, _pinch = null, _gazeCoef = 0, _yOffset = 1;
            function onTouchStart(ev) {
                if (_this.parent.cameraAnimateIn)
                    return;
                let touch;
                _isDown = !0;
                let isPortrait = Stage.width < Stage.height;
                for (let i = 0, l = ev.touches.length; i < l; i++)
                    if (isPortrait) {
                        if (ev.touches[i].clientY < _ui.joystickZoneY || ev.touches[i].clientX > .5 * Stage.width && ev.touches[i].clientY > _ui.joystickZoneY) {
                            touch = ev.touches[i];
                            break
                        }
                    } else if (ev.touches[i].clientX > .4 * Stage.width || ev.touches[i].clientY < Stage.height - 300) {
                        touch = ev.touches[i];
                        break
                    }
                if (touch && _lastPos.set(touch.clientX, touch.clientY),
                2 !== ev.touches.length || _ui.isDown) {
                    let now = Date.now();
                    now - _lastTap < 400 && function onDoubleTap() {
                        if (_this.parent.cameraAnimateIn)
                            return;
                        _this.events.fire(GameControls.JUMP)
                    }(),
                        _lastTap = now
                } else
                    _pinch = null,
                        _pinching = !0
            }
            function onTouchEnd(ev) {
                _this.parent.cameraAnimateIn || (_isDown = !1,
                    _pinching = !1,
                    _pinch = null)
            }
            function onPointerLeave(ev) {
                _this.parent.cameraAnimateIn || (_isDown = !1)
            }
            function onTouchMove(ev) {
                if (_this.parent.cameraAnimateIn)
                    return;
                if (!_isDown)
                    return;
                let touch, isPortrait = Stage.width < Stage.height;
                for (let i = 0, l = ev.touches.length; i < l; i++)
                    if (isPortrait) {
                        if (ev.touches[i].clientY < _ui.joystickZoneY || ev.touches[i].clientX > .5 * Stage.width && ev.touches[i].clientY > _ui.joystickZoneY) {
                            touch = ev.touches[i];
                            break
                        }
                    } else if (ev.touches[i].clientX > .4 * Stage.width || ev.touches[i].clientY < Stage.height - 300) {
                        touch = ev.touches[i];
                        break
                    }
                if (1 === ev.touches.length && (touch = ev.touches[0],
                    _pinching = !1),
                _pinching && !_ui.isDown && ev.touches.length > 1) {
                    let dist = Math.hypot(ev.touches[0].pageX - ev.touches[1].pageX, ev.touches[0].pageY - ev.touches[1].pageY);
                    _pinch || (_pinch = dist);
                    let delta = _pinch - dist;
                    _pinch = dist,
                        _radiusTarget += .04 * delta,
                        _radiusTarget = Math.clamp(_radiusTarget, 3, 10)
                }
                if (!touch)
                    return onTouchEnd();
                let deltaX = touch.clientX - _lastPos.x
                    , deltaY = touch.clientY - _lastPos.y;
                _angleXTarget += .01 * deltaX * _radiusSpeedCoef,
                    _panYTarget += .02 * deltaY * _radiusSpeedCoef,
                    _panYTarget = Math.clamp(_panYTarget, 1.5, 5),
                    _lastPos.set(touch.clientX, touch.clientY),
                    _radiusTarget = Math.clamp(_radiusTarget, 3, 10)
            }
            function onKeyDown({layoutKey: layoutKey}) {
                _this.parent.cameraAnimateIn || "space" === layoutKey && _this.events.fire(GameControls.JUMP)
            }
            _panY = _panYTarget = 4,
                _angleX = _angleXTarget = Math.PI / 2,
                Scroll.createUnlimited(),
                _ui = _this.initClass(MobileControlsUI),
                Stage.add(_ui),
                function addListeners() {
                    Mobile.fullscreen(),
                        _ui.$panZone.bind("touchmove", onTouchMove),
                        _ui.$panZone.bind("touchstart", onTouchStart),
                        _ui.$panZone.bind("touchend", onTouchEnd),
                        _this.events.sub(Keyboard, Keyboard.DOWNED, onKeyDown),
                        document.body.addEventListener("mouseleave", onPointerLeave, !1),
                        document.body.style.cursor = "grab"
                }(),
                _this.updateParentInputs = function() {
                    if (_this.parent.cameraAnimateIn)
                        return;
                    _this.parent.up = Keyboard.isDown("up"),
                        _this.parent.down = Keyboard.isDown("down"),
                        _this.parent.left = Keyboard.isDown("left"),
                        _this.parent.right = Keyboard.isDown("right"),
                        _this.parent.run = Keyboard.isDown("shift");
                    let {up: up, down: down, right: right, left: left, run: run, direction: direction} = _this.parent;
                    direction.set(0, 0),
                        left ? direction.x = -1 : right && (direction.x = 1),
                        up ? direction.y = -1 : down && (direction.y = 1),
                    _ui.direction.x && (direction.x = _ui.direction.x),
                    _ui.direction.y && (direction.y = _ui.direction.y),
                        direction.x || direction.y ? _this.parent.noDirection = !1 : _this.parent.noDirection = !0
                }
                ,
                _this.animateIn = function(d) {
                    _ui.animateIn(d)
                }
                ,
                _this.animateOut = function(d) {
                    _ui.animateOut(d)
                }
                ,
                _this.update = function(time, delta) {
                    let {mainPlayer: mainPlayer} = PlayerController;
                    _this.parent.cameraAnimateIn || (_this.updateParentInputs(),
                        _radiusSpeedCoef = Math.range(_radius, 0, 7, .2, .8, !0),
                    _this.parent.noDirection || (_radius > 6 ? _radiusTarget -= .1 : _radius < 5 && (_radiusTarget += .1)),
                        _radius = Math.lerp(_radiusTarget, _radius, .1)),
                        _lookAt.copy(mainPlayer.group.position),
                        _lookAt.y += _yOffset,
                    _this.parent.cameraAnimateIn || (_lookAt.y += Math.range(_panY, 1.5, 2.5, 1, 0, !0),
                        _angleX = Math.lerp(_angleXTarget, _angleX, .2),
                        _panY = Math.lerp(_panYTarget, _panY, .1)),
                        _offset.x = _radius * Math.cos(_angleX + _this.endRotationOffset),
                        _offset.z = _radius * Math.sin(_angleX + _this.endRotationOffset),
                        _offset.y = _panY
                }
                ,
                _this.forcePanY = val=>{
                    _panYTarget = _panY = val
                }
                ,
                _this.forceAngleX = val=>{
                    _angleX = _angleXTarget = val
                }
                ,
                _this.set("angleX", (val=>{
                        _angleX = val
                    }
                )),
                _this.get("angleX", (_=>_angleX)),
                _this.set("radius", (val=>{
                        _radius = val
                    }
                )),
                _this.get("radius", (_=>_radius)),
                _this.set("panY", (val=>{
                        _panY = val
                    }
                )),
                _this.get("panY", (_=>_panY)),
                _this.set("gazeCoef", (val=>{
                        _gazeCoef = val
                    }
                )),
                _this.get("gazeCoef", (_=>_gazeCoef)),
                _this.set("yOffset", (val=>{
                        _yOffset = val
                    }
                )),
                _this.get("yOffset", (_=>_yOffset)),
                _this.get("offset", (_=>_offset)),
                _this.get("lookAt", (_=>_lookAt))
        }
    )),
    Class((function Guitar() {
            Inherit(this, Element);
            const _this = this;
            let $this, _logo, _bg, _nav, _link, _view;
            Global.EP = !0,
                Config.TEASER = !0;
            function animateIn() {
                _bg && _bg.animateIn(),
                _nav && _nav.animateIn()
            }
            !function initHTML() {
                $this = _this.element,
                    $this.css({
                        position: "static"
                    }),
                    Stage.add($this),
                    Stage.bg("#eee")
            }(),
                async function loadView() {
                    Global.INVERT = !0;
                    let loaderView = _this.initClass(LoaderView)
                        , loader = _this.initClass(AssetLoader, Assets.list().filter(["shaders", "data"]));
                    _this.events.sub(loader, Events.PROGRESS, loaderView.progress),
                        _this.events.sub(loader, Events.COMPLETE, (()=>{
                                loaderView.animateOut((()=>loaderView = loaderView.destroy()))
                            }
                        )),
                        await Initializer3D.createWorld(),
                        function initView() {
                            World.instance(),
                                $this.add(World.ELEMENT);
                            let index = 1;
                            index = Number(index) - 1,
                                Utils.query("path") ? Utils.query("path") : window.location.pathname,
                                Data.TEASER.forEach(((d,i)=>{
                                        "/nurture" == d.link && (index = i)
                                    }
                                ));
                            let data = Data.TEASER[index];
                            data.link.includes(["nurture"]) && (Global.INVERT = data.invert = !0);
                            let bgData = Data.TEASER[5];
                            bgData.guitar = !0,
                                _bg = _this.initClass(EPBackground, bgData),
                                World.SCENE.add(_bg.group),
                                _logo = _this.initClass(LogoUI),
                                _nav = _this.initClass(UINav),
                                _link = _this.initClass(EPLink, Data.TEASER[index], [Stage]),
                                _link.element.setZ(11),
                                _link.art.css({
                                    boxShadow: "0 5px 20px rgba(0,0,0,0.1)"
                                }),
                            data.invert && _this.events.fire(EPArt.RESIZE),
                                _view = _this.initClass(GuitarView)
                        }(),
                        _this.delayedCall(animateIn, 500)
                }(),
                _this.last = Date.now()
        }
    ), "singleton"),
    Class((function LevelController() {
            Inherit(this, Component);
            const _this = this
                , info = (this.element,
                getLogger("LevelCtrl", "#9b59b6", Utils.query("debug")));
            var _main, _quad, _transitionQuad, _staticShader, _transitionShader, _prevScene, _currentScene, _scenes = [], _scenesMap = {}, _transition = {
                value: 0
            };
            function startScene(id) {
                _scenesMap[id].start()
            }
            function updateResolution(id) {
                _scenes.forEach((scene=>{
                        scene.setResolution((scene.id || scene.name) !== id ? Tests.getPreviewDPR() : 1),
                            scene.setSize(Stage.width * scene.resolution, Stage.height * scene.resolution)
                    }
                ))
            }
            function loop(time, delta) {
                GameControls.instance().update(time, delta),
                    PlayerController.update(time, delta);
                for (let i = 0, l = _scenes.length; i < l; i++) {
                    let scene = _scenes[i];
                    scene.isRunning && scene.update(time, delta),
                        scene.checkStateReset()
                }
            }
            _this.FIRST_SCENE_READY = Promise.create(),
                _this.CHANGE_SCENE = "change_scene",
                _this.id = "main_room",
                _this.gameStarted = Promise.create(),
                _this.raycaster = new Raycaster,
                _this.init = async function init() {
                    _this.initalized || (_this.initalized = !0,
                        info("Init"),
                        function initScreenQuad() {
                            _staticShader = _this.initClass(Shader, "ScreenQuad", {
                                tMap: {
                                    value: Utils3D.getTexture("assets/images/_scenelayout/uv.jpg")
                                }
                            }),
                                _transitionShader = _this.initClass(Shader, "LevelTransition", {
                                    tMap: {
                                        value: Utils3D.getTexture("assets/images/_scenelayout/uv.jpg")
                                    },
                                    tMap2: {
                                        value: Utils3D.getTexture("assets/images/_scenelayout/uv.jpg")
                                    },
                                    uProgress: _transition
                                }),
                                _quad = new Mesh(World.QUAD,_staticShader),
                                _transitionQuad = new Mesh(World.QUAD,_transitionShader),
                                World.SCENE.add(_quad),
                                World.SCENE.add(_transitionQuad),
                                _quad.frustumCulled = !1,
                                _transitionQuad.frustumCulled = !1
                        }(),
                        await async function initScenes() {
                            _scenesMap.water = _this.initClass(WaterLevel),
                                _scenes.push(_scenesMap.water),
                                await _scenesMap.water.uploadAll(),
                                await _scenesMap.water.ready(),
                                await defer(),
                                _scenesMap.grass = _this.initClass(GrassLevel),
                                _scenes.push(_scenesMap.grass),
                                await _scenesMap.grass.uploadAll(),
                                await defer(),
                                _scenesMap.env4 = Config.TRACKS.env4.locked ? _scenesMap.grass : _this.initClass(Env4Level),
                                _scenes.push(_scenesMap.env4),
                            Config.TRACKS.env4.locked || await _scenesMap.env4.uploadAll();
                            await _scenesMap.env4.ready(),
                                await defer(),
                                _scenesMap.env3 = Config.TRACKS.env3.locked ? _scenesMap.grass : _this.initClass(Env3Level),
                                _scenes.push(_scenesMap.env3),
                            Config.TRACKS.env3.locked || await _scenesMap.env3.uploadAll();
                            await _scenesMap.env3.ready(),
                                await defer(),
                                _scenesMap.env5 = Config.TRACKS.env5.locked ? _scenesMap.grass : _this.initClass(Env5Level),
                                _scenes.push(_scenesMap.env5),
                            Config.TRACKS.env5.locked || await _scenesMap.env5.uploadAll();
                            await _scenesMap.env5.ready(),
                                await defer(),
                                _main = _scenesMap.main_room = _this.initClass(MainRoom),
                                _scenes.push(_scenesMap.main_room),
                                function setVisible(id) {
                                    let scene = _scenesMap[id];
                                    startScene(id),
                                        _this.rt = scene.rt,
                                        _prevScene = _currentScene,
                                        _currentScene = scene,
                                        updateResolution(id),
                                        _staticShader.set("tMap", _currentScene.rt),
                                        _quad.visible = !0,
                                        _transitionQuad.visible = !1,
                                        _transition.value = 1
                                }("main_room"),
                                await _main.uploadAll(),
                                await _this.wait(200),
                                _this.scenesAreReady = !0,
                                _this.FIRST_SCENE_READY.resolve()
                        }(),
                        function addListeners() {
                            _this.startRender(loop)
                        }())
                }
                ,
                _this.ready = async function() {
                    await _this.wait("scenesAreReady")
                }
                ,
                _this.transitionTo = function transitionTo(id, transitionName) {
                    _scenes.forEach((scene=>{
                            scene.pause()
                        }
                    ));
                    let scene = _scenesMap[id];
                    startScene(id),
                        scene.reset(),
                        _this.rt = scene.rt,
                        _prevScene = _currentScene,
                        _currentScene = scene,
                        updateResolution(id),
                    _prevScene && _transitionShader.set("tMap", _prevScene.rt),
                        _transitionShader.set("tMap2", _currentScene.rt),
                        _staticShader.set("tMap", _currentScene.rt),
                        _this.id = id,
                        _this.events.fire(_this.CHANGE_SCENE, {
                            id: id
                        }),
                        GLUI.Scene.alpha = "main_room" == id ? 1 : 0,
                        _quad.visible = !1,
                        _prevScene.visible = !1,
                        _transitionQuad.visible = !0,
                        _currentScene.visible = !0,
                        VFX.instance().shader.set("uBrighten", .3),
                        VFX.instance().shader.tween("uBrighten", 0, 1e3, "easeOutSIne"),
                    _prevScene.reset && _prevScene.reset(),
                        _this.events.fire(Scribble.ENTER_SCENE, {
                            time: "main_room" == id ? 1e3 : 2e3
                        }),
                        _transition.value = 1,
                        _transitionShader.set("tMap", _currentScene.rt),
                        _quad.visible = !0,
                        _transitionQuad.visible = !1
                }
                ,
                _this.forceResolution = function(previewRatio) {
                    "main_room" === _currentScene.name ? _scenes.forEach((scene=>{
                            if ("main_room" !== scene.name) {
                                scene.resolution = .75;
                                let h = Stage.height * scene.resolution;
                                scene.setSize(h * previewRatio, h)
                            } else
                                scene.resolution = 1,
                                    scene.setSize(Stage.width, Stage.height)
                        }
                    )) : _scenes.forEach((scene=>{
                            let isMainRoom = "main_room" == scene.name
                                , isNotCurrent = scene.name !== _currentScene.name;
                            isMainRoom ? (scene.resolution = .5,
                                scene.setSize(Stage.width * scene.resolution, Stage.height * scene.resolution)) : isNotCurrent || (scene.resolution = 1,
                                scene.setSize(Stage.width, Stage.height))
                        }
                    ))
                }
                ,
                _this.animateIn = function() {
                    _main.animateIn()
                }
                ,
                _this.changeRemotePlayerScene = function(id) {
                    info(`Switch remote player to ${id} scene`),
                        id && _scenesMap[id] ? (_this.events.fire(MainRoom.REMOTE_CHANGE, {
                            id: id
                        }),
                            _scenes.forEach((s=>{
                                    s.removeRemotePlayer()
                                }
                            )),
                            _scenesMap[id].addRemotePlayer()) : console.warn("scene id not valid", id)
                }
                ,
                _this.getScene = id=>_scenesMap[id],
                this.syncLevelState = function(name, values) {
                    let scene = _scenesMap[name];
                    scene && scene.syncRemoteState && scene.syncRemoteState(values)
                }
                ,
                this.getLevelState = function(name) {
                    let scene = _scenesMap[name];
                    return scene ? scene.state : []
                }
                ,
                this.updateResolution = updateResolution,
                _this.get("currentScene", (_=>_currentScene)),
                _this.TRANSITION = "transition",
                _this.REMOTE_CHANGE = "remote_change"
        }
    ), "static"),
    Class((function PlayerController() {
            Inherit(this, Component);
            const _this = this
                , info = (this.element,
                getLogger("PlayerCtrl", "#9b59b6", Utils.query("debug")));
            var _remoteData = null;
            function onPlayerJoin(e) {
                _this.remotePlayer && _this.remotePlayer.connect(e)
            }
            function onConnectionLost(e) {
                _this.remotePlayer && _this.remotePlayer.disconnect(e)
            }
            function onMultiPlayerData(e) {
                _remoteData = e.data;
                let now = Date.now();
                (!_this.lastData || now - _this.lastData > 2e3) && (_this.lastData = now,
                Utils.query("addDebug") && console.log("remote data")),
                _this.remotePlayer && !_this.remotePlayer.visible && _this.remotePlayer.connect()
            }
            _this.mainPlayerReady = Promise.create(),
                _this.mainPlayer = null,
                _this.remotePlayer = null,
                function addListeners() {
                    _this.events.sub(Multiplayer.ON_DATA, onMultiPlayerData),
                        _this.events.sub(Multiplayer.PLAYER_JOINED, onPlayerJoin),
                        _this.events.sub(Multiplayer.CONNECTION_LOST, onConnectionLost),
                        _this.events.sub(GameCenter.DISCONNECTED, onConnectionLost),
                        _this.events.sub("multiplayerui_diconnected", onConnectionLost)
                }(),
                _this.init = async function init() {
                    _this.initalized || (info("Init"),
                        _this.initalized = !0,
                        await async function initMainPlayer() {
                            _this.mainPlayer = _this.initClass(MainPlayer),
                                await Initializer3D.uploadAll(_this.mainPlayer.group),
                                await Initializer3D.uploadAll(_this.mainPlayer.orb.group),
                                _this.mainPlayerReady.resolve()
                        }(),
                        await async function initRemotePlayer() {
                            _this.remotePlayer = _this.initClass(RemotePlayer),
                                await Initializer3D.uploadAll(_this.remotePlayer.group),
                                await Initializer3D.uploadAll(_this.remotePlayer.orb.group)
                        }(),
                        _this.isReady = !0)
                }
                ,
                _this.update = function(time, delta) {
                    _this.mainPlayer && _this.mainPlayer.update(time, delta),
                    _this.remotePlayer && _this.remotePlayer.update(time, delta, _remoteData)
                }
                ,
                _this.onPlayerJoin = onPlayerJoin,
                this.ready = async function() {
                    await _this.wait(_this, "isReady")
                }
        }
    ), "static"),
    Class((function Playground() {
            Inherit(this, Component);
            const _this = this;
            let _view;
            !async function() {
                await UILStorage.ready(),
                    Global.PLAYGROUND = Utils.query("p"),
                    function initThree() {
                        World.instance(),
                            Stage.add(World.ELEMENT)
                    }(),
                    function initView() {
                        let request = Global.PLAYGROUND.split("/")[0]
                            , view = window["Playground" + request] || window[request] || null;
                        if (!view)
                            throw `No Playground class ${request} found.`;
                        _view = view.instance ? view.instance() : _this.initClass(view),
                        _view.element && Stage.add(_view.element);
                        if (_view.rt && _view.scene && _view.nuke) {
                            let shader = _this.initClass(Shader, "ScreenQuad", {
                                tMap: {
                                    value: _view
                                }
                            })
                                , mesh = new Mesh(World.QUAD,shader);
                            mesh.frustumCulled = !1,
                                World.SCENE.add(mesh)
                        } else
                            World.SCENE.add(_view.group || _view.mesh || _view.object3D || new Group);
                        Dev.expose("view", _view)
                    }(),
                    defer(window.onresize)
            }()
        }
    ), "singleton"),
    Class((function UI() {
            Inherit(this, Element);
            var $this, _multiplayer, _location, _nav, _this = this;
            function setActive(e) {
                "home" == e.text ? (_location.animateIn(),
                _multiplayer && _multiplayer.animateIn()) : (_location.animateOut(),
                _multiplayer && _multiplayer.animateOut())
            }
            !function initHTML() {
                ($this = _this.element).css({
                    position: "static"
                }).setZ(10),
                    Stage.add($this)
            }(),
                function initUI() {
                    Tests.showFallback() || (_multiplayer = _this.initClass(MultiplayerUI)),
                        _this.initClass(LogoUI),
                        _location = _this.initClass(LocationUI),
                        _nav = _this.initClass(UINav),
                    Storage.get("seen_tutorial") || _this.initClass(UITutorial),
                    window.location.href.includes("?a") || UIPreOrder.instance()
                }(),
                function addHandlers() {
                    _this.events.sub(UINavView.SET_ACTIVE, setActive)
                }(),
                this.animateIn = async function() {
                    if (_this.isVisible)
                        return;
                    _this.isVisible = !0;
                    let delay = Global.IN_TOUR || Global.LOAD_EUROPE ? 500 : 2500;
                    $this.css({
                        opacity: 0
                    }),
                        await _this.wait(delay),
                        $this.tween({
                            opacity: 1
                        }, 2e3, "easeInOutSine"),
                    !_multiplayer || Global.IN_TOUR || Global.LOAD_EUROPE || _multiplayer.animateIn(0),
                        _nav.animateIn(0),
                    window.location.href.includes("?a") || UIPreOrder.instance().animateIn(2e3)
                }
        }
    ), "singleton"),
    FX.Class((function BloomLayer() {
            Inherit(this, FXLayer);
            const _this = this;
            _this.create(),
            Tests.useBloom() && _this.startRender((_=>{
                    _this.render()
                }
            ))
        }
    ), "singleton"),
    Class((function VFX() {
            Inherit(this, Component);
            const _this = this;
            var _pass, _controls, _nuke = World.NUKE;
            function generatePerturbationMap(size=64) {
                const data = new Float32Array(3 * (size * size));
                let i, l, x;
                for (i = 0,
                         l = data.length; i < l; i += 3)
                    x = 255 * Math.random(),
                        data[i] = x,
                        data[i + 1] = x,
                        data[i + 2] = x;
                const map = new DataTexture(data,size,size,Texture.RGBFormat);
                return map.needsUpdate = !0,
                    map
            }
            function loop(time, delta) {
                PlayerController.mainPlayer && PlayerController.mainPlayer.currentScene && "env5" == PlayerController.mainPlayer.currentScene.name ? _pass.uniforms.uEnv5Darken.value = Global.ENV5_DISTANCE || 0 : (_pass.uniforms.uEnv5Darken.value = 0,
                    _pass.uniforms.uEnv5Brighten.value = 0)
            }
            !async function() {
                FX.BloomLayer.instance(),
                Tests.useFXAA() && _nuke.add(new FXAA),
                    function initVFX() {
                        CanvasDraw.instance(),
                            _pass = _this.initClass(NukePass, "VFX", {
                                uUIOverlay: {
                                    value: 0
                                },
                                uInstructions: {
                                    value: 0
                                },
                                uOverlay: {
                                    value: 0
                                },
                                uBrighten: {
                                    value: 0
                                },
                                uSketchOverlay: {
                                    value: 0
                                },
                                uDrawOverlay: {
                                    value: 0
                                },
                                uGlitch: {
                                    value: 0
                                },
                                uLineShow: {
                                    value: 0
                                },
                                uRandom: {
                                    value: Math.random()
                                },
                                uSeed: {
                                    value: new Vector2(Math.random(),Math.random())
                                },
                                uDistortion: {
                                    value: new Vector2
                                },
                                tPerturbation: {
                                    value: generatePerturbationMap()
                                },
                                uSwap: {
                                    value: 0
                                },
                                uPixellation: {
                                    value: Device.mobile.phone ? 10 : 7
                                },
                                uVignette: {
                                    value: Config.TEASER ? 0 : 1
                                },
                                uEnv5Brighten: {
                                    value: 0
                                },
                                uEnv5Darken: {
                                    value: 0
                                },
                                uEnv5Ghosts: {
                                    value: 0
                                }
                            }),
                            _this.shader = _pass,
                            _nuke.add(_pass)
                    }(),
                    _controls = GameControls.instance().controls,
                    _this.startRender(loop)
            }(),
                _this.toggleuUIOverlay = async function toggleuUIOverlay(toggle) {
                    toggle ? (_pass.set("uSwap", 0),
                        _pass.set("uUIOverlay", 0),
                        tween(GLUI.Scene, {
                            alpha: 0
                        }, 1e3, "easeOutSine"),
                        await _pass.tween("uUIOverlay", 1, 2e3, "easeInOutQuart").promise(),
                        _this.blockRender = !0,
                        _pass.set("uSwap", 1),
                        _pass.set("uUIOverlay", 0)) : (_this.blockRender = !1,
                        _pass.set("uSwap", 1),
                        _pass.set("uUIOverlay", 0),
                    "main_room" == LevelController.id && tween(GLUI.Scene, {
                        alpha: 1
                    }, 1e3, "easeOutSine", 1e3),
                        _pass.tween("uSketchOverlay", 0, 1200, "easeOutCubic"),
                        await _pass.tween("uUIOverlay", 1, 2e3, "easeInOutQuart").promise(),
                        _pass.set("uSwap", 0),
                        _pass.set("uUIOverlay", 0)),
                        _this.toggle = toggle
                }
                ,
                _this.toggleBlackOverlay = async function toggleBlackOverlay(toggle) {
                    toggle ? await _pass.tween("uOverlay", 1, 400, "easeOutSine").promise() : await _pass.tween("uOverlay", 0, 400, "easeOutSine").promise()
                }
                ,
                _this.toggleSketchOverlay = async function toggleSketchOverlay(toggle) {
                    toggle ? (_controls.animateOut && _controls.animateOut(500),
                        CanvasDraw.instance().animateIn(),
                        tween(GLUI.Scene, {
                            alpha: 0
                        }, 800, "easeOutCubic"),
                        await _pass.tween("uSketchOverlay", 1, 1200, "easeOutCubic").promise()) : (_controls.animateIn && _controls.animateIn(0),
                        CanvasDraw.instance().animateOut(),
                    "main_room" == LevelController.id && tween(GLUI.Scene, {
                        alpha: 1
                    }, 1e3, "easeOutCubic", 500),
                        await _pass.tween("uSketchOverlay", 0, 1200, "easeOutCubic").promise())
                }
                ,
                _this.toggleDrawMode = async function toggleDrawMode(toggle) {
                    toggle ? (_controls.animateOut && _controls.animateOut(500),
                        await _pass.tween("uDrawOverlay", 1, 1500, "easeInOutCubic").promise()) : (_controls.animateIn && _controls.animateIn(0),
                        await _pass.tween("uDrawOverlay", 0, 800, "easeInCubic").promise())
                }
                ,
                _this.toggleInstructions = async function toggleInstructions(toggle) {
                    toggle ? (_controls.animateOut && _controls.animateOut(500),
                        await _pass.tween("uInstructions", 1, 1e3, "easeOutCubic").promise()) : (_controls.animateIn && _controls.animateIn(0),
                        await _pass.tween("uInstructions", 0, 1e3, "easeOutCubic").promise())
                }
        }
    ), "singleton"),
    Class((function World() {
            Inherit(this, Component);
            const _this = this;
            let _renderer, _scene, _camera, _nuke, _controls;
            function resize() {
                _renderer.setSize(Stage.width, Stage.height),
                    _camera.fov = Device.mobile.phone && Stage.width < Stage.height ? 65 : 38,
                    _camera.aspect = Stage.width / Stage.height,
                    _camera.updateProjectionMatrix()
            }
            function loop(t, delta) {
                VFX.instance().blockRender || (_controls && _controls.enabled && _controls.update(),
                    RenderManager.render())
            }
            World.DPR = Tests.getDPR(),
                function initWorld() {
                    World.FRUSTUM = new Frustum,
                        World.PLANE = new PlaneGeometry(1,1),
                        World.PLANE_COMPLEX = new PlaneGeometry(1,1,50,50),
                        World.QUAD = Utils3D.getQuad(),
                        World.BOX = new BoxGeometry(1,1,1),
                        World.SPHERE = new SphereGeometry(1,16,16),
                        World.CYLINDER = new CylinderGeometry(1,1,1,50),
                        World.HALF_DOME = new SphereGeometry(1,8,8,0,2 * Math.PI,0,.7 * Math.PI),
                        World.PLANE_HIGH = new PlaneGeometry(150,150,Tests.getWaterFloorTesselation(),Tests.getWaterFloorTesselation()).toNonIndexed(),
                        RenderManager.initialize(RenderManager.NORMAL, {
                            powerPreference: "high-performance",
                            alpha: !0,
                            forceWebGL1: "chrome" == Device.system.browser && "mac" == Device.system.os && GPU.detect("amd radeon pro") && 3 == GPU.TIER
                        }),
                        _renderer = RenderManager.gl,
                        _scene = RenderManager.scene,
                        _camera = RenderManager.camera.worldCamera,
                        _camera.fov = 35,
                        _nuke = RenderManager.nuke,
                        World.SCENE = _scene,
                        World.RENDERER = _renderer,
                        World.ELEMENT = $(_renderer.domElement),
                        World.CAMERA = _camera,
                        World.NUKE = _nuke,
                        VFX.instance()
                }(),
                function initControls() {
                    window.DebugControls && (_controls = new DebugControls(_camera,World.ELEMENT.div),
                        RenderManager.type == RenderManager.NORMAL ? (_camera.position.set(0, 0, 6),
                            _camera.target = new Vector3(0,0,0),
                            _camera.lookAt(_camera.target),
                            _controls.target = _camera.target) : _controls.enabled = !1,
                        World.CONTROLS = _controls)
                }(),
                function addHandlers() {
                    _this.events.sub(Events.RESIZE, resize)
                }(),
                resize(),
            Utils.query("uilOnly") || Render.onDrawFrame(loop),
            RenderManager.type == RenderManager.NORMAL && Camera.instance(_camera)
        }
    ), (function() {
            var _instance;
            World.instance = function() {
                return _instance || (_instance = new World),
                    _instance
            }
        }
    )),
    Class((function SceneView() {
            Inherit(this, Object3D);
            const _this = this;
            !function initMesh() {
                let mesh = new Mesh(new BoxGeometry(1,1,1),Utils3D.getTestShader());
                _this.add(mesh),
                    _this.startRender((t=>{
                            mesh.position.y = .3 * Math.sin(.002 * t),
                                mesh.rotation.y += .01,
                                mesh.rotation.x += .004
                        }
                    )),
                    World.SCENE.add(_this.group);
                let camera = _this.initClass(GazeCamera);
                camera.moveXY.set(8, 4),
                    camera.position.set(0, 0, 6),
                    camera.lerpSpeed = .07,
                    camera.lookAt = new Vector3,
                    camera.lock()
            }()
        }
    )),
    Class((function EPView() {
            Inherit(this, Element);
            const _this = this;
            var _links;
            !function initHTML() {
                _this.element.size(550, 550).center().setZ(10)
            }(),
                function initLinks() {
                    _links = _this.initClass(EPLinks),
                        defer(_links.animateIn)
                }(),
                this.animateIn = function() {}
        }
    )),
    Class((function EPArt(_data) {
            Inherit(this, Element);
            const _this = this;
            let $this, $logo, $art, _links, _top;
            _this.size = Device.mobile.phone ? 400 : 480;
            var _preorder = "/nurture" == _data.link;
            function resizeHandler() {
                clearTimeout(_this.resizeTimeout),
                    _this.resizeTimeout = _this.delayedCall(resize, 100)
            }
            function resize() {
                let check = Math.min(Stage.width - 2 * Config.OFFSET, Stage.height - (_preorder ? Device.mobile.phone ? 150 : 300 : 120))
                    , scale = Math.range(check, 0, _this.size, 0, 1, !0);
                Device.mobile.phone && _preorder && (scale *= .8),
                    $this.transform({
                        scale: scale
                    }).css({
                        marginTop: -_this.size / 2 - (_preorder ? 10 : 30)
                    }).setZ(10),
                    _this.events.fire(EPArt.RESIZE, {
                        size: _this.size,
                        scale: scale
                    })
            }
            _preorder && (_this.size = Math.round(_this.size * (Device.mobile.phone ? .76 : .95))),
                function initHTML() {
                    $this = _this.element,
                        $this.size(_this.size, _this.size).center().css({
                            opacity: 0,
                            marginTop: -_this.size / 2 - 30
                        }).setZ(10)
                }(),
                function initArt() {
                    $art = $this.create("inner"),
                        $art.size(_this.size, _this.size).css({
                            overflow: "hidden",
                            boxShadow: "0 15px 60px rgba(0,0,0,0.2)"
                        }),
                        $art.inner = $art.create(".inner"),
                        $art.inner.size(_this.size, _this.size).css({
                            overflow: "hidden"
                        }),
                        $art.inner2 = $art.inner.create(".inner"),
                        $art.inner2.size(_this.size, _this.size).bg(_data.artwork)
                }(),
                function initLinks() {
                    if (_preorder) {
                        let scale = Device.mobile.phone ? .38 : .42;
                        $logo = $this.create(".logo"),
                            $logo.size(1e3 * scale, 311 * scale).center(1, 0).css({
                                top: -350 * scale
                            }).bg("assets/images/common/logo.png"),
                            _data.optionalTitle = "",
                            _data.title = "",
                            _links = _this.initClass(EPLinks, _data),
                            _links.element.css({
                                bottom: -70
                            }),
                            _top = _this.initClass(EPLinks, {
                                link: _data.link,
                                url: _data.shop
                            }),
                            _top.element.css({
                                bottom: -167
                            })
                    } else
                        _links = _this.initClass(EPLinks, _data)
                }(),
                function initAccess() {
                    $art.attr("role", "img"),
                        $art.attr("aria-label", "porter robinson : something comforting")
                }(),
                function addHandlers() {
                    _this.events.sub(Events.RESIZE, resizeHandler),
                    _preorder && $art.interact(null, (_=>{
                            open(_data.shop)
                        }
                    ))
                }(),
                _this.delayedCall(resize, 500),
                this.animateIn = function() {
                    $this.css({
                        opacity: 0
                    }).tween({
                        opacity: 1
                    }, 1e3, "easeInOutSine"),
                    _links && _links.animateIn(),
                    _top && _this.delayedCall(_top.animateIn, 600)
                }
        }
    ), (_=>{
            EPArt.RESIZE = "epart_resize"
        }
    )),
    Class((function EPLinks(_data) {
            Inherit(this, Element);
            const _this = this;
            let $this, $text, _buttons, _button;
            var _preorder = "/nurture" == _data.link;
            function hover(e) {
                switch (clearTimeout(_this.hoverOut),
                    e.action) {
                    case "over":
                        _buttons.forEach((button=>{
                                button.text == e.text ? button.hover({
                                    action: "over"
                                }) : button.hover({
                                    action: "out"
                                })
                            }
                        ));
                        break;
                    case "out":
                        _this.hoverOut = _this.delayedCall((_=>{
                                _buttons.forEach((button=>{
                                        button.hover({
                                            action: "out"
                                        })
                                    }
                                ))
                            }
                        ), 200)
                }
            }
            !function initHTML() {
                $this = _this.element,
                    $this.size(500, 75).center(1, 0).css({
                        bottom: -90
                    }).setZ(10).invisible().mouseEnabled(!1),
                _data.invert && $this.css({
                    filter: "invert(1)"
                })
            }(),
                function initText() {
                    $text = $this.create(".text"),
                        $text.fontStyle(Config.FONTS.serif, Device.mobile.phone ? 12 : 14, "#fff"),
                        $text.css({
                            width: "100%",
                            fontStyle: "italic",
                            textAlign: "center",
                            textTransform: "lowercase",
                            letterSpacing: "0.2em"
                        });
                    let title = _data.optionalTitle || _data.title;
                    $text.html(_preorder ? title : "stream: <span style=font-style:italic>" + title + "</span>")
                }(),
                function initIcons() {
                    let icons = [];
                    _data.apple && icons.push({
                        text: "Apple Music",
                        type: "apple",
                        url: _data.apple,
                        invert: _data.invert
                    }),
                    _data.youtube && icons.push({
                        text: "Youtube",
                        type: "yt",
                        url: _data.youtube,
                        invert: _data.invert
                    }),
                    _data.spotify && icons.push({
                        text: "Spotify",
                        type: "spot",
                        url: _data.spotify,
                        invert: _data.invert
                    }),
                    _data.apple2 && icons.push({
                        text: "iTunes",
                        type: "itu",
                        url: _data.apple2,
                        invert: _data.invert
                    }),
                    _data.itunes && icons.push({
                        text: "iTunes",
                        type: "itunes",
                        url: _data.itunes,
                        invert: _data.invert
                    }),
                    _data.soundcloud && icons.push({
                        text: "Soundcloud",
                        type: "sound",
                        url: _data.soundcloud,
                        invert: _data.invert
                    }),
                    _data.amazon && icons.push({
                        text: "Amazon Music",
                        type: "amazon",
                        url: _data.amazon,
                        invert: _data.invert
                    }),
                    _data.deezer && icons.push({
                        text: "Deezer",
                        type: "deezer",
                        url: _data.deezer,
                        invert: _data.invert
                    }),
                    _data.shop && icons.push({
                        text: "Order Vinyl",
                        type: "vinyl",
                        url: _data.shop,
                        invert: _data.invert
                    }),
                        _buttons = [];
                    let gap = 56;
                    icons.forEach(((icon,i)=>{
                            let button = _this.initClass(EPLinksButton, icon);
                            button.text = icon.text,
                                button.element.center(1, 0).css({
                                    marginLeft: .5 * -gap * icons.length + gap * i,
                                    bottom: 0
                                }),
                                _buttons.push(button)
                        }
                    ))
                }(),
            _data.url && function initButton() {
                _button = _this.initClass(UINavViewItem, {
                    url: _data.url,
                    boxWidth: 250,
                    width: 210,
                    height: 40,
                    text: "ORDER VINYL/CD NOW",
                    fontSize: 12
                }),
                    _button.element.css({
                        border: "2px solid #fff",
                        top: 5
                    }).center(1, 0)
            }(),
                function initAccess() {
                    $text.attr("role", "heading")
                }(),
                function addHandlers() {
                    _buttons.forEach((button=>{
                            _this.events.sub(button, Events.HOVER, hover)
                        }
                    ))
                }(),
                this.animateIn = function() {
                    $this.visible(),
                        $text.transform({
                            y: 20
                        }).css({
                            opacity: 0
                        }).tween({
                            y: 0,
                            opacity: 1,
                            math: !0
                        }, 1500, "easeOutQuart", 300),
                        _buttons.forEach(((button,i)=>{
                                button.element.transform({
                                    y: 20
                                }).css({
                                    opacity: 0
                                }).tween({
                                    y: 0,
                                    opacity: 1,
                                    math: !0
                                }, 1500, "easeOutQuart", 600 + 120 * i)
                            }
                        )),
                    _button && _button.animateIn()
                }
                ,
                this.get("title", (()=>$text))
        }
    )),
    Class((function EPLinksButton(_config) {
            Inherit(this, Element);
            const _this = this;
            var $this, $icon, $text;
            function hover(e) {
                e.text = _config.text,
                    _this.events.fire(Events.HOVER, e)
            }
            function click() {
                open(_config.url)
            }
            _this.size = 56,
                function initHTML() {
                    ($this = _this.element).size(_this.size, _this.size)
                }(),
                function initIcon() {
                    let size = Math.round(.9 * _this.size);
                    ($icon = $this.create(".icon")).size(size, size).center().bg("assets/images/ep/icons/" + _config.type + ".png"),
                        $icon.css({
                            opacity: .8
                        })
                }(),
                function initText() {
                    ($text = $this.create(".text")).fontStyle(Config.FONTS.serif, 11, "#fff"),
                        $text.size(100, 12).center(1, 0).css({
                            opacity: 0,
                            textAlign: "center",
                            fontStyle: "italic",
                            letterSpacing: 1,
                            bottom: -10
                        }).transform({
                            y: 5
                        }),
                        $text.text(_config.text)
                }(),
                function addHandlers() {
                    $this.interact(hover, click, _config.url, _config.text),
                        $this.mouseEnabled(!0)
                }(),
                this.hover = function(e) {
                    switch (e.action) {
                        case "over":
                            $icon.tween({
                                opacity: 1
                            }, 200, "easeOutSine"),
                                $text.tween({
                                    y: 0,
                                    opacity: 1
                                }, 500, "easeOutCubic");
                            break;
                        case "out":
                            $icon.tween({
                                opacity: .8
                            }, 200, "easeOutSine"),
                                $text.tween({
                                    y: 5,
                                    opacity: 0
                                }, 300, "easeOutCubic")
                    }
                }
                ,
                this.animateIn = function() {}
        }
    )),
    Class((function EPBackground(_data) {
            Inherit(this, Object3D);
            let _shader, _mesh, _video, _this = this;
            var _direction = _data.perma.includes(["get-your-wish", "mirror", "musician"]) ? 1 : 0
                , _flip = _data.perma.includes(["mirror", "nurture"]) ? 1 : 0
                , _needsTexture = _data.perma.includes(["everything-goes-on"]) ? 1 : 0
                , _texture = null
                , _fakeImg = {};
            function resize(e) {
                let percent = .5
                    , move = 0;
                switch (_data.perma) {
                    case "get-your-wish":
                    case "musician":
                        percent = 565 / 1024;
                        break;
                    case "something-comforting":
                        percent = .40625,
                            move = -30;
                        break;
                    case "mirror":
                        percent = 565 / 1024,
                            move = 70
                }
                let check = _direction ? Stage.width : Stage.height
                    , size = e.size * e.scale
                    , offset = (check - size) / 2 / check - move / check + size / check * percent;
                if (_shader.set("uOffset", offset),
                    _shader.set("uRatio", Stage.width / Stage.height),
                _video && _video.resize(offset),
                    CanvasDraw.instance().resize(),
                    _needsTexture) {
                    let ratioFrame = Stage.width / Stage.height
                        , ratioTexture = (_texture.dimensions.width || 2084) / (_texture.dimensions.height || 1173);
                    ratioTexture > ratioFrame ? (_shader.set("uFillScaleX", ratioTexture / ratioFrame),
                        _shader.set("uFillScaleY", 1)) : (_shader.set("uFillScaleX", 1),
                        _shader.set("uFillScaleY", 1 / (ratioTexture / ratioFrame)))
                }
            }
            !async function() {
                await async function getTexture() {
                    if (!_needsTexture)
                        return;
                    if (_data.perma.includes("everything-goes-on"))
                        return _texture = Utils3D.getTexture(Assets.getPath("assets/images/ep/everythinggoeson-bg.jpg")),
                            function safariTextureFlag() {
                                let img = new Image;
                                img.onload = ()=>{
                                    _fakeImg.loaded = !0
                                }
                                    ,
                                    img.src = Assets.getPath("assets/images/ep/everythinggoeson-bg.jpg")
                            }(),
                            _texture.promise
                }(),
                    await async function initShader() {
                        let isTextureWider, ratioFrame, ratioTexture;
                        _needsTexture && (await function HydraWait(object, key, callback) {
                            const promise = Promise.create();
                            let condition;
                            "string" == typeof object && (callback = key,
                                key = object,
                                object = _this);
                            if ("number" == typeof object && 1 === arguments.length)
                                return _this.delayedCall(promise.resolve, object),
                                    promise;
                            "function" == typeof object && 1 === arguments.length && (condition = object,
                                object = _this);
                            if ("function" == typeof object && "string" == typeof callback) {
                                let _object = object;
                                object = key,
                                    key = callback,
                                    callback = _object
                            }
                            callback = callback || promise.resolve,
                            condition || ("!" === key?.charAt?.(0) ? (key = key.slice(1),
                                condition = ()=>!(object[key] || _this.flag(key))) : condition = ()=>!!object[key] || !!_this.flag(key));
                            if (condition())
                                callback();
                            else {
                                function test() {
                                    if (!object || !_this.flag || null === object.destroy)
                                        return Render.stop(test);
                                    condition() && (callback(),
                                        Render.stop(test))
                                }
                                Render.start(test)
                            }
                            return promise
                        }(_fakeImg, "loaded"),
                            await _this.wait(1e3),
                            ratioFrame = Stage.width / Stage.height,
                            ratioTexture = (_texture.dimensions.width || 2084) / (_texture.dimensions.height || 1173),
                            isTextureWider = ratioTexture > ratioFrame);
                        _shader = _this.initClass(Shader, "EPBackground", {
                            uColor0: {
                                value: new Color(_data.colors[0].hex)
                            },
                            uColor1: {
                                value: new Color(_data.colors[1].hex)
                            },
                            uDirection: {
                                value: _direction
                            },
                            uFlip: {
                                value: _flip
                            },
                            uRatio: {
                                value: Stage.width / Stage.height
                            },
                            uInvert: {
                                value: Global.INVERT ? 1 : 0
                            },
                            uOffset: {
                                value: .51
                            },
                            uTransition: {
                                value: 0
                            },
                            uNeedsTexture: {
                                value: _needsTexture
                            },
                            uFillScaleX: {
                                value: isTextureWider ? ratioTexture / ratioFrame : 1
                            },
                            uFillScaleY: {
                                value: isTextureWider ? 1 : 1 / (ratioTexture / ratioFrame)
                            },
                            tMap: {
                                value: _texture
                            }
                        })
                    }(),
                    function initMesh() {
                        _mesh = new Mesh(World.QUAD,_shader),
                            _this.add(_mesh)
                    }(),
                "something-comforting" == _data.perma && function initVideo() {
                    _video = _this.initClass(EPBackgroundVideo, _data, [Stage])
                }(),
                    function addHandlers() {
                        _this.events.sub(EPArt.RESIZE, resize)
                    }(),
                    _this.flag("isReady", !0)
            }(),
                this.ready = async function() {
                    await _this.wait(_this, "isReady")
                }
                ,
                this.animateIn = async function() {
                    await _this.ready(),
                        CanvasDraw.instance().animateIn(),
                        _shader.tween("uTransition", 1, 3e3, "easeInOutQuart")
                }
        }
    )),
    Class((function EPBackgroundVideo(_data) {
            Inherit(this, Element);
            var $this, $wrapper, _video, _this = this;
            !function initHTML() {
                ($this = _this.element).size("100%").css({
                    overflow: "hidden"
                }).setZ(0),
                    ($wrapper = $this.create(".wrapper")).size("100%")
            }(),
                function initVideo() {
                    console.log(_data),
                        _data.guitar ? ((_video = _this.initClass(Video, {
                            src: "assets/videos/grass.mp4",
                            width: 1280,
                            height: 720,
                            muted: !0,
                            loop: !0,
                            autoplay: !0
                        })).width = 1802,
                            _video.height = 866) : ((_video = _this.initClass(Video, {
                            src: "assets/videos/sc.mp4",
                            width: 1280,
                            height: 720,
                            muted: !0,
                            loop: !0,
                            autoplay: !0
                        })).width = 1280,
                            _video.height = 720),
                        _video.div.play(),
                        _this.events.sub(Mouse.input, Interaction.CLICK, (_=>{
                                _video.div.play()
                            }
                        )),
                        $wrapper.add(_video.element),
                        _video.div.width = "100%",
                        _video.div.height = "100%",
                        _video.element.css({
                            width: "100%",
                            height: "100%"
                        }).mouseEnabled(!1)
                }(),
                this.resize = function(offset) {
                    _data.guitar && (offset = 0);
                    let wrapperHeight = (1 - offset) * Stage.height
                        , width = Stage.width
                        , height = width * (_video.height / _video.width);
                    height < wrapperHeight && (height = wrapperHeight,
                        width = height * (_video.width / _video.height)),
                        $wrapper.size(width, height);
                    let x = (Stage.width - width) / 2;
                    Stage.height;
                    $wrapper.transform({
                        x: x,
                        y: 0
                    }),
                        $this.size(Stage.width, wrapperHeight)
                }
        }
    )),
    Class((function EPViewBG() {
            Inherit(this, Element);
            const _this = this;
            var $this, $frame, _player;
            function initPlayer() {
                _player = new YT.Player("frame",{
                    videoId: "e7QeR0VxnlA",
                    playerVars: {
                        rel: 0,
                        controls: 0,
                        fs: 0,
                        loop: !0,
                        showinfo: 0,
                        modestbranding: 1
                    },
                    events: {
                        onReady: onPlayerReady,
                        onStateChange: onPlayerStateChange
                    }
                })
            }
            function play() {
                _player && _player.playVideo && (_player.playVideo(),
                    _player.mute())
            }
            function resize() {
                let scaleY = Stage.height / 540
                    , scaleX = Stage.width / 960
                    , scale = Math.max(scaleY, scaleX);
                $this.size(960, 540).center().transform({
                    scale: scale
                })
            }
            function onPlayerReady() {
                $this.tween({
                    opacity: .1
                }, 4e3, "easeInOutSine"),
                    play()
            }
            function onPlayerStateChange(e) {
                0 == e.data && play()
            }
            !function initHTML() {
                ($this = _this.element).size("100%").css({
                    opacity: 0
                }).mouseEnabled(!1).setZ(10)
            }(),
                function initFrame() {
                    ($frame = $this.create(".frame")).div.setAttribute("id", "frame"),
                        $frame.size("100%").setZ(2)
                }(),
                function addHandlers() {
                    _this.events.sub(Events.RESIZE, resize),
                        _this.events.sub(Mouse.input, Interaction.END, play)
                }(),
                resize(),
                _this.delayedCall(initPlayer, 500),
                this.animateIn = function() {}
        }
    )),
    Class((function EPLink(_data) {
            Inherit(this, Element);
            var $this, $art, $text, _this = this, _size = Device.mobile.phone ? 60 : 100;
            function hover(e) {
                switch (e.action) {
                    case "over":
                        $art.tween({
                            opacity: .7
                        }, 200, "easeOutSine"),
                            $text.tween({
                                opacity: 1
                            }, 200, "easeOutSine");
                        break;
                    case "out":
                        $art.tween({
                            opacity: 1
                        }, 400, "easeOutSine"),
                            $text.tween({
                                opacity: .7
                            }, 400, "easeOutSine")
                }
            }
            function click() {
                let link = _data.link;
                Hydra.LOCAL && (link = window.location.origin + window.location.pathname + "?path=" + _data.link.split("/")[1]),
                    Stage.tween({
                        opacity: 0
                    }, 150, "easeOutSine", (_=>{
                            open(link, "_self")
                        }
                    ))
            }
            function resize() {
                $this.css({
                    top: Stage.height - _size - Config.OFFSET - (Device.mobile.phone ? 20 : 25)
                })
            }
            !function initHTML() {
                ($this = _this.element).size(_size, _size + 25).setZ(5).css({
                    right: Config.OFFSET
                }),
                    ($art = $this.create(".art")).size(_size, _size).bg(_data.artwork),
                    _this.art = $art,
                    ($text = $this.create(".text")).fontStyle(Config.FONTS.serif, Device.mobile.phone ? 9 : 12, Global.INVERT ? "#000" : "#fff"),
                    $text.size(100, 20).center(1, 0).css({
                        opacity: .7,
                        top: _size + 8,
                        textAlign: "center",
                        textTransform: "lowercase",
                        letterSpacing: "0.15em"
                    }),
                    $text.html(_data.optionalTitle || _data.title)
            }(),
                function addHandlers() {
                    $this.interact(hover, click, _data.link, _data.title),
                        _this.events.sub(Events.RESIZE, resize)
                }(),
                resize(),
                this.animateIn = function() {}
        }
    )),
    Class((function EPSingle(_name=Utils.query("name")) {
            Inherit(this, Object3D);
            const _this = this;
            var _layout;
            !async function() {
                _layout = _this.initClass(SceneLayout, `${_name}_single`, {}),
                    _this.group.add(_layout.group),
                    await _layout.getAllLayers(),
                    function initCamera() {
                        let camera = _this.initClass(GazeCamera);
                        camera.moveXY.set(-3, 1),
                            camera.position.set(0, 0, 4),
                            camera.lookAt = new Vector3(0,0,-.4),
                            camera.lock()
                    }()
            }(),
                this.animateIn = function() {
                    _this.group.visible = !0
                }
        }
    )),
    Class((function EPAlbum() {
            Inherit(this, Object3D);
            const _this = this;
            var _shader, _mesh;
            _this.group.visible = !1,
                World.SCENE.add(_this.group),
                function initShader() {
                    _shader = new Shader("EPAlbum",{
                        tMap: {
                            value: Utils3D.getTexture("assets/images/ep/front.jpg")
                        }
                    })
                }(),
                function initMesh() {
                    _mesh = new Mesh(World.PLANE,_shader),
                        _this.add(_mesh)
                }(),
                function initCamera() {
                    let camera = _this.initClass(GazeCamera);
                    camera.moveXY.set(-2, 1),
                        camera.position.set(0, 0, 3),
                        camera.lookAt = new Vector3(0,0,-.4),
                        camera.lock()
                }(),
                this.animateIn = function() {
                    _this.group.visible = !0,
                        _shader.tween("uAlpha", 1, 5e3, "easeInOutSine")
                }
        }
    )),
    Class((function EPSinglePage(_data) {
            Inherit(this, Element);
            const _this = this;
            var $this = _this.element;
            let $logo, $art, $flyer, $embed, $streams, _links, _top, _streamItems = [];
            _this.size = Device.mobile.phone ? 400 : 480;
            var _preorder = "/nurture" == _data.link;
            _preorder && (_this.size = Math.round(_this.size * (Device.mobile.phone ? .76 : .95)));
            let _isStreamReady = !1;
            function resizeHandler() {
                clearTimeout(_this.resizeTimeout),
                    _this.resizeTimeout = _this.delayedCall(resize, 100)
            }
            function resize() {
                let check = Math.min(Stage.width - 2 * Config.OFFSET, Stage.height - (_preorder ? Device.mobile.phone ? 150 : 300 : 120))
                    , scale = Math.range(check, 0, _this.size, 0, 1, !0);
                Device.mobile.phone && _preorder && (scale *= .8),
                    $this.transform({
                        scale: scale
                    }).setZ(10);
                let streamsWidth = Math.min(Stage.width - 20, 700);
                $streams && $streams.css({
                    width: streamsWidth,
                    left: -(streamsWidth - _this.size) / 2
                }),
                    $embed.css({
                        width: streamsWidth,
                        height: _isStreamReady ? .5625 * streamsWidth : "unset",
                        left: -(streamsWidth - _this.size) / 2
                    }),
                    _this.events.fire(EPArt.RESIZE, {
                        size: _this.size,
                        scale: scale
                    })
            }
            !async function() {
                Mobile.allowNativeScroll(),
                    Stage.div.style.top = "0",
                    function initHTML() {
                        $this.size(_this.size, 0).center().css({
                            opacity: 0,
                            top: 0,
                            marginTop: 0,
                            paddingTop: 150,
                            position: "relative",
                            transformOrigin: "top center"
                        }).setZ(10),
                            CanvasDraw.instance().container.css({
                                position: "absolute",
                                top: 0,
                                left: 0
                            }),
                            World.RENDERER.canvas.style.pointerEvents = "none"
                    }(),
                    function initArt() {
                        $art = $this.create("inner"),
                            $art.size(_this.size, _this.size).css({
                                position: "relative",
                                overflow: "hidden",
                                boxShadow: "0 15px 60px rgba(0,0,0,0.2)"
                            }),
                            $art.inner = $art.create(".inner"),
                            $art.inner.size(_this.size, _this.size).css({
                                overflow: "hidden"
                            }),
                            $art.inner2 = $art.inner.create(".inner"),
                            $art.inner2.size(_this.size, _this.size).bg(_data.artwork)
                    }(),
                    function initLinks() {
                        if (_preorder) {
                            let scale = Device.mobile.phone ? .38 : .42;
                            $logo = $this.create(".logo"),
                                $logo.size(1e3 * scale, 311 * scale).center(1, 0).css({
                                    top: -350 * scale
                                }).bg("assets/images/common/logo.png"),
                                _data.optionalTitle = "",
                                _data.title = "",
                                _links = _this.initClass(EPLinks, _data),
                                _links.element.css({
                                    bottom: -70
                                }),
                                _top = _this.initClass(EPLinks, {
                                    link: _data.link,
                                    url: _data.shop
                                }),
                                _top.element.css({
                                    bottom: -167
                                })
                        } else
                            _links = _this.initClass(EPLinks, _data);
                        _links.element.css({
                            position: "relative",
                            bottom: "unset",
                            marginTop: 40
                        });
                        let unlockDate = new Date(_data.ytEmbedDateUnlock).getTime()
                            , linksTitle = (new Date).getTime() < unlockDate ? "pre-save" : "stream";
                        _links.title.html(`${linksTitle}: <span style=font-style:italic> everything goes on </span>`)
                    }(),
                    function initAccess() {
                        $art.attr("role", "img"),
                            $art.attr("aria-label", "porter robinson : something comforting")
                    }(),
                    function initEmbedPlayer() {
                        let hideYoutube = _data.hideEmbededYoutube
                            , embedTop = _data.displayAtTopEmbededYoutube;
                        $embed = $this.create("EmbedSection").css({
                            opacity: 0,
                            position: "relative",
                            width: "100%",
                            height: 400,
                            marginTop: embedTop ? 0 : 50,
                            marginBottom: embedTop ? 50 : 0
                        }),
                            $embed.inner = $embed.create("inner").css({
                                width: "100%",
                                height: "100%",
                                position: "relative"
                            }),
                        embedTop && ($this.add($art.div),
                            $this.add(_links.element));
                        hideYoutube ? $embed.css({
                            display: "none"
                        }) : (_isStreamReady = !0,
                            function initIframe() {
                                $embed.inner.div.innerHTML = `<iframe width="100%" height="100%" src="https://www.youtube.com/embed/${_data.ytEmbed}?controls=0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>`
                            }());
                        $embed.create(".pad").css({
                            position: "relative",
                            width: "100%",
                            height: 50
                        })
                    }(),
                _data.hideFlyerAndTourDates || function initFlyerAndTour() {
                    (function initFlyer() {
                            $flyer = $this.create("FlyerContainer"),
                                $flyer.size(_this.size, "unset").css({
                                    position: "relative",
                                    overflow: "hidden",
                                    boxShadow: "0 15px 60px rgba(0,0,0,0.2)",
                                    marginTop: "50px"
                                }),
                                $flyer.inner = $flyer.create(".wrapper"),
                                $flyer.inner.size(_this.size, "unset").css({
                                    overflow: "hidden",
                                    position: "relative"
                                }),
                                $flyer.inner2 = $flyer.inner.create(".flyer", "img").css({
                                    position: "relative",
                                    width: "100%",
                                    verticalAlign: "top"
                                }),
                                $flyer.inner2.div.src = _data.flyerArtwork
                        }
                    )(),
                        function initStreamTour() {
                            $streams = $this.create("StreamTourSection").css({
                                paddingBottom: "80px"
                            }),
                                _data.streamTour.forEach(((d,i)=>{
                                        let item = _this.initClass(UIStreamTourItem, d, [$streams]);
                                        _streamItems.push(item)
                                    }
                                ))
                        }()
                }(),
                    function addHandlers() {
                        _this.events.sub(Events.RESIZE, resizeHandler),
                        _preorder && $art.interact(null, (_=>{
                                open(_data.shop)
                            }
                        ))
                    }(),
                    _this.flag("isReady", !0),
                    _this.delayedCall(resize, 500),
                    await function HydraWait(object, key, callback) {
                        const promise = Promise.create();
                        let condition;
                        "string" == typeof object && (callback = key,
                            key = object,
                            object = _this);
                        if ("number" == typeof object && 1 === arguments.length)
                            return _this.delayedCall(promise.resolve, object),
                                promise;
                        "function" == typeof object && 1 === arguments.length && (condition = object,
                            object = _this);
                        if ("function" == typeof object && "string" == typeof callback) {
                            let _object = object;
                            object = key,
                                key = callback,
                                callback = _object
                        }
                        callback = callback || promise.resolve,
                        condition || ("!" === key?.charAt?.(0) ? (key = key.slice(1),
                            condition = ()=>!(object[key] || _this.flag(key))) : condition = ()=>!!object[key] || !!_this.flag(key));
                        if (condition())
                            callback();
                        else {
                            function test() {
                                if (!object || !_this.flag || null === object.destroy)
                                    return Render.stop(test);
                                condition() && (callback(),
                                    Render.stop(test))
                            }
                            Render.start(test)
                        }
                        return promise
                    }((()=>null != document.querySelector(".MobileControlsUI"))),
                    document.querySelector(".MobileControlsUI").style.pointerEvents = "none"
            }(),
                this.ready = function() {
                    return _this.wait("isReady")
                }
                ,
                this.animateIn = async function() {
                    await _this.ready(),
                        $this.css({
                            opacity: 0
                        }).tween({
                            opacity: 1
                        }, 1e3, "easeInOutSine"),
                        $embed.css({
                            opacity: 0
                        }).tween({
                            opacity: 1
                        }, 1e3, "easeInOutSine", 600),
                    _links && _links.animateIn(),
                    _top && _this.delayedCall(_top.animateIn, 600),
                        _streamItems.forEach(((item,i)=>{
                                _this.delayedCall(item.animateIn, 150 * i + 500)
                            }
                        ))
                }
        }
    ), (_=>{
            EPSinglePage.RESIZE = "EPSinglePage_resize"
        }
    )),
    Class((function UIStreamTourItem(_data) {
            Inherit(this, Element);
            var $this, $line, $wrapper, $title, $info, $button, _button, _this = this, _buttonWidth = Device.mobile.phone ? 130 : 150, _textSpacing = Device.mobile.phone ? 18 : 25;
            var _offsetTime;
            function hover(e) {
                switch (e.action) {
                    case "over":
                        $title.tween({
                            x: 10,
                            opacity: 1
                        }, 500, "easeOutCubic"),
                            $line.inner2.clearTween().transformPoint("100%", "50%").transform({
                                scaleX: 0
                            }).tween({
                                scaleX: 1
                            }, 500, "easeOutCubic");
                        break;
                    case "out":
                        $title.tween({
                            x: 0,
                            opacity: 1
                        }, 700, "easeOutCubic"),
                            $line.inner2.tween({
                                scaleX: 0
                            }, 1200, "easeInOutCubic")
                }
            }
            !function dateOffset() {
                var targetTime = new Date(_data.date)
                    , dbTzDifference = -108e5
                    , eventTzDifference = -252e5
                    , userTzDifference = 6e4 * (new Date).getTimezoneOffset();
                _offsetTime = new Date(targetTime.getTime() + dbTzDifference - eventTzDifference - userTzDifference)
            }(),
                function initHTML() {
                    ($this = _this.element).size("100%", 100).css({
                        height: "auto",
                        position: "relative",
                        display: "block",
                        margin: Device.mobile.phone ? "50px 0" : "60px 0"
                    }).invisible(),
                        ($wrapper = $this.create(".wrapper")).css({
                            display: "block",
                            position: "relative",
                            paddingRight: _buttonWidth
                        })
                }(),
                function initTitle() {
                    let size = Device.mobile.phone ? 30 : 50;
                    _data.headline || console.log(_data),
                        ($title = $wrapper.create(".title")).fontStyle(Config.FONTS.serif, size, "#000"),
                        $title.css({
                            display: "block",
                            fontWeight: "light",
                            textTransform: "lowercase",
                            lineHeight: 1.15 * size,
                            letterSpacing: "0.02em",
                            position: "relative",
                            paddingRight: 10
                        }),
                        $title.text(_data.headline)
                }(),
                function initTickets() {
                    ($line = $wrapper.create(".line")).css({
                        display: "block",
                        position: "relative",
                        height: 1,
                        margin: "1px 0"
                    }),
                    Device.mobile.phone && $line.css({
                        marginTop: 6
                    }),
                        $line.inner = $line.create(".inner"),
                        $line.inner.size("100%").transformPoint("0%", "50%").transform({
                            scaleX: 0
                        }).css({
                            background: Device.mobile ? "rgba(0,0,0,0.4)" : "rgba(0,0,0,0.15)"
                        }),
                        $line.inner2 = $line.inner.create(".inner"),
                        $line.inner2.size("100%").bg("#000").transformPoint("100%", "50%").transform({
                            scaleX: 0
                        }),
                        ($button = $wrapper.create(".button")).size(_buttonWidth, 40).css({
                            marginTop: -25,
                            right: 0,
                            border: "1px solid #fff"
                        }).bg("#000"),
                        _button = _this.initClass(UINavViewItem, {
                            url: _data.url,
                            width: Device.mobile.phone ? _buttonWidth - 20 : _buttonWidth - 40,
                            height: 40,
                            fontSize: Device.mobile.phone ? 10 : 11,
                            text: "STREAM LINK"
                        }, [$button])
                }(),
                function initInfo() {
                    ($info = $wrapper.create(".info")).fontStyle(Config.FONTS.sansSerif, Device.mobile.phone ? 10 : 12, "#000"),
                        $info.css({
                            display: "block",
                            textTransform: "uppercase",
                            letterSpacing: "0.1em",
                            position: "relative",
                            marginTop: 10
                        }),
                        $info.date = $info.create(".date"),
                        $info.date.css({
                            display: "inline-block",
                            fontWeight: "bold",
                            position: "relative",
                            marginRight: .4 * _textSpacing
                        });
                    let dateObj = new Date(_offsetTime)
                        , dateText = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][dateObj.getMonth()].slice(0, 3) + " - " + dateObj.getDate() + " - " + dateObj.getFullYear();
                    $info.date.text(dateText),
                        $info.time = $info.create(".time"),
                        $info.time.css({
                            display: "inline-block",
                            opacity: .7,
                            position: "relative",
                            marginRight: 1.2 * _textSpacing
                        }),
                        $info.time.text(CalendarUtils.formatTime(dateObj)),
                        $info.location = $info.create(".streamer"),
                        $info.location.css({
                            display: "inline-block",
                            position: "relative",
                            marginRight: _textSpacing
                        }),
                        $info.location.text(_data.info)
                }(),
                function addHandlers() {
                    _this.events.sub(_button, Events.HOVER, hover)
                }(),
                this.animateIn = function() {
                    $this.visible(),
                        $title.transform({
                            y: 10
                        }).css({
                            opacity: 0
                        }).tween({
                            y: 0,
                            opacity: 1
                        }, 800, "easeOutQuart"),
                        $line.inner.transform({
                            scaleX: 0
                        }).transformPoint("0%", "50%").tween({
                            scaleX: 1
                        }, 1e3, "easeOutQuart"),
                        $line.inner2.transform({
                            scaleX: 1
                        }).transformPoint("100%", "50%").tween({
                            scaleX: 0
                        }, 2e3, "easeInOutQuart"),
                        $info.date.transform({
                            x: 20
                        }).css({
                            opacity: 0
                        }).tween({
                            x: 0,
                            opacity: 1
                        }, 800, "easeOutQuart", 200),
                        $info.time.transform({
                            x: 20
                        }).css({
                            opacity: 0
                        }).tween({
                            x: 0,
                            opacity: .8
                        }, 800, "easeOutQuart", 300),
                        $info.location.transform({
                            x: 20
                        }).css({
                            opacity: 0
                        }).tween({
                            x: 0,
                            opacity: 1
                        }, 800, "easeOutQuart", 400),
                        $button.transform({
                            x: 30
                        }).css({
                            opacity: 0
                        }).tween({
                            x: 0,
                            opacity: 1
                        }, 800, "easeOutQuart", 300),
                        _this.delayedCall(_button.animateIn, 700)
                }
        }
    )),
    Class((function EPSpinner() {
            Inherit(this, Object3D);
            var _this = this
                , _layers = []
                , _wrapper = new THREE.Group;
            function loop(t) {
                _wrapper.position.z = .5 + .1 * Math.sin(5e-4 * t),
                    _layers.forEach(((layer,i)=>{
                            _this.down || (layer.unlocked.z += i % 2 == 0 ? -.002 : .002),
                            Math.abs(layer.unlocked.z) > Math.radians(layer.turn) && (layer.unlocked.z = 0),
                                layer.unlocked.x = i > 1 ? .35 + .35 * Math.sin(.001 * t + i) : 0,
                                layer.locked.x = .9,
                                layer.move.lerp(_this.down ? layer.locked : layer.unlocked, .03),
                                layer.rotation.z = layer.move.z,
                                layer.shader.set("uOpacity", layer.move.x)
                        }
                    ))
            }
            !function initLayers() {
                let turns = [72, 90, 90, 90, 30, 90, 90, 90, 60, 60, 45, 90, 180];
                for (var i = 3; i < 12; i++) {
                    let shader = _this.initClass(Shader, "LandingSpinner", {
                        uMap: {
                            value: Utils3D.getTexture("assets/images/intro/" + i + ".jpg")
                        },
                        uMask: {
                            value: CursorMask.instance().texture
                        },
                        uDimensions: World.RESOLUTION,
                        uTime: World.TIME,
                        uOpacity: {
                            value: 0
                        },
                        uAlpha: {
                            value: 0
                        },
                        transparent: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        blending: THREE.AdditiveBlending
                    })
                        , mesh = new THREE.Mesh(World.PLANE,shader.material);
                    mesh.shader = shader,
                        mesh.turn = turns[i],
                        mesh.unlocked = new Vector3,
                        mesh.unlocked.z = Math.random(0, Math.radians(i % 2 == 0 ? -mesh.turn : mesh.turn), 3),
                        mesh.locked = new Vector3,
                        mesh.move = new Vector3,
                        mesh.alpha = 0,
                        mesh.scale.setScalar(Device.mobile.phone ? 1.7 : 2),
                        _wrapper.add(mesh),
                        _layers.push(mesh)
                }
                _this.add(_wrapper)
            }(),
                this.animateIn = function() {
                    _this.startRender(loop),
                        _layers.forEach(((layer,i)=>{
                                layer.shader.tween("uAlpha", .75, 8e3, "easeOutSine"),
                                    layer.position.z = 1.2 + .43 * i,
                                    tween(layer.position, {
                                        z: -3
                                    }, 12e3, "easeOutExpo")
                            }
                        ))
                }
        }
    )),
    Class((function GuitarPage(_data) {
            Inherit(this, Element);
            const _this = this
                , $this = _this.element;
            var $inner, _images, _margin = Device.mobile.phone ? 90 : 100;
            !function initHTML() {
                $this.size("100%").setZ(10).mouseEnabled(!1).css({
                    opacity: .5
                }).overflowScroll({
                    y: 1,
                    x: 0
                }),
                    ($inner = $this.create(".inner")).css({
                        margin: _margin + "px auto",
                        textAlign: "center",
                        width: "100%",
                        position: "relative",
                        display: "block",
                        boxShadow: "0 5px 50px rgba(0,0,0,0.15)",
                        overflow: "hidden"
                    }).bg("#f00"),
                    _images = [];
                for (var i = 1; i < _data.count + 1; i++) {
                    let $image = $inner.create(".image");
                    $image.bg(`assets/images/guitar/${_data.name}/${i}.jpg`).setZ(100),
                        _images.push($image)
                }
            }(),
                this.resize = function(width, height) {
                    let w = Device.mobile.phone ? 1.15 * width : width
                        , h = Device.mobile.phone ? 1.15 * height : height;
                    _images.forEach((($image,i)=>{
                            $image.size(w, h).center(1, 0).css({
                                top: i * h
                            })
                        }
                    )),
                        _this.height = h * _images.length,
                    Device.mobile.phone && (width -= 40),
                        $this.size(Stage.width, Stage.height),
                        $inner.css({
                            width: width,
                            height: _this.height,
                            top: 0,
                            left: 0
                        })
                }
                ,
                this.activate = function() {
                    $this.mouseEnabled(!0),
                        $this.tween({
                            opacity: 1
                        }, 700, "easeInOutSine")
                }
                ,
                this.deactivate = function() {
                    $this.mouseEnabled(!1),
                        $this.tween({
                            opacity: .5
                        }, 400, "easeOutCubic")
                }
        }
    )),
    Class((function GuitarView() {
            Inherit(this, Element);
            const _this = this
                , $this = _this.element;
            var $dots, $pages, _pages, _active, _debounce, _width, _index = 0, _padding = Device.mobile.phone ? 0 : 50, _x = 0;
            function click() {
                Mouse.y < 100 || (Mouse.x < .2 * Stage.width && changeSlide(_index - 1),
                Mouse.x > .8 * Stage.width && changeSlide(_index + 1))
            }
            function onKeyDown(e) {
                "left" == e.layoutKey && changeSlide(_index - 1),
                "right" == e.layoutKey && changeSlide(_index + 1)
            }
            function start() {
                Math.abs(Mouse.tilt.x) < .3 || (_this.dragging = !0)
            }
            function end() {
                _x += 7 * Mouse.delta.x,
                    clearTimeout(_this.dragTimeout),
                    _this.dragTimeout = _this.delayedCall((_=>{
                            _this.dragging = !1
                        }
                    ), 500)
            }
            function drag(e) {
                _this.changing || (_x += Mouse.delta.x)
            }
            function changeSlide(index) {
                if (!_pages[index])
                    return;
                let x = -index * (_width + _padding);
                Device.mobile.phone && (x -= .5 * _padding),
                    clearTimeout(_this.changeTimeout),
                    _this.changing = !0,
                    _this.changeTimeout = _this.delayedCall((_=>{
                            _this.changing = !1
                        }
                    ), 500),
                    _x = x
            }
            function loop() {
                _this.dragging || _this.changing || (_x = -_index * (_width + _padding)),
                    _x = Math.clamp(_x, -_pages.length * (_width + _padding) - 50, 50);
                let index = Math.round(Math.abs(_x) / (_width + _padding));
                index = Math.clamp(index, 0, _pages.length - 1),
                _index === index && _active || (_index = index,
                _active && (_active.deactivate(),
                    _active.dot.css({
                        background: ""
                    }),
                    _active.dot.tween({
                        opacity: .2
                    }, 200, "easeOutSine")),
                    (_active = _pages[_index]).activate(),
                    _active.dot.css({
                        background: "#fff"
                    }),
                    _active.dot.tween({
                        opacity: 1
                    }, 500, "easeOutSine")),
                    $pages.x = Math.lerp(_x, $pages.x, .12),
                    $pages.transform(),
                    _pages.forEach(((page,i)=>{
                            let dif = Math.abs(i - _index);
                            dif >= 2 && !page.hidden ? (page.hidden = !0,
                                page.element.hide()) : dif < 2 && page.hidden && (page.hidden = !1,
                                page.element.show())
                        }
                    ))
            }
            function resize() {
                let width = Math.min(Stage.width, Device.mobile.phone ? 600 : 792)
                    , height = width * (1024 / 792);
                _width = width;
                let left = 0;
                _pages.forEach(((page,i)=>{
                        page.resize(width, height),
                            left = (width + _padding) * i + .5 * _padding,
                            page.element.css({
                                top: 0,
                                left: left
                            })
                    }
                )),
                    $pages.css({
                        left: 0,
                        width: (width + _padding) * (_pages.length - 1)
                    }),
                    clearTimeout(_debounce),
                    _debounce = _this.delayedCall((_=>{
                            _x = -_index * (_width + _padding)
                        }
                    ), 200)
            }
            !async function() {
                !function initHTML() {
                    $this.size("100%").setZ(10)
                }(),
                    function initPages() {
                        let pages = [{
                            name: "lifelike",
                            count: 2
                        }, {
                            name: "lats",
                            count: 4
                        }, {
                            name: "getyourwish",
                            count: 3
                        }, {
                            name: "windtempos",
                            count: 2
                        }, {
                            name: "musician",
                            count: 4
                        }, {
                            name: "dore",
                            count: 3
                        }, {
                            name: "mother",
                            count: 4
                        }, {
                            name: "dullscythe",
                            count: 2
                        }, {
                            name: "sweettime",
                            count: 3
                        }, {
                            name: "mirror",
                            count: 4
                        }, {
                            name: "somethingcomforting",
                            count: 4
                        }, {
                            name: "blossom",
                            count: 3
                        }, {
                            name: "unfold",
                            count: 4
                        }, {
                            name: "trying",
                            count: 3
                        }];
                        _pages = [],
                            ($pages = $this.create(".pages")).size("100%").css({
                                top: 0
                            }).mouseEnabled(!1),
                            $pages.x = 0,
                            pages.forEach((p=>{
                                    let page = _this.initClass(GuitarPage, p, [$pages]);
                                    _pages.push(page)
                                }
                            ))
                    }(),
                    function initDots() {
                        let size = 5
                            , spacing = 11;
                        ($dots = $this.create(".dots")).size(size * _pages.length + spacing * (_pages.length - 1), size).center(1, 0).css({
                            top: Device.mobile.phone ? 60 : 38
                        });
                        let left = 0;
                        _pages.forEach((page=>{
                                let $dot = $dots.create(".dot");
                                $dot.size(size, size).css({
                                    opacity: .2,
                                    borderRadius: size,
                                    border: "2px solid #fff",
                                    left: left
                                }),
                                    page.dot = $dot,
                                    left += size + spacing
                            }
                        ))
                    }(),
                    function addHandlers() {
                        _this.events.sub(Keyboard, Keyboard.DOWNED, onKeyDown),
                            _this.events.sub(Mouse.input, Interaction.CLICK, click),
                        Device.mobile.phone && (_this.events.sub(Mouse.input, Interaction.START, start),
                            _this.events.sub(Mouse.input, Interaction.DRAG, drag),
                            _this.events.sub(Mouse.input, Interaction.END, end));
                        _this.onResize(resize)
                    }(),
                    await _this.wait(500),
                    _this.startRender(loop)
            }(),
                this.resize = function(width, height) {}
        }
    )),
    Class((function AbstractLevel(_name, _id) {
            Inherit(this, FXScene);
            const _this = this;
            function resize() {
                LevelController.currentScene === _this && _this.setSize(Stage.width, Stage.height)
            }
            !function() {
                if (!_name)
                    return void console.warn("Please provide a name as first arg to the super function");
                _this.id = _id || _name,
                    _this.create(World.NUKE, null, {
                        format: Texture.RGBAFormat
                    }),
                    _this.name = _name,
                    _this.state = {};
                let id = `${_name}_level`;
                "grass" === _name && (id = "grass_scene"),
                    _this.layout = _this.initClass(SceneLayout, id),
                    _this.scene.add(_this.layout.group),
                "clouds" == _name && (_this.name = _name = "env4"),
                "snow" == _name && (_this.name = _name = "env3"),
                    _this.isRunning = !1,
                    _this.playerConfig = {
                        speed: 1,
                        spawn: new Vector3(0,0,0)
                    },
                    _this.visible = !1,
                    _this.isLayoutReady = Promise.create(),
                    _this.layout.ready().then((()=>{
                            _this.isLayoutReady.resolve()
                        }
                    )),
                    function addHandlers() {
                        _this.onResize(resize)
                    }()
            }(),
                _this.reset = function() {
                    _this.resolution = 1
                }
                ,
                _this.start = function(isPreview=!1) {
                    if (isPreview || _this.addMainPlayer(),
                    _this.onStart && _this.onStart(),
                        _this.visible = !0,
                        _this.isRunning = !0,
                    !isPreview && (_this.isPlayground() && "main_room" !== _name && Lighting.useScene(_id),
                    PlayerController.mainPlayer.currentScene.name === _name && "main_room" !== _name)) {
                        let mainRoom = LevelController.getScene("main_room")
                            , preview = mainRoom && mainRoom.previewsMap[_name];
                        preview && Global.MAIN_ROOM_CAMERA && (Global.MAIN_ROOM_CAMERA.position.copy(preview.position),
                            Global.MAIN_ROOM_CAMERA.position.y = 0,
                            Global.MAIN_ROOM_CAMERA.basePos = preview.position.clone(),
                            Global.MAIN_ROOM_CAMERA.basePos.y = 0)
                    }
                }
                ,
                _this.pause = function(isPreview=!1) {
                    isPreview || _this.removeMainPlayer(),
                        _this.visible = !1,
                    _this.onPause && _this.onPause(),
                        _this.isRunning = !1
                }
                ,
                _this.setStaticPreview = function() {}
                ,
                _this.checkDebug = function() {
                    Global.PLAYGROUND !== `${(_id || _name).capitalize()}Level` && "MainRoom" !== Global.PLAYGROUND || ("MainRoom" !== Global.PLAYGROUND && Lighting.useScene(_id),
                        PlayerController.init(),
                        _this.startRender(((time,delta)=>{
                                GameControls.instance().update(time, delta),
                                    PlayerController.update(time, delta)
                            }
                        )),
                        defer((()=>{
                                _this.startRender(_this.update),
                                    _this.start(),
                                    _this.onResize((()=>{
                                            _this.setSize(Stage.width, Stage.height)
                                        }
                                    ))
                            }
                        )))
                }
                ,
                _this.addInstanced = _this.addInstancedObject = async function(object) {
                    object.instanceMeshReady && await object.instanceMeshReady;
                    let meshes = object.instanceMesh;
                    Array.isArray(meshes) || (meshes = [meshes]);
                    for (let i = 0; i < meshes.length; i++)
                        _this.add(meshes[i])
                }
                ,
                _this.addMainPlayer = function() {
                    let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                    mainPlayer && (mainPlayer.reset(_name, _this.playerConfig),
                        _this.layout.group.add(mainPlayer.group),
                        _this.layout.group.add(mainPlayer.orb.group),
                        mainPlayer.previousScene = mainPlayer.currentScene,
                        mainPlayer.currentScene = _this,
                        mainPlayer.currentSceneId = _name),
                    remotePlayer && remotePlayer.currentSceneId === _name && (_this.layout.group.add(remotePlayer.group),
                        _this.layout.group.add(remotePlayer.orb.group),
                        remotePlayer.currentScene = _this)
                }
                ,
                _this.removeMainPlayer = function() {
                    let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                    mainPlayer && (_this.layout.group.remove(mainPlayer.group),
                        _this.mainPlayer = null)
                }
                ,
                _this.addRemotePlayer = function() {
                    let remotePlayer = PlayerController.remotePlayer;
                    remotePlayer && (_this.layout.group.add(remotePlayer.group),
                        _this.layout.group.add(remotePlayer.orb.group),
                        PlayerController.remotePlayer.currentScene = _this,
                        PlayerController.remotePlayer.onSceneChanged(_this),
                        remotePlayer.orb.reset("main_room" === _name ? null : remotePlayer.group.position)),
                    _this.onRemotePlayerAdded && _this.onRemotePlayerAdded()
                }
                ,
                _this.removeRemotePlayer = function() {
                    _this.onRemotePlayerRemoved && _this.onRemotePlayerRemoved()
                }
                ,
                _this.updateCamera = function() {
                    World.CAMERA.aspect = _this.width / _this.height,
                        World.CAMERA.updateProjectionMatrix()
                }
                ,
                _this.update = function(time, delta) {
                    let camera = _this.camera || World.CAMERA;
                    _this.nuke.camera = camera,
                        _this.updateCamera(),
                        _this.render(null, camera)
                }
                ,
                _this.checkStateReset = function() {
                    let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                    remotePlayer && _this.resetState && !_this.isReset && (remotePlayer.isConnected || !mainPlayer.currentScene || mainPlayer.currentScene.name === _name ? mainPlayer.currentScene && remotePlayer.currentScene && mainPlayer.currentScene.name !== _name && remotePlayer.currentScene.name !== _name && _this.resetState() : _this.resetState())
                }
                ,
                _this.syncRemoteState = state=>{
                    _this.state = state
                }
                ,
                this.uploadAll = async function() {
                    await Initializer3D.uploadAll(_this.layout)
                }
                ,
                this.uploadAllAsync = async function() {
                    await Initializer3D.uploadAllAsync(_this.layout)
                }
        }
    ), (()=>{
            AbstractLevel.PLAYERS_ENABLED = "abstractlevel_players_enabled"
        }
    )),
    Class((function BackgroundShader(_mesh, _shader, _input, _group) {
            Inherit(this, Component);
            _shader.uniforms.uColor = {
                value: new Color
            },
                _shader.uniforms.uAlpha = {
                    value: 1
                }
        }
    )),
    Class((function DomeBounds(_mesh, _shader) {
            Inherit(this, Component);
            const _this = this;
            var _pos = new Vector3
                , _calc = new Vector3
                , _origin = new Vector3;
            function loop() {
                if (!PlayerController.mainPlayer)
                    return;
                _calc.subVectors(PlayerController.mainPlayer.group.position, _origin),
                    _calc.length() > _mesh.scale.x - 17 ? _this.animatedIn || (_this.animatedIn = !0,
                        _shader.tween("uAlpha", 1, 4e3, "easeOutSine")) : _this.animatedIn && (_this.animatedIn = !1,
                        _shader.tween("uAlpha", 0, 2e3, "easeOutSine"))
            }
            _shader.addUniforms({
                tMap: {
                    value: Utils3D.getRepeatTexture("assets/images/common/grid.jpg")
                },
                uColor: {
                    value: new Color(16777215)
                },
                uPlayerPos: {
                    value: _pos
                },
                uAlpha: {
                    value: 0
                }
            }),
                _shader.transparent = !0,
                _shader.blending = Shader.ADDITIVE_BLENDING,
                _mesh.visible = !1,
                _shader.set("uAlpha", 0),
                _this.startRender(loop)
        }
    )),
    Class((function DrawZone(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            var _sphere, _this = this;
            function loop() {
                let worldPos = _mesh.getWorldPosition();
                _sphere.center = worldPos,
                    _sphere.center.y = 0;
                let mainPlayer = PlayerController.mainPlayer;
                if (mainPlayer) {
                    _sphere.containsPoint(mainPlayer.group.position) ? function activatePlayer() {
                        if (_this.activatedPlayer)
                            return;
                        _this.activatedPlayer = !0,
                            _mesh.shader.tween("uPlayerActive", 1, 1e3, "easeOutQuint"),
                            tween(_mesh.scale, _mesh.toScale, 1e3, "easeOutQuint")
                    }() : function deactivatePlayer() {
                        if (!_this.activatedPlayer)
                            return;
                        _this.activatedPlayer = !1,
                            _mesh.shader.tween("uPlayerActive", 0, 1e3, "easeOutQuint"),
                        _this.activatedRemote || tween(_mesh.scale, _mesh.oScale, 1e3, "easeOutQuint")
                    }()
                }
                let remotePlayer = PlayerController.remotePlayer;
                if (remotePlayer) {
                    _this.blocked || function showZone() {
                        if (_this.showing)
                            return;
                        _this.showing = !0,
                            _mesh.shader.tween("uVisible", 1, 2e3, "easeInOutSine")
                    }(),
                        _sphere.containsPoint(remotePlayer.group.position) ? function activateRemote() {
                            if (_this.activatedRemote)
                                return;
                            _this.activatedRemote = !0,
                                _mesh.shader.tween("uRemoteActive", 1, 1e3, "easeOutQuint"),
                                tween(_mesh.scale, _mesh.toScale, 1e3, "easeOutQuint")
                        }() : function deactivateRemote() {
                            if (!_this.activatedRemote)
                                return;
                            _this.activatedRemote = !1,
                                _mesh.shader.tween("uRemoteActive", 0, 1e3, "easeOutQuint"),
                            _this.activatedPlayer || tween(_mesh.scale, _mesh.oScale, 1e3, "easeOutQuint")
                        }()
                } else
                    hideZone();
                _this.activatedPlayer && _this.activatedRemote && !_this.blocked && function startDrawMode() {
                    if (_this.drawing)
                        return;
                    _this.drawing = !0,
                        VFX.instance().toggleDrawMode(!0),
                        CanvasDraw.instance().animateIn(!0),
                        _this.stopRender(loop),
                        _this.delayedCall(stopDrawMode, Config.DRAW_TIMER)
                }(),
                    _shader.uniforms.uTime.value += .005
            }
            function hideZone() {
                _this.showing && (_this.showing = !1,
                    _mesh.shader.tween("uVisible", 0, 1e3, "easeOutSine"))
            }
            function stopDrawMode() {
                _this.drawing && (_this.drawing = !1,
                    _this.blocked = !0,
                    _this.delayedCall((_=>{
                            _this.blocked = !1
                        }
                    ), 6e4),
                    hideZone(),
                    VFX.instance().toggleDrawMode(),
                    CanvasDraw.instance().animateOut(),
                    _this.startRender(loop))
            }
            _shader.addUniforms({
                uAlpha: {
                    value: 1
                },
                uPlayerActive: {
                    value: 0
                },
                uRemoteActive: {
                    value: 0
                },
                uVisible: {
                    value: 0
                },
                uTime: {
                    value: 0
                }
            }),
                _sphere = new Sphere(_mesh.position,1.5 * _mesh.scale.x),
                _mesh.renderOrder = 9999,
                _mesh.oScale = (new Vector3).copy(_mesh.scale),
                _mesh.toScale = (new Vector3).copy(_mesh.oScale).addScalar(.2),
                _this.startRender(loop)
        }
    )),
    Class((function FlowerPatch(_group, _grasspatch, _defines, _scene) {
            Inherit(this, Object3D);
            const _this = this;
            var _antimatter, _behavior, _mesh;
            function loop() {
                _antimatter.update()
            }
            !async function() {
                await _grasspatch.ready(),
                    await async function initAntimatter() {
                        const uniforms = _grasspatch.mesh.shader.uniforms
                            , offset = _grasspatch.mesh.geometry.attributes.offset
                            , scale = _grasspatch.mesh.geometry.attributes.scale;
                        let positionTexture = function getPositionTexture(position, scale) {
                            let size = function findSize(num) {
                                var values = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
                                for (let i = 0; i < values.length; i++) {
                                    var p2 = values[i];
                                    if (p2 * p2 >= num)
                                        return p2
                                }
                            }(position.count)
                                , array = new Float32Array(size * size * 4)
                                , j = 0;
                            for (let i = 0; i < 4 * position.count; i += 4)
                                array[i + 0] = position.array[i + 0],
                                    array[i + 1] = position.array[i + 1],
                                    array[i + 2] = position.array[i + 2],
                                    array[i + 3] = scale.array[j++];
                            return new DataTexture(array,size,size,Texture.RGBAFormat,Texture.FLOAT)
                        }(offset, scale);
                        _antimatter = _this.initClass(Antimatter, offset.count, {
                            w: [-1, 1],
                            h: [-1, 1],
                            d: [-1, 1]
                        }, World.RENDERER, _defines),
                            await _antimatter.ready(),
                            _antimatter.vertexShader = _antimatter.fragmentShader = "FlowerParticles",
                            _antimatter.uniforms = {
                                tMap: uniforms.tFlowerMap,
                                tRocks: uniforms.tRocks,
                                uBboxMin: uniforms.uBboxMin,
                                uBboxMax: uniforms.uBboxMax,
                                uColor1: uniforms.uFlowerColor1,
                                uColor2: uniforms.uFlowerColor2,
                                uAlpha: uniforms.uFlowerAlpha,
                                uTransition: {
                                    value: 0
                                },
                                tOrigin: {
                                    value: positionTexture
                                },
                                uHeightScale: uniforms.uHeightScale,
                                uSpeed: {
                                    value: "grass" === _scene ? .4 : 1
                                },
                                uTime: GrassLevel.uTime,
                                uSize: {
                                    value: "grass" == _scene ? 1.7 : .7
                                },
                                DPR: {
                                    value: World.DPR,
                                    ignoreUIL: !0
                                },
                                transparent: !0
                            },
                            _this.antimatter = _antimatter,
                            (_behavior = _this.initClass(AntimatterPass, "FlowerPatchBehavior")).addInput("tOrigin", positionTexture),
                            _behavior.addInput("tAttribs", _antimatter.attribs),
                            _behavior.addUniforms({
                                uPlayer1Pos: uniforms.uPlayer1Pos,
                                uPlayer2Pos: uniforms.uPlayer2Pos,
                                uPlayer1InScene: uniforms.uPlayer1InScene,
                                uPlayer1Vel: uniforms.uPlayer1Vel,
                                uPlayer2Vel: uniforms.uPlayer2Vel,
                                uPlayer2InScene: uniforms.uPlayer2InScene,
                                uRange: uniforms.uRange,
                                uHeightScale: uniforms.uHeightScale,
                                uRepulsionStrength: uniforms.uRepulsionStrength,
                                uTrigger: uniforms.uFlowerTrigger,
                                uRepop: uniforms.uFlowerRepop,
                                uPos: {
                                    value: _grasspatch.group.position
                                },
                                uRegrow: {
                                    value: .008
                                },
                                uDecay: {
                                    value: .008
                                },
                                uTime: GrassLevel.uTime,
                                uSpeed: {
                                    value: "grass" === _scene ? .4 : 1
                                },
                                uGrass: {
                                    value: "grass" === _scene ? 1 : 0
                                }
                            }),
                            _behavior.depthTest = !1,
                            _antimatter.addPass(_behavior),
                            (_mesh = _antimatter.getMesh()).renderOrder = 99999,
                            _this.add(_mesh),
                            _this.mesh = _mesh
                    }(),
                    function addListeners() {
                        _this.startRender(loop)
                    }(),
                    _this.isReady = !0
            }(),
                _this.ready = _=>{
                    _this.wait("isReady")
                }
                ,
                _this.activate = _=>{
                    _behavior.uniforms.uTrigger.value = 1,
                        _behavior.uniforms.uRepop.value = 0
                }
                ,
                _this.desactivate = _=>{
                    _behavior.uniforms.uTrigger.value = 0,
                        _behavior.uniforms.uRepop.value = 1
                }
        }
    ), (()=>{
            FlowerPatch.ID = 0
        }
    )),
    Class((function GrassPatch(_index, _group, _scale, _density=1 / 8, _scene, _defines=[]) {
            Inherit(this, Object3D);
            const _this = this;
            var _mesh, _shader, _sphere, _activated, _flowers = null;
            new Vector3,
                new Vector3;
            function checkSphere() {
                let mainPlayer = PlayerController.mainPlayer;
                mainPlayer && mainPlayer.currentScene.name === _scene && !_activated && _sphere.containsPoint(mainPlayer.group.position) && !_activated && activate()
            }
            function activate() {
                _activated = !0,
                _flowers && _flowers.activate(),
                    _this.parent.parent.onPatchActivate(_this)
            }
            function onPlayerConnect() {}
            function onPlayerLeave() {
                _shader.uniforms.uPlayer2Pos.value.set(0, 0, 0)
            }
            function loop() {
                let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                mainPlayer.currentScene.name === _scene ? (_shader.set("uPlayer1InScene", 1),
                    _shader.set("uPlayer1Vel", Math.range(mainPlayer.velocity3.length(), 0, .25, 0, 1, !0)),
                    _shader.uniforms.uPlayer1Pos.value.lerp(mainPlayer.group.position, .1)) : (_shader.set("uPlayer1InScene", 0),
                    _shader.set("uPlayer1Vel", 0)),
                    remotePlayer && remotePlayer.currentScene && remotePlayer.currentScene.name === _scene ? (_shader.set("uPlayer2InScene", 1),
                        _shader.set("uPlayer2Vel", Math.range(remotePlayer.velocity3.length(), 0, .25, 0, 1, !0)),
                        _shader.uniforms.uPlayer2Pos.value.lerp(remotePlayer.group.position, .1)) : (_shader.set("uPlayer2InScene", 0),
                        _shader.set("uPlayer2Vel", 0))
            }
            !async function() {
                await async function initMesh() {
                    let grass = World.GRASS_FLOOR;
                    grass || (grass = await GeomThread.loadGeometry("assets/geometry/grass/grassfloor.json"),
                        World.GRASS_FLOOR = grass);
                    grass.boundingBox && grass.computeBoundingBox();
                    let geometry = new Geometry;
                    const segments = 8
                        , height = 1
                        , number = Tests.getFlowerGrassDensity() * (_scale * _density);
                    let positions = new GeometryAttribute(new Float32Array(3 * segments),3);
                    for (let i = 0; i < segments; i++)
                        positions.setXYZ(i, 0, height / (segments - 1) * i, 0);
                    geometry.addAttribute("position", positions);
                    let offsets = new GeometryAttribute(new Float32Array(4 * number),4,1)
                        , random = new GeometryAttribute(new Float32Array(4 * number),4,1)
                        , scales = new GeometryAttribute(new Float32Array(number),1,1);
                    for (let i = 0; i < number; i++) {
                        let angle = i * Math.PI * 2 / number
                            , radius = Math.random(0, 1, 2);
                        offsets.setXYZ(i, Math.cos(angle) * radius, 0, Math.sin(angle) * radius),
                            random.setXYZW(i, Math.random(-1, 1, 2), Math.random(-1, 1, 2), Math.random(-1, 1, 2), Math.random(-1, 1, 2));
                        let s = .4 + Math.pow(1 - radius, .5) * Math.random(.2, .5, 2) * .8;
                        scales.setX(i, s),
                            offsets.setXYZ(i, Math.cos(angle) * radius, 0, Math.sin(angle) * radius)
                    }
                    geometry.addAttribute("offset", offsets),
                        geometry.addAttribute("scale", scales),
                        geometry.addAttribute("random", random),
                        _shader = new Shader("GrassPatch",{
                            customCompile: "GrassPatch_" + Date.now(),
                            tRocks: {
                                value: Utils3D.getTexture("assets/images/grass/grass_scale.jpg"),
                                ignoreUIL: !0
                            },
                            tDepth: {
                                value: Utils3D.getTexture("assets/images/env3/ground_height.jpg"),
                                ignoreUIL: !0
                            },
                            uColorStem: {
                                value: new Color("#b6c6da")
                            },
                            uColor1: {
                                value: new Color("#ff282e")
                            },
                            uColor2: {
                                value: new Color("#ff262c")
                            },
                            uEnColor: {
                                value: new Color("#ffb89f")
                            },
                            uProximityColor: {
                                value: new Color("#e6164c")
                            },
                            uGroundColor: {
                                value: new Color("#afc9e5")
                            },
                            uGroundFade: {
                                value: .5
                            },
                            uDepth: {
                                value: new Vector2
                            },
                            uRange: {
                                value: _scale,
                                ignoreUIL: !0
                            },
                            uHeightScale: {
                                value: 1.5
                            },
                            uRepulsionStrength: {
                                value: .5
                            },
                            uPlayer1InScene: {
                                value: 0,
                                ignoreUIL: !0
                            },
                            uPlayer2InScene: {
                                value: 0,
                                ignoreUIL: !0
                            },
                            uBboxMin: {
                                value: grass.boundingBox.min,
                                ignoreUIL: !0
                            },
                            uBboxMax: {
                                value: grass.boundingBox.max,
                                ignoreUIL: !0
                            },
                            uPlayer1Pos: {
                                value: new Vector3,
                                ignoreUIL: !0
                            },
                            uPlayer2Pos: {
                                value: new Vector3,
                                ignoreUIL: !0
                            },
                            uPlayer1Vel: {
                                value: 0,
                                ignoreUIL: !0
                            },
                            uPlayer2Vel: {
                                value: 0,
                                ignoreUIL: !0
                            },
                            uEnabled: {
                                value: 0,
                                ignoreUIL: !0
                            },
                            uTime: GrassLevel.uTime,
                            transparent: !0,
                            depthWrite: !1,
                            tFlowerMap: {
                                value: Utils3D.getTexture("assets/images/env3/flower.png")
                            },
                            uFlowerColor1: {
                                value: new Color("#ff4248")
                            },
                            uFlowerColor2: {
                                value: new Color("#ff1800")
                            },
                            uFlowerRepop: {
                                value: "grass" === _this.parent.parent.name ? 0 : 1,
                                ignoreUIL: !0
                            },
                            uFlowerTrigger: {
                                value: 0,
                                ignoreUIL: !0
                            },
                            uFlowerAlpha: {
                                value: 1
                            }
                        }),
                    "grass" == _scene && (_shader.set("uColorStem", new Color("#8ecf95")),
                        _shader.set("uColor1", new Color("#6fa674")),
                        _shader.set("uColor2", new Color("#fbe7a2")),
                        _shader.set("uEnColor", new Color("#5d8a4d")),
                        _shader.set("uProximityColor", new Color("#6fa674")),
                        _shader.set("uGroundColor", new Color("#6fa674")),
                        _shader.set("uFlowerColor1", new Color("#daae00")),
                        _shader.set("uFlowerColor2", new Color("#daae00")),
                        _shader.set("uHeightScale", 2));
                    if (_defines && _defines.length) {
                        let str = "";
                        for (let i = 0, l = _defines.length; i < l; i++)
                            str += `#define ${_defines[i]}\n`;
                        _shader.vertexShader = _shader.vertexShader.replace("__DEFINES__", str),
                            _shader.fragmentShader = _shader.fragmentShader.replace("__DEFINES__", str)
                    }
                    _shader.vertexShader = _shader.vertexShader.replace("__DEFINES__", ""),
                        _shader.fragmentShader = _shader.fragmentShader.replace("__DEFINES__", ""),
                        _mesh = new Line(geometry,_shader),
                        geometry.computeBoundingSphere = ()=>{
                            Geometry.prototype.computeBoundingSphere.call(geometry),
                                geometry.boundingSphere.radius = _scale
                        }
                        ,
                        _this.add(_mesh),
                        _shader.UILPrefix += ++GrassPatch.ID,
                        ShaderUIL.add(_shader, _group),
                        PlayerController.mainPlayerReady.then((()=>{}
                        ))
                }(),
                    function addListeners() {
                        _this.events.sub(Multiplayer.PLAYER_JOINED, onPlayerConnect),
                            _this.events.sub(Multiplayer.CONNECTION_LOST, onPlayerLeave),
                            _this.startRender(loop)
                    }(),
                    _this.isReady = !0,
                    _shader.set("uRange", _scale),
                "grass" === _scene && function initSphere() {
                    _sphere = new Sphere(_this.group.position,.65 * _scale),
                        _this.startRender(checkSphere, 30)
                }()
            }(),
                this.ready = ()=>_this.wait("isReady"),
                this.get("mesh", (_=>_mesh)),
                this.get("activated", (_=>_activated)),
                this.addFlowers = function() {
                    if (!_flowers)
                        return _flowers = _this.initClass(FlowerPatch, _group, _this, _defines, _scene),
                            _this.flowers = _flowers,
                            _flowers
                }
                ,
                _this.activate = activate,
                _this.desactivate = function desactivate() {
                    _activated = !1,
                    _flowers && _flowers.desactivate(),
                        _this.parent.parent.onPatchDesactivate(_this)
                }
        }
    ), (()=>{
            GrassPatch.ID = 0
        }
    )),
    Class((function GrassPatches(_layout, _name, _scene, _defines) {
            Inherit(this, Object3D);
            const _this = this;
            var _regex, _config = [], _instances = [];
            function captureGrass(name, capture) {
                return !Utils.query("noCapture") && (!!("" + name).match(_regex) && (capture(((obj,name,group,input)=>{
                        _config.push({
                            name: name,
                            position: obj.position.clone(),
                            scale: obj.scale.clone(),
                            group: group
                        })
                    }
                )),
                    !0))
            }
            _this.instanceMesh = [],
                async function() {
                    _regex = new RegExp(`${_name}\\d`),
                        _layout.onCreateLayer = captureGrass,
                        await _layout.ready(),
                        await _this.wait(100),
                        function initGrass() {
                            _instances = _config.map(((config,i)=>{
                                    let grass = _this.initClass(GrassPatch, i, config.group, Math.max(config.scale.x, config.scale.z), Tests.getPatchDensity(), _scene, _defines);
                                    return grass.group.position.copy(config.position),
                                        grass
                                }
                            ))
                        }(),
                        await Promise.all(_instances.map((obj=>obj.ready()))),
                        _this.instanceMesh = _instances.map((obj=>obj.mesh)),
                        _this.isReady = !0
                }(),
                this.uploadAll = async function() {
                    for (let i = 0; i < _instances.length; i++)
                        await _instances[i].ready(),
                            await Initializer3D.uploadAll(_instances[i].group)
                }
                ,
                this.uploadAllAsync = async function() {
                    await _this.ready();
                    for (let i = 0; i < _instances.length; i++)
                        await _instances[i].ready(),
                            await Initializer3D.uploadAllAsync(_instances[i].group)
                }
                ,
                this.ready = async()=>{
                    await _this.wait("isReady")
                }
                ,
                this.addFlowers = function(index=-1) {
                    let patches = _instances[index];
                    patches || (patches = _instances),
                    Array.isArray(patches) || (patches = [patches]);
                    let flowers = [];
                    return patches.forEach((patch=>{
                            flowers.push(patch.addFlowers())
                        }
                    )),
                        flowers
                }
                ,
                this.getState = function() {
                    return _instances.map((instance=>instance.activated))
                }
                ,
                this.desactivate = function() {
                    _instances.forEach((i=>{
                            i.desactivate()
                        }
                    ))
                }
                ,
                this.playerActivate = ()=>{
                    _instances.forEach((i=>{
                            i.mesh.shader.tween("uEnabled", 1, 3e3, "easeOutSine")
                        }
                    ))
                }
                ,
                this.playerDesactivate = ()=>{
                    _instances.forEach((i=>{
                            i.mesh.shader.tween("uEnabled", 0, 3e3, "easeOutSine")
                        }
                    ))
                }
                ,
                this.setState = function(state) {
                    state.forEach(((s,i)=>{
                            s && _instances[i].activate()
                        }
                    ))
                }
        }
    )),
    Class((function HitTest(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                uAlpha: {
                    value: 1
                }
            })
        }
    )),
    Class((function Horizon(_mesh, _shader) {
            Inherit(this, Component);
            _shader.addUniforms({
                uColor: {
                    value: new Color("#3282b8")
                },
                uColor2: {
                    value: new Color("#ff6666")
                },
                uColorEnabled: {
                    value: new Color("#3282b8")
                },
                uColor2Enabled: {
                    value: new Color("#ff6666")
                },
                tFBM: {
                    value: Utils3D.getRepeatTexture("assets/images/noise/fbm-64.png")
                },
                tStars: {
                    value: Utils3D.getRepeatTexture("assets/images/common/stars.jpg")
                },
                uCldScale: {
                    value: 15
                },
                uCldWeight: {
                    value: .3
                },
                uCldSpeed: {
                    value: .01
                },
                uCldDark: {
                    value: .5
                },
                uCldLight: {
                    value: 0
                },
                uCldClamp: {
                    value: 2
                },
                uCldAlpha: {
                    value: 1
                },
                uCldColor: {
                    value: new Color("#ffffff")
                },
                uStars: {
                    value: 0
                },
                uEnabled: {
                    value: 0,
                    ignoreUIL: !0
                },
                uClds: {}
            })
        }
    )),
    Class((function RangedSky(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            function getSkyTexture(src, scale) {
                let texture = Utils3D.getTexture(src, scale);
                return texture.wrapS = Texture.REPEAT,
                    texture.minFilter = texture.magFilter = Texture.NEAREST,
                    texture.generateMipmaps = !1,
                    texture
            }
            _shader.addUniforms({
                tMap: {
                    value: null,
                    getTexture: getSkyTexture
                },
                uTile: {
                    value: new Vector2
                },
                uOffset: {
                    value: new Vector2
                },
                uRange: {
                    value: new Vector2
                },
                uColor1: {
                    value: new Color
                },
                uColor2: {
                    value: new Color
                }
            })
        }
    )),
    Class((function LevelPortal(_mesh, _shader) {
            Inherit(this, Component);
            const _this = this
                , V2 = new Vector2
                , V2_2 = new Vector2
                , V3 = new Vector3
                , DOWN_V3 = new Vector3(0,-1,0);
            var _position = new Vector3;
            function loop(time, delta) {
                if (!PlayerController.mainPlayer)
                    return;
                let {mainPlayer: mainPlayer} = PlayerController
                    , {position: position} = mainPlayer.group;
                _position.lerp(position, .15),
                    V2.set(position.x, position.z);
                let angle = V2.angle();
                if (_mesh.position.x = 59.99 * Math.cos(angle),
                    _mesh.position.z = 59.99 * Math.sin(angle),
                    _mesh.scale.x = .001,
                    _mesh.lookAt(0, 0, 0),
                _this.scene.name !== mainPlayer.currentScene.name)
                    return void (_mesh.visible = !1);
                _mesh.visible = !0,
                    V2_2.set(_mesh.position.x, _mesh.position.z);
                let distance = V2.distanceTo(V2_2)
                    , scalar = 4 * TweenManager.Interpolation.Quad.InOut(Math.range(distance, 10, 30, 1, 1e-4, !0), 2)
                    , uAlpha = Math.range(scalar, 1e-4, .2, 0, 1, !0)
                    , ratio = Stage.width / Stage.height;
                if (_mesh.scale.set(scalar * ratio, 5, 5),
                    _mesh.shader.set("uAlpha", uAlpha),
                    V3.copy(_mesh.position),
                    V3.y += 10,
                scalar > .01) {
                    let intersects = LevelController.raycaster.checkFromValues([_this.scene.floor], V3, DOWN_V3);
                    if (intersects && intersects.length) {
                        let point = intersects[0].point;
                        _mesh.position.y = point.y + _mesh.scale.y / 2 - .1 * _mesh.scale.y
                    }
                }
                _mesh.scale.x > .1 && _this.mainRoom && (_this.mainRoom.nuke.camera = Global.MAIN_ROOM_CAMERA,
                    Global.MAIN_ROOM_CAMERA.aspect = _mesh.scale.x / _mesh.scale.y,
                    Global.MAIN_ROOM_CAMERA.updateProjectionMatrix(),
                    _this.mainRoom.renderPreview(_mesh, _this.scene))
            }
            _this.parent.name.includes("grass"),
                _this.mainRoom = LevelController.getScene("main_room"),
                _this.mesh = _mesh,
                _this.scene = _this.parent.parent,
                _shader.addUniforms({
                    uAlpha: {
                        value: 0
                    },
                    uColor: {
                        value: new Color("0x000000")
                    },
                    tMap: {
                        value: null
                    }
                }),
                _shader.transparent = !0,
                _shader.deptHTest = !0,
                _shader.depthWrite = !0,
                _this.startRender(loop),
                LevelController.ready().then((()=>{
                        _this.mainRoom = LevelController.getScene("main_room"),
                        _this.mainRoom && _shader.set("tMap", _this.mainRoom.rt)
                    }
                ))
        }
    )),
    Class((function Env3Level() {
            const NAME = atob("c25vdw==");
            Inherit(this, AbstractLevel, NAME, "env3");
            const _this = this;
            var _fluidScene, _grassPatches, _customBloom, _fluidColor = new Color("#777777");
            _this.state.minAngle = .95,
                _this.state.maxAngle = .05;
            var _crackFloor, _crackTrees, _crackTreesShader, _pointShader, _bloomPoints, _treePos, _circleCompleted = !1, _currentMinAngle = _this.state.minAngle, _currentMaxAngle = _this.state.maxAngle, _lerpSpeed = .025, _bloomGlobalSTR = 0, _initialPlayerPosition = new Vector2(0,0), _currentPlayerPosition = new Vector2, _temp1 = new Vector2, _temp2 = new Vector2, _lightDarkColor = new Color("#7E92AD"), _lightDirDarkColor = new Color("#000F2D"), _snDarkColor = new Color("#555555"), _bloomNightColor = new Color("#DD2F2D"), _floorDarkCrackColor = new Color("#FFFFFF"), _grassColors = {
                uColorStem: new Color("#1D222B"),
                uColor1: new Color("#575757"),
                uColor2: new Color("#2B2B2B"),
                uFlowerColor1: new Color("#7D2121"),
                uFlowerColor2: new Color("#5B0000"),
                uFlowerAlpha: .5
            };
            let enabled1 = {
                val: 0
            }
                , enabled2 = {
                val: 0
            };
            !async function() {
                Lighting.createScene("env3", _this.scene),
                    Lighting.useScene("env3"),
                    _grassPatches = _this.initClass(GrassPatches, _this.layout, "grass", _this.name),
                    _this.layout.group.add(_grassPatches.group),
                    _grassPatches.ready().then((()=>{
                            Tests.useFlowers() && (_grassPatches.addFlowers(),
                                _grassPatches.instanceMesh.forEach((g=>{
                                        ["uColorStem", "uColor1", "uColor2", "uFlowerColor1", "uFlowerColor2", "uFlowerAlpha"].forEach((u=>{
                                                g.shader.uniforms[u] && ("number" == typeof g.shader.uniforms[u].value ? g[`__${u}`] = g.shader.uniforms[u].value : g[`__${u}`] = g.shader.uniforms[u].value.clone())
                                            }
                                        ))
                                    }
                                )))
                        }
                    )),
                    _this.playerConfig = {
                        speed: 1,
                        spawn: new Vector3(0,10,0),
                        angleX: Math.PI / 2
                    },
                    _this.radiusBounds = 60,
                    await async function initLevel() {
                        Lighting.useScene("env3"),
                            _this.layers = await _this.layout.getAllLayers(),
                            _this.floor = _this.layers.floor,
                            _this.portal = _this.layers.portal,
                            _this.particles = _this.layers.ambient_particles,
                            _this.moon = _this.layers.moon,
                            _this.layers.ambient_particles.visible = Tests.env3HasAmbientParticles();
                        let pr = [get("assets/geometry/env3/treepositions.json").then((e=>{
                                _treePos = e.positions
                            }
                        ))];
                        Tests.useEnv3Fluid() && (_fluidScene = new Env3FluidScene,
                            await _this.wait(_fluidScene, "fluid"),
                            _this.floor.shader.set("tFluid", _fluidScene.fluid.rt));
                        _this.layers.dir_light._initialColor = _this.layers.dir_light.light.color.clone(),
                            _this.layers.light._initialColor = _this.layers.light.light.color.clone(),
                            _this.floor.__initialCrackColor = _this.floor.shader.uniforms.uCrackColor.value.clone(),
                            await _this.layers.ambient_particles.ready(),
                            _this.layers.ambient_particles._initialColor = _this.layers.ambient_particles.mesh.shader.uniforms.uColor.value.clone(),
                            (_crackFloor = _this.floor.clone()).shader = new Shader("Env3FloorCrack",{
                                uCrackScale: {
                                    value: 60
                                },
                                uCrackRadius: {
                                    value: .326
                                },
                                uCrackWidth: {
                                    value: .002
                                },
                                uCrackAmount: {
                                    value: 30
                                },
                                uCrackDisplacement: {
                                    value: -.012
                                },
                                uCrackDispNoise: {
                                    value: new Vector2(.063,.48)
                                },
                                uCrackBigNoise: {
                                    value: new Vector3(.021,.04,.103)
                                },
                                uCrackMinAngle: {
                                    value: 0
                                },
                                uCrackMaxAngle: {
                                    value: .1
                                },
                                uEnabled: {
                                    value: 0
                                },
                                tTreeGlow: {
                                    value: Utils3D.getTexture("assets/images/env3/trees_glow.png")
                                },
                                tCell: {
                                    value: Utils3D.getTexture("assets/images/env3/cellnoise.jpg")
                                }
                            }),
                            _crackTrees = new Group,
                            _crackTreesShader = new Shader("Env3TreesCrack",{
                                uSize: {
                                    value: 0
                                },
                                uWindStrength: {
                                    value: .005
                                },
                                uWiggleStrength: {
                                    value: 5
                                },
                                uWindFrequency: {
                                    value: 1
                                },
                                uNoiseSpeed: {
                                    value: .5
                                },
                                uNoiseStrength: {
                                    value: .005
                                },
                                uNoiseScale: {
                                    value: 1
                                },
                                uCrackScale: {
                                    value: 60
                                },
                                uCrackRadius: {
                                    value: .326
                                },
                                uCrackWidth: {
                                    value: .002
                                },
                                uCrackAmount: {
                                    value: 30
                                },
                                uCrackDisplacement: {
                                    value: -.012
                                },
                                uCrackDispNoise: {
                                    value: new Vector2(.063,.48)
                                },
                                uCrackBigNoise: {
                                    value: new Vector3(.021,.04,.103)
                                },
                                tCell: {
                                    value: Utils3D.getTexture("assets/images/env3/cellnoise.jpg")
                                },
                                uEnabled: {
                                    value: 0
                                }
                            });
                        for (let i = 1; i < 4; i++) {
                            let tree = _this.layers[`baretree_${i}`];
                            pr.push(tree.instanceMeshReady)
                        }
                        await Promise.all(pr);
                        for (let i = 1; i < 4; i++) {
                            let tree = _this.layers[`baretree_${i}`];
                            tree = tree.instanceMesh.clone(),
                                tree.shader = _crackTreesShader,
                                _crackTrees.add(tree)
                        }
                        for (let key in _crackTreesShader.uniforms)
                            _this.layers.baretree_1.shader.uniforms[key] && !_crackTreesShader.uniforms[key] && ("number" == typeof _crackTreesShader.uniforms[key].value ? _crackTreesShader.uniforms[key].value = _this.layers.baretree_1.shader.uniforms[key].value : _crackTreesShader.uniforms[key].value.copy(_this.layers.baretree_1.shader.uniforms[key].value));
                        (_customBloom = new FX.UnrealBloomCustom(_this.nuke,{},_this.name)).clearColor = new Color("#000000"),
                            _this.nuke.add(_customBloom.pass),
                            _customBloom.events.unsub(RenderManager.POST_RENDER, _customBloom.renderBloom),
                            _customBloom.__initialTintColor = _customBloom.compositeColor.clone(),
                            _customBloom.__initialSTR = _customBloom.compositeSTR,
                            _customBloom.__initialRadius = _customBloom.compositeRadius,
                            _customBloom.compositeSTR = .5,
                            _customBloom.compositeRadius = .5,
                            _customBloom.cracksScene.add(_crackFloor),
                            _customBloom.cracksScene.add(_crackTrees);
                        let offsets = []
                            , seeds = [];
                        _treePos.forEach((t=>{
                                for (let i = 0; i < 15; i++)
                                    offsets.push(t[0], t[1], t[2]),
                                        seeds.push(Math._random(), Math._random(), Math._random(), Math._random())
                            }
                        ));
                        let pointGeometry = new Geometry;
                        pointGeometry.addAttribute("position", new GeometryAttribute(new Float32Array(offsets),3)),
                            pointGeometry.addAttribute("seed", new GeometryAttribute(new Float32Array(seeds),4)),
                            _pointShader = _this.initClass(Shader, "Env3Particles", {
                                uColor: {
                                    value: new Color("#ff0000")
                                },
                                uPointSize: {
                                    value: 20
                                },
                                uSpeed: {
                                    value: 1.25
                                },
                                uEnabled: {
                                    value: 0
                                },
                                unique: NAME,
                                transparent: !0,
                                depthWrite: !0,
                                depthTest: !0
                            }),
                            ShaderUIL.add(_pointShader).setLabel("Particle Shader");
                        let part = new Points(pointGeometry,_pointShader);
                        part.frustumCulled = !1,
                            part.onBeforeRender = _=>{
                                _pointShader.uniforms.uColor.value.setRGB(1, 0, 0)
                            }
                            ,
                            _this.layout.group.add(part),
                            (_bloomPoints = part.clone()).onBeforeRender = _=>{
                                _pointShader.uniforms.uColor.value.setRGB(1, 1, 1)
                            }
                            ,
                            _customBloom.cracksScene.add(_bloomPoints)
                    }(),
                    _this.checkDebug(),
                    _this.isReady = !0
            }(),
                _this.update = (time,delta)=>{
                    if (!_this.isReady)
                        return;
                    World.CAMERA.far = 1e3,
                        _this.updateCamera(),
                        Lighting.useScene("env3"),
                    _fluidScene && _fluidScene.update();
                    let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                    [mainPlayer, remotePlayer].forEach((player=>{
                            if (player && player !== remotePlayer && player.currentScene && "env3" === player.currentScene.name && !_this.resetting) {
                                let velocity = player.velocity3
                                    , length = velocity.length()
                                    , radius = 75
                                    , x = Math.range(player.group.position.x, -radius, radius, 0, Stage.width)
                                    , y = Math.range(player.group.position.z, -radius, radius, 0, Stage.height);
                                if (_fluidScene && _fluidScene.fluid && _fluidScene.fluid.drawInput(x, y, 10 * velocity.x, 10 * velocity.z, _fluidColor, Math.range(length, 0, .25, 1, 3) + .1 * Math.sin(Render.TIME)),
                                    !_circleCompleted) {
                                    _currentPlayerPosition.x = player.group.position.x,
                                        _currentPlayerPosition.y = player.group.position.z;
                                    let l = _temp1.copy(_initialPlayerPosition).sub(_currentPlayerPosition).length();
                                    _temp2.setScalar(0),
                                        _temp1.rotateAround(_temp2, .5 * -Math.PI),
                                        _temp1.subScalar(.5);
                                    let a = 1 - _temp1.angle() / (2 * Math.PI);
                                    if (l > 25 && l < 42 && _this.state.maxAngle < _this.state.minAngle) {
                                        let offset = .02
                                            , dMax = Math.abs(a - _this.state.maxAngle)
                                            , dMin = Math.abs(a - _this.state.minAngle);
                                        (dMax < offset || dMin < offset) && (dMax < dMin ? _this.state.maxAngle = Math.max(_this.state.maxAngle, a + offset) : _this.state.minAngle = Math.min(_this.state.minAngle, a - offset),
                                        _this.state.maxAngle >= _this.state.minAngle && (_lerpSpeed = .075))
                                    }
                                    _currentMaxAngle = Math.lerp(_this.state.maxAngle, _currentMaxAngle, _lerpSpeed),
                                        _this.floor.shader.set("uCrackMaxAngle", _currentMaxAngle),
                                        _currentMinAngle = Math.lerp(_this.state.minAngle, _currentMinAngle, _lerpSpeed),
                                        _this.floor.shader.set("uCrackMinAngle", _currentMinAngle),
                                    _currentMaxAngle >= _currentMinAngle && (_circleCompleted = !0,
                                        _this.isReset = !1,
                                        tween(enabled1, {
                                            val: 1
                                        }, 5e3, "easeInOutCubic", 500).onUpdate((_=>{
                                                _crackTreesShader.set("uEnabled", enabled1.val),
                                                    _crackFloor.shader.set("uEnabled", enabled1.val),
                                                    _this.floor.shader.set("uGlow", enabled1.val),
                                                    _this.floor.shader.uniforms.uCrackColor.value.lerp(_floorDarkCrackColor, enabled1.val),
                                                    _this.layers.baretree_1.shader.set("uGlow", enabled1.val),
                                                    _bloomGlobalSTR = enabled1.val,
                                                    _customBloom.compositeRadius = Math.mix(_customBloom.__initialRadius, -1, enabled1.val),
                                                    _pointShader.set("uEnabled", enabled1.val),
                                                    _customBloom.compositeColor.copy(_customBloom.__initialTintColor).lerp(_bloomNightColor, enabled1.val)
                                            }
                                        )),
                                        tween(enabled2, {
                                            val: 1
                                        }, 4e3, "easeInOutCubic").onUpdate((_=>{
                                                _this.layers.horizon.shader.set("uEnabled", enabled2.val),
                                                    _this.floor.shader.set("uEnabled", enabled2.val),
                                                    _this.moon.shader.set("uAlpha", enabled2.val),
                                                    _this.layers.baretree_1.shader.set("uEnabled", enabled2.val),
                                                    _this.layers.light.light.color.copy(_this.layers.light._initialColor).lerp(_lightDarkColor, enabled2.val),
                                                    _this.layers.dir_light.light.color.copy(_this.layers.dir_light._initialColor).lerp(_lightDirDarkColor, enabled2.val),
                                                    _this.layers.ambient_particles.mesh.shader.uniforms.uColor.value.copy(_this.layers.ambient_particles._initialColor).lerp(_snDarkColor, .9 * enabled2.val),
                                                    _grassPatches.instanceMesh.forEach((g=>{
                                                            ["uColorStem", "uColor1", "uColor2"].forEach((u=>{
                                                                    g[`__${u}`] && ("number" == typeof g.shader.uniforms[u].value ? g.shader.uniforms[u].value = Math.mix(g[`__${u}`], _grassColors[u], enabled2.val) : g.shader.uniforms[u].value.copy(g[`__${u}`]).lerp(_grassColors[u], enabled2.val))
                                                                }
                                                            )),
                                                                ["uFlowerColor1", "uFlowerColor2", "uFlowerAlpha"].forEach((u=>{
                                                                        g[`__${u}`] && ("number" == typeof g.shader.uniforms[u].value ? g.shader.uniforms[u].value = Math.mix(g[`__${u}`], _grassColors[u], enabled2.val) : g.shader.uniforms[u].value.copy(g[`__${u}`]).lerp(_grassColors[u], enabled2.val))
                                                                    }
                                                                ))
                                                        }
                                                    ))
                                            }
                                        )))
                                }
                            }
                        }
                    ));
                    for (let key in _crackFloor.shader.uniforms)
                        "uEnabled" !== key && ("number" == typeof _crackFloor.shader.uniforms[key].value ? (_crackFloor.shader.uniforms[key] && (_crackFloor.shader.uniforms[key].value = _this.floor.shader.uniforms[key].value),
                        _crackTreesShader.uniforms[key] && (_crackTreesShader.uniforms[key].value = _this.floor.shader.uniforms[key].value),
                        _this.layers.baretree_1.shader.uniforms[key] && (_this.layers.baretree_1.shader.uniforms[key].value = _this.floor.shader.uniforms[key].value)) : "tTreeGlow" !== key && "tCell" !== key && (_crackFloor.shader.uniforms[key] && _crackFloor.shader.uniforms[key].value.copy(_this.floor.shader.uniforms[key].value),
                        _crackTreesShader.uniforms[key] && _crackTreesShader.uniforms[key].value.copy(_this.floor.shader.uniforms[key].value),
                        _this.layers.baretree_1.shader.uniforms[key] && _this.layers.baretree_1.shader.uniforms[key].value.copy(_this.floor.shader.uniforms[key].value)));
                    if (mainPlayer && _this.particles.shader.set("uRes", mainPlayer.currentScene.name === NAME ? 1 : Tests.getPreviewDPR()),
                    _customBloom && (_customBloom.compositeSTR = Math.mix(.5, .75 * _customBloom.__initialSTR + .25 * _customBloom.__initialSTR * (Math.sin(.002 * Render.TIME) / 2 + .5), _bloomGlobalSTR),
                        _customBloom.renderBloom()),
                        _this.render(null, World.CAMERA),
                        _this.rayCaster) {
                        document.body.style.cursor = "default";
                        let hits = _this.rayCaster.checkHit(_this.floor);
                        hits.length > 0 && (_this.lastCastedPoint = hits[0].point.clone())
                    }
                }
                ,
                _this.getLevelState = ()=>_this.state,
                _this.syncRemoteState = state=>{
                    if (!_this.resetting)
                        return _this.state.maxAngle = Math.max(_this.state.maxAngle, state.maxAngle),
                            _this.state.minAngle = Math.max(_this.state.minAngle, state.minAngle),
                            _this.state
                }
                ,
                _this.resetState = function() {
                    _this.isReset || (_this.isReset = !0,
                        _this.resetting = !0,
                        _this.delayedCall((_=>{
                                _this.resetting = !1
                            }
                        ), 500),
                        _this.state.minAngle = .95,
                        _this.state.maxAngle = .05,
                        _currentMinAngle = _this.state.minAngle,
                        _currentMaxAngle = _this.state.maxAngle,
                        _this.floor.shader.set("uCrackMaxAngle", _currentMaxAngle),
                        _this.floor.shader.set("uCrackMinAngle", _currentMinAngle),
                        _temp1.set(0, 0),
                        _temp2.set(0, 0),
                        _initialPlayerPosition.set(0, 0, 0),
                        _currentPlayerPosition.set(0, 0, 0),
                        !1,
                        _circleCompleted = !1,
                        clearTween(enabled1),
                        clearTween(enabled2),
                        enabled1.val = 0,
                        enabled2.val = 0,
                        _lerpSpeed = .025,
                        _crackTreesShader.set("uEnabled", 0),
                        _crackFloor.shader.set("uEnabled", 0),
                        _this.layers.horizon.shader.set("uEnabled", 0),
                        _this.floor.shader.set("uEnabled", 0),
                        _this.floor.shader.set("uGlow", 0),
                        _this.layers.baretree_1.shader.set("uEnabled", 0),
                        _this.layers.baretree_1.shader.set("uGlow", 0),
                        _this.layers.light.light.color.copy(_this.layers.light._initialColor),
                        _this.layers.dir_light.light.color.copy(_this.layers.dir_light._initialColor),
                        _this.layers.ambient_particles.mesh.shader.uniforms.uColor.value.copy(_this.layers.ambient_particles._initialColor),
                        _this.floor.shader.uniforms.uCrackColor.value.copy(_this.floor.__initialCrackColor),
                        _pointShader.set("uEnabled", 0),
                        _this.moon.shader.set("uAlpha", 0),
                        _customBloom.compositeColor.copy(_customBloom.__initialTintColor),
                        _customBloom.compositeRadius = _customBloom.__initialRadius,
                        _grassPatches.instanceMesh.forEach((g=>{
                                ["uColorStem", "uColor1", "uColor2", "uFlowerColor1", "uFlowerColor2", "uFlowerAlpha"].forEach((u=>{
                                        g[`__${u}`] && ("number" == typeof g.shader.uniforms[u].value ? g.shader.uniforms[u].value = g[`__${u}`] : g.shader.uniforms[u].value.copy(g[`__${u}`]))
                                    }
                                ))
                            }
                        )),
                        _bloomGlobalSTR = 0,
                        _customBloom.compositeSTR = .5,
                        _customBloom.compositeRadius = .5)
                }
                ,
                _this.ready = ()=>_this.wait("isReady"),
                this.uploadAll = async function() {
                    await _this.ready(),
                        await Initializer3D.uploadAll(_this.layout),
                        await _grassPatches.uploadAll()
                }
                ,
                this.uploadAllAsync = async function() {
                    await _this.ready(),
                        await Initializer3D.uploadAllAsync(_this.layout),
                        await _grassPatches.uploadAllAsync()
                }
        }
    )),
    Class((function Env3Floor(_mesh, _shader) {
            Inherit(this, Component);
            _shader.addUniforms({
                tLightmap: {
                    value: null
                },
                tNightmap: {
                    value: null
                },
                tFluid: {
                    value: null,
                    ignoreUIL: !0
                },
                tNormal: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                tRandom: {
                    value: Utils3D.getRepeatTexture("assets/images/noise/random256.jpg"),
                    ignoreUIL: !0
                },
                uOffset: {
                    value: new Vector2
                },
                uEdgeColor: {
                    value: new Color
                },
                uRange: {
                    value: new Vector2
                },
                uEnabled: {
                    value: 0
                },
                uGlow: {
                    value: 0
                },
                uCrackScale: {
                    value: .3
                },
                uCrackRadius: {
                    value: 5
                },
                uCrackWidth: {
                    value: .3
                },
                uCrackColor: {
                    value: new Color
                },
                uGlowColor: {
                    value: new Color
                },
                uCrackAmount: {
                    value: 5
                },
                uCrackDisplacement: {
                    value: 1
                },
                uCrackDispNoise: {
                    value: new Vector2
                },
                uCrackBigNoise: {
                    value: new Vector3
                },
                uMoonLightPos: {
                    value: new Vector4
                },
                uMoonLightColor: {
                    value: new Color
                },
                uCrackMinAngle: {
                    value: 0
                },
                uCrackMaxAngle: {
                    value: .1
                },
                tCell: {
                    value: Utils3D.getTexture("assets/images/env3/cellnoise.jpg")
                },
                tTreeGlow: {
                    value: Utils3D.getTexture("assets/images/env3/trees_glow.png")
                },
                tNoise: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                }
            }),
                _mesh.geometry.computeVertexNormals(),
                this.update = function(time, delta) {}
        }
    )),
    Class((function Env3FluidScene(_fluid) {
            Inherit(this, FXScene);
            const _this = this;
            function resize() {
                let scale = Tests.getFluidScenesResolution();
                _this.setSize(Stage.width * scale, Stage.height * scale)
            }
            function loop() {
                let clearAlpha = World.RENDERER.getClearAlpha();
                World.RENDERER.setClearAlpha(0),
                    _this.render(),
                    World.RENDERER.setClearAlpha(clearAlpha)
            }
            !async function() {
                _this.create(World.NUKE, null, {
                    format: Texture.RGBAFormat
                });
                let layout = _this.initClass(SceneLayout, "env3fluid")
                    , fluid = await layout.getLayer("fluid");
                fluid.additiveBlending = !1,
                    _this.fluid = fluid,
                _this.isPlayground() && (fluid.debugMouse = !0,
                    _this.startRender(loop)),
                    _this.onResize(resize)
            }(),
                this.update = function() {
                    loop()
                }
        }
    )),
    Class((function Env3Moon(_mesh, _shader) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMap: {
                    value: null
                },
                uColor: {
                    value: new Color
                },
                tNoise: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                uAlpha: {
                    value: 0
                }
            })
        }
    )),
    Class((function Env3Trees(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMap: {
                    value: null
                },
                uColorMix: {
                    value: .5
                },
                uColor: {
                    value: new Color
                },
                uColor2: {
                    value: new Color
                },
                uAlphaCutOff: {
                    value: .5
                },
                uHighlightRange: {
                    value: new Vector2(.6,2.25)
                },
                uHighlightColor: {
                    value: new Color
                },
                uSize: {
                    value: 0
                },
                uWindStrength: {
                    value: .005
                },
                uWiggleStrength: {
                    value: 5
                },
                uWindFrequency: {
                    value: 1
                },
                uNoiseSpeed: {
                    value: .5
                },
                uNoiseStrength: {
                    value: .005
                },
                uNoiseScale: {
                    value: 1
                },
                uFadeColor: {
                    value: new Color
                },
                uFadeEnabledColor: {
                    value: new Color
                },
                uFadeRange: {
                    value: new Vector2
                },
                uEnabled: {
                    value: 0
                },
                uGlow: {
                    value: 0
                },
                uCrackScale: {
                    value: .3
                },
                uCrackRadius: {
                    value: 5
                },
                uCrackWidth: {
                    value: .3
                },
                uLightColor: {
                    value: new Color
                },
                uLightColorBase: {
                    value: new Color
                },
                uCrackAmount: {
                    value: 5
                },
                uCrackDisplacement: {
                    value: 1
                },
                uCrackDispNoise: {
                    value: new Vector2
                },
                uCrackBigNoise: {
                    value: new Vector3
                },
                tCell: {
                    value: Utils3D.getTexture("assets/images/env3/cellnoise.jpg"),
                    ignoreUIL: !0
                }
            })
        }
    )),
    Class((function BoxGrass(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMap: {
                    value: null
                },
                tLightmap: {
                    value: null
                },
                uColor1: {
                    value: new Color
                },
                uColor2: {
                    value: new Color
                },
                uTextureMix: {
                    value: .5
                },
                uHighlightColor: {
                    value: new Color
                },
                uHighlightRange: {
                    value: new Vector2
                },
                uNoiseSpeed: {
                    value: .5
                },
                uNoiseScale: {
                    value: 1
                },
                uNoiseStrength: {
                    value: .5
                },
                uTextureOffset: {
                    value: new Vector2(.5,0)
                },
                uTextureRangeX: {
                    value: new Vector2
                },
                uTextureRangeZ: {
                    value: new Vector2
                },
                uScale: {
                    value: new Vector3(1,1,1)
                },
                uOffset: {
                    value: new Vector3
                },
                uFogCutoff: {
                    value: 50
                },
                uAlphaCutoff: {
                    value: .5
                }
            })
        }
    )),
    Class((function BoxShadow(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMask: {
                    value: null
                },
                tMap: {
                    value: null
                },
                uColor: {
                    value: new Color
                }
            })
        }
    )),
    Class((function Env4Floor(_mesh, _shader) {
            Inherit(this, Component);
            !function() {
                let geom = new PlaneGeometry(1,1,50,50).toNonIndexed()
                    , pos = geom.attributes.position.array;
                for (let i = 0, l = pos.length; i < l; i += 3) {
                    pos[i + 0],
                        pos[i + 1],
                        pos[i + 2]
                }
                geom.attributes.position.needsUpdate = !0,
                    geom.computeVertexNormals(),
                    _mesh.geometry = geom,
                    _mesh.rotation.x = -Math.PI / 2,
                    _shader.addUniforms({
                        tFluid: {
                            value: null
                        },
                        uColor: {
                            value: new Color
                        },
                        tNormal: {
                            value: null,
                            getTexture: Utils3D.getRepeatTexture
                        },
                        tRoughness: {
                            value: null,
                            getTexture: Utils3D.getRepeatTexture
                        },
                        uNormalRange: {
                            value: new Vector2
                        },
                        uRoughnessRange: {
                            value: new Vector2
                        },
                        uNormalIntensity: {
                            value: 1
                        },
                        uTile: {
                            value: 1
                        },
                        uColor2: {
                            value: new Color
                        },
                        uColor3: {
                            value: new Color
                        },
                        uColorBlend: {
                            value: 1
                        },
                        uEnabled: {
                            value: 1
                        }
                    })
            }(),
                this.update = function(time, delta) {}
        }
    )),
    Class((function Env4Level() {
            const NAME = atob("Y2xvdWRz");
            Inherit(this, AbstractLevel, NAME, "env4");
            const _this = this;
            var _fluidScene, _horizonClone, _fluidColor = new Color("#FFFFFF"), _canPlayNote = !0;
            function beforeMirrorRender() {
                let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController
                    , mScene = _this.mirror.scene;
                mainPlayer && mainPlayer.currentScene && mainPlayer.currentScene.name === NAME && (mScene.add(mainPlayer.group),
                    mScene.add(mainPlayer.orb.group),
                    mainPlayer.mirrorRenderSwap = !0),
                remotePlayer && remotePlayer.currentScene && remotePlayer.currentScene.name === NAME && (mScene.add(remotePlayer.group),
                    mScene.add(remotePlayer.orb.group),
                    remotePlayer.mirrorRenderSwap = !0)
            }
            function afterMirrorRender() {
                let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                if (mainPlayer && mainPlayer.mirrorRenderSwap && (mainPlayer.mirrorRenderSwap = !1,
                    mainPlayer.currentScene)) {
                    let group = mainPlayer.currentScene.layout.group;
                    group.add(mainPlayer.group),
                        group.add(mainPlayer.orb.group)
                }
                if (remotePlayer && remotePlayer.mirrorRenderSwap && (mainPlayer.mirrorRenderSwap = !1,
                    remotePlayer.currentScene)) {
                    let group = remotePlayer.currentScene.layout.group;
                    group.add(remotePlayer.group),
                        group.add(remotePlayer.orb.group)
                }
            }
            function playNote(index) {
                if (!_canPlayNote || !_this.canJumpHit)
                    return;
                if (_canPlayNote = !1,
                    _this.delayedCall((_=>{
                            _canPlayNote = !0
                        }
                    ), 1500),
                null == index && (_this.state.notes = _this.state.notes || [],
                (index = _this.state.notes.indexOf(!1)) < 0 && (index = _this.state.notes.length)),
                    _this.state.notes[index])
                    return;
                if (index > 3)
                    return;
                3 === index && _this.onPlayersEnabled(),
                    _this.state.notes[index] = !0;
                let audio = document.createElement("audio");
                audio.preload = "preload";
                let src = document.createElement("source");
                src.src = `assets/audio/piano/${index + 1}.mp3`,
                    audio.appendChild(src),
                    audio.load(),
                    audio.play()
            }
            !async function() {
                _this.playerConfig = {
                    speed: 1,
                    spawn: new Vector3(0,10,0),
                    angleX: Math.PI / 2 * 2
                },
                    function addListeners() {
                        _this.events.sub(GameControls.JUMP, (_=>{
                                _this.delayedCall(playNote, 2e3)
                            }
                        ))
                    }(),
                    await async function initLevel() {
                        Lighting.createScene("env4", _this.scene),
                            Lighting.useScene("env4"),
                            _this.layers = await _this.layout.getAllLayers(),
                            _this.floor = _this.layers.floor,
                            _this.portal = _this.layers.portal,
                            _this.rain = _this.layers.rain,
                            _this.ghost = _this.layers.ghost,
                            _this.ghost.shader.set("uAlpha", 0),
                            await _this.rain.ready(),
                            _this.rain.shader.set("uAlpha", 0);
                        let shader = _this.layers.horizon.shader;
                        _this.floor.shader.addUniforms({
                            uHorizonColor: shader.uniforms.uColor,
                            uHorizonColor2: shader.uniforms.uColor2,
                            uHorizonColorEnabled: shader.uniforms.uColorEnabled,
                            uHorizonColor2Enabled: shader.uniforms.uColor2Enabled,
                            uEnabled: shader.uniforms.uEnabled
                        }),
                            _this.hitMeshes = [_this.layers.grassmound_hit, _this.layers.floor_hit],
                            _this.collisionMeshes = [_this.layers.piano, _this.layers.piano_hit],
                            _this.layers.grassmound_hit.shader.neverRender = !0,
                            _this.layers.piano_hit.shader.neverRender = !0,
                            _this.layers.floor_hit.shader.neverRender = !0
                    }(),
                    function initMirror() {
                        _horizonClone = new Mesh(_this.layers.horizon.geometry,_this.layers.horizon.shader);
                        let mirror = _this.initClass(FX.Mirror, _this.layers.floor, {
                            size: Tests.waterMirrorSize(),
                            enabled: Tests.renderMirror()
                        });
                        mirror.add(_this.layers.box),
                            mirror.add(_this.layers.grassmound),
                            mirror.scene.add(_horizonClone),
                            mirror.add(_this.layers.piano),
                            mirror.add(_this.layers.portal),
                            mirror.add(_this.layers.stool),
                        _this.isPlayground() && mirror.start();
                        _this.mirror = mirror,
                            mirror.onBeforeRender = beforeMirrorRender,
                            mirror.onAfterRender = afterMirrorRender
                    }(),
                Tests.useEnv4Fluid() && await async function initFluidScene() {
                    _fluidScene = _this.initClass(Env4FluidScene),
                        await _this.wait(_fluidScene, "fluid"),
                        _this.floor.shader.set("tFluid", _fluidScene.fluid.rt)
                }(),
                    _this.checkDebug(),
                    _this.radiusBounds = 60,
                    _this.isReady = !0
            }(),
                this.onStart = function() {
                    _this.isRunning || _this.mirror.start()
                }
                ,
                this.onPause = function() {
                    _this.isRunning && _this.mirror.stop()
                }
                ,
                _this.update = (time,delta)=>{
                    if (_fluidScene && _fluidScene.update(),
                        _horizonClone.scale.copy(_this.layers.horizon.scale).multiplyScalar(1.2),
                        World.CAMERA.far = 400,
                        _this.updateCamera(),
                    !_fluidScene || !_fluidScene.fluid)
                        return;
                    let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                    [mainPlayer, remotePlayer].forEach((player=>{
                            if (!player)
                                return;
                            if (player == remotePlayer)
                                return;
                            let velocity = player.velocity3
                                , length = velocity.length()
                                , x = Math.range(player.group.position.x, -75, 75, 0, Stage.width)
                                , y = Math.range(player.group.position.z, -75, 75, 0, Stage.height);
                            player && player.currentScene && player.currentScene.name === NAME && _fluidScene.fluid.drawInput(x, y, 10 * velocity.x, 10 * velocity.z, _fluidColor, Math.range(length, 0, .25, .1, 1.5) + .1 * Math.sin(Render.TIME))
                        }
                    )),
                        _this.render()
                }
                ,
                _this.onPlayersEnabled = function() {
                    _this.layers.horizon.shader.tween("uEnabled", 1, 6e3, "easeInOutCubic"),
                        _this.layers.grassmound.shader.tween("uEnabled", 1, 6e3, "easeInOutCubic"),
                        _this.layers.stool.shader.tween("uEnabled", 1, 6e3, "easeInOutCubic"),
                        _this.layers.piano.shader.tween("uEnabled", 1, 6e3, "easeInOutCubic"),
                        _this.rain.shader.tween("uAlpha", 1, 6e3, "easeInOutCubic"),
                        _this.ghost.shader.tween("uAlpha", 1, 6e3, "easeInOutCubic"),
                        _this.layers.box.shader.tween("uAlpha", 0, 6e3, "easeInOutCubic")
                }
                ,
                _this.getLevelState = ()=>(_this.state.notes || (_this.state.notes = [!1, !1, !1]),
                    _this.state),
                _this.syncRemoteState = state=>{
                    if (_this.getLevelState(),
                    state.notes && _this.state.notes) {
                        for (let i = 0, l = _this.state.notes.length; i < l; i++)
                            state.notes[i] && (_this.state.notes[i] = state.notes[i]);
                        return _this.state.notes.forEach(((value,i)=>{
                                value && playNote(i)
                            }
                        )),
                            _this.state
                    }
                }
                ,
                _this.resetState = function() {
                    _this.isReset || (_this.isReset = !0,
                        _this.state.notes = [!1, !1, !1],
                        _this.rain.shader.set("uAlpha", 0),
                    _this.layers && (_this.layers.horizon && _this.layers.horizon.shader.tween("uEnabled", 0, 3e3, "easeInOutSine"),
                    _this.layers.box && _this.layers.box.shader.tween("uAlpha", 1, 3e3, "easeInOutSine")))
                }
                ,
                this.onCollision = function(e) {
                    _this.collided || (console.log("play note"),
                        _this.collided = !0,
                        _this.canJumpHit = !0,
                        playNote())
                }
                ,
                this.onNoCollision = function(e) {
                    _this.collided && (_this.collided = !1,
                        _this.delayRemove = _this.delayedCall((_=>{
                                _this.canJumpHit = !1
                            }
                        ), 3e3))
                }
                ,
                _this.ready = ()=>_this.wait("isReady"),
                _this.uploadAll = async function() {
                    await _this.ready(),
                        await Initializer3D.uploadAll(_this.layout)
                }
                ,
                _this.uploadAllAsync = async function() {
                    await _this.ready(),
                        await Initializer3D.uploadAllAsync(_this.layout)
                }
        }
    )),
    Class((function Ghost(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            !async function() {
                _shader.addUniforms({
                    tMap: {
                        value: null,
                        getTexture: Utils3D.getRepeatTexture
                    },
                    uFloatSpeed: {
                        value: 3
                    },
                    uNoiseSpeed: {
                        value: 1.95
                    },
                    uNoiseScale: {
                        value: 1
                    },
                    uNoiseStrength: {
                        value: .5
                    },
                    uBlinkStrength: {
                        value: 1
                    },
                    uBlinkSpeed: {
                        value: 1
                    },
                    uFloatAmountX: {
                        value: .7
                    },
                    uFloatAmountY: {
                        value: .7
                    },
                    uFloatAmountZ: {
                        value: .7
                    },
                    uAlpha: {
                        value: 0
                    },
                    transparent: !0,
                    blending: Shader.ADDITIVE_BLENDING
                })
            }()
        }
    )),
    Class((function GrassEdge(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMap: {
                    value: null
                },
                tLightmap: {
                    value: null
                }
            })
        }
    )),
    Class((function GrassMound(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMask: {
                    value: null
                },
                tGrass: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                uGrassTile: {
                    value: 2
                },
                uTextureMix: {
                    value: .5
                },
                tLightmap: {
                    value: null
                },
                uColor1: {
                    value: new Color
                },
                uColor2: {
                    value: new Color
                },
                uColorRange: {
                    value: new Vector2
                },
                uTint1: {
                    value: new Color
                },
                uTint2: {
                    value: new Color
                },
                uTintRange: {
                    value: new Vector2
                },
                uEnabled: {
                    value: 0
                },
                uEnabledColor: {
                    value: new Color
                }
            })
        }
    )),
    Class((function LightmapSurface(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMap: {
                    value: null
                },
                uAlpha: {
                    value: 1
                },
                tLightmap: {
                    value: null
                },
                uFadeRange: {
                    value: new Vector2
                },
                uEnabled: {
                    value: 0
                },
                uEnabledColor: {
                    value: new Color
                },
                transparent: !0
            })
        }
    )),
    Class((function Env4FluidScene(_fluid) {
            Inherit(this, FXScene);
            const _this = this;
            new Color("#FF6600");
            function resize() {
                let scale = Tests.getFluidScenesResolution();
                _this.setSize(Stage.width * scale, Stage.height * scale)
            }
            function loop() {
                _this.render()
            }
            !async function() {
                await async function initScene() {
                    _this.create(),
                        _this.layout = _this.initClass(SceneLayout, "env4fluid");
                    let fluid = await _this.layout.getLayer("fluid");
                    if (_this.fluid = fluid,
                        _this.setResolution(Tests.getFluidScenesResolution()),
                        _this.isPlayground()) {
                        let plane = new Mesh(World.PLANE,new Shader("ScreenQuad",{
                            tMap: {
                                value: fluid.rt
                            }
                        }));
                        _this.scene.add(plane),
                            _this.startRender(loop)
                    }
                    _this.onResize(resize)
                }()
            }(),
                _this.update = function() {
                    loop()
                }
        }
    )),
    Class((function Env5Level() {
            Inherit(this, AbstractLevel, "env5", "env5");
            const _this = this;
            var $time, _curve, _background, _video, _drops = [{
                darken: [1.45, 2.1],
                brighten: [2.17, 2.25]
            }, {
                darken: [3.11, 3.2],
                brighten: [3.4, 3.5],
                brightValue: .8
            }];
            function play() {
                Env5Level.isPlaying || (Env5Level.isPlaying = !0,
                    Env5Level.percent = 0,
                    _this.startTime = Render.TIME,
                    _this.checkPlaying = !1,
                    _video.start(),
                    _video.video.volume = 1,
                _video.video.div.currentTime > 0 && (_video.video.div.currentTime = 0),
                    _this.events.sub(_video.video, Video.PLAYING, (_=>{
                            if (!_this.checkPlaying) {
                                _this.checkPlaying = !0;
                                let jump = Math.clamp(Render.TIME - _this.startTime, 0, 1e4);
                                _video.video.div.currentTime = jump / 1e3
                            }
                        }
                    )),
                    _this.events.sub(Keyboard.UPPED, forcePlay),
                    _this.events.sub(Mouse.input, Interaction.START, forcePlay))
            }
            function forcePlay() {
                if (Env5Level.percent > 0)
                    return _this.events.unsub(Keyboard.UPPED, forcePlay),
                        void _this.events.unsub(Mouse.input, Interaction.START, forcePlay);
                _video.video.div.play()
            }
            function stop() {
                Env5Level.isPlaying && (_this.state.local = !1,
                    _this.state.remote = !1,
                    _this.events.unsub(Keyboard.UPPED, forcePlay),
                    _this.events.unsub(Mouse.input, Interaction.START, forcePlay),
                    Env5Level.isPlaying = !1,
                    Env5Level.isPlayingMulti = !1,
                    Env5Level.percent = 0,
                    _video.video.div.pause(),
                    _video.video.div.currentTime = 0,
                    _video.stop())
            }
            !async function() {
                _curve = Env5Level.getCurve(),
                    _video = Env5Video.getVideo(),
                    Env5Level.uFogRange.value.set(.25 * Tests.getEnv5FarPlane(), Tests.getEnv5FarPlane()),
                    _this.playerConfig = {
                        speed: .7,
                        spawn: new Vector3(2,0,6),
                        useSpawn: !0,
                        angleX: 90
                    },
                    function addListeners() {
                        _this.events.sub(Env5Level.PLAY, play)
                    }(),
                    function initBackground() {
                        (_background = _this.initClass(Env5Background)).mesh = new Mesh(World.QUAD,new Shader("Env5Material",{
                            tMap: {
                                value: _background
                            },
                            depthWrite: !1
                        })),
                            _background.mesh.frustumCulled = !1,
                            _background.mesh.renderOrder = -1,
                            _this.layout.group.add(_background.mesh)
                    }(),
                    await async function initLevel() {
                        Lighting.createScene("env5", _this.scene),
                            Lighting.useScene("env5"),
                            _this.layers = await _this.layout.getAllLayers(),
                            _this.floor = _this.layers.floor,
                            _this.video = _this.layers.video,
                            _this.hitMeshes = [_this.layers.floor]
                    }(),
                    _this.checkDebug(),
                    _this.noBounds = !0,
                    _this.isReady = !0,
                "Env5Level" == Global.PLAYGROUND && (_this.events.sub(Keyboard, Keyboard.DOWNED, (e=>{
                        Number(e.layoutKey) > 0 && Number(e.layoutKey) < 10 && Mouse.x < Stage.width - 300 && (_video.video.div.currentTime = Env5Video.DURATION * (Number(e.layoutKey) / 10))
                    }
                )),
                    ($time = Stage.create(".time")).fontStyle("Courier New", 15, "#fff"),
                    $time.css({
                        top: 20,
                        left: 20,
                        letterSpacing: "0.2em"
                    }).setZ(100))
            }(),
                this.onStart = function() {
                    if (_this.isRunning)
                        return;
                    Env5Level.isPlaying = !1;
                    let camera = World.CAMERA;
                    camera.saveFar || (camera.saveFar = camera.far),
                        camera.far = Tests.getEnv5FarPlane(),
                        camera.updateProjectionMatrix()
                }
                ,
                this.onPause = function() {
                    if (!_this.isRunning)
                        return;
                    let camera = World.CAMERA;
                    camera.saveFar && (camera.far = camera.saveFar,
                        camera.updateProjectionMatrix()),
                        stop()
                }
                ,
                _this.update = (time,delta)=>{
                    let speed = _this.activated ? .1 : 1;
                    Env5Level.uTime.value += delta / 1e3 * speed;
                    let videoTime = _video.video.div.currentTime;
                    Global.ENV5_VIDEO_TIME = Env5Level.videoTime = videoTime;
                    let percent = videoTime / Env5Video.DURATION || 0;
                    Env5Level.isPlaying || (percent = 0);
                    let position = _curve.getPoint(percent);
                    if (position.y -= 5.2 - .35 * Math.sin(.001 * time),
                        _this.layers.timer.rotation.x += .01,
                        _this.layers.timer.rotation.y += .015,
                        Env5Level.percent = percent,
                        Env5Level.position.copy(position),
                        $time) {
                        let mins = Math.floor(videoTime / 60)
                            , seconds = Math.round(videoTime - 60 * mins);
                        seconds < 10 && (seconds = "0" + seconds),
                            $time.text(mins + ":" + seconds)
                    }
                    let brightness = Math.range(percent, 0, .05, 1.5, 1, !0);
                    for (var i = 0; i < _drops.length; i++) {
                        let start1 = Env5Level.convertTime(_drops[i].darken[0])
                            , end1 = Env5Level.convertTime(_drops[i].darken[1])
                            , start2 = Env5Level.convertTime(_drops[i].brighten[0])
                            , end2 = Env5Level.convertTime(_drops[i].brighten[1]);
                        percent > start1 && percent < end2 && (brightness = Math.range(percent, start1, end1, 1, .8, !0)),
                        percent > start2 && percent < end2 && (brightness = Math.range(percent, start2, end2, _drops[i].brightValue || 1.5, 1, !0))
                    }
                    percent > Env5Level.convertTime(4.25) && (brightness = Math.range(percent, Env5Level.convertTime(4.25), Env5Level.convertTime(4.5), 1, 2, !0));
                    Env5Level.uFogBrightness.value = Math.lerp(brightness, Env5Level.uFogBrightness.value, .05),
                    _background && _background.update();
                    let camera = World.CAMERA;
                    _this.nuke.camera = camera,
                        _this.updateCamera(),
                        _this.render(null, camera)
                }
                ,
                _this.onPlayerComplete = function() {
                    _this.resetState()
                }
                ,
                _this.onPlayerReady = function() {
                    _this.state.local || (_this.state.local = !0,
                    PlayerController.remotePlayer && Global.CONNECTED || play())
                }
                ,
                _this.onPlayersEnabled = function() {
                    Env5Level.isPlayingMulti || (Env5Level.isPlayingMulti = !0,
                        play())
                }
                ,
                _this.getLevelState = ()=>_this.state,
                _this.syncRemoteState = state=>(_this.getLevelState(),
                state.local && (_this.state.remote = !0),
                _this.state.local && _this.state.remote && _this.onPlayersEnabled(),
                    _this.state),
                _this.resetState = function() {
                    stop()
                }
                ,
                this.onCollision = function() {}
                ,
                this.onNoCollision = function() {}
                ,
                _this.ready = ()=>_this.wait("isReady"),
                _this.uploadAll = async function() {
                    await _this.ready(),
                        await Initializer3D.uploadAll(_this.layout)
                }
                ,
                _this.uploadAllAsync = async function() {
                    await _this.ready(),
                        await Initializer3D.uploadAllAsync(_this.layout)
                }
        }
    ), (_=>{
            var _curve;
            Env5Level.percent = 0,
                Env5Level.videoTime = 0,
                Env5Level.isPlaying = !1,
                Env5Level.isPlayingMulti = !1,
                Env5Level.position = new Vector3,
                Env5Level.uTime = {
                    value: 0
                },
                Env5Level.uFogBrightness = {
                    value: 1,
                    ignoreUIL: !0
                },
                Env5Level.uFogColor = {
                    value: new Color("#14251a"),
                    ignoreUIL: !0
                },
                Env5Level.uFogRange = {
                    value: new Vector2(20,100),
                    ignoreUIL: !0
                },
                Env5Level.PLAY = "envlevel5_play",
                Env5Level.getCurve = function() {
                    if (_curve)
                        return _curve;
                    let curve = Assets.JSON["data/path/porter-path-full"].curves[0]
                        , array = [];
                    for (let i = 0; i < curve.length; i += 3)
                        array.push([1.7 * curve[i + 0], 1.7 * curve[i + 1], 1.7 * curve[i + 2]]);
                    return (_curve = new CurveDistance(array,200)).scale = 1.7,
                        _curve
                }
                ,
                Env5Level.convertTime = function(time) {
                    let total = Env5Video.DURATION
                        , mins = Math.floor(time)
                        , perc = (60 * mins + 100 * (time - mins)) / total;
                    return Math.clamp(perc, 0, 1)
                }
        }
    )),
    Global.ENV5_VIDEO_TIME = 0,
    Class((function Env5ARScene() {
            Inherit(this, Object3D);
            const _this = this;
            var _curve;
            function getPosition(value) {
                let position = _curve.getPoint(value);
                return position.multiplyScalar(1 / _curve.scale),
                    position.y -= 3,
                    position
            }
            !async function() {
                _curve = Env5Level.getCurve(),
                    _this.layout = _this.initClass(SceneLayout, "Env5ARScene"),
                    _this.layers = await _this.layout.getAllLayers(),
                    _this.isReady = !0,
                    await async function initEffects() {
                        _this.initClass(Env5ArtLeaves).group.position.copy(getPosition(Env5Level.convertTime(4.35))),
                            await defer(),
                            _this.initClass(Env5ArtRain).group.position.copy(getPosition(Env5Level.convertTime(3.32))),
                            await defer(),
                            _this.initClass(Env5ArtGhosts).group.position.copy(getPosition(Env5Level.convertTime(2.1))),
                            await defer();
                        _this.initClass(Env5Scribble, [getPosition(Env5Level.convertTime(.25)), getPosition(Env5Level.convertTime(.42)), getPosition(Env5Level.convertTime(1))]);
                        await defer();
                        _this.initClass(Env5ArtChord);
                        await defer()
                    }(),
                    await _this.wait(2e3)
            }(),
                this.ready = async function() {
                    await _this.wait("isReady")
                }
        }
    )),
    Class((function Env5ArtChord() {
            Inherit(this, Object3D);
            var _shader, _curve, _wrapper, _meshes, _glows, _chords, _beats, _this = this, _dimension = new Vector2(8,3), _position = new Vector2(0,0), _colorHexes = ["#0048ff", "#ff0000", "#ffff00"], _colors = [], _white = new Color("#ffffff");
            function getPosition(value) {
                let position = _curve.getPoint(value);
                return position.multiplyScalar(1 / _curve.scale),
                    position.y -= 2.5,
                    position
            }
            function update() {
                _meshes.forEach(((mesh,index)=>{
                        let moveX = 1 / (_dimension.x - 1);
                        mesh.attributes.cellX += moveX,
                        mesh.attributes.cellX > 1 && (mesh.attributes.cellX = 0)
                    }
                ))
            }
            function loop() {
                _chords.forEach(((chord,i)=>{
                        chord - 1e-4 <= Env5Level.percent && chord + 1e-4 > Env5Level.percent && change(chord)
                    }
                )),
                    _beats.forEach((beat=>{
                            beat - 1e-4 <= Env5Level.percent && beat + 1e-4 > Env5Level.percent && change(beat, !0)
                        }
                    )),
                    _meshes.forEach(((mesh,index)=>{
                            let position = getPosition(mesh.start);
                            position.x += .1 * Math.sin(3e-4 * Render.TIME + .1 * index),
                                position.y += .1 * Math.sin(.001 * Render.TIME + .1 * index),
                                position.z += .1 * Math.sin(4e-4 * Render.TIME + .1 * index),
                                position.add(mesh.offset),
                                mesh.position.copy(position),
                                Utils3D.billboard(mesh),
                                position = getPosition(mesh.start),
                                position.y -= 1.2,
                                position.add(mesh.offset),
                                _glows[index].position.copy(position)
                        }
                    )),
                Global.NAME_FLOOR_SHADER && (Global.NAME_FLOOR_SHADER.uniforms.uColor.value.copy(_shader.uniforms.uColor.value),
                    Global.NAME_FLOOR_SHADER.uniforms.uMixColor.value = _shader.uniforms.uAlpha.value)
            }
            async function change(perc, white) {
                if (_this.block)
                    return;
                _this.block = !0,
                    _this.delayedCall((_=>{
                            _this.block = !1
                        }
                    ), 500);
                let moveY = 1 / (_dimension.y - 1);
                _position.y += moveY,
                _position.y > 1 && (_position.y = 0);
                let index = Math.floor(_position.y * (_dimension.y - 1));
                _shader.set("uColor", white ? _white : _colors[index]),
                    _meshes.forEach(((mesh,index)=>{
                            mesh.scale.setScalar(0),
                                _glows[index].scale.setScalar(0),
                                mesh.offset.x = Utils.headsTails(-1, 1) * Math.random(1, 1.5, 3) * 1,
                                mesh.offset.z = Utils.headsTails(-1, 1) * Math.random(1, 1.5, 3) * 1.5,
                                mesh.offset.y = Utils.headsTails(-1, 1) * Math.random(1, 1.5, 3) * .1
                        }
                    )),
                    loop(),
                    await defer(),
                    _meshes.forEach(((mesh,index)=>{
                            let s = Math.random(.8, 1, 3)
                                , delay = Math.random(0, 100);
                            mesh.scale.setScalar(0),
                                tween(mesh.scale, {
                                    x: s,
                                    y: s,
                                    z: s
                                }, 500, "easeOutBack", delay),
                                _glows[index].scale.setScalar(0),
                                s *= 3,
                                tween(_glows[index].scale, {
                                    x: s,
                                    y: s,
                                    z: s
                                }, 500, "easeOutBack", delay)
                        }
                    )),
                    _shader.set("uAlpha", 1),
                    _shader.tween("uAlpha", 0, white ? 5e3 : 4e3, "easeInCubic")
            }
            !function() {
                _colorHexes.forEach((color=>{
                        _colors.push(new Color(color))
                    }
                )),
                    _curve = Env5Level.getCurve(),
                    _chords = [Env5Level.convertTime(3.434), Env5Level.convertTime(3.466), Env5Level.convertTime(3.477), Env5Level.convertTime(3.52), Env5Level.convertTime(3.541), Env5Level.convertTime(3.562), Env5Level.convertTime(3.59)],
                    _beats = [];
                for (var i = 0; i < 25; i++) {
                    let time = Env5Level.convertTime(4.005 + .0053 * i);
                    _beats.push(time)
                }
                !function initShader() {
                    _shader = _this.initClass(Shader, "Env5ArtChord", {
                        tMap: {
                            value: Utils3D.getTexture("assets/images/env5/chord.png")
                        },
                        uDimensions: {
                            value: _dimension
                        },
                        uPosition: {
                            value: _position
                        },
                        uColor: {
                            value: _colors[0]
                        },
                        uAlpha: {
                            value: 0
                        },
                        transparent: !0,
                        depthWrite: !1,
                        depthTest: !1,
                        blending: Shader.ADDITIVE_BLENDING
                    })
                }(),
                    function initMesh() {
                        _wrapper = new Group,
                            _this.add(_wrapper);
                        let batch = _this.initClass(MeshBatch);
                        batch.renderOrder += 241,
                            _wrapper.add(batch.group),
                            _meshes = [],
                            _glows = [];
                        let start = 3.4
                            , count = Tests.getEnv5DancingSprites()
                            , spacing = .01
                            , moveX = 1 / (_dimension.x - 1);
                        for (var i = 0; i < count; i++) {
                            let mesh = new Mesh(World.PLANE,_shader);
                            mesh.start = Env5Level.convertTime(start + i * spacing),
                                mesh.position.copy(getPosition(mesh.start)),
                                mesh.attributes = {
                                    cellX: Math.random(0, _dimension.x - 1) * moveX,
                                    glow: 0
                                },
                                mesh.offset = new Vector3,
                                mesh.offset.x += Utils.headsTails(-1, 1) * Math.random(1, 1.5, 3) * .5,
                                mesh.offset.z += Utils.headsTails(-1, 1) * Math.random(1, 1.5, 3) * 1;
                            let glow = new Mesh(World.PLANE,_shader);
                            glow.attributes = {
                                cellX: 0,
                                glow: 1
                            },
                                glow.rotation.x = Math.radians(-90),
                                glow.position.copy(getPosition(mesh.start)),
                                batch.add(mesh),
                                batch.add(glow),
                                _meshes.push(mesh),
                                _glows.push(glow)
                        }
                    }(),
                    _this.startRender(update, 12),
                    _this.startRender(loop),
                    Env5VisibilityUtil.instance().add(_wrapper, _chords[0] - .02, _chords[_chords.length - 1] + .1)
            }(),
                this.animateIn = function() {}
        }
    )),
    Class((function Env5ArtCircle(_config) {
            Inherit(this, Object3D);
            var _shader, _wrapper, _meshes, _this = this;
            function loop(t) {
                _meshes.forEach(((mesh,i)=>{
                        let angle = i / (_config.count / 2) * Math.PI + 3e-4 * t * _config.rotate
                            , x = _config.radius * Math.cos(angle)
                            , z = _config.radius * Math.sin(angle);
                        mesh.position.z = z,
                            mesh.position.x = x,
                            Utils3D.billboard(mesh, Global.TRACK_CAMERA || World.CAMERA),
                            mesh.position.y = .08 * Math.sin(.001 * t + 10 * mesh.seed)
                    }
                ))
            }
            _config || (_config = {}),
            _config.sheet || (_config.sheet = "sheet2"),
            _config.sheetCount || (_config.sheetCount = 13),
            _config.sheetOffset || (_config.sheetOffset = 0),
            _config.count || (_config.count = Math.random(6, 12)),
            _config.radius || (_config.radius = .8),
            _config.startRandom || (_config.startRandom = 0),
            _config.endRandom || (_config.endRandom = _config.sheetCount - 2),
            _config.rotate || (_config.rotate = 1),
                async function() {
                    !function initShader() {
                        _shader = _this.initClass(Shader, "Env5ArtCircle", {
                            tMap: {
                                value: Utils3D.getTexture("assets/images/env5/" + _config.sheet + ".png")
                            },
                            uSheetCount: {
                                value: _config.sheetCount
                            },
                            uSheetOffset: {
                                value: _config.sheetOffset
                            },
                            uFogRange: Env5Level.uFogRange,
                            uIndex: {
                                value: 4,
                                batchUnique: !0
                            },
                            uAlpha: {
                                value: 1
                            },
                            depthWrite: !1,
                            transparent: !0,
                            blending: Shader.ADDITIVE_BLENDING,
                            side: Shader.DOUBLE_SIDE
                        })
                    }(),
                        function initMesh() {
                            _wrapper = new Group,
                                _this.add(_wrapper);
                            let batch = _this.initClass(MeshBatch);
                            batch.renderOrder += 51,
                                _wrapper.add(batch.group),
                                _meshes = [];
                            for (var i = 0; i < _config.count; i++) {
                                let mesh = new Mesh(World.PLANE,_shader);
                                mesh.seed = Math.random(0, 1, 3),
                                    mesh.attributes = {
                                        index: Math.random(_config.startRandom, _config.endRandom),
                                        seed: Math.random(0, 1, 3)
                                    },
                                    batch.add(mesh),
                                    _meshes.push(mesh)
                            }
                        }(),
                        _this.startRender(loop),
                        await _this.wait(500),
                        _this.isReady = !0
                }(),
                this.ready = async function() {
                    await _this.wait("isReady")
                }
                ,
                this.animateIn = function() {}
        }
    )),
    Class((function Env5ARTrack() {
            Inherit(this, Object3D);
            const _this = this;
            !async function() {
                for (var i in _this.layout = _this.initClass(SceneLayout, "Env5ARTrack"),
                    _this.layout.group.renderOrder = 50,
                    _this.layers = await _this.layout.getAllLayers(),
                    _this.layers) {
                    let layer = _this.layers[i];
                    layer.depthWrite = !1,
                        layer.renderOrder += 20
                }
                _this.isReady = !0
            }(),
                this.ready = async function() {
                    await _this.wait("isReady")
                }
        }
    )),
    Class((function NameFloor(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            var _start, _end, _white, _this = this;
            function loop() {
                if (Env5Level.percent) {
                    let alpha = _start < Env5Level.percent && _end > Env5Level.percent ? 1 : 0;
                    _shader.uniforms.uAlpha.value = Math.lerp(alpha, _shader.uniforms.uAlpha.value, .01);
                    let white = _white < Env5Level.percent ? 1 : 0;
                    _shader.uniforms.uWhite.value = Math.lerp(white, _shader.uniforms.uWhite.value, .01)
                }
            }
            _shader.addUniforms({
                tMap: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                uSpeed: {
                    value: 1
                },
                uScale: {
                    value: 1
                },
                uAlpha: {
                    value: 0
                },
                uColor: {
                    value: new Color
                },
                uWhite: {
                    value: 0
                },
                uMixColor: {
                    value: 0
                },
                uFogBrightness: Env5Level.uFogBrightness,
                uFogColor: Env5Level.uFogColor,
                uFogRange: Env5Level.uFogRange
            }),
                _this.startRender(loop),
                _start = Env5Level.convertTime(3.4),
                _end = Env5Level.convertTime(4.12),
                _white = Env5Level.convertTime(4),
                Env5VisibilityUtil.instance().add(_mesh, _start - .02, _end + .1),
                Global.NAME_FLOOR_SHADER = _shader
        }
    )),
    Class((function flowers(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            var _start1, _end1, _start2, _end2, _this = this;
            function loop() {
                if (Env5Level.percent) {
                    let alpha = _start1 < Env5Level.percent && _end1 > Env5Level.percent ? 1 : 0;
                    _start2 < Env5Level.percent && _end2 > Env5Level.percent && (alpha = 1),
                        _shader.uniforms.uAlpha.value = Math.lerp(alpha, _shader.uniforms.uAlpha.value, .1)
                } else
                    _shader.uniforms.uAlpha.value = Global.PLAYGROUND ? 1 : 0
            }
            !async function() {
                _shader.addUniforms({
                    tMap: {
                        value: null,
                        getTexture: Utils3D.getRepeatTexture
                    },
                    uSpeed: {
                        value: .5
                    },
                    uAlphaCutOff: {
                        value: .15
                    },
                    uNoiseSpeed: {
                        value: .6
                    },
                    uNoiseScale: {
                        value: 2
                    },
                    uTimeOffset: {
                        value: 0
                    },
                    uNoiseStrength: {
                        value: .5
                    },
                    uScale: {
                        value: new Vector3(1,1,1)
                    },
                    uOffset: {
                        value: new Vector3
                    },
                    uAlpha: {
                        value: 0
                    },
                    uFogRange: Env5Level.uFogRange,
                    transparent: !0
                }),
                    _this.startRender(loop),
                    _start1 = Env5Level.convertTime(1.09),
                    _end1 = Env5Level.convertTime(1.5),
                    _start2 = Env5Level.convertTime(4.195),
                    _end2 = Env5Level.convertTime(4.5),
                    await defer(),
                    _mesh.instanceMeshReady.then((()=>{
                            Env5VisibilityUtil.instance().add(_mesh.instanceMesh, _start1 - .02, _end2 + .02)
                        }
                    ))
            }()
        }
    )),
    Class((function souls(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            var _start, _end, _this = this;
            function loop() {
                if (Env5Level.percent) {
                    let fade = _start < Env5Level.percent && _end > Env5Level.percent ? 1 : 0;
                    _shader.uniforms.uFade.value = Math.lerp(fade, _shader.uniforms.uFade.value, .01)
                }
            }
            !async function() {
                _shader.addUniforms({
                    tMap: {
                        value: null,
                        getTexture: Utils3D.getRepeatTexture
                    },
                    uFadeSpeed: {
                        value: 1
                    },
                    uAlphaCutOff: {
                        value: .15
                    },
                    uFloatSpeed: {
                        value: 3
                    },
                    uFloatAmount: {
                        value: .7
                    },
                    uScale: {
                        value: 1
                    },
                    uFogRange: Env5Level.uFogRange,
                    transparent: !0,
                    uFade: {
                        value: 0
                    },
                    blending: Shader.ADDITIVE_BLENDING
                }),
                    _start = Env5Level.convertTime(.35),
                    _end = Env5Level.convertTime(1),
                    _this.startRender(loop),
                    _mesh.renderOrder += 100,
                    Env5VisibilityUtil.instance().add(_mesh, _start - .02, _end + .02)
            }()
        }
    )),
    Class((function squiggles(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            var _start, _end, _this = this;
            function loop() {
                if (Env5Level.percent) {
                    let strobe = _start < Env5Level.percent && _end > Env5Level.percent ? 1 : 0;
                    _shader.uniforms.uStrobe.value = Math.lerp(strobe, _shader.uniforms.uStrobe.value, .02)
                }
                _shader.uniforms.uTime.value += .005 + .05 * _shader.uniforms.uStrobe.value
            }
            !async function() {
                _shader.addUniforms({
                    tMap: {
                        value: null,
                        getTexture: Utils3D.getRepeatTexture
                    },
                    uAlphaCutOff: {
                        value: .15
                    },
                    uFloatSpeed: {
                        value: 3
                    },
                    uBlinkStrength: {
                        value: 1
                    },
                    uBlinkSpeed: {
                        value: 1
                    },
                    uFloatAmountX: {
                        value: .7
                    },
                    uFloatAmountY: {
                        value: .7
                    },
                    uFloatAmountZ: {
                        value: .7
                    },
                    uStrobe: {
                        value: 0
                    },
                    uScale: {
                        value: 1
                    },
                    uTime: {
                        value: 0
                    },
                    uFogRange: Env5Level.uFogRange,
                    transparent: !0,
                    blending: Shader.ADDITIVE_BLENDING
                }),
                    _this.startRender(loop),
                    _start = Env5Level.convertTime(2.51),
                    _end = Env5Level.convertTime(3.08),
                    Env5VisibilityUtil.instance().add(_mesh, _start - .15, _end + .1)
            }()
        }
    )),
    Class((function waves(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMap: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                uSpeed: {
                    value: 1
                },
                uNoiseSpeed: {
                    value: 1.95
                },
                uNoiseScale: {
                    value: 1
                },
                uDistortScale: {
                    value: .5
                },
                uDistortSpeed: {
                    value: 1.5
                },
                uNoiseStrength: {
                    value: .5
                },
                uScale: {
                    value: new Vector3(1,1,1)
                },
                uOffset: {
                    value: new Vector3
                }
            })
        }
    )),
    Class((function Env5ArtGhosts() {
            Inherit(this, Object3D);
            var _ghosts, _this = this;
            function loop() {
                if (Env5Level.percent) {
                    let alpha = 0;
                    Env5Level.percent > Env5Level.convertTime(1.43) && (alpha = 1),
                    Env5Level.percent > Env5Level.convertTime(2.12) && (alpha = 0),
                        _ghosts.shader.uniforms.uAlpha.value = Math.lerp(alpha, _ghosts.shader.uniforms.uAlpha.value, .015)
                }
            }
            !async function() {
                _this.layout = _this.initClass(SceneLayout, "Env5ArtGhosts_layout"),
                    _this.add(_this.layout.group),
                    _this.layers = await _this.layout.getAllLayers(),
                    _ghosts = _this.layers.ghosts,
                    await _ghosts.ready(),
                    _ghosts.mesh.frustumCulled = !1,
                    _ghosts.mesh.renderOrder += 200,
                    _ghosts.group.frustumCulled = !1,
                    _ghosts.shader.addUniforms({
                        uFogRange: Env5Level.uFogRange
                    }),
                    _ghosts.shader.uniforms.uAlpha.value = 0,
                    _ghosts.renderOrder += 200,
                    _this.group.renderOrder = 1e3,
                    _this.startRender(loop),
                    Env5VisibilityUtil.instance().add(_ghosts.mesh, Env5Level.convertTime(1.3), Env5Level.convertTime(2.3))
            }(),
                this.animateIn = function() {}
        }
    )),
    Class((function Env5ArtLeaves() {
            Inherit(this, Object3D);
            var _shader, _start, _end, _this = this;
            function loop() {
                if (Env5Level.percent) {
                    let alpha = _start < Env5Level.percent && _end > Env5Level.percent ? 1 : 0;
                    _shader.uniforms.uAlpha.value = Math.lerp(alpha, _shader.uniforms.uAlpha.value, .1)
                }
            }
            !async function() {
                _this.layout = _this.initClass(SceneLayout, "Env5ArtLeaves_layout"),
                    _this.add(_this.layout.group),
                    _this.layers = await _this.layout.getAllLayers(),
                    await _this.layers.leaves.ready(),
                    _this.layers.leaves.renderOrder += 200,
                    _this.layers.leaves.group.frustumCulled = !1,
                    _this.layers.leaves.shader.addUniforms({
                        uFogRange: Env5Level.uFogRange,
                        uAlpha: {
                            value: 0
                        }
                    }),
                    _shader = _this.layers.leaves.shader,
                    _this.startRender(loop),
                    _start = Env5Level.convertTime(4.195),
                    _end = Env5Level.convertTime(4.5),
                    Env5VisibilityUtil.instance().add(_this.layers.leaves.group, _start - .02, _end - .02)
            }(),
                this.animateIn = function() {}
        }
    )),
    Class((function Env5ArtRain() {
            Inherit(this, Object3D);
            var _rain, _this = this;
            function loop() {
                if (Env5Level.percent) {
                    let speed = 1
                        , alpha = 0;
                    Env5Level.percent > Env5Level.convertTime(3.1) && (alpha = 1),
                    Env5Level.percent > Env5Level.convertTime(3.4) && (alpha = 0),
                    Env5Level.percent > Env5Level.convertTime(3.21) && (speed = 0),
                    Env5Level.percent > Env5Level.convertTime(3.25) && (speed = -1.1),
                        _rain.shader.uniforms.uAlpha.value = Math.lerp(alpha, _rain.shader.uniforms.uAlpha.value, .02),
                        _rain.behavior.shader.uniforms.uSpeed.value = Math.lerp(speed, _rain.behavior.shader.uniforms.uSpeed.value, .006),
                    _rain.shader.uniforms.uAlpha.value > .001 && (VFX.instance().shader.uniforms.uEnv5Ghosts.value = .5 * _rain.shader.uniforms.uAlpha.value)
                }
            }
            !async function() {
                _this.layout = _this.initClass(SceneLayout, "Env5ArtRain_layout"),
                    _this.add(_this.layout.group),
                    _this.layers = await _this.layout.getAllLayers(),
                    _rain = _this.layers.rain,
                    await _rain.ready(),
                    _this.layers.rain.renderOrder += 200,
                    _rain.shader.transparent = !0,
                    _rain.shader.uniforms.uAlpha.value = 0,
                    _this.startRender(loop),
                    Env5VisibilityUtil.instance().add(_this.layout.group, Env5Level.convertTime(3), Env5Level.convertTime(5))
            }(),
                this.animateIn = function() {}
        }
    )),
    Class((function Env5Scribble(positions) {
            Inherit(this, Object3D);
            const _this = this;
            var _strokes = [];
            function loop() {
                _strokes.forEach((stroke=>{
                        stroke.pos2.lerp(stroke.pos, .1),
                            stroke.draw(stroke.pos2)
                    }
                ))
            }
            function randomLine() {
                _strokes.forEach((stroke=>{
                        stroke.pos.x = stroke.lastPos.x + Math.random(-1 * Math.range(stroke.lastPos.x, -1, 0, 0, .1, !0), 1 * Math.range(stroke.lastPos.x, 0, 1, .1, 0, !0), 4),
                            stroke.pos.y = stroke.lastPos.y + Math.random(-1 * Math.range(stroke.lastPos.y, -1, 0, 0, .1, !0), 1 * Math.range(stroke.lastPos.y, 0, 1, .1, 0, !0), 4),
                            stroke.pos.z = stroke.lastPos.z + Math.random(-1 * Math.range(stroke.lastPos.z, -1, 0, 0, .1, !0), 1 * Math.range(stroke.lastPos.z, 0, 1, .1, 0, !0), 4),
                            stroke.lastPos.copy(stroke.pos),
                            stroke.pos.multiplyScalar(25),
                            stroke.pos.y *= .54
                    }
                )),
                    clearTimeout(_this.autoDelay),
                    _this.autoDelay = _this.delayedCall(randomLine, Math.random(100, 400))
            }
            _this.velocity = 0,
                _this.wrapper = new Group,
                _this.add(_this.wrapper),
            Tests.hasFloorScribble() && (function initStroke() {
                let width = 1.3
                    , color = "#ffffff"
                    , length = 200;
                positions.forEach((pos=>{
                        let stroke = new Line3D({
                            width: width,
                            color: color,
                            length: length,
                            opacity: .25
                        });
                        stroke.pos = new Vector3(.5 * Math.random(-1, 1, 3),-.2,.5 * Math.random(-1, 1, 3)),
                            stroke.lastPos = (new Vector3).copy(stroke.pos),
                            stroke.pos2 = new Vector3(.5 * Math.random(-1, 1, 3),-.2,.5 * Math.random(-1, 1, 3)),
                            stroke.shader.blending = Shader.ADDITIVE_BLENDING,
                            stroke.group = new Group,
                            pos.y += 1.8,
                            stroke.group.position.copy(pos),
                            _this.wrapper.add(stroke.group),
                            _strokes.push(stroke)
                    }
                ))
            }(),
                _this.startRender(loop, 30),
                randomLine(),
                Env5VisibilityUtil.instance().add(_this.wrapper, .02, .55))
        }
    )),
    Class((function Env5Video() {
            Inherit(this, Object3D);
            const _this = this;
            var _video, _shader, _curve, _wrapper, _meshes;
            function getPosition(value) {
                let position = _curve.getPoint(value);
                return position.multiplyScalar(1 / _curve.scale),
                    position.y -= 2.1,
                    position
            }
            function loop() {
                _meshes.forEach(((mesh,index)=>{
                        let position = getPosition(mesh.start);
                        if (Env5Level.percent) {
                            let padding = mesh.padding || .025
                                , visible = Math.range(Env5Level.percent, mesh.start - padding, mesh.start - .3 * padding, 0, 1, !0);
                            if (mesh.end ? visible *= Math.range(Env5Level.percent, mesh.end + padding, mesh.end + .3 * padding, 0, 1, !0) : mesh.final ? visible *= Math.range(Env5Level.percent, 1, .975, 0, 1, !0) : visible *= Math.range(Env5Level.percent, mesh.start + padding, mesh.start + .3 * padding, 0, 1, !0),
                                mesh.attributes.visible = visible,
                                mesh.end) {
                                position = getPosition(Math.clamp(Env5Level.percent, mesh.start, mesh.end) + .0015)
                            }
                        }
                        position.x += .1 * Math.sin(.0016 * Render.TIME),
                            position.y += .06 * Math.sin(.0013 * Render.TIME),
                            position.z += .1 * Math.sin(.0015 * Render.TIME),
                        0 == index && (position.x += 10,
                            position.z += 4),
                            mesh.position.lerp(position, .03),
                            Utils3D.billboard(mesh)
                    }
                ))
            }
            _curve = Env5Level.getCurve(),
                function initVideo() {
                    _video = Env5Video.getVideo()
                }(),
                function initShader() {
                    _shader = _this.initClass(Shader, "Env5Video", {
                        tMap: {
                            value: _video
                        },
                        tMask: {
                            value: Utils3D.getTexture("assets/images/env5/video-mask.jpg")
                        },
                        uFogRange: {
                            value: new Vector2(20,30)
                        },
                        uVisible: {
                            value: 0,
                            batchUnique: !0
                        },
                        uFogBrightness: Env5Level.uFogBrightness,
                        side: Shader.DOUBLE_SIDE,
                        transparent: !0,
                        depthWrite: !1
                    })
                }(),
                function initMesh() {
                    _wrapper = new Group,
                        _this.add(_wrapper);
                    let batch = _this.initClass(MeshBatch);
                    batch.renderOrder += 400,
                        _wrapper.add(batch.group),
                        _meshes = [];
                    let points = [.09, .2, .3, .39, 1.17, 1.27, 1.37, 1.5, 2.25, 2.38, 3.15, 3.27, 3.37, 4.22, 4.34, 4.46, 5];
                    for (var i = points.length - 1; i > -1; i--) {
                        let point = points[i]
                            , mesh = new Mesh(World.PLANE,_shader);
                        mesh.start = Env5Level.convertTime(point),
                            mesh.position.copy(getPosition(mesh.start));
                        let scale = i == points.length - 1 ? 2.7 : 1.4;
                        mesh.scale.setScalar(scale),
                            mesh.attributes = {
                                invert: 0,
                                visible: 0
                            },
                        .39 == point && (mesh.end = Env5Level.convertTime(point + .285)),
                        1.5 == point && (mesh.end = Env5Level.convertTime(point + .24)),
                        i == points.length - 1 && (mesh.padding = .05,
                            mesh.final = !0),
                            batch.add(mesh),
                            _meshes.push(mesh)
                    }
                }(),
                _this.startRender(loop)
        }
    ), (_=>{
            var _video;
            Env5Video.DURATION = 312.853333,
                Env5Video.getVideo = function() {
                    return _video || (_video = new VideoTexture("assets/videos/m.mp4",{
                        autoplay: !1,
                        loop: !1
                    }))
                }
        }
    )),
    Class((function DistanceFade(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMap: {
                    value: Utils3D.getTexture("assets/images/_scenelayout/uv.jpg")
                },
                uAlpha: {
                    value: 1
                },
                transparent: !0,
                uTime: Env5Level.uTime,
                uFogBrightness: Env5Level.uFogBrightness,
                uFogColor: Env5Level.uFogColor,
                uFogRange: Env5Level.uFogRange
            }),
                _mesh.renderOrder = 0
        }
    )),
    Class((function Env5Landscape() {
            Inherit(this, Object3D);
            const _this = this;
            _this.element;
            !async function initLayout() {
                _this.layout = _this.initClass(SceneLayout, "env5landscape"),
                    _this.layers = await _this.layout.getAllLayers();
                let track = []
                    , treesMultiplier = Tests.env5TreesHide()
                    , grassMultiplier = Tests.env5GrassHide();
                for (let key in _this.layers) {
                    let layer = _this.layers[key];
                    key.includes(["tree", "twig"]) && layer.instanceMeshReady && layer.instanceMeshReady.then((_=>{
                            layer.scriptClass.frustumCulled = !0,
                                layer.scriptClass.maxInstancedCount = Math.round(layer.scriptClass.maxInstancedCount * treesMultiplier),
                                track.push(layer.instanceMesh)
                        }
                    )),
                    key.includes("grass") && layer.instanceMeshReady && layer.instanceMeshReady.then((_=>{
                            layer.scriptClass.frustumCulled = !0,
                                layer.scriptClass.maxInstancedCount = Math.round(layer.scriptClass.maxInstancedCount * grassMultiplier),
                                track.push(layer.instanceMesh)
                        }
                    ))
                }
                let v3 = new Vector3;
                _this.startRender((_=>{
                        for (let i = 0; i < track.length; i++) {
                            let mesh = track[i];
                            if (!mesh.geometry.boundingSphere)
                                continue;
                            v3.copy(mesh.geometry.boundingSphere.center).applyMatrix4(mesh.matrixWorld);
                            let distance = World.CAMERA.position.distanceTo(v3);
                            mesh.visible = distance < 3 * mesh.geometry.boundingSphere.radius
                        }
                    }
                ), 24)
            }()
        }
    )),
    Class((function Env5Background() {
            Inherit(this, FXScene);
            const _this = this;
            var _layout;
            function loop(time, delta) {
                _this.nuke.camera.quaternion.copy(World.CAMERA.quaternion),
                    _this.render()
            }
            !async function() {
                _this.create(World.NUKE, null, {
                    format: Texture.RGBAFormat
                }),
                    await async function initLayout() {
                        _layout = _this.initClass(SceneLayout, "env5_background");
                        let camera = World.CAMERA.clone();
                        _this.useCamera(camera),
                            _this.layers = await _layout.getAllLayers(),
                            _this.layers.horizon.renderOrder = 99,
                            _this.layers.horizon.frustumCulled = !1,
                            _this.layers.horizon.depthWrite = !1,
                            _this.scene.add(_layout.group)
                    }(),
                "Env5Background" == Global.PLAYGROUND && _this.startRender(loop)
            }(),
                _this.update = function(time, delta) {
                    loop()
                }
        }
    )),
    Class((function FlatLeafShader(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMap: {
                    value: null
                },
                uCutoff: {
                    value: .5
                },
                uTime: Env5Level.uTime,
                uFogBrightness: Env5Level.uFogBrightness,
                uFogColor: Env5Level.uFogColor,
                uFogRange: Env5Level.uFogRange
            })
        }
    )),
    Class((function Env5Grass(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            var _start, _end, _this = this;
            function loop() {
                if (Env5Level.percent) {
                    let strobe = _start < Env5Level.percent && _end > Env5Level.percent ? 1 : 0;
                    _shader.uniforms.uStrobe.value = Math.lerp(strobe, _shader.uniforms.uStrobe.value, .02)
                }
            }
            !async function() {
                _shader.addUniforms({
                    tMap: {
                        value: null
                    },
                    uColor1: {
                        value: new Color
                    },
                    uColor2: {
                        value: new Color
                    },
                    uTextureMix: {
                        value: .5
                    },
                    uHighlightColor: {
                        value: new Color
                    },
                    uHighlightRange: {
                        value: new Vector2
                    },
                    uNoiseSpeed: {
                        value: .5
                    },
                    uNoiseScale: {
                        value: 1
                    },
                    uNoiseStrength: {
                        value: .5
                    },
                    uTextureOffset: {
                        value: new Vector2(.5,0)
                    },
                    uTextureRangeX: {
                        value: new Vector2
                    },
                    uTextureRangeZ: {
                        value: new Vector2
                    },
                    uScale: {
                        value: new Vector3(1,1,1)
                    },
                    uOffset: {
                        value: new Vector3
                    },
                    uFogCutoff: {
                        value: 50
                    },
                    uAlphaCutoff: {
                        value: .5
                    },
                    uTime: Env5Level.uTime,
                    uFogBrightness: Env5Level.uFogBrightness,
                    uStrobe: {
                        value: 0
                    },
                    uFogColor: Env5Level.uFogColor,
                    uFogRange: Env5Level.uFogRange
                }),
                    _mesh.renderOrder = 0,
                    _start = Env5Level.convertTime(4.195),
                    _end = Env5Level.convertTime(4.5),
                    _this.startRender(loop),
                    await defer()
            }()
        }
    )),
    Class((function Env5Ground(_mesh, _shader) {
            Inherit(this, Object3D);
            function getGrassTexture(src, scale) {
                let texture = Utils3D.getTexture(src, scale);
                return texture.wrapS = texture.wrapT = Texture.REPEAT,
                    texture.minFilter = texture.magFilter = Texture.NEAREST,
                    texture
            }
            _shader.addUniforms({
                tMap: {
                    value: null,
                    getTexture: getGrassTexture
                },
                uBrightness: {
                    value: 1
                },
                uTile: {
                    value: new Vector2
                },
                uColor: {
                    value: new Color
                },
                uEnColor: {
                    value: new Color
                },
                uFar: {
                    value: 50
                },
                uDistanceFogStrength: {
                    value: 1
                },
                uNoiseStrength: {
                    value: 1
                },
                uNoiseScale: {
                    value: 1
                },
                uNoiseSpeed: {
                    value: 1
                },
                uTint1: {
                    value: new Color
                },
                uTint2: {
                    value: new Color
                },
                uEnTint1: {
                    value: new Color
                },
                uEnTint2: {
                    value: new Color
                },
                uEnabled: {
                    value: 0
                },
                uTime: Env5Level.uTime,
                uFogBrightness: Env5Level.uFogBrightness,
                uFogColor: Env5Level.uFogColor,
                uFogRange: Env5Level.uFogRange
            }),
                Env5Ground.GEOMETRY = _mesh.geometry,
                Env5Ground.READY.resolve(Env5Ground.GEOMETRY),
                this.update = function(time, delta) {}
        }
    ), (_=>{
            Env5Ground.READY = Promise.create()
        }
    )),
    Class((function Env5Horizon(_mesh, _shader) {
            Inherit(this, Component);
            _shader.addUniforms({
                uFogBrightness: Env5Level.uFogBrightness,
                uFogColor: Env5Level.uFogColor,
                uSkyColor: {
                    value: new Color("#ccf5ff")
                }
            })
        }
    )),
    Class((function Env5Leaves(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            var _strobe, _blue, _this = this;
            new Color("#242952");
            function loop() {
                if (Env5Level.percent) {
                    let strobe = _strobe[0] < Env5Level.percent && _strobe[1] > Env5Level.percent ? 1 : 0;
                    _shader.uniforms.uStrobe.value = Math.lerp(strobe, _shader.uniforms.uStrobe.value, .1);
                    let blue = _blue[0] < Env5Level.percent && _blue[1] > Env5Level.percent ? 1 : 0;
                    _shader.uniforms.uBlue.value = Math.lerp(blue, _shader.uniforms.uBlue.value, .01),
                    _shader.uniforms.uBlue.value > .001 && (VFX.instance().shader.uniforms.uEnv5Ghosts.value = _shader.uniforms.uBlue.value)
                }
            }
            !async function() {
                _shader.addUniforms({
                    tMap: {
                        value: null
                    },
                    tAlpha: {
                        value: null
                    },
                    uColorMix: {
                        value: 0
                    },
                    uColor: {
                        value: new Color("#c7be71")
                    },
                    uEnColor: {
                        value: new Color("#a1b961")
                    },
                    uSkyColor: {
                        value: new Color("#ccf5ff")
                    },
                    uAlphaCutOff: {
                        value: 1
                    },
                    uHighlightRange: {
                        value: new Vector2(0,.7)
                    },
                    uHighlightColor: {
                        value: new Color("#2b4f12")
                    },
                    uEnHighlightColor: {
                        value: new Color("#4bb388")
                    },
                    uSize: {
                        value: 1
                    },
                    uWindStrength: {
                        value: .1
                    },
                    uWiggleStrength: {
                        value: 5
                    },
                    uWindFrequency: {
                        value: 1
                    },
                    uNoiseSpeed: {
                        value: .4
                    },
                    uNoiseStrength: {
                        value: .3
                    },
                    uNoiseScale: {
                        value: .4
                    },
                    uNoiseApplyY: {
                        value: new Vector2(-3,6)
                    },
                    uTipColor: {
                        value: new Color("#000000")
                    },
                    uEnTipColor: {
                        value: new Color("#000000")
                    },
                    uTipRange: {
                        value: 1
                    },
                    uEnabled: {
                        value: 0
                    },
                    uTime: Env5Level.uTime,
                    uFogBrightness: Env5Level.uFogBrightness,
                    uFogColor: Env5Level.uFogColor,
                    uFogRange: Env5Level.uFogRange,
                    uStrobe: {
                        value: 0
                    },
                    uBlue: {
                        value: 0
                    },
                    transparent: !0
                }),
                    _this.startRender(loop),
                    _strobe = [Env5Level.convertTime(4.195), Env5Level.convertTime(4.5)],
                    _blue = [Env5Level.convertTime(1.43), Env5Level.convertTime(2.13)]
            }()
        }
    )),
    Class((function Env5Path(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            _shader.addUniforms({
                tMap: {
                    value: Utils3D.getTexture("assets/images/_scenelayout/uv.jpg")
                },
                uAlpha: {
                    value: 1
                },
                transparent: !0,
                uTime: Env5Level.uTime,
                uFogBrightness: Env5Level.uFogBrightness,
                uFogColor: Env5Level.uFogColor,
                uFogRange: Env5Level.uFogRange
            })
        }
    )),
    Class((function Env5Portal(_mesh, _shader) {
            Inherit(this, Component);
            const _this = this
                , V2 = new Vector2
                , V2_2 = new Vector2
                , V3 = new Vector3
                , DOWN_V3 = new Vector3(0,-1,0);
            var _position = new Vector3;
            function loop(time, delta) {
                if (!PlayerController.mainPlayer)
                    return;
                let {mainPlayer: mainPlayer} = PlayerController
                    , {position: position} = mainPlayer.group;
                if (_position.lerp(position, .15),
                    V2.set(position.x, position.z),
                    _mesh.scale.x = .001,
                _this.scene.name !== mainPlayer.currentScene.name)
                    return void (_mesh.visible = !1);
                _mesh.visible = !0;
                let wpos = _mesh.getWorldPosition();
                V2_2.set(wpos.x, wpos.z);
                let distance = V2.distanceTo(V2_2)
                    , scalar = 4 * TweenManager.Interpolation.Quad.InOut(Math.range(distance, 10, 30, 1, 1e-4, !0), 2)
                    , uAlpha = Math.range(scalar, 1e-4, .2, 0, 1, !0)
                    , ratio = Stage.width / Stage.height;
                if (_mesh.scale.set(scalar * ratio * .8, 4, 4),
                    _mesh.shader.set("uAlpha", uAlpha),
                    V3.copy(_mesh.position),
                    V3.y += 10,
                scalar > .01) {
                    let intersects = LevelController.raycaster.checkFromValues([_this.scene.floor], V3, DOWN_V3);
                    if (intersects && intersects.length) {
                        let point = intersects[0].point;
                        _mesh.position.y = point.y + _mesh.scale.y / 2 - .1 * _mesh.scale.y
                    }
                }
                _mesh.scale.x > .1 && _this.mainRoom && (_this.mainRoom.nuke.camera = Global.MAIN_ROOM_CAMERA,
                    Global.MAIN_ROOM_CAMERA.aspect = _mesh.scale.x / _mesh.scale.y,
                    Global.MAIN_ROOM_CAMERA.updateProjectionMatrix(),
                    _this.mainRoom.renderPreview(_mesh, _this.scene)),
                distance < 3 && "env5" == _this.scene.name && mainPlayer.teleportToMainRoom()
            }
            _this.mainRoom = LevelController.getScene("main_room"),
                _this.mesh = _mesh,
                _this.scene = _this.parent.parent.parent.parent,
                _shader.addUniforms({
                    uAlpha: {
                        value: 0
                    },
                    uColor: {
                        value: new Color("0x000000")
                    },
                    tMap: {
                        value: null
                    }
                }),
                _shader.transparent = !0,
                _shader.deptHTest = !0,
                _shader.depthWrite = !0,
                _this.startRender(loop),
                LevelController.ready().then((()=>{
                        _this.mainRoom = LevelController.getScene("main_room"),
                        _this.mainRoom && _shader.set("tMap", _this.mainRoom.rt)
                    }
                ))
        }
    )),
    Class((function Env5Trees(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            var _start1, _end1, _start2, _end2, _this = this;
            function loop() {
                if (Env5Level.percent) {
                    let strobe = _start1 < Env5Level.percent && _end1 > Env5Level.percent ? 1 : 0;
                    _start2 < Env5Level.percent && _end2 > Env5Level.percent && (strobe = 1),
                        _shader.uniforms.uStrobe.value = Math.lerp(strobe, _shader.uniforms.uStrobe.value, .02)
                }
            }
            !async function() {
                _shader.addUniforms({
                    tMap: {
                        value: Utils3D.getRepeatTexture("assets/images/env5/bark-14.jpg")
                    },
                    uColor: {
                        value: new Color("#171915")
                    },
                    uColorMix: {
                        value: 0
                    },
                    uAlpha: {
                        value: 1
                    },
                    transparent: !0,
                    uNoiseSpeed: {
                        value: .2
                    },
                    uNoiseStrength: {
                        value: .4
                    },
                    uNoiseScale: {
                        value: .4
                    },
                    uNoiseApplyY: {
                        value: new Vector2(-4,10)
                    },
                    uFogBrightness: Env5Level.uFogBrightness,
                    uFogColor: Env5Level.uFogColor,
                    uFogRange: Env5Level.uFogRange,
                    uStrobe: {
                        value: 0
                    }
                }),
                    _this.startRender(loop),
                    _start1 = Env5Level.convertTime(2.17),
                    _end1 = Env5Level.convertTime(2.43),
                    _start2 = Env5Level.convertTime(4.195),
                    _end2 = Env5Level.convertTime(4.5)
            }()
        }
    )),
    Class((function SimpleWater(_mesh, _shader) {
            Inherit(this, Component);
            _shader.addUniforms({
                uAttenuation: {
                    value: 1
                },
                uShininess: {
                    value: 1
                },
                uFresnelPow: {
                    value: 2
                },
                uColor1: {
                    value: new Color
                },
                uColor2: {
                    value: new Color
                },
                uEdgeColor: {
                    value: new Color
                },
                uLightDir: {
                    value: new Vector3(.5,.5,.5)
                },
                tNormal: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                tAlpha: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                tExtraGlow: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                uTile: {
                    value: 1
                },
                uNormalIntensity: {
                    value: 1
                },
                uSpeed: {
                    value: 1
                },
                uWaterAlpha: {
                    value: 1
                },
                uEdgeAlpha: {
                    value: 0
                },
                uExtraGlowStrength: {
                    value: .5
                },
                uBlinkSpeed: {
                    value: 1
                },
                uScale: {
                    value: 1
                },
                uFogBrightness: Env5Level.uFogBrightness,
                uFogColor: Env5Level.uFogColor,
                uFogRange: Env5Level.uFogRange
            })
        }
    )),
    Class((function Env5VisibilityUtil() {
            Inherit(this, Component);
            const _this = this;
            function loop() {
                PlayerController && PlayerController.mainPlayer && PlayerController.mainPlayer.currentScene && "env5" === PlayerController.mainPlayer.currentScene.name && _this.items.forEach((item=>{
                        item.element.visible = Env5Level.percent > item.start && Env5Level.percent < item.end,
                        item.flowers && console.log(item.element.visible, Env5Level.percent, item.start, item.end)
                    }
                ))
            }
            _this.items = [],
                _this.startRender(loop),
                this.add = function(element, start, end) {
                    _this.items.push({
                        element: element,
                        start: start,
                        end: end
                    })
                }
        }
    ), "singleton"),
    Class((function Env5Zone(_mesh, _shader, _group, _input) {
            Inherit(this, Component);
            var _sphere, _curve, _this = this, _distance = new Vector3;
            function loop() {
                if (_this.resetting)
                    return;
                if (LevelController.currentScene && "env5" != LevelController.currentScene.name)
                    return void (_shader.uniforms.uAlpha.value = 0);
                if (Env5Level.percent > .94 && Env5Level.isPlaying)
                    return void (Env5Level.percent >= 1 && !_this.complete && (_this.complete = !0,
                        _this.tween = tween(Global, {
                            ENV5_DISTANCE: 1
                        }, 6e3, "easeInSine", (_=>{
                                !function reset() {
                                    _this.resetting = !0,
                                        _this.delayedCall((_=>{
                                                _this.resetting = !1
                                            }
                                        ), 1e3);
                                    let position = _curve.getPoint(0);
                                    position.y -= 5.4,
                                        _mesh.position.copy(position),
                                        _shader.uniforms.uAlpha.value = .7,
                                        _this.inZone = 0,
                                        PlayerController.mainPlayer.group.position.x = 2,
                                        PlayerController.mainPlayer.group.position.y = 0,
                                        PlayerController.mainPlayer.group.position.z = 6
                                }(),
                                    _this.findParent("Env5Level").onPlayerComplete()
                            }
                        ))));
                _this.complete = !1,
                _this.tween && _this.tween.stop && _this.tween.stop();
                let position = _curve.getPoint(Env5Level.percent);
                position.y -= 5.4,
                    _distance.subVectors(position, _mesh.position),
                    _mesh.position.lerp(position, .025),
                _distance.length() > 20 && _mesh.position.copy(position);
                let worldPos = _mesh.getWorldPosition();
                _sphere.center = worldPos,
                    _sphere.center.y = 0;
                PlayerController.mainPlayer;
                PlayerController.mainPlayer && function checkMainPlayer() {
                    let x = _mesh.position.x - PlayerController.mainPlayer.group.position.x
                        , z = _mesh.position.z - PlayerController.mainPlayer.group.position.z
                        , y = _mesh.position.y - PlayerController.mainPlayer.group.position.y
                        , inZone = Math.abs(x) < _sphere.radius && Math.abs(z) < _sphere.radius && Math.abs(y) < _sphere.radius;
                    PlayerController.mainPlayer.group.position.length() || (inZone = !1);
                    inZone ? function enterZone() {
                        if (_this.entered)
                            return;
                        _this.entered = !0,
                            _mesh.shader.tween("uEntered", Env5Level.isPlaying ? .5 : 1, 500, "easeOutSine", (_=>{
                                    _mesh.shader.tween("uEntered", 0, 2e3, "easeInOutSine")
                                }
                            )),
                        Env5Level.isPlaying || (_this.playedChime || (_this.playedChime = !0,
                            _this.delayedCall((_=>{
                                    _this.playedChime = !1
                                }
                            ), 500),
                            AudioPlayer.loop = !1,
                            AudioPlayer.volume = .4,
                            AudioPlayer.play("assets/audio/ping.mp3")),
                            _this.findParent("Env5Level").onPlayerReady())
                    }() : function exitZone() {
                        if (!_this.entered)
                            return;
                        _this.entered = !1,
                            _mesh.shader.tween("uEntered", 0, 2e3, "easeInOutSine")
                    }();
                    let tooFar = Math.abs(x) > 40 || Math.abs(z) > 40 || Math.abs(y) > 40
                        , moving = Keyboard.isDown("up") || Keyboard.isDown("down") || Keyboard.isDown("left") || Keyboard.isDown("right");
                    Global.MOBILE_JOYSTICK_TOUCH && (moving = !0);
                    _this.lockMovement && (moving = !1);
                    _this.inZone = Math.lerp(inZone ? 1 : 0, _this.inZone, .005),
                    (!inZone || moving) && (_this.inZone = 0);
                    let distanceFade = Math.range(Math.max(Math.abs(x), Math.abs(z)), 30, 42, 0, 1, !0)
                        , alpha = .7;
                    (inZone && !moving || tooFar) && (tooFar && !_this.lockMovement && (_this.lockMovement = !0,
                        _this.delayedCall((_=>{
                                _this.lockMovement = !1
                            }
                        ), 2e3),
                        _this.inZone = 1),
                        alpha = 0,
                        PlayerController.mainPlayer.group.position.x += x * _this.inZone,
                        PlayerController.mainPlayer.group.position.z += z * _this.inZone,
                        PlayerController.mainPlayer.group.position.y += y * _this.inZone);
                    Global.ENV5_DISTANCE = Math.lerp(distanceFade, Global.ENV5_DISTANCE, .1),
                        _shader.uniforms.uAlpha.value = Math.lerp(alpha, _shader.uniforms.uAlpha.value, .01)
                }(),
                PlayerController.remotePlayer && function checkRemotePLayer() {
                    let x = _mesh.position.x - PlayerController.remotePlayer.group.position.x
                        , z = _mesh.position.z - PlayerController.remotePlayer.group.position.z
                        , y = _mesh.position.y - PlayerController.remotePlayer.group.position.y
                        , inZone = Math.abs(x) < _sphere.radius && Math.abs(z) < _sphere.radius && Math.abs(y) < _sphere.radius;
                    PlayerController.remotePlayer.group.position.length() || (inZone = !1);
                    inZone ? function remoteEnterZone() {
                        if (_this.remoteEntered)
                            return;
                        _this.remoteEntered = !0,
                            _mesh.shader.tween("uEntered", Env5Level.isPlaying ? .3 : .7, 500, "easeOutSine", (_=>{
                                    _mesh.shader.tween("uEntered", 0, 2e3, "easeInOutSine")
                                }
                            )),
                        Env5Level.isPlaying || _this.playedChime || (_this.playedChime = !0,
                            _this.delayedCall((_=>{
                                    _this.playedChime = !1
                                }
                            ), 500),
                            AudioPlayer.loop = !1,
                            AudioPlayer.volume = .3,
                            AudioPlayer.play("assets/audio/ping.mp3"))
                    }() : function remoteExitZone() {
                        if (!_this.remoteEntered)
                            return;
                        _this.remoteEntered = !1,
                            _mesh.shader.tween("uEntered", 0, 2e3, "easeInOutSine")
                    }()
                }()
            }
            _this.inZone = 0,
                _shader.addUniforms({
                    uAlpha: {
                        value: 1
                    },
                    uEntered: {
                        value: 0
                    },
                    uRemoteEntered: {
                        value: 0
                    },
                    uTime: {
                        value: 0
                    }
                }),
                _sphere = new Sphere(_mesh.position,1.2 * _mesh.scale.x),
                _curve = Env5Level.getCurve(),
                _mesh.renderOrder = 9999,
                _mesh.oScale = (new Vector3).copy(_mesh.scale),
                _mesh.toScale = (new Vector3).copy(_mesh.oScale).addScalar(.2),
                _this.startRender(loop)
        }
    )),
    Global.ENV5_DISTANCE = 0,
    Class((function GrassField(_mesh, _shader) {
            Inherit(this, Object3D);
            function getGrassTexture(src, scale) {
                let texture = Utils3D.getTexture(src, scale);
                return texture.wrapS = texture.wrapT = Texture.REPEAT,
                    texture.minFilter = texture.magFilter = Texture.NEAREST,
                    texture
            }
            _shader.addUniforms({
                tMap: {
                    value: null,
                    getTexture: getGrassTexture
                },
                uBrightness: {
                    value: 1
                },
                uTile: {
                    value: new Vector2
                },
                uColor: {
                    value: new Color
                },
                uEnColor: {
                    value: new Color
                },
                uFogColor: {
                    value: new Color
                },
                uFar: {
                    value: 50
                },
                uDistanceFogStrength: {
                    value: 1
                },
                uNoiseStrength: {
                    value: 1
                },
                uNoiseScale: {
                    value: 1
                },
                uNoiseSpeed: {
                    value: 1
                },
                uTint1: {
                    value: new Color
                },
                uTint2: {
                    value: new Color
                },
                uEnTint1: {
                    value: new Color
                },
                uEnTint2: {
                    value: new Color
                },
                uEnabled: {
                    value: 0
                },
                uTime: GrassLevel.uTime
            }),
                GrassField.GEOMETRY = _mesh.geometry,
                GrassField.READY.resolve(GrassField.GEOMETRY),
                this.update = function(time, delta) {}
        }
    ), (_=>{
            GrassField.READY = Promise.create()
        }
    )),
Class((function GrassFloor(_input, _folder) {
        Inherit(this, Object3D);
        const _this = this;
        var _mesh, _shader;
        !function() {
            let geom = GrassFloor.getGeometry();
            _shader = _this.initClass(Shader, "GrassFloor", {
                uniforms: {
                    tMap: {
                        value: null,
                        getTexture: Utils3D.getRepeatTexture
                    },
                    uBrightness: {
                        value: 1
                    },
                    uTile: {
                        value: new Vector2
                    },
                    uColor: {
                        value: new Color
                    },
                    uFogColor: {
                        value: new Color
                    },
                    uFar: {
                        value: 50
                    },
                    uDistanceFogStrength: {
                        value: 1
                    },
                    uNoiseStrength: {
                        value: 1
                    },
                    uNoiseScale: {
                        value: 1
                    },
                    uNoiseSpeed: {
                        value: 1
                    },
                    uTime: GrassLevel.uTime
                },
                receiveLight: !0
            }),
                ShaderUIL.add(_shader, _folder),
                _shader.receiveLight = !0,
                _shader.set("uFar", Tests.getGrassFar()),
                _mesh = new Mesh(geom,_shader),
                _this.add(_mesh),
                _mesh.rotation.x = -Math.PI / 2,
                _this.mesh = _mesh
        }(),
            _this.update = function(time, delta) {}
            ,
            _this.get("mesh", (_=>_mesh))
    }
), (_=>{
        var geom;
        GrassFloor.getGeometry = function() {
            if (geom)
                return geom;
            let pos = (geom = new PlaneGeometry(1,1,100,100).toNonIndexed()).attributes.position.array;
            for (let i = 0, l = pos.length; i < l; i += 3) {
                let x = pos[i + 0]
                    , y = pos[i + 1]
                    , h = (pos[i + 2],
                .25 * Math.sin(22 * x + .2345) + .15 * Math.cos(20 * y) - .4);
                pos[i + 2] = .015 * h
            }
            return geom.attributes.position.needsUpdate = !0,
                geom.computeVertexNormals(),
                geom
        }
    }
)),
Class((function GrassLevel() {
        Inherit(this, AbstractLevel, "grass", "grass");
        const _this = this;
        new Color("#ff00ff");
        var _shader, _quad, _flowerPatches, _wind, _camera = World.CAMERA.clone();
        !async function() {
            _camera.far = Tests.getGrassFar(),
                _camera.aspect = Stage.width / Stage.height,
                _camera.updateProjectionMatrix(),
                _this.radiusBounds = 60,
                await async function initLevel() {
                    _this.mainScene = _this.initClass(GrassMain),
                        _flowerPatches = _this.initClass(GrassPatches, _this.mainScene.layout, "flower", _this.name, ["GRASS"]),
                        _this.mainScene.layout.group.add(_flowerPatches.group),
                        await _flowerPatches.ready();
                    let flowers = _flowerPatches.addFlowers();
                    await _this.mainScene.ready(),
                        _this.checkDebug(),
                        _shader = _this.initClass(Shader, "ScreenQuad", {
                            tMap: {
                                value: _this.mainScene.rt
                            }
                        }),
                        (_quad = new Mesh(World.QUAD,_shader)).frustumCulled = !1,
                        _quad.shader.depthTest = !1,
                        _quad.renderOrder = -2,
                        _this.scene.add(_quad),
                        Lighting.createScene("grass", _this.mainScene.scene),
                        _this.activeLayers = await _this.layout.getAllLayers(),
                        _this.layers = _this.mainScene.layers,
                        _this.floor = _this.layers.floor,
                        _this.layers.floor.renderOrder = -1e3,
                        _this.add(_this.layers.portal),
                        _this.add(_this.layers.floor),
                        _this.add(_this.layers.rockwide_joined),
                        await _this.addInstanced(_this.layers.tree2_branch),
                        await _this.addInstanced(_this.layers.tree2_leaves),
                        await _this.addInstanced(_this.layers.rockwide),
                        await _this.addInstanced(_flowerPatches),
                        _this.hitMeshes = [_this.layers.floor, _this.activeLayers.rocks_hit],
                        _this.collisionMeshes = [_this.activeLayers.tree_hit],
                        _this.layers.floor.isFloor = !0,
                        _this.activeLayers.rocks_hit.isRock = !0,
                        _this.activeLayers.rocks_hit.shader.neverRender = !0,
                        _this.activeLayers.tree_hit.shader.neverRender = !0;
                    for (let i = 0, l = flowers.length; i < l; i++)
                        await _this.wait(flowers[i], "mesh"),
                            _this.add(flowers[i].mesh);
                    (Tests.useWindGrass() || Utils.query("wind")) && (_wind = _this.initClass(GrassWind),
                        _this.mainScene.scene.add(_wind.group),
                        _wind.ready().then((()=>{
                                _wind.lines.forEach((line=>{
                                        _this.add(line.mesh)
                                    }
                                ))
                            }
                        )));
                    _this.layers.draw_zone.renderOrder = 9999,
                        _this.layers.draw_zone.frustumCulled = !1,
                        _this.add(_this.layers.draw_zone)
                }(),
                function initPlayer() {
                    _this.playerConfig = {
                        speed: 1,
                        spawn: new Vector3(0,10,0),
                        angleX: Math.radians(0),
                        maxPanY: 10
                    }
                }(),
                _this.setSize(Stage.width, Stage.height),
                _this.isReady = !0
        }();
        let sSetSize = _this.setSize;
        _this.setSize = (w=Stage.width,h=Stage.height,e)=>{
            _camera.aspect = w / h,
                _camera.updateProjectionMatrix(),
                sSetSize(w, h, e),
                _this.mainScene.setSize(w, h, e)
        }
            ,
            _this.getLevelState = ()=>{
                let patches;
                return patches = _flowerPatches ? _flowerPatches.getState() : [!1, !1, !1],
                    _this.state.patches = patches,
                    _this.state
            }
            ,
            _this.syncRemoteState = state=>{
                if (_this.getLevelState(),
                state.patches && _this.state.patches) {
                    for (let i = 0, l = _this.state.patches.length; i < l; i++)
                        state.patches[i] && (_this.state.patches[i] = state.patches[i]);
                    return _flowerPatches && _flowerPatches.setState(_this.state.patches),
                        _this.state
                }
            }
            ,
            _this.update = (time,delta)=>{
                GrassLevel.uTime.value += delta / 1e3 * 1 * Render.HZ_MULTIPLIER,
                    _camera.position.copy(World.CAMERA.position),
                    _camera.quaternion.copy(World.CAMERA.quaternion),
                    World.CAMERA.far = 1e3,
                    _this.updateCamera(),
                World.CAMERA.fov !== _camera.fov && (_camera.fov = World.CAMERA.fov,
                    _camera.updateProjectionMatrix());
                let {remotePlayer: remotePlayer} = PlayerController
                    , isRemoteHere = remotePlayer && remotePlayer.currentScene && "grass" === remotePlayer.currentScene.name;
                isRemoteHere && (_this.mainScene.layout.add(remotePlayer),
                    _this.mainScene.layout.add(remotePlayer.orb)),
                _this.mainScene && _this.mainScene.isReady && (Lighting.useScene("grass"),
                    _this.mainScene.layout.group.add(_this.layers.birds.group),
                    _this.mainScene.layout.group.add(_this.layers.blowingleaves.group),
                    _this.mainScene.update(time, delta)),
                isRemoteHere && (_this.layout.add(remotePlayer),
                    _this.layout.add(remotePlayer.orb)),
                _wind && _wind.update(time, delta),
                    _this.layout.group.add(_this.layers.birds.group),
                    _this.layout.group.add(_this.layers.blowingleaves.group),
                    _this.render(null, _camera)
            }
            ,
            _this.onRemotePlayerAdded = ()=>{
                _this.remoteAdded = !0
            }
            ,
            _this.onRemotePlayerRemoved = ()=>{
                _this.remoteAdded && (_this.remoteAdded = !1)
            }
            ,
            _this.onPatchActivate = patch=>{
                _this.getLevelState();
                let validated = !0;
                if (_this.isReset = !1,
                    _this.state.patches) {
                    for (let i = 0, l = _this.state.patches.length; i < l; i++)
                        _this.state.patches[i] || (validated = !1);
                    validated && _this.onPlayersEnabled()
                }
            }
            ,
            _this.onPatchDesactivate = patch=>{}
            ,
            _this.onPlayersEnabled = ()=>{
                if (!_this.activated) {
                    _this.activated = !0,
                        _this.layers.horizon.shader.tween("uEnabled", 1, 3e3, "easeInOutSine"),
                        _this.layers.floor.shader.tween("uEnabled", 1, 3e3, "easeInOutSine"),
                        _this.layers.tree2_leaves.shader.tween("uEnabled", 1, 3e3, "easeInOutSine"),
                    _this.layers.birds.proton && _this.layers.birds.proton.customClass.shader.tween("uEnabled", 1, 3e3, "easeInOutSine"),
                    _this.layers.birds.proton && _this.layers.birds.proton.behavior.shader.tween("uEnabled", 1, 3e3, "easeInOutSine"),
                    _this.layers.blowingleaves.proton && _this.layers.blowingleaves.proton.mesh.shader.tween("uEnabled", .9, 1, "easeInOutSine"),
                    _this.layers.blowingleaves.proton && _this.layers.blowingleaves.proton.behavior.shader.tween("uEnabled", .9, 3e3, "easeInOutSine");
                    for (let i = 0, l = 5; i < l; i++)
                        _this.activeLayers[`tile_${i}`].instancedShader.tween("uEnabled", 1, 3e3, "easeInOutSine");
                    _flowerPatches.playerActivate()
                }
            }
            ,
            _this.resetState = function() {
                if (!_this.isReset) {
                    _this.activated = !1,
                        _this.isReset = !0,
                        _flowerPatches.desactivate(),
                        _this.layers.horizon.shader.tween("uEnabled", 0, 3e3, "easeInOutSine"),
                        _this.layers.floor.shader.tween("uEnabled", 0, 3e3, "easeInOutSine"),
                        _this.layers.tree2_leaves.shader.tween("uEnabled", 0, 3e3, "easeInOutSine"),
                    _this.layers.birds.proton && _this.layers.birds.proton.customClass.shader.tween("uEnabled", 0, 3e3, "easeInOutSine"),
                    _this.layers.birds.proton && _this.layers.birds.proton.behavior.shader.tween("uEnabled", 0, 3e3, "easeInOutSine"),
                    _this.layers.blowingleaves.proton && _this.layers.blowingleaves.proton.mesh.shader.tween("uEnabled", 0, 1, "easeInOutSine"),
                    _this.layers.blowingleaves.proton && _this.layers.blowingleaves.proton.behavior.shader.tween("uEnabled", 0, 3e3, "easeInOutSine");
                    for (let i = 0, l = 5; i < l; i++)
                        _this.activeLayers[`tile_${i}`].instancedShader.tween("uEnabled", 0, 3e3, "easeInOutSine");
                    if (_flowerPatches.playerDesactivate(),
                        _this.state.patches)
                        for (let i = 0, l = _this.state.patches.length; i < l; i++)
                            _this.state.patches[i] = !1
                }
            }
            ,
            _this.ready = ()=>_this.wait("isReady"),
            this.uploadAll = async function() {
                await _this.ready(),
                    await Initializer3D.uploadAll(_this.layout),
                    await _flowerPatches.uploadAll()
            }
            ,
            this.uploadAllAsync = async function() {
                await _this.ready(),
                    await Initializer3D.uploadAllAsync(_this.layout),
                    await _flowerPatches.uploadAllAsync()
            }
    }
), (_=>{
        GrassLevel.uTime = {
            value: 0
        }
    }
)),
Class((function GrassMain() {
        Inherit(this, FXScene);
        const _this = this;
        !async function() {
            _this.name = "grass",
                Lighting.createScene("grass", _this.scene),
                _this.layout = _this.initClass(SceneLayout, "grass_level", {}),
                _this.scene.add(_this.layout.group),
                _this.create(World.NUKE, null, {
                    format: Texture.RGBAFormat
                }),
                _this.layers = await _this.layout.getAllLayers(),
                _this.floor = _this.layers.floor,
                _this.grass = _this.layers.grass,
                _this.horizon = _this.layers.horizon,
                _this.horizon.renderOrder = -1,
                _this.radiusBounds = 60,
                _this.portal = _this.layers.portal,
                _this.isReady = !0
        }(),
            _this.update = (time,delta)=>{
                _this.render(null, World.CAMERA)
            }
            ,
            _this.ready = ()=>_this.wait("isReady"),
            _this.get("isRunning", (_=>_this.parent.isRunning))
    }
)),
Class((function GrassScene() {
        Inherit(this, FXScene);
        const _this = this;
        var _camera = World.CAMERA.clone();
        _camera.far = Tests.getGrassFar(),
            _camera.updateProjectionMatrix(),
            _this.layout = _this.initClass(SceneLayout, "grass_scene", {}),
            _this.scene.add(_this.layout.group),
            _this.create(World.NUKE, null, {
                format: Texture.RGBAFormat
            }),
            _this.isReady = !0,
            _this.update = (time,delta)=>{
                _camera.position.copy(World.CAMERA.position),
                    _camera.quaternion.copy(World.CAMERA.quaternion),
                World.CAMERA.fov !== _camera.fov && (_camera.fov = World.CAMERA.fov,
                    _camera.updateProjectionMatrix()),
                World.CAMERA.aspect !== _camera.aspect && (_camera.aspect = World.CAMERA.aspect,
                    _camera.updateProjectionMatrix()),
                    World.RENDERER.setClearAlpha(0),
                    _this.render(null, World.CAMERA),
                    World.RENDERER.setClearAlpha(1)
            }
            ,
            _this.ready = ()=>_this.wait("isReady"),
            _this.get("isRunning", (_=>_this.parent.isRunning))
    }
)),
Class((function GrassWind() {
        Inherit(this, Object3D);
        const _this = this;
        var _lines = [];
        !function initWind() {
            for (let i = 0, l = 30; i < l; i++) {
                let line = _this.initClass(GrassWindLine);
                _lines.push(line),
                    _this.delayedCall((()=>{
                            line.emit()
                        }
                    ), Math.random(0, 5e3))
            }
        }(),
            this.get("stroke", (_=>_stroke)),
            this.get("lines", (_=>_lines)),
            _this.ready = _=>{
                let promises = [];
                for (let i = 0, l = _lines.length; i < l; i++)
                    promises.push(_lines[i].ready());
                return Promise.all(promises)
            }
            ,
            _this.update = (time,delta)=>{
                for (let i = 0, l = _lines.length; i < l; i++)
                    _lines[i].update(time, delta)
            }
    }
)),
Class((function GrassWindLine() {
        Inherit(this, Object3D);
        const _this = this;
        var _stroke, _track = new Vector3, _direction = new Vector3(-1,0,.3), _dirOffset = new Vector3, _sinOffset = new Vector3;
        new Vector3;
        function emit() {
            _this.emitted = !0,
                _direction.set(-1 + Math.random(-.05, .05, 10), 0, .3 + Math.random(-.05, .05, 10)),
                _track.set(Math.random(0, 60), Math.random(-.3, 1, 10), Math.random(-60, 0)),
                _this.reset()
        }
        !function initWind() {
            let width = .5
                , color = "#ffffff"
                , length = 40;
            _this.length = length,
                _stroke = new Line3D({
                    width: width,
                    color: color,
                    length: length
                }),
                _this.add(_stroke),
                _stroke.frustumCulled = !1,
                _stroke.shader.transparent = !0,
                _stroke.shader.side = Shader.DOUBLE_SIDE
        }(),
            _this.reset = function() {
                for (let i = 0, l = _this.length; i < l; i++)
                    _stroke.draw(_track)
            }
            ,
            this.get("stroke", (_=>_stroke)),
            this.ready = _=>_this.wait(_stroke, "mesh"),
            _this.get("mesh", (_=>_stroke.mesh)),
            _this.emit = emit,
            _this.update = function update(time, delta) {
                if (!_this.emitted)
                    return;
                _dirOffset.copy(_direction).multiplyScalar(.1),
                    _dirOffset.copy(_direction).multiplyScalar(.1);
                let offsetTime = .2 * time;
                _sinOffset.x = .1 * Math.cos(.0024 * offsetTime) + .1 * Math.cos(.015 * offsetTime + .234),
                    _sinOffset.y = .002 * Math.sin(.012 * offsetTime * .002 + 2345.2345),
                    _sinOffset.z = .1 * Math.sin(.0019 * offsetTime) + .1 * Math.cos(.0012 * offsetTime + .23),
                    _track.add(_dirOffset).add(_sinOffset),
                    Math.abs(_track.x) > 60 || Math.abs(_track.z) > 60 ? emit() : _stroke.draw(_track)
            }
    }
)),
Class((function InstancedGrass(_input, _group) {
        Inherit(this, Object3D);
        const _this = this;
        var _shader, _player1Pos = new Vector3, _player2Pos = new Vector3, _player1Pos2 = new Vector3, _player2Pos2 = new Vector3;
        const V3 = new Vector3;
        function onPlayerConnect() {
            _shader.uniforms.uPlayer2Pos.value = PlayerController.remotePlayer.group.position
        }
        function onPlayerLeave() {
            _shader.uniforms.uPlayer2Pos.value = new Vector3
        }
        function loop(time, delta) {
            let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
            if ("grass" === mainPlayer.currentScene.name ? _shader.set("uPlayer1InScene", 1) : _shader.set("uPlayer1InScene", 0),
                remotePlayer && remotePlayer.currentScene && "grass" === remotePlayer.currentScene.name ? _shader.set("uPlayer2InScene", 1) : _shader.set("uPlayer2InScene", 0),
            mainPlayer && mainPlayer.group && mainPlayer.group.position) {
                let delta = Math.abs(_player1Pos2.length() - mainPlayer.group.position.length());
                delta = Math.range(delta, 0, 6, .2, 1, !0),
                    _shader.set("uPlayer1Movement", delta),
                    _player1Pos.lerp(mainPlayer.group.position, .1),
                    _player1Pos2.lerp(_player1Pos, .1)
            } else
                _shader.set("uPlayer1Movement", 0);
            if (remotePlayer && remotePlayer.group && remotePlayer.group.position) {
                let delta = Math.abs(_player2Pos2.length() - remotePlayer.group.position.length());
                delta = Math.range(delta, 0, 6, .2, 1, !0),
                    _shader.set("uPlayer2Movement", delta),
                    _player2Pos.lerp(remotePlayer.group.position, .1),
                    _player2Pos2.lerp(_player2Pos, .1)
            } else
                _shader.set("uPlayer2Movement", 0);
            let offsetArr = _this.geometry.attributes.offset.array
                , visibleArr = _this.geometry.attributes.visible.array
                , baseFov = World.CAMERA.fov;
            World.CAMERA.fov += 10,
                World.CAMERA.aspect = "main_room" === mainPlayer.currentScene.name ? Global.PREVIEW_ASPECT : Stage.width / Stage.height,
                World.CAMERA.updateProjectionMatrix(),
                World.FRUSTUM.setFromCamera(World.CAMERA);
            for (let i = 0, l = offsetArr.length / 4; i < l; i++)
                V3.set(offsetArr[4 * i + 0], offsetArr[4 * i + 1], offsetArr[4 * i + 2]),
                    visibleArr[i] = World.FRUSTUM.containsPoint(V3) ? 1 : 0;
            World.CAMERA.fov = baseFov,
                World.CAMERA.aspect = Stage.width / Stage.height,
                World.CAMERA.updateProjectionMatrix(),
                _this.geometry.attributes.visible.needsUpdate = !0
        }
        !async function() {
            _this.proton = await _this.parent.getLayer("grass"),
                await async function initMesh() {
                    await GrassField.READY;
                    let pos = GrassField.GEOMETRY.attributes.position.array
                        , positions = []
                        , visible = [];
                    for (let i = 0, l = pos.length; i < l; i += 3)
                        for (let j = 0, lj = Tests.getGrassNumberCoef(); j < lj; j++)
                            positions.push(200 * pos[i + 1] + 2 * Math.random(-1, 1, 4)),
                                positions.push(200 * pos[i + 2]),
                                positions.push(200 * pos[i + 0] + 2 * Math.random(-1, 1, 4)),
                                positions.push(0),
                                visible.push(0);
                    let array = new Float32Array(positions)
                        , geometry = (new Geometry).instanceFrom(new PlaneGeometry(1,1));
                    geometry.addAttribute("offset", new GeometryAttribute(array,4,1)),
                        geometry.addAttribute("visible", new GeometryAttribute(new Float32Array(visible),1,1));
                    let random = new Float32Array(array.length);
                    for (let i = 0; i < array.length; i++)
                        random[4 * i + 0] = Math.random(0, 1, 4),
                            random[4 * i + 1] = Math.random(0, 1, 4),
                            random[4 * i + 2] = Math.random(0, 1, 4),
                            random[4 * i + 3] = Math.random(0, 1, 4);
                    geometry.addAttribute("random", new GeometryAttribute(random,4,1)),
                        (_shader = _this.initClass(Shader, "InstancedGrass", {
                            tMap: {
                                value: null
                            },
                            tAlpha: {
                                value: null
                            },
                            uSize: {
                                value: 1
                            },
                            uSizeRandom: {
                                value: 0
                            },
                            uOffset: {
                                value: new Vector3
                            },
                            uFogRange: {
                                value: new Vector2
                            },
                            uHeight: {
                                value: 0
                            },
                            uSkew: {
                                value: 0
                            },
                            uSizeRandom: {
                                value: 0
                            },
                            uBaseColor: {
                                value: new Color
                            },
                            uColor1: {
                                value: new Color
                            },
                            uColor2: {
                                value: new Color
                            },
                            uColorMapBlend: {
                                value: 0
                            },
                            uFogColor: {
                                value: new Color
                            },
                            uDiffuse1: {
                                value: new Color
                            },
                            uDiffuse2: {
                                value: new Color
                            },
                            uRandomColor: {
                                value: new Color
                            },
                            uRandomColorAmount: {
                                value: 1
                            },
                            uNoiseStrength: {
                                value: 1
                            },
                            uNoiseScale: {
                                value: 1
                            },
                            uNoiseSpeed: {
                                value: 1
                            },
                            uDistanceFogStrength: {
                                value: 1
                            },
                            uHighlightStrength: {
                                value: .5
                            },
                            uHighlightColor: {
                                value: new Color
                            },
                            uPlayer1Pos: {
                                value: PlayerController.mainPlayer.group.position
                            },
                            uPlayer2Pos: {
                                value: new Vector3
                            },
                            uPlayer1InScene: {
                                value: 0
                            },
                            uPlayer2InScene: {
                                value: 0
                            },
                            uEnabled: {
                                value: 0
                            },
                            uPlayer1Movement: {
                                value: 1,
                                ignoreUIL: !0
                            },
                            uPlayer2Movement: {
                                value: 1,
                                ignoreUIL: !0
                            }
                        })).transparent = !0,
                        _shader.depthWrite = !0,
                        _shader.depthTest = !1,
                        _shader.side = Shader.DOUBLE_SIDE,
                        ShaderUIL.add(_shader, _group).setLabel("Shader");
                    let mesh = new Mesh(geometry,_shader);
                    mesh.side = Shader.DOUBLE_SIDE,
                        mesh.depthTest = !1,
                        mesh.frustumCulled = !1,
                        _this.geometry = geometry,
                        _this.add(mesh)
                }(),
                function addListeners() {
                    _this.events.sub(Multiplayer.PLAYER_JOINED, onPlayerConnect),
                        _this.events.sub(Multiplayer.CONNECTION_LOST, onPlayerLeave),
                        _this.startRender(loop)
                }(),
                Dev.expose("grass", _this)
        }()
    }
)),
Class((function InstancedGrassTile(_proton, _group) {
        Inherit(this, Object3D);
        const _this = this;
        var _shader;
        const UP = new Vector3(0,1,0);
        var _index, _player1Pos = new Vector3, _player2Pos = new Vector3, _player1Pos2 = new Vector3, _player2Pos2 = new Vector3, _box = new Box3;
        const V3 = new Vector3;
        function onPlayerConnect() {
            _shader.uniforms.uPlayer2Pos.value = PlayerController.remotePlayer.group.position
        }
        function onPlayerLeave() {}
        function parentLoop() {
            World.FRUSTUM.setFromCamera(World.CAMERA),
                _this.visible = World.FRUSTUM.intersectsBox(_box)
        }
        function loop(time, delta) {
            let fromTop = Math.range(World.CAMERA.position.dot(UP), 3, 8, 1, 0, !0);
            _shader.set("uViewFromTop", fromTop);
            let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
            if ("grass" === mainPlayer.currentScene.name ? _shader.set("uPlayer1InScene", 1) : _shader.set("uPlayer1InScene", 0),
                remotePlayer && remotePlayer.currentScene && "grass" === remotePlayer.currentScene.name ? _shader.set("uPlayer2InScene", 1) : _shader.set("uPlayer2InScene", 0),
            mainPlayer && mainPlayer.group && mainPlayer.group.position) {
                let delta = Math.abs(_player1Pos2.length() - mainPlayer.group.position.length());
                delta = Math.range(delta, 0, 6, .2, 1, !0),
                    _shader.set("uPlayer1Movement", delta),
                    _player1Pos.lerp(mainPlayer.group.position, .05),
                    _player1Pos2.lerp(_player1Pos, .05)
            } else
                _shader.set("uPlayer1Movement", 0);
            if (remotePlayer && remotePlayer.group && remotePlayer.group.position) {
                let delta = Math.abs(_player2Pos2.length() - remotePlayer.group.position.length());
                delta = Math.range(delta, 0, 6, .2, 1, !0),
                    _shader.set("uPlayer2Movement", delta),
                    _player2Pos.lerp(remotePlayer.group.position, .05),
                    _player2Pos2.lerp(_player2Pos, .05)
            } else
                _shader.set("uPlayer2Movement", 0)
        }
        !async function() {
            _this.proton = _proton,
                _index = parseInt(_proton.uilInput.get("wildcard"), 10),
                await async function initMesh() {
                    await PlayerController.mainPlayerReady;
                    let grass = World.GRASS_FLOOR;
                    grass || (grass = await GeomThread.loadGeometry("assets/geometry/grass/grassfloor.json"),
                        World.GRASS_FLOOR = grass);
                    grass.boundingBox && grass.computeBoundingBox();
                    let pos = grass.attributes.position.array
                        , positions = []
                        , visible = []
                        , step = parseInt(pos.length / 5, 10)
                        , start = _index * step
                        , end = (_index + 1) * step;
                    start = 3 * Math.ceil(start / 3),
                        end = 3 * Math.ceil(end / 3),
                    -1 === _index && (start = 0,
                        end = pos.length);
                    for (let i = start, l = end; i < l; i += 3)
                        for (let j = 0, lj = Tests.getGrassNumberCoef(); j < lj; j++) {
                            let x = pos[i + 0] + 5 * Math.random(-1, 1, 4)
                                , y = .5
                                , z = pos[i + 2] + 5 * Math.random(-1, 1, 4);
                            positions.push(x),
                                positions.push(y),
                                positions.push(z),
                                positions.push(0),
                                visible.push(1),
                                V3.set(x, y, z),
                                _box.expandByPoint(V3)
                        }
                    let array = new Float32Array(positions)
                        , geometry = (new Geometry).instanceFrom(new PlaneGeometry(1,1));
                    geometry.addAttribute("offset", new GeometryAttribute(array,4,1)),
                        geometry.addAttribute("visible", new GeometryAttribute(new Float32Array(visible),1,1));
                    let random = new Float32Array(array.length);
                    for (let i = 0; i < array.length; i++)
                        random[4 * i + 0] = Math.random(0, 1, 4),
                            random[4 * i + 1] = Math.random(0, 1, 4),
                            random[4 * i + 2] = Math.random(0, 1, 4),
                            random[4 * i + 3] = Math.random(0, 1, 4);
                    geometry.addAttribute("random", new GeometryAttribute(random,4,1)),
                        (_shader = _this.initClass(Shader, "InstancedGrass", {
                            tMap: {
                                value: null
                            },
                            tDepth: {
                                value: Utils3D.getTexture("assets/images/env3/ground_height.jpg"),
                                ignoreUIL: !0
                            },
                            tRocks: {
                                value: Utils3D.getTexture("assets/images/grass/grass_scale.jpg"),
                                ignoreUIL: !0
                            },
                            tAlpha: {
                                value: null
                            },
                            uSize: {
                                value: 1
                            },
                            uSizeRandom: {
                                value: 0
                            },
                            uDepth: {
                                value: new Vector2
                            },
                            uOffset: {
                                value: new Vector3
                            },
                            uFogRange: {
                                value: new Vector2(0,10),
                                ignoreUIL: !0
                            },
                            uHeight: {
                                value: 0
                            },
                            uSkew: {
                                value: 0
                            },
                            uSizeRandom: {
                                value: 0
                            },
                            uBaseColor: {
                                value: new Color
                            },
                            uColor1: {
                                value: new Color
                            },
                            uColor2: {
                                value: new Color
                            },
                            uColorMapBlend: {
                                value: 0
                            },
                            uFogColor: {
                                value: new Color
                            },
                            uDiffuse1: {
                                value: new Color
                            },
                            uDiffuse2: {
                                value: new Color
                            },
                            uBboxMin: {
                                value: grass.boundingBox.min,
                                ignoreUIL: !0
                            },
                            uBboxMax: {
                                value: grass.boundingBox.max,
                                ignoreUIL: !0
                            },
                            uRandomColor: {
                                value: new Color
                            },
                            uRandomColorAmount: {
                                value: 1
                            },
                            uNoiseStrength: {
                                value: 1
                            },
                            uNoiseScale: {
                                value: 1
                            },
                            uNoiseSpeed: {
                                value: 1
                            },
                            uDistanceFogStrength: {
                                value: 1
                            },
                            uHighlightStrength: {
                                value: .5
                            },
                            uEnabled: {
                                value: 0,
                                ignoreUIL: !0
                            },
                            uEnableColor1: {
                                value: new Color
                            },
                            uEnableColor2: {
                                value: new Color
                            },
                            uHighlightColor: {
                                value: new Color
                            },
                            uPlayer1Pos: {
                                value: PlayerController.mainPlayer.group.position
                            },
                            uPlayer2Pos: {
                                value: new Vector3
                            },
                            uPlayer1InScene: {
                                value: 0
                            },
                            uPlayer2InScene: {
                                value: 0
                            },
                            uTime: GrassLevel.uTime,
                            uFar: {
                                value: Tests.getGrassFar()
                            },
                            uPlayer1Movement: {
                                value: 1,
                                ignoreUIL: !0
                            },
                            uPlayer2Movement: {
                                value: 1,
                                ignoreUIL: !0
                            },
                            uViewFromTop: {
                                value: 0
                            }
                        })).transparent = !0,
                        _shader.depthWrite = !1,
                        _shader.side = Shader.DOUBLE_SIDE,
                        _proton.instancedShader = _shader,
                        ShaderUIL.add(_shader, _group).setLabel("Shader");
                    let mesh = new Mesh(geometry,_shader);
                    mesh.frustumCulled = !1,
                        _this.geometry = geometry,
                        _this.add(mesh)
                }(),
                function addListeners() {
                    _this.events.sub(Multiplayer.PLAYER_JOINED, onPlayerConnect),
                        _this.events.sub(Multiplayer.CONNECTION_LOST, onPlayerLeave),
                        _this.startRender(loop),
                        _this.parent.startRender(parentLoop)
                }()
        }()
    }
)),
Class((function Leaves(_mesh, _shader, _group, _input) {
        Inherit(this, Component);
        _shader.addUniforms({
            tMap: {
                value: null
            },
            tAlpha: {
                value: null
            },
            uColorMix: {
                value: .5
            },
            uColor: {
                value: new Color
            },
            uEnColor: {
                value: new Color
            },
            uAlphaCutOff: {
                value: .5
            },
            uHighlightRange: {
                value: new Vector2(.6,2.25)
            },
            uHighlightColor: {
                value: new Color
            },
            uEnHighlightColor: {
                value: new Color
            },
            uSize: {
                value: 0
            },
            uWindStrength: {
                value: .005
            },
            uWiggleStrength: {
                value: 5
            },
            uWindFrequency: {
                value: 1
            },
            uNoiseSpeed: {
                value: .5
            },
            uNoiseStrength: {
                value: .005
            },
            uNoiseScale: {
                value: 1
            },
            uTipColor: {
                value: new Color
            },
            uEnTipColor: {
                value: new Color
            },
            uTipRange: {
                value: 1
            },
            uEnabled: {
                value: 0
            },
            uTime: GrassLevel.uTime
        })
    }
)),
Class((function Rock(_mesh, _shader, _group, _input) {
        Inherit(this, Component);
        _shader.addUniforms({
            tNormal: {
                value: null
            },
            uColor: {
                value: new Color
            },
            uFadeRange: {
                value: new Vector2
            },
            uGrassColor: {
                value: new Color
            },
            uClipHeight: {
                value: .5
            }
        })
    }
)),
Class((function AnimatedBird(_mesh, _shader, _group, _input) {
        Inherit(this, Component);
        _shader.addUniforms({
            tAnimation: {
                value: null
            }
        })
    }
)),
Class((function Bird(_input, _group) {
        Inherit(this, Object3D);
        const _this = this;
        !async function() {
            !async function initScene() {
                _this.layout = _this.initClass(SceneLayout, "birdlayout")
            }()
        }()
    }
)),
Class((function BirdFlockLayout() {
        Inherit(this, Object3D);
        const _this = this;
        var _flock1, _flock2, _flock3, _flock4;
        !async function() {
            Tests.hasBirds() && (await async function initScene() {
                _this.layout = _this.initClass(SceneLayout, "birdflocklayout_flocking"),
                    await _this.layout.getAllLayers(),
                    _flock1 = _this.layout.layers.flock_1,
                    _flock2 = _this.layout.layers.flock_2,
                    _flock3 = _this.layout.layers.flock_3,
                    _flock4 = _this.layout.layers.flock_4,
                    _flock1.shader.visible = !1,
                    _flock2.shader.visible = !1,
                    _flock3.shader.visible = !1,
                    _flock4.shader.visible = !1;
                let proton = _this.layout.layers.particles;
                await proton.ready(),
                    proton.behavior.shader.addUniforms({
                        uFlock1: {
                            value: new Vector3
                        },
                        uFlock2: {
                            value: new Vector3
                        },
                        uFlock3: {
                            value: new Vector3
                        },
                        uFlock4: {
                            value: new Vector3
                        }
                    }),
                    _this.proton = proton,
                    proton.behavior.shader.uniforms.uFlock1.value = _flock1.position,
                    proton.behavior.shader.uniforms.uFlock2.value = _flock2.position,
                    proton.behavior.shader.uniforms.uFlock3.value = _flock3.position,
                    proton.behavior.shader.uniforms.uFlock4.value = _flock4.position
            }(),
                _this.startRender((_=>{
                        _flock1.position.z = 20 * Math.sin(-15e-5 * Render.TIME + .5) * Render.HZ_MULTIPLIER,
                            _flock1.position.x = 28 * Math.cos(-15e-5 * Render.TIME + .5) * Render.HZ_MULTIPLIER,
                            _flock2.position.z = 22 * Math.sin(-15e-5 * Render.TIME + 1) * Render.HZ_MULTIPLIER,
                            _flock2.position.x = 25 * Math.cos(-15e-5 * Render.TIME + 1) * Render.HZ_MULTIPLIER,
                            _flock3.position.z = 22 * Math.sin(15e-5 * Render.TIME + 1.5) * Render.HZ_MULTIPLIER,
                            _flock3.position.x = 28 * Math.cos(15e-5 * Render.TIME + 1.5) * Render.HZ_MULTIPLIER,
                            _flock4.position.z = 25 * Math.sin(15e-5 * Render.TIME + .75) * Render.HZ_MULTIPLIER,
                            _flock4.position.x = 25 * Math.cos(15e-5 * Render.TIME + .75) * Render.HZ_MULTIPLIER
                    }
                )))
        }()
    }
)),
Class((function InstancedBirds(_proton, _group) {
        Inherit(this, Object3D);
        const _this = this;
        !async function initMesh() {
            _proton.antimatter.storeVelocity = !0;
            let birdGeometry = await GeomThread.loadGeometry("assets/geometry/grass/simplebird2.json")
                , geom = (new Geometry).instanceFrom(birdGeometry);
            _proton.applyToInstancedGeometry(geom);
            let shader = _this.initClass(Shader, "InstancedBirdParticles", {
                tAnimation: {
                    value: Utils3D.getLookupTexture("assets/images/grass/birdanimation.jpg")
                },
                uColor1: {
                    value: new Color
                },
                uColor2: {
                    value: new Color
                },
                uAltColor1: {
                    value: new Color
                },
                uAltColor2: {
                    value: new Color
                },
                uEnabled: {
                    value: 0
                }
            });
            _this.shader = shader,
                ShaderUIL.add(shader, _group).setLabel("Shader"),
                _proton.applyToShader(shader);
            let mesh = new Mesh(geom,shader);
            mesh.frustumCulled = !1,
                _this.add(mesh)
        }()
    }
)),
Class((function BlowingLeaves(_proton) {
        Inherit(this, Object3D);
        const _this = this;
        var _origin = new Vector3;
        !async function() {
            await _proton.ready(),
                _this.startRender((_=>{
                        Math.random() > .2 || _proton.spawn.release(_origin, 1, 6, .1)
                    }
                ), 10)
        }()
    }
)),
Class((function BlowingLeavesLayout() {
        Inherit(this, Object3D);
        const _this = this;
        !async function initScene() {
            if (!Tests.hasBlowingLeaves())
                return;
            let layout = _this.initClass(SceneLayout, "blowingleaveslayout");
            _this.layers = await layout.getAllLayers(),
                _this.proton = _this.layers.particles
        }()
    }
)),
Class((function SpritesheetTest(_mesh, _shader, _group, _input) {
        Inherit(this, Component);
        _shader.addUniforms({
            tMap: {
                value: null,
                getTexture: Utils3D.getRepeatTexture
            }
        })
    }
)),
Class((function TreeTest() {
        Inherit(this, Object3D);
        const _this = this;
        !async function initScene() {
            _this.initClass(SceneLayout, "treetestlayout")
        }()
    }
)),
Class((function WaterLevel() {
        Inherit(this, AbstractLevel, "water", "water");
        const _this = this;
        var _fluidScene, _mirror, _fireworks, _fireworksMesh, _horizonClone, _fluidColor = new Color("#777777"), _reflectionCamera = World.CAMERA.clone();
        function beforeMirrorRender() {
            let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController
                , mScene = _mirror.scene;
            mainPlayer && mainPlayer.currentScene && "water" === mainPlayer.currentScene.name && (mScene.add(mainPlayer.group),
                mScene.add(mainPlayer.orb.group),
                mainPlayer.mirrorRenderSwap = !0),
            remotePlayer && remotePlayer.currentScene && "water" === remotePlayer.currentScene.name && (mScene.add(remotePlayer.group),
                mScene.add(remotePlayer.orb.group),
                remotePlayer.mirrorRenderSwap = !0)
        }
        function afterMirrorRender() {
            let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
            if (mainPlayer && mainPlayer.mirrorRenderSwap && (mainPlayer.mirrorRenderSwap = !1,
                mainPlayer.currentScene)) {
                let group = mainPlayer.currentScene.layout.group;
                group.add(mainPlayer.group),
                    group.add(mainPlayer.orb.group)
            }
            if (remotePlayer && remotePlayer.mirrorRenderSwap && (mainPlayer.mirrorRenderSwap = !1,
                remotePlayer.currentScene)) {
                let group = remotePlayer.currentScene.layout.group;
                group.add(remotePlayer.group),
                    group.add(remotePlayer.orb.group)
            }
        }
        function resize() {
            _reflectionCamera.aspect = Stage.width / Stage.height,
                _reflectionCamera.updateProjectionMatrix()
        }
        !async function() {
            await function initScenes() {
                Lighting.createScene("water", _this.scene),
                    Lighting.useScene("water"),
                    _this.unwaterParticles = _this.initClass(WaterUnder),
                    _this.refractionRT = Utils3D.createRT(Stage.width, Stage.height),
                    _this.refractionRT.createDepthTexture(),
                Tests.useFireworks() && (_fireworks = _this.initClass(Fireworks),
                    (_fireworksMesh = new Mesh(World.SPHERE,new Shader("FireworksMaterial",{
                        tMap: {
                            value: _fireworks
                        },
                        transparent: !0,
                        side: Shader.BACK_SIDE,
                        blending: Shader.ADDITIVE_BLENDING
                    }))).scale.setScalar(74),
                    _this.layout.group.add(_fireworksMesh))
            }(),
                await async function initLevel() {
                    _this.checkDebug(),
                        _this.layers = await _this.layout.getAllLayers();
                    let floor = _this.layers.floor;
                    floor.shader.set("tParticles", _this.unwaterParticles),
                        floor.shader.set("tDepth", _this.refractionRT.depth);
                    let shader = _this.layers.horizon.shader;
                    floor.shader.addUniforms({
                        uHorizonColor: shader.uniforms.uColor,
                        uHorizonColor2: shader.uniforms.uColor2,
                        uHorizonColorEnabled: shader.uniforms.uColorEnabled,
                        uHorizonColor2Enabled: shader.uniforms.uColor2Enabled,
                        uEnabled: shader.uniforms.uEnabled
                    }),
                    _fireworksMesh && _fireworksMesh.scale.setScalar(_this.layers.horizon.scale.x - 1);
                    Tests.useWaterFluid() && (_fluidScene = new WaterFluidScene,
                        await _this.wait(_fluidScene, "fluid"),
                        floor.shader.set("tFluid", _fluidScene));
                    _this.layers.horizon.frustumCulled = !1,
                        _this.radiusBounds = 60,
                        _this.floor = floor,
                        _this.arks = await _this.layers.arks.layout.getAllLayers(),
                        _this.collisionMeshes = [_this.arks["ark-1"], _this.arks["ark-2"], _this.arks["ark-3"]],
                        _horizonClone = new Mesh(_this.layers.horizon.geometry,_this.layers.horizon.shader),
                        (_mirror = new FX.Mirror(_this.layers.floor,{
                            enabled: !0,
                            width: Tests.waterMirrorSize(),
                            height: Tests.waterMirrorSize(),
                            format: Texture.RGBFormat
                        })).useCamera(World.CAMERA),
                        _mirror.scene.add(_horizonClone),
                        _mirror.add(_this.arks["ark-1"]),
                        _mirror.add(_this.arks["ark-2"]),
                        _mirror.add(_this.arks["ark-3"]),
                        _mirror.add(_this.layers.portal),
                    _this.isPlayground() && _mirror.start();
                    _mirror.onBeforeRender = beforeMirrorRender,
                        _mirror.onAfterRender = afterMirrorRender
                }(),
                function initPlayer() {
                    _this.playerConfig = {
                        speed: 1,
                        spawn: new Vector3(0,10,0),
                        angleX: Math.PI / 2 * 3
                    }
                }(),
                function addListeners() {
                    _this.onResize(resize)
                }(),
                _this.isReady = !0
        }(),
            _this.onPlayersEnabled = function() {
                _this.playerActivated = !0,
                    0,
                    _this.layers.horizon.shader.tween("uEnabled", 1, 3e3, "easeInOutSine"),
                    _this.layers.floor.shader.tween("uEnabled", 1, 3e3, "easeInOutSine"),
                _this.arks && _this.arks["ark-1"] && (_this.state.arks[0] = _this.arks["ark-1"].activated,
                    _this.state.arks[1] = _this.arks["ark-2"].activated,
                    _this.state.arks[2] = _this.arks["ark-3"].activated),
                    _this.getLevelState()
            }
            ,
            _this.onArkEnabled = function() {
                _this.isReset = !1;
                let validated = !0;
                0,
                    _this.delayedCall((()=>{
                            _this.getLevelState(),
                                (_this.state.arks || []).forEach((s=>{
                                        s || (validated = !1)
                                    }
                                )),
                            validated && _this.onPlayersEnabled()
                        }
                    ), 500)
            }
            ,
            _this.onArkDisabled = function() {}
            ,
            _this.getLevelState = ()=>(_this.arks && _this.arks["ark-1"] && (_this.state.arks || (_this.state.arks = [!1, !1, !1]),
                _this.state.arks[0] = _this.arks["ark-1"].activated,
                _this.state.arks[1] = _this.arks["ark-2"].activated,
                _this.state.arks[2] = _this.arks["ark-3"].activated),
                _this.state),
            _this.syncRemoteState = state=>{
                if (_this.getLevelState(),
                state.arks && _this.state.arks) {
                    for (let i = 0, l = _this.state.arks.length; i < l; i++)
                        state.arks[i] && (_this.state.arks[i] = state.arks[i]);
                    return _this.state.arks.forEach(((value,i)=>{
                            let mesh = _this.arks[`ark-${i + 1}`];
                            value && !mesh.activated && mesh.activate()
                        }
                    )),
                        _this.state
                }
            }
            ,
            _this.resetState = function() {
                _this.isReset || (_this.playerActivated = !1,
                    _this.isReset = !0,
                _this.layers && (_this.layers.horizon && _this.layers.horizon.shader.tween("uEnabled", 0, 3e3, "easeInOutSine"),
                _this.layers.floor && _this.layers.floor.shader.tween("uEnabled", 0, 3e3, "easeInOutSine")),
                _this.arks && _this.arks["ark-1"] && (_this.arks["ark-1"].desactivate(),
                    _this.arks["ark-2"].desactivate(),
                    _this.arks["ark-3"].desactivate()),
                    _this.state.arks = [!1, !1, !1])
            }
            ,
            this.onStart = function() {
                _this.isRunning || _mirror && _mirror.start()
            }
            ,
            this.onPause = function() {
                _this.isRunning && _mirror && _mirror.stop()
            }
            ,
            _this.update = (time,delta)=>{
                if (!_this.layers || !_this.layers.floor)
                    return;
                if (_horizonClone && _horizonClone.scale.copy(_this.layers.horizon.scale).multiplyScalar(2.5),
                    Lighting.useScene("water"),
                    World.CAMERA.far = 700,
                    _this.updateCamera(),
                _mirror && _mirror.useCamera(_this.nuke.camera),
                _this.unwaterParticles && _this.unwaterParticles.update(),
                _fluidScene && _fluidScene.update(),
                !_fluidScene || !_fluidScene.fluid)
                    return;
                let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                [mainPlayer, remotePlayer].forEach((player=>{
                        if (!player)
                            return;
                        if (player == remotePlayer)
                            return;
                        let velocity = player.velocity3
                            , length = velocity.length()
                            , x = Math.range(player.group.position.x, -75, 75, 0, Stage.width)
                            , y = Math.range(player.group.position.z, -75, 75, 0, Stage.height);
                        player && player.currentScene && "water" === player.currentScene.name && _fluidScene.fluid.drawInput(x, y, 10 * velocity.x, 10 * velocity.z, _fluidColor, Math.range(length, 0, .25, 1, 3) + .1 * Math.sin(Render.TIME))
                    }
                ));
                let mainPlayerInScene = !1;
                if (mainPlayer.currentScene && mainPlayer.currentScene.name == _this.name && (_this.removeMainPlayer(),
                    mainPlayerInScene = !0),
                    _this.layout.group.remove(_this.layers.floor),
                    World.RENDERER.render(_this.scene, _this.nuke.camera, _this.refractionRT),
                    _this.layout.group.add(_this.layers.floor),
                mainPlayerInScene && _this.addMainPlayer(),
                mainPlayerInScene && _fireworks) {
                    _fireworks.update();
                    let time = AudioPlayer.time;
                    time && (time > 92 && time < 120 || time > 164 && time < 205 ? _this.events.fire(Fireworks.EMIT) : _this.events.fire(Fireworks.STOP_EMIT))
                }
                _this.render()
            }
            ,
            _this.ready = function() {
                return _this.wait("isReady")
            }
            ,
            this.uploadAll = async function() {
                await _this.ready(),
                    await Initializer3D.uploadAll(_this.layout),
                    await Initializer3D.uploadAll(_this.unwaterParticles.layout),
                _fluidScene && await Initializer3D.uploadAll(_fluidScene.scene)
            }
            ,
            this.uploadAllAsync = async function() {
                await _this.ready(),
                    await Initializer3D.uploadAllAsync(_this.layout),
                    await Initializer3D.uploadAllAsync(_this.unwaterParticles.layout),
                _fluidScene && await Initializer3D.uploadAllAsync(_fluidScene.scene)
            }
    }
)),
Class((function ArkScript(_mesh) {
        Inherit(this, Object3D);
        const _this = this;
        var _sphere, _activated = !1;
        function loop() {
            let worldPos = _mesh.getWorldPosition();
            _sphere.center = worldPos;
            let mainPlayer = PlayerController.mainPlayer;
            if (mainPlayer) {
                _sphere.containsPoint(mainPlayer.group.position) && !_activated && activate()
            }
        }
        function activate() {
            _activated = !0,
                _this.findParent("WaterLevel").onArkEnabled(),
                _mesh.shader.tween("uProgress", 1, 2e3, "easeOutCubic"),
                _mesh.activated = _activated
        }
        function desactivate() {
            _activated = !1,
                _mesh.activated = _activated,
                _this.findParent("WaterLevel").onArkDisabled(),
                _mesh.shader.tween("uProgress", 0, 3e3, "easeInCubic")
        }
        _sphere = new Sphere(_mesh.position,3.5 * _mesh.scale.x),
            _mesh.activated = _activated,
            _mesh.activate = activate,
            _mesh.desactivate = desactivate,
            _this.startRender(loop)
    }
)),
Class((function ArkShader(_mesh, _shader, _input, _group) {
        Inherit(this, Component);
        !async function() {
            _shader.addUniforms({
                uTopColor: {
                    value: new Color("#0e4bb6")
                },
                uBottomColor: {
                    value: new Color("#072b88")
                },
                uProgress: {
                    value: 0
                }
            })
        }()
    }
)),
Class((function Arks() {
        Inherit(this, Object3D);
        const _this = this;
        _this.layout = _this.initClass(SceneLayout, "arks")
    }
)),
Class((function Fireworks() {
        Inherit(this, FXScene);
        const _this = this;
        var _layout;
        !async function() {
            _this.create(World.NUKE, null, {
                format: Texture.RGBAFormat
            }),
                await async function initLayout() {
                    _layout = _this.initClass(SceneLayout, "water_fireworks", {});
                    let layers = await _layout.getAllLayers();
                    for (var i in layers) {
                        layers[i].renderOrder = 99999
                    }
                    _this.scene.add(_layout.group)
                }()
        }(),
            _this.update = function(time, delta) {
                !function loop(time, delta) {
                    let alpha = World.RENDERER.getClearColor();
                    World.RENDERER.setClearAlpha(0),
                        _this.render(),
                        World.RENDERER.setClearAlpha(alpha)
                }()
            }
    }
), (_=>{
        Fireworks.EMIT = "fireworks_emit",
            Fireworks.STOP_EMIT = "fireworks_stop_emit"
    }
)),
Class((function FireworksEmitter(_proton) {
        Inherit(this, Component);
        const _this = this;
        var _origin = new Vector3;
        new Vector3;
        function randomSign() {
            return Math.random() < .5 ? -1 : 1
        }
        function startEmit() {
            if (_this.isEmitting && !_this.forceEmit)
                return;
            _this.isEmitting = !0;
            let emitTimout = _=>{
                    _this.isEmitting && (clearTimeout(_this.nextEmit),
                        _this.nextEmit = _this.delayedCall((()=>{
                                _this.isEmitting && (!function emit() {
                                    if (!_this.parent.parent)
                                        return;
                                    if (!_this.parent.parent.parent)
                                        return;
                                    _origin.set(Math.random(20, 200, 10) * randomSign(), Math.random(40, 60, 10), Math.random(20, 200, 10) * randomSign()),
                                        _proton.spawn.release(_origin, 300, .03)
                                }(),
                                    emitTimout())
                            }
                        ), Math.random(200, 500)))
                }
            ;
            emitTimout()
        }
        function stopEmit() {
            _this.isEmitting && !_this.forceEmit && (_this.isEmitting = !1,
                clearTimeout(_this.nextEmit))
        }
        _proton.shader.uniforms.uDPR.value = Math.max(1, Tests.getDPR()),
        Utils.query("emit") && (_this.forceEmit = !0,
            startEmit()),
            _this.events.sub(Fireworks.EMIT, startEmit),
            _this.events.sub(Fireworks.STOP_EMIT, stopEmit)
    }
)),
Class((function WaterFloor(_mesh, _shader) {
        Inherit(this, Component);
        const _this = this;
        var _player1Pos = new Vector3
            , _player2Pos = new Vector3
            , _player1Pos2 = new Vector3
            , _player2Pos2 = new Vector3;
        function onPlayerConnect() {
            _shader.uniforms.uPlayer2Pos.value = PlayerController.remotePlayer.group.position
        }
        function onPlayerLeave() {}
        function loop(time, delta) {
            let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
            if ("water" === mainPlayer.currentScene.name ? _shader.set("uPlayer1InScene", 1) : _shader.set("uPlayer1InScene", 0),
                remotePlayer && remotePlayer.currentScene && "water" === remotePlayer.currentScene.name ? _shader.set("uPlayer2InScene", 1) : _shader.set("uPlayer2InScene", 0),
            mainPlayer && mainPlayer.group && mainPlayer.group.position) {
                let delta = Math.abs(_player1Pos2.length() - mainPlayer.group.position.length());
                delta = Math.range(delta, 0, .1, 0, 1, !0),
                    _shader.uniforms.uPlayer1Movement.value = Math.lerp(delta, _shader.uniforms.uPlayer1Movement.value, .07),
                    _player1Pos.lerp(mainPlayer.group.position, .15),
                    _player1Pos2.lerp(_player1Pos, .03),
                    _shader.set("uPlayer1Pos", _player1Pos)
            } else
                _shader.set("uPlayer1Movement", 0);
            if (remotePlayer && remotePlayer.group && remotePlayer.group.position) {
                let delta = Math.abs(_player2Pos2.length() - remotePlayer.group.position.length());
                delta = Math.range(delta, 0, .1, 0, 1, !0),
                    _shader.uniforms.uPlayer2Movement.value = Math.lerp(delta, _shader.uniforms.uPlayer2Movement.value, .07),
                    _player2Pos.lerp(remotePlayer.group.position, .15),
                    _player2Pos2.lerp(_player2Pos, .03),
                    _shader.set("uPlayer2Pos", _player2Pos)
            } else
                _shader.set("uPlayer2Movement", 0)
        }
        !function() {
            let geom = World.PLANE_HIGH;
            _mesh.geometry = geom,
                _shader.addUniforms({
                    uTopColor: {
                        value: new Color
                    },
                    uBottomColor: {
                        value: new Color
                    },
                    uFogColor1: {
                        value: new Color
                    },
                    uFogColor2: {
                        value: new Color
                    },
                    uAlpha: {
                        value: 1
                    },
                    uPlayer1Pos: {
                        value: PlayerController.mainPlayer.group.position,
                        ignoreUIL: !0
                    },
                    uPlayer2Pos: {
                        value: new Vector3,
                        ignoreUIL: !0
                    },
                    uPlayer1InScene: {
                        value: 0,
                        ignoreUIL: !0
                    },
                    uPlayer2InScene: {
                        value: 0,
                        ignoreUIL: !0
                    },
                    uPlayer1Movement: {
                        value: 1,
                        ignoreUIL: !0
                    },
                    uPlayer2Movement: {
                        value: 1,
                        ignoreUIL: !0
                    },
                    uNormalScale: {
                        value: 1
                    },
                    uCurrentSpeed: {
                        value: .1
                    },
                    uEnabled: {
                        value: 0
                    },
                    tNormal: {
                        value: null,
                        getTexture: Utils3D.getRepeatTexture
                    },
                    tParticles: {
                        value: null,
                        ignoreUIL: !0
                    },
                    tDepth: {
                        value: null,
                        ignoreUIL: !0
                    },
                    tFluid: {
                        value: null,
                        ignoreUIL: !0
                    },
                    uNearFar: {
                        value: new Vector2(World.CAMERA.near,World.CAMERA.far),
                        ignoreUIL: !0
                    },
                    uFogStrength: {
                        value: .5
                    },
                    uRefractionStrength: {
                        value: .06
                    }
                }),
                function addListeners() {
                    _this.events.sub(Multiplayer.PLAYER_JOINED, onPlayerConnect),
                        _this.events.sub(Multiplayer.CONNECTION_LOST, onPlayerLeave),
                        _this.startRender(loop)
                }()
        }(),
            _this.update = function(time, delta) {}
    }
)),
Class((function WaterFluidScene(_fluid) {
        Inherit(this, FXScene);
        const _this = this;
        function resize() {
            let scale = Tests.getFluidScenesResolution();
            _this.setSize(Stage.width * scale, Stage.height * scale)
        }
        function loop() {
            let clearAlpha = World.RENDERER.getClearAlpha();
            World.RENDERER.setClearAlpha(0),
                _this.render(),
                World.RENDERER.setClearAlpha(clearAlpha)
        }
        !async function() {
            _this.create(World.NUKE, null, {
                format: Texture.RGBAFormat
            });
            let layout = _this.initClass(SceneLayout, "waterfluid")
                , fluid = await layout.getLayer("fluid");
            fluid.additiveBlending = !1,
                _this.fluid = fluid;
            let plane = new Mesh(World.PLANE,new Shader("DepthFluid",{
                tMap: {
                    value: fluid
                },
                transparent: !0
            }));
            plane.rotation.x = .5 * -Math.PI,
                plane.scale.x = plane.scale.y = 150,
                plane.position.y = -.25,
                _this.scene.add(plane),
                _this.isPlayground() ? (fluid.debugMouse = !0,
                    _this.startRender(loop)) : fluid.remove(fluid.mesh),
                _this.onResize(resize)
        }(),
            this.update = function() {
                loop()
            }
    }
)),
Class((function WaterUnder() {
        Inherit(this, FXScene);
        const _this = this;
        !async function() {
            _this.create(),
                _this.layout = _this.initClass(SceneLayout, "waterunder", {}),
                _this.scene.add(_this.layout.group)
        }(),
            _this.update = (time,delta)=>{
                _this.render()
            }
    }
)),
Class((function MainRoom() {
        Inherit(this, AbstractLevel, "main_room");
        const _this = this;
        var _all = ["water", "env3", "env4", "grass", "env5"]
            , _seed = ["water", "grass", "env4", "env3"]
            , _noUnfold = window.location.href.includes("nofold") || Utils.query("nofold");
        _noUnfold && (_all = _seed = ["water", "grass", "env5", "env4"]);
        const V3 = new Vector3
            , V3_2 = new Vector3
            , V3_3 = new Vector3;
        var _mirror, _previews;
        function updatePreviews() {
            let ids = _all = _all.shuffle();
            if (_seed && (ids = _seed),
                !_noUnfold) {
                let existing = PlayerController?.remotePlayer?.currentScene?.name;
                if (existing) {
                    let index = ids.findIndex((id=>id == existing));
                    ids.splice(3, 0, ids.splice(index, 1)[0])
                }
            }
            _previews.forEach(((preview,i)=>{
                    setPreview(preview, ids[i])
                }
            )),
            _noUnfold || (_seed = null)
        }
        function setPreview(preview, id) {
            _noUnfold && "env3" == id || "main_room" != id && (preview.init(id),
                preview.id = id,
                preview.text.setData(id),
                preview.scene_id = id,
                preview.zone.init(id),
                preview.zone.id = id,
            Config.TRACKS[id] && !Config.TRACKS[id].locked || preview.toggleLock(),
                _this.previewsMap[id] = preview)
        }
        function updateSinglePreview(preview) {
            if (preview.changed || _noUnfold)
                return;
            if (preview.changed = !0,
            PlayerController.remotePlayer && PlayerController.remotePlayer.currentScene && preview.id == PlayerController.remotePlayer.currentScene.name)
                return;
            let ids = [];
            _previews.forEach((preview=>{
                    ids.push(preview.id)
                }
            ));
            let leftout = "";
            for (var i = 0; i < _all.length; i++)
                -1 == ids.indexOf(_all[i]) && (leftout = _all[i]);
            setPreview(preview, leftout)
        }
        function remoteChange(e) {
            if (("main_room" != e.id || _noUnfold) && _this.isRunning && _this.closestRemote && e.id !== _this.closestRemote.id) {
                let fromID = _this.closestRemote.id;
                _this.previewsMap[e.id] && setPreview(_this.previewsMap[e.id], fromID),
                    setPreview(_this.closestRemote, e.id)
            }
        }
        _this.isVisible = !1,
            _this.previewsMap = {},
            _this.closest = null,
            _this.closestRemote = null,
            async function() {
                _this.name = "main_room",
                    _this.playerConfig = {
                        speed: .6,
                        spawn: new Vector3(0,0,0)
                    },
                    _this.checkDebug(),
                    Global.MAIN_ROOM_CAM_GROUP = new Group,
                    Global.MAIN_ROOM_CAMERA = World.CAMERA.clone(),
                    Global.MAIN_ROOM_CAM_GROUP.add(Global.MAIN_ROOM_CAMERA),
                    _this.scene.add(Global.MAIN_ROOM_CAM_GROUP),
                    _this.layers = await _this.layout.getAllLayers(),
                    _this.floor = _this.layers.floor,
                    _this.base = _this.layers.base,
                    _this.layers.base.shader.uniforms.tMap.value.anisotropy = World.RENDERER.getMaxAnisotropy(),
                    function initPreviews() {
                        _previews = [];
                        for (var i = 0; i < 4; i++) {
                            let preview = _this.layers["preview_" + (i + 1)];
                            preview.zone = _this.layers["zone_" + (i + 1)],
                                preview.index = i,
                                preview.text = _this.initClass(LevelPreviewText),
                                _this.layout.group.add(preview.text.group),
                                _previews.push(preview)
                        }
                    }(),
                    updatePreviews(),
                    _this.bounds = {
                        x: {
                            min: -_this.floor.scale.x / 2,
                            max: _this.floor.scale.x / 2
                        },
                        z: {
                            min: -_this.floor.scale.y / 2,
                            max: _this.floor.scale.y / 2
                        }
                    },
                    _this.isReady = !0,
                    function initMirror() {
                        _mirror = new FX.Mirror(_this.layers.mirror,{
                            enabled: !0,
                            width: Tests.waterMirrorSize(),
                            height: Tests.waterMirrorSize(),
                            format: Texture.RGBFormat
                        }),
                            _previews.forEach((preview=>{
                                    _mirror.add(preview)
                                }
                            )),
                        (_this.isPlayground() || _this.isRunning) && _mirror.start()
                    }(),
                    function addHandlers() {
                        _this.events.sub(MainRoom.REMOTE_CHANGE, remoteChange)
                    }()
            }(),
            _this.onStart = async()=>{
                if (await _this.wait("isReady"),
                _mirror && _mirror.start(),
                    _this.layers.mirror.visible = !0,
                _this.base && _this.base.clear && _this.base.clear(),
                    _this.isRunning)
                    return;
                _this.animating || updatePreviews();
                let {mainPlayer: mainPlayer} = PlayerController;
                if (mainPlayer.previousScene) {
                    let angleX = mainPlayer.previousScene.playerConfig.angleX
                        , damping = mainPlayer.rotationDamping;
                    mainPlayer.wrotationDamping = 1,
                        GameControls.instance().controls.forceAngleX(angleX),
                        _this.delayedCall((()=>{
                                mainPlayer.rotationDamping = damping
                            }
                        ), 100)
                }
            }
            ,
            _this.onPause = async()=>{
                await _this.wait("isReady"),
                    clearTimeout(_this.previewTimeout),
                _mirror && _mirror.stop(),
                _this.base && _this.base.stop && _this.base.stop(),
                    _this.layers.mirror.visible = !1
            }
            ,
            _this.update = async(time,delta)=>{
                if (await _this.wait("isReady"),
                    !_this.isReady)
                    return;
                _this.layers.mirror.visible = !0;
                !function updatePreviewSize() {
                    _previews.forEach(((preview,i)=>{
                            if (preview.direction) {
                                if (preview.direction.set(0, 0, -1),
                                    preview.direction.applyQuaternion(preview.quaternion),
                                    preview.text.group.position.copy(preview.position),
                                    preview.text.group.rotation.copy(preview.rotation),
                                    preview.text.layers) {
                                    let title = preview.text.layers.title;
                                    title.group.position.y = .65 * -preview.scale.y,
                                        title.group.position.z = .5,
                                        title.group.scale.setScalar(3.5);
                                    let date = preview.text.layers.date;
                                    date.group.position.x = .53 * -preview.scale.x,
                                        date.group.position.y = .5 * -preview.scale.y,
                                        date.group.scale.setScalar(3);
                                    let time = preview.text.layers.time;
                                    time.group.position.x = .53 * preview.scale.x,
                                        time.group.position.y = .5 * preview.scale.y,
                                        time.group.scale.setScalar(4.5),
                                        preview.text.layers.locked.group.scale.setScalar(2.5)
                                }
                                preview.zone.scale.x = preview.scale.x,
                                    preview.zone.scale.y = 2,
                                preview.zone.prevScale !== preview.zone.scale.x && (preview.zone.setBbox(),
                                    preview.zone.prevScale = preview.zone.scale.x)
                            }
                        }
                    ))
                }();
                let closestDot = -1
                    , closestPreview = null
                    , furthestDot = 1
                    , furthestPreview = null
                    , closestRemote = null
                    , closestRemoteDistance = 100
                    , remoteDistanceV = new Vector3
                    , remoteDistance = null;
                V3.set(0, 0, -1),
                    V3.applyQuaternion(World.CAMERA.quaternion),
                    _previews.forEach(((preview,i)=>{
                            if (preview.scene) {
                                preview.scene.nuke.camera = World.CAMERA,
                                    preview.firstRenderDone ? preview.stopPreview() : (preview.firstRenderDone = !0,
                                        preview.startPreview()),
                                _this.loadExtra || 1 != i || (_this.loadExtra = !0,
                                    updateSinglePreview(preview),
                                    preview.firstRenderDone = !1);
                                let dot = V3.dot(preview.direction);
                                dot > closestDot && (closestDot = dot,
                                    closestPreview = preview,
                                    _this.closest = closestPreview),
                                dot < furthestDot && (furthestDot = dot,
                                    furthestPreview = preview),
                                PlayerController.remotePlayer && PlayerController.remotePlayer.group.position && (remoteDistance = remoteDistanceV.subVectors(preview.getWorldPosition(), PlayerController.remotePlayer.group.position).length(),
                                remoteDistance < closestRemoteDistance && (closestRemoteDistance = remoteDistance,
                                    closestRemote = preview))
                            }
                        }
                    )),
                closestRemote && _this.isVisible && (_this.closestRemote = closestRemote),
                furthestPreview && _this.isVisible && !_noUnfold && updateSinglePreview(furthestPreview),
                closestPreview && _this.isVisible && (closestPreview.changed = !1,
                    closestPreview.startPreview()),
                    _this.updateCamera(),
                    _this.render(null, World.CAMERA)
            }
            ,
            _this.animateIn = function() {
                _this.animating = !0,
                    _previews.forEach((preview=>{
                            preview.animateIn(200),
                                preview.text.animateIn(4800)
                        }
                    )),
                    _this.delayedCall((_=>{
                            _this.layers.scribble.start(),
                                LevelController.gameStarted.resolve()
                        }
                    ), 7e3),
                    _this.delayedCall((_=>{
                            _this.isVisible = !0,
                                _this.animating = !1
                        }
                    ), 4e3),
                    _this.base.animateIn()
            }
            ,
            _this.renderPreview = function(portal, scene) {
                V3.set(portal.position.x, 0, portal.position.z).normalize(),
                    V3_2.set(World.CAMERA.position.x, 0, World.CAMERA.position.z).normalize();
                let dir = Math.sign(V3_3.crossVectors(V3, V3_2).y)
                    , angle = V3.angleTo(V3_2) * dir;
                angle = Math.clamp(Math.radians(-90), Math.radians(90), angle),
                    Global.MAIN_ROOM_CAMERA.lookAt(0, 0, 0);
                let multiply = "env5" == scene.id ? 1 : 3;
                Global.MAIN_ROOM_CAM_GROUP.rotation.y = -angle * multiply,
                    _this.layers.mirror.visible = !1,
                    _this.scene.visible = !0,
                    _this.render(null, Global.MAIN_ROOM_CAMERA)
            }
            ,
            this.ready = async function() {
                await _this.wait(_this, "isReady")
            }
            ,
            this.uploadAll = async function() {
                await _this.ready(),
                    await Initializer3D.uploadAll(_this.layout),
                    await Initializer3D.uploadAll(_this.layers.scribble.group);
                for (let i = 0; i < _previews.length; i++)
                    await Initializer3D.uploadAll(_previews[i].text.layout)
            }
            ,
            this.uploadAllAsync = async function() {
                await _this.ready(),
                    await Initializer3D.uploadAllAsync(_this.layout),
                    await Initializer3D.uploadAllAsync(_this.layers.scribble.group)
            }
    }
), (_=>{
        MainRoom.REMOTE_CHANGE = "main_remote_change"
    }
)),
Class((function CompassFloor() {
        Inherit(this, Object3D);
        const _this = this;
        var _canvas, _context, _line, _shader, _mainPlayer, _mainPos, _last = new Vector2(512,512), _move = new Vector2(512,512), _position = new Vector2(512,512), _playerPos = new Vector2, _playerPos2 = new Vector2, _movement = 0, _movement2 = 0;
        function changeScene(e) {
            _canvas && _canvas.clear()
        }
        function loop() {
            if (!PlayerController.mainPlayer)
                return;
            if (PlayerController.mainPlayer && PlayerController.mainPlayer.currentScene && "main_room" !== PlayerController.mainPlayer.currentScene.name)
                return;
            if (UIOverlay.instance().visible)
                return;
            _canvas && (_canvas.cleared = !1),
                _position.x = Math.range(_mainPos.x, -10, 10, 0, 1024),
                _position.y = Math.range(_mainPos.z, -10, 10, 0, 1024),
                _playerPos.x = Math.range(_mainPos.x, -10, 10, -.5, .5),
                _playerPos.y = Math.range(_mainPos.z, -10, 10, .5, -.5),
                _playerPos2.lerp(_playerPos, .15);
            let delta = Math.abs(_playerPos2.length() - _playerPos.length());
            delta = Math.range(delta, 0, .003, 0, 1, !0),
                _movement = Math.lerp(delta, _movement, .03),
                _movement2 = Math.lerp(_movement, _movement2, .03),
                _shader.set("uMovement", _movement2),
            (_move.subVectors(_last, _position).length() > 51.2 || Math.abs(_this.lastTime - Render.TIME) > 30) && (_this.lastTime = Render.TIME,
                _move.copy(_position),
                function drawLine() {
                    if (!_canvas)
                        return;
                    if (PlayerController.mainPlayer && PlayerController.mainPlayer.currentScene && "main_room" !== PlayerController.mainPlayer.currentScene.name)
                        return;
                    _context.strokeStyle = Multiplayer.PLAYER_COLOR && Multiplayer.PLAYER_COLOR.getHexString && Multiplayer.PLAYER_COLOR.getHexString() || "#ffffff",
                        _context.beginPath(),
                        _context.moveTo(_last.x, _last.y),
                        _context.lineTo(_move.x, _move.y),
                        _context.stroke(),
                        _line.needsUpdate = !0,
                        _last.copy(_move)
                }())
        }
        _this.lastTime = 0,
            async function() {
                !function initCanvas() {
                    Tests.lobbyCanvasEnabled() && (_canvas = _this.initClass(Canvas, 1024, 1024),
                        (_context = _canvas.context).strokeStyle = "#ffffff",
                        _context.lineWidth = 1.5,
                        _line = new Texture(_canvas.div))
                }(),
                    _mainPlayer = PlayerController.mainPlayer,
                    _mainPos = _mainPlayer && _mainPlayer.group && _mainPlayer.group.position || new Vector3;
                let batch = new MeshBatch;
                _this.add(batch.group),
                    _this.id = ID,
                    ID++;
                let geom = World.PLANE_COMPLEX;
                _shader = new Shader("CompassShader",{
                    tMap: {
                        value: Utils3D.getTexture("assets/images/main/compass.png")
                    },
                    uPlayerPos: {
                        value: _playerPos2
                    },
                    uMainRoom: {
                        value: 0
                    },
                    uMovement: {
                        value: _movement
                    },
                    tLine: {
                        value: _line || null
                    },
                    uAlpha: {
                        value: 1
                    },
                    uFade: {
                        value: 0
                    },
                    blending: Shader.ADDITIVE_BLENDING,
                    transparent: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    side: Shader.DOUBLE_SIDE
                }),
                    _this.shader = _shader;
                for (var i = 0; i < 5; i++) {
                    let mesh = new Mesh(geom,_shader);
                    mesh.scale.x = mesh.scale.y = 1.2,
                        mesh.position.z = -.03 - .03 * i,
                        mesh.attributes = {
                            alpha: 0 == i ? 1 : Math.range(i, 0, 4, .2, .02, !0),
                            index: i
                        },
                        mesh.frustumCulled = !1,
                        batch.add(mesh)
                }
                _this.batch = batch,
                    _this.startRender(loop),
                    function addHandlers() {
                        _this.events.sub(LevelController.CHANGE_SCENE, changeScene)
                    }()
            }(),
            _this.clear = function() {
                _canvas && _canvas.clear(),
                    _shader.set("uMainRoom", 1)
            }
            ,
            _this.animateIn = function() {
                _shader.set("uAlpha", 0),
                    _shader.tween("uAlpha", 1, 1e3, "easeInOutSine"),
                    _shader.set("uFade", 0),
                    _shader.tween("uFade", 1, 5e3, "easeInOutSine")
            }
            ,
            _this.stop = function() {
                _shader.set("uMainRoom", 0)
            }
    }
)),
Class((function MainRoomFloor(_mesh, _shader) {
        Inherit(this, Component);
        _shader.addUniforms({
            uColor: {
                value: new Color
            }
        }),
            this.update = function(time, delta) {}
    }
)),
Class((function MainMirrorFloor(_mesh, _shader) {
        Inherit(this, Component);
        new Vector2;
        this.lastTime = 0,
            _shader.addUniforms({
                uColor: {
                    value: new Color
                },
                tMap: {
                    value: Utils3D.getTexture("assets/images/main/compass.png")
                },
                uAlpha: {
                    value: 1
                },
                uFade: {
                    value: 0
                },
                tNormal: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                tRoughness: {
                    value: null,
                    getTexture: Utils3D.getRepeatTexture
                },
                uNormalRange: {
                    value: new Vector2
                },
                uRoughnessRange: {
                    value: new Vector2
                },
                uNormalIntensity: {
                    value: 1
                },
                uMirroBrightness: {
                    value: .2
                },
                uTile: {
                    value: 1
                },
                blending: Shader.ADDITIVE_BLENDING,
                transparent: !0,
                depthTest: !1,
                depthWrite: !1
            }),
            _mesh.animateIn = function() {
                _shader.set("uAlpha", 0),
                    _shader.tween("uAlpha", 1, 1e3, "easeInOutSine"),
                    _shader.tween("uFade", 1, 3e3, "easeInOutSine", 3e3)
            }
    }
)),
Class((function LevelPreview(_mesh, _shader, _a, _input) {
        Inherit(this, Component);
        const _this = this;
        var _mouse = new Vector2
            , _ratio = new Vector2
            , _border = new Vector2;
        new Vector2,
            new Vector2;
        var _direction = new Vector3;
        function startPreview(first) {
            _this.locked || !_this.scene.isReady || _this.resizing || Tests.lobbyPortalPreview() && (_this.toggleRt || (_this.toggleRt = !0,
                _shader.tween("uProgress", 1, 300, "easeOutCubic")),
                _this.scene.start(!0))
        }
        function stopPreview(quick) {
            Tests.lobbyPortalPreview() && (_this.toggleRt && (_this.toggleRt = !1,
                _shader.tween("uProgress", 0, 800, "easeOutCubic")),
                _this.scene.pause(!0))
        }
        function loop() {
            _mouse.lerp(Mouse.tilt, .07)
        }
        function onResize() {
            let ratio = Stage.width / Stage.height;
            _ratio.x = .6,
                _ratio.y = Stage.width / Stage.height * _ratio.x * .8,
                ratio = Math.clamp(ratio, 1.3, 2.8),
                LevelController.forceResolution(ratio),
                _mesh.scale.y = 4.5,
                _mesh.scale.x = ratio * _mesh.scale.y,
                _mesh.position.y = .5 * _mesh.scale.y - .6,
                _border.y = .01,
                _border.x = _border.y / ratio,
                Global.PREVIEW_ASPECT = _mesh.scale.x / _mesh.scale.y
        }
        !function initShader() {
            _shader.addUniforms({
                tMap: {
                    value: Utils3D.getTexture("assets/images/_scenelayout/uv.jpg"),
                    ignoreUIL: !0
                },
                tStatic: {
                    value: null,
                    ignoreUIL: !0
                },
                uLocked: {
                    value: 0
                },
                uProgress: {
                    value: 0
                },
                uRatio: {
                    value: _ratio
                },
                uBorder: {
                    value: _border
                },
                uAlpha: {
                    value: 1
                },
                uProgress: {
                    value: 0
                },
                uVisible: {
                    value: 1
                },
                uTransition: {
                    value: 0
                },
                uSeed: {
                    value: Math.random(0, 100, 3)
                }
            }),
                _shader.transparent = !0,
                _shader.depthTest = !1,
                _shader.blending = Shader.ADDITIVE_BLENDING
        }(),
            function addListeners() {
                _this.onResize(onResize),
                    _mesh.saveRotationX = _mesh.rotation.x,
                    _mesh.saveRotationY = _mesh.rotation.y,
                    _this.startRender(loop)
            }(),
            _mesh.init = async function(id) {
                id != _this.id && (_this.id = id || _input.get("wildcard"),
                _this.id && (_mesh.direction = _direction,
                    _mesh.sceneId = _this.id,
                    _mesh.startPreview = startPreview,
                    _mesh.stopPreview = stopPreview,
                    _mesh.setSize = onResize,
                    _this.scene = LevelController.getScene(_this.id),
                    _mesh.scene = _this.scene,
                    _shader.set("uTransition", 1),
                    await defer(),
                    _shader.set("tMap", _this.scene.rt.texture),
                    _shader.set("tStatic", Utils3D.getTexture(`assets/images/previews/${_this.id}.jpg`)),
                    _shader.tween("uTransition", 0, 1e3, "easeOutCubic")))
            }
            ,
            _mesh.animateIn = function(delay=500) {
                _shader.set("uVisible", 0),
                    _shader.tween("uVisible", 1, 5e3, "easeInCubic", delay)
            }
            ,
            _mesh.toggleLock = function(lock=1) {
                _shader.set("uLocked", lock),
                    _this.locked = !!lock
            }
    }
)),
Class((function PreviewZone(_mesh, _shader, _a, _input) {
        Inherit(this, Component);
        const _this = this;
        var _bbox;
        new Vector2,
            new Vector2;
        function loop() {
            if (!_this.canTransition || _this.isDisabled)
                return;
            let {mainPlayer: mainPlayer} = PlayerController
                , playerPos = mainPlayer.group.position;
            playerPos.x >= _bbox.min.x && playerPos.x <= _bbox.max.x && playerPos.z >= _bbox.min.z && playerPos.z <= _bbox.max.z && (LevelController.transitionTo(_this.id),
                _this.canTransition = !1,
                _this.delayedCall((()=>{
                        _this.canTransition = !0
                    }
                ), 100))
        }
        function setBbox() {
            _bbox || (_bbox = new Box3),
                _bbox.setFromObject(_mesh),
                _this.canTransition = !0
        }
        async function onResize() {
            await defer(),
                await defer(),
                await defer(),
                setBbox()
        }
        _mesh.init = function(id) {
            _this.id = id || _input.get("wildcard"),
                _this.isDisabled = !Config.TRACKS[_this.id] || Config.TRACKS[_this.id].locked,
            _this.id && (_shader.visible = Utils.query("previewZone") || !1,
                function addListeners() {
                    _this.onResize(onResize),
                        _this.startRender(loop)
                }(),
                _mesh.setBbox = setBbox)
        }
    }
)),
Class((function LevelPreviewText(_id) {
        Inherit(this, Object3D);
        var _title, _date, _time, _locked, _data, _this = this, _now = new Date;
        _now.getTime(),
            _now.getTimezoneOffset();
        function updateTime() {
            _this.locked || _data && _time.setText(_data.trackTimeText)
        }
        _this.time = 0,
            async function() {
                _this.layout = _this.initClass(SceneLayout, "level_preview_text");
                let layers = await _this.layout.getAllLayers();
                _this.layers = layers,
                    _title = _this.layers.title,
                    _date = _this.layers.date,
                    _time = _this.layers.time,
                    _locked = _this.layers.locked,
                    await _title.ready(),
                    await _date.ready(),
                    await _time.ready(),
                    _this.ready = !0
            }(),
            this.setData = async function(id) {
                await _this.wait("ready");
                let data = Config.TRACKS[id];
                if (data == _data)
                    return;
                _data = data,
                    _this.locked = !_data || _data.locked;
                let setTitle = "";
                if (_data) {
                    let title = _data.optionalTitle || _data.title;
                    title && !_this.locked || (title = " "),
                        _this.locked && _data.lockedTitle ? _locked.setText(_data.lockedTitle) : _locked.visible = !1,
                        setTitle = title.toLowerCase(),
                    _this.locked || _date.setText(_data.date),
                    _data.trackLength || 300,
                        function addHandlers() {
                            _this.events.sub(TrackTimeUtil.UPDATE, updateTime)
                        }()
                }
                _title.setText(setTitle),
                    _this.hasData = !0
            }
            ,
            this.animateIn = async function(delay=1500) {
                await _this.wait("ready"),
                    await _this.wait("hasData"),
                    _title.text.alpha = 0,
                    _title.text.y = .4,
                    _title.text.z = -.3,
                    _title.text.tween({
                        alpha: _this.locked ? .5 : 1,
                        y: 0,
                        z: 0
                    }, 2e3, "easeOutQuint", delay + 500),
                _locked && _locked.text && _locked.visible && (_locked.text.alpha = 0,
                    _locked.text.z = -.3,
                    _locked.text.tween({
                        alpha: 1,
                        z: 0
                    }, 2e3, "easeOutQuint", delay + 500)),
                    _date.text.alpha = 0,
                    _date.text.x = .15,
                    _date.text.tween({
                        alpha: _this.locked ? 0 : 1,
                        x: 0
                    }, 1500, "easeOutQuint", delay),
                    _time.text.alpha = 0,
                    _time.text.x = .15,
                    _time.text.tween({
                        alpha: _this.locked ? 0 : 1,
                        x: 0
                    }, 1500, "easeOutQuint", delay)
            }
    }
)),
Class((function AbstractPlayer() {
        Inherit(this, Object3D);
        const _this = this;
        var _orb, V3 = new Vector3;
        !function() {
            let name = "MainPlayer" == _this.constructor.name ? "main_player" : "remote_player";
            (_orb = new Scribble(name)).frustumCulled = !1,
                _this.mesh = _orb.stroke,
                _this.velocityTarget = 0,
                _this.velocity = 0,
                _this.velocity3 = new Vector3,
                _this.lastPos = _this.group.position.clone(),
                _this.lastPosLength = _this.group.position.length()
        }(),
            _this.updateVelocity = ()=>{
                _orb.name = _this.name;
                let posLength = _this.group.position.length();
                _this.velocityTarget = posLength - _this.lastPosLength,
                    _this.lastPosLength = posLength,
                    _this.velocity3.copy(_this.lastPos).sub(_this.group.position);
                let lerp = "remote_player" === _this.name ? .04 : .08;
                _this.velocity = Math.lerp(_this.velocityTarget, _this.velocity, lerp),
                _orb.shader && _orb.shader.set("uVelocity", _this.velocity3),
                    V3.copy(_this.velocity3),
                    V3.x = Math.min(5 * Math.abs(V3.x), .2),
                    V3.y = -Math.min(5 * Math.abs(V3.y), .2),
                    V3.z = Math.min(5 * Math.abs(V3.z), .2),
                    _this.lastPos.copy(_this.group.position)
            }
            ,
            _this.get("orb", (_=>_orb))
    }
)),
Class((function CrossLine() {
        Inherit(this, Object3D);
        const _this = this;
        !function() {
            let geom = new CylinderGeometry(.008,.008,1);
            _this.mesh = new Mesh(geom,new Shader("ColorMaterial")),
                _this.mesh.shader.addUniforms({
                    color: {
                        value: new Color("#ffffff")
                    }
                }),
                _this.add(_this.mesh),
                _this.mesh.position.y = -1.2
        }()
    }
)),
Class((function MainPlayer() {
        Inherit(this, AbstractPlayer);
        const _this = this;
        var _controls, _orb = _this.orb, _posAcceleration = (Date.now(),
            0), _rotAcceleration = 0, _posAccelerationTgt = 0, _rotAccelerationTgt = 0, _camDirection = new Vector3, _cameraAngle = 0, _canJump = !0, _isOutOfRange = !1, _jump = {
            value: 0
        }, _raycastPoint = new Vector3;
        const info = getLogger("MainPlayer", "#c9b6e4", !0);
        var _speed = .014
            , _speedCoef = 1
            , _speedMulti = 1
            , _baseSpeed = _speed
            , _rotationDamping = .08
            , _targetPosY = 0;
        const V2 = new Vector2
            , V3 = new Vector3
            , DIR_3 = new Vector3
            , DOWN_V3 = new Vector3(0,-1,0);
        function jump() {
            _canJump && (_canJump = !1,
                clearTimeout(_this.jumpTo),
                _this.jumpTo = _this.delayedCall((()=>{
                        _canJump = !0
                    }
                ), 800),
                tween(_jump, {
                    value: .2 * _speedCoef
                }, 300, "easeOutSine").onComplete((()=>{
                        tween(_jump, {
                            value: 0
                        }, 600, "easeInOutSine").onComplete((()=>{}
                        ))
                    }
                )))
        }
        _this.color = new Color(Config.AVATAR_COLORS.random(Config.AVATAR_COLORS.length - 1)),
            _this.name = "main_player",
            _controls = GameControls.instance(),
            _this.baseY = _this.group.position.y,
            _targetPosY = _this.group.position.y,
            _this.forceUpdate = !0,
            function addListeners() {
                _this.events.sub(GameControls.JUMP, jump)
            }(),
            _this.connectRoom = function(room) {
                Multiplayer.linkMainPlayer(_this),
                    info(`Linked to room #${room.id}`),
                    _this.forceUpdate = !0
            }
            ,
            _this.reset = (name,_config)=>{
                _speedCoef = _config.speed || 1,
                _config.spawn && _config.useSpawn && _this.group.position.copy(_config.spawn)
            }
            ,
            _this.update = function(time, delta) {
                _speedMulti = 1,
                    Global.SPEED_MULTI = _speedCoef,
                    function checkGrounded() {
                        !0
                    }(),
                    function processControls() {
                        let {up: up, down: down, right: right, left: left, run: run, noDirection: noDirection, direction: direction} = _controls;
                        _speed = _baseSpeed * _speedCoef * Render.HZ_MULTIPLIER * _speedMulti,
                            _this.needsUpdate = !noDirection || _this.forceUpdate,
                        run && (_speed *= 6);
                        const charPos = _this.group.position;
                        if (!noDirection) {
                            let maxSpeed = run ? .42 : .21;
                            maxSpeed *= _speedCoef * Render.HZ_MULTIPLIER * _speedMulti,
                                _posAccelerationTgt += -_speed,
                                _posAccelerationTgt = Math.clamp(_posAccelerationTgt, -maxSpeed, maxSpeed);
                            const rotation = -Math.atan2(direction.y, direction.x);
                            _rotAccelerationTgt = rotation - _cameraAngle
                        }
                        _camDirection.copy(charPos).sub(World.CAMERA.position),
                            _cameraAngle = V2.set(_camDirection.x, _camDirection.z).angle() - Math.PI
                    }(),
                    function rotate() {
                        _rotAcceleration = Math.lerpAngle(_rotAcceleration, _rotAccelerationTgt, _rotationDamping)
                    }(),
                    function accelerate() {
                        !_controls.noDirection && GameControls.instance().canControl || (_posAccelerationTgt = 0),
                            _controls.reset,
                            _posAcceleration = Math.lerp(_posAccelerationTgt, _posAcceleration, .08);
                        let coords = Math.polarToCartesian(_posAcceleration, _rotAcceleration)
                            , x = Math.abs(Number(_this.group.position.x)).toFixed(2);
                        x < 10 ? x = "00" + x : x < 100 && (x = "0" + x),
                            x = x > 0 ? "E " + x.replace(".", "°") + "'" : "W " + x.replace(".", "°") + "'";
                        let y = Math.abs(Number(_this.group.position.z)).toFixed(2);
                        y < 10 ? y = "00" + y : y < 100 && (y = "0" + y),
                            y = y > 0 ? "N " + y.replace(".", "°") + "'" : "S " + y.replace(".", "°") + "'",
                        Global.LOCATION_TEXT && Global.LOCATION_TEXT.text(y + " " + x);
                        let skipAccelerate = !1;
                        if (_this.currentScene && _this.currentScene.collisionMeshes && LevelController.raycaster && !_isOutOfRange && !_controls.noDirection) {
                            V3.copy(_this.group.position),
                                DIR_3.set(coords.y, 0, coords.x).normalize();
                            let intersect = LevelController.raycaster.checkFromValues(_this.currentScene.collisionMeshes, V3, DIR_3)[0];
                            intersect && intersect.distance < 1.1 ? (skipAccelerate = !0,
                                _posAcceleration = _posAccelerationTgt = .5 * _posAcceleration,
                            _this.currentScene.onCollision && _this.currentScene.onCollision(intersect)) : _this.currentScene.onNoCollision && _this.currentScene.onNoCollision()
                        }
                        _isOutOfRange || skipAccelerate || (_this.group.position.x += coords.y,
                            _this.group.position.z += coords.x)
                    }();
                let intersect = null;
                if (_this.currentScene && _this.currentScene.floor && _this.needsUpdate) {
                    V3.copy(_this.group.position),
                        V3.y += 2;
                    let hit = _this.currentScene.hitMeshes || [_this.currentScene.floor]
                        , intersects = LevelController.raycaster.checkFromValues(hit, V3, DOWN_V3);
                    if (intersects && intersects.length) {
                        intersect = intersects[0];
                        let point = intersect.point;
                        if (_raycastPoint.copy(point),
                            _targetPosY = point.y,
                        "grass" === _this.currentScene.name) {
                            let h = 1;
                            intersect.object.isRock && (h = .2),
                                _targetPosY += h
                        }
                    }
                }
                let lerp = .1;
                intersect && intersect.object.isRock && (lerp = .12),
                _targetPosY < _this.group.position.y && (lerp = .06),
                    _this.group.position.y = Math.lerp(_targetPosY, _this.group.position.y, lerp),
                    _this.group.position.y += _jump.value,
                _this.currentScene.noBounds || function checkBounds() {
                    if (_this.currentScene && _this.currentScene.bounds) {
                        let bounds = _this.currentScene.bounds;
                        _this.group.position.x = Math.clamp(_this.group.position.x, bounds.x.min, bounds.x.max),
                            _this.group.position.z = Math.clamp(_this.group.position.z, bounds.z.min, bounds.z.max)
                    } else if (_this.currentScene.customRadius) {
                        let isInRadius = _this.currentScene.customRadius(_this.group.position);
                        _isOutOfRange === isInRadius && (_isOutOfRange = !isInRadius) && _this.teleportToMainRoom()
                    } else if (_this.currentScene && _this.currentScene.radiusBounds) {
                        let radius = _this.currentScene.radiusBounds
                            , centerX = 0
                            , centerY = 0
                            , x = _this.group.position.x
                            , y = _this.group.position.z
                            , isInRadius = Math.sqrt((x - centerX) * (x - centerX) + (y - centerY) * (y - centerY)) < radius;
                        _isOutOfRange === isInRadius && (_isOutOfRange = !isInRadius) && _this.teleportToMainRoom()
                    }
                }(),
                    _this.updateVelocity(),
                    _orb.update(time, delta, _this.velocity3)
            }
            ,
            _this.teleportToMainRoom = ()=>{
                _this.currentScene && "main_room" !== _this.currentScene.name && !_this.lockSwitch && (_this.lockSwitch = !0,
                    _isOutOfRange = !0,
                    _this.delayedCall((()=>{
                            _this.lockSwitch = !1
                        }
                    ), 2e3),
                    tween(_this.group.scale, {
                        x: .1,
                        y: .1,
                        z: .1
                    }, 400, "easeOutSine", 500),
                    VFX.instance().toggleBlackOverlay(!0),
                    _this.delayedCall((()=>{
                            _this.group.scale.set(1, 1, 1),
                                VFX.instance().toggleBlackOverlay(!1),
                                _this.group.position.set(0, 0, 0),
                                _isOutOfRange = !1,
                                LevelController.transitionTo("main_room");
                            let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                            mainPlayer && mainPlayer.orb.reset()
                        }
                    ), 20))
            }
            ,
            _this.get("cameraAngle", (_=>_cameraAngle)),
            _this.get("raycastPoint", (_=>_raycastPoint)),
            this.set("rotationDamping", (val=>{
                    _rotationDamping = val
                }
            )),
            this.get("rotationDamping", (_=>_rotationDamping))
    }
), (()=>{
        MainPlayer.JUMP = "main_jump"
    }
)),
Class((function RemotePlayer() {
        Inherit(this, AbstractPlayer);
        const _this = this;
        var _orb = _this.orb
            , _positionTarget = new Vector3
            , _rotationTarget = new Quaternion;
        const info = getLogger("RemotePlayer", "#be9fe1", !0);
        _this.color = new Color(Config.AVATAR_COLORS.random(Config.AVATAR_COLORS.length - 1)),
            _this.name = "remote_player",
            _this.isConnected = !1,
            _this.currentSceneId = null,
            _this.group.position.y = 0,
            _this.notSet = !0,
            Dev.expose("remote", _this),
            _this.group.scale.setScalar(.01),
            _this.connect = function(e) {
                _this.currentSceneId = null,
                _this.isConnected || (info("Connected", e),
                    _this.visible = !0,
                    _this.notSet = !0,
                    _this.isConnected = !0,
                    _this.needReset = !0,
                    _orb.reset(),
                    tween(_this.group.scale, {
                        x: 1,
                        y: 1,
                        z: 1
                    }, 1e3, "easeOutEliastic"),
                    _orb.show(),
                    _this.events.fire(MultiplayerUI.CONNECTED))
            }
            ,
            _this.disconnect = function(e) {
                _this.isConnected && (info("Disconected", e),
                    _this.isConnected = !1,
                    _this.currentScene = null,
                    _orb.hide(),
                    tween(_this.group.scale, {
                        x: .01,
                        y: .01,
                        z: .01
                    }, 1e3, "easeOutExpo").onComplete((()=>{
                            _this.visible = !1,
                                _this.group.position.set(0, 0, 0),
                                _orb.reset()
                        }
                    )))
            }
            ,
            _this.onSceneChanged = function(scene) {
                _this.notSet = !0
            }
            ,
            _this.update = function(time, delta, data) {
                if (data) {
                    let id = data.currentSceneId;
                    ["water", "grass", "env3", "env4", "env5"].forEach((id=>{
                            let datum = data[`${id}State`];
                            datum && LevelController.syncLevelState(id, datum)
                        }
                    )),
                        _positionTarget.copy(data.position),
                        _rotationTarget.copy(data.quaternion),
                    _this.currentSceneId !== id && id && (LevelController.changeRemotePlayerScene(id),
                        _this.currentSceneId = id,
                    _this.notSet && (_this.notSet = !1,
                        _this.group.position.copy(_positionTarget),
                        _this.group.quaternion.copy(_rotationTarget))),
                    _this.needReset && (_this.needReset = !1,
                        _orb.reset(_this.group.position))
                }
                _this.notSet || (_this.group.position.lerp(_positionTarget, .1),
                    _this.group.quaternion.slerp(_rotationTarget, .1)),
                    _this.updateVelocity(),
                    _orb.update(time, delta, _this.velocity3)
            }
    }
)),
Class((function Compass() {
        Inherit(this, Object3D);
        const _this = this;
        var _layout, _layers, _mainPlayer, _remotePlayer, _mainPos, _raycastPoint, _angleTarget = 0, _angle = 0;
        const V2 = new Vector2
            , TGT1 = new Vector2
            , TGT2 = new Vector2;
        var _player1Pos = new Vector3
            , _delta = 0;
        function onPlayerJoin() {
            _this.isConnected = !0,
                !1,
            _this.isVisible && _layers.arrow.shader.tween("uAlpha", 1, 2e3, "easeInOutSine"),
                defer((()=>{
                        _remotePlayer = PlayerController.remotePlayer
                    }
                ))
        }
        function onConnectionLost() {
            _this.isConnected = !1,
                _layers.arrow.shader.tween("uAlpha", 0, 1e3, "easeOutSine").onComplete((()=>{}
                ))
        }
        function loop() {
            if (_this.group.position.x = _mainPos.x,
                _this.group.position.y = .5 * _raycastPoint.y,
                _this.group.position.z = _mainPos.z,
            !_remotePlayer || !_remotePlayer.isConnected || !_remotePlayer.currentScene)
                return;
            TGT1.set(_mainPlayer.group.position.x, _mainPlayer.group.position.z),
                _mainPlayer.currentScene.name === _remotePlayer.currentScene.name ? function pointingPlayer() {
                    TGT2.set(_remotePlayer.group.position.x, _remotePlayer.group.position.z),
                        _this.sameRoom = !0,
                        _angleTarget = -V2.angleTo(TGT1, TGT2) + Math.PI / 2
                }() : "main_room" === _mainPlayer.currentScene.name ? function pointingPreview() {
                    let id = _remotePlayer.currentScene.name
                        , preview = LevelController.getScene("main_room").previewsMap[id];
                    preview && (_this.sameRoom = !1,
                        TGT2.set(preview.position.x, preview.position.z),
                        _angleTarget = -V2.angleTo(TGT1, TGT2) + Math.PI / 2)
                }() : function pointingExit() {
                    let currentScene = _mainPlayer.currentScene;
                    currentScene.portal && (_this.sameRoom = !1,
                        TGT2.set(currentScene.portal.position.x, currentScene.portal.position.z),
                        _angleTarget = -V2.angleTo(TGT1, TGT2) + Math.PI / 2)
                }();
            let delta = Math.abs(_player1Pos.length() - _mainPlayer.group.position.length());
            if (delta = Math.range(delta, 0, .01, 1, 0, !0),
                _delta = Math.lerp(delta, _delta, .07),
                _layers.arrow.shader.set("uVisible", _delta),
                _player1Pos.lerp(_mainPlayer.group.position, .15),
                _angle = Math.lerpAngle(_angle, _angleTarget, .1),
                _this.group.rotation.y = _angleTarget,
                _this.isConnected) {
                TGT2.set(_remotePlayer.group.position.x, _remotePlayer.group.position.z);
                let distance = TGT2.distanceTo(TGT1);
                _layers.arrow.shader.set("uDistance", _this.sameRoom ? Math.range(distance, 8, 20, 0, 1, !0) : 1)
            }
        }
        !async function() {
            _layout = _this.initClass(SceneLayout, "compass", {}),
                _this.group.add(_layout.group),
                _layers = await _layout.getAllLayers(),
                _layout.group.scale.x = _layout.group.scale.y = 5,
            "Compass" !== Global.PLAYGROUND && (_layout.group.rotation.x = -Math.PI / 2,
                _layout.group.position.y = -.2,
                _layers.arrow.shader.set("uAlpha", 0),
                function addListeners() {
                    _this.events.sub(Multiplayer.PLAYER_JOINED, onPlayerJoin),
                        _this.events.sub(Multiplayer.CONNECTION_LOST, onConnectionLost),
                        _this.startRender(loop)
                }()),
                _mainPlayer = PlayerController.mainPlayer,
                _mainPos = _mainPlayer.group.position,
                _raycastPoint = _mainPlayer.raycastPoint
        }(),
            this.animateIn = function(delay=0) {
                _this.isVisible = !0,
                _this.isConnected && _layers.arrow.shader.tween("uAlpha", 1, 2e3, "easeInOutSine", delay)
            }
    }
)),
Class((function CompassArrow(_mesh, _shader, _group, _input) {
        Inherit(this, Component);
        _shader.addUniforms({
            tMap: {
                value: Utils3D.getTexture("assets/images/arrow.png")
            },
            uAlpha: {
                value: 0
            },
            uVisible: {
                value: 1
            },
            uDistance: {
                value: 0
            }
        }),
            _mesh.shader = _shader
    }
)),
Class((function Cross() {
        Inherit(this, Object3D);
        const _this = this
            , UP = new Vector3(0,1,0);
        var _direction = new Vector3
            , _velocity = new Vector3
            , _quat = new Quaternion
            , _matrixTilt = new Matrix4
            , _matrixDirection = new Matrix4
            , _euler = new Euler
            , _colors = ["#80ff8f", "#8098ff", "#80fff5", "#ffce80", "#80b6ff", "#ff8080"];
        function loop(t) {
            _this.layout.group.rotation.y = .08 * Math.sin(.0014 * t),
                _this.layout.group.rotation.z = .04 * Math.sin(.0012 * t),
                _this.layout.group.rotation.x = .03 * Math.sin(.0012 * t)
        }
        !async function() {
            _this.layout = _this.initClass(SceneLayout, "cross");
            let cross = await _this.layout.getLayer("cross")
                , colorHex = _colors.random();
            PlayerController.mainPlayer.color = colorHex;
            let color = new Color(colorHex);
            cross.shader.set("uColor", color),
                cross.shader.set("uGlowColor", color),
                _this.isReady = !0,
                _this.startRender(loop)
        }(),
            _this.ready = function() {
                return _this.wait("isReady")
            }
            ,
            this.update = function(time, delta, velocity) {
                _matrixTilt.identity(),
                    _matrixDirection.identity();
                let angle = Math.atan2(velocity.z, velocity.x);
                _euler.set(0, -angle, 0),
                    _matrixDirection.makeRotationFromEuler(_euler),
                    _velocity.lerp(velocity, .1),
                    _direction.copy(_velocity).cross(UP),
                    _quat.setFromAxisAngle(_direction, 5 * velocity.length()),
                    _matrixTilt.makeRotationFromQuaternion(_quat),
                    _this.group.rotation.setFromRotationMatrix(_matrixTilt.multiply(_matrixDirection))
            }
    }
)),
Class((function CrossShader(_mesh, _shader, _input, _group) {
        Inherit(this, Component),
            async function() {
                FX.BloomLayer.instance().add(_mesh),
                    _shader.addUniforms({
                        tEdges: {
                            value: Utils3D.getTexture("assets/images/cross-edges.png")
                        },
                        uColor: {
                            value: new Color("#ffff00")
                        },
                        uGlowColor: {
                            value: new Color("#ffff00")
                        },
                        uAlpha: {
                            value: 1
                        },
                        uVelocity: {
                            value: new Vector3
                        }
                    }),
                    _shader.transparent = !0
            }()
    }
)),
Class((function Orb(_color) {
        Inherit(this, Object3D);
        const _this = this;
        var _layout, _layers;
        !async function() {
            _layout = _this.initClass(SceneLayout, "orb", {}),
                _this.group.add(_layout.group),
                (_layers = await _layout.getAllLayers()).orb.setColor(_color),
                _layers.sphere.setColor(_color),
                _layers.main_group.basePos = _layers.main_group.position.clone(),
                _layers.main_group.baseScale = _layers.main_group.scale.clone(),
                _layers.main_group.position.y = _layers.sphere.scale.y,
                _this.distCoef = 0,
                _this.distCoefTarget = 0,
                _this.isReady = !0
        }(),
            _this.update = function(time, delta) {
                let {mainPlayer: mainPlayer, remotePlayer: remotePlayer} = PlayerController;
                if (mainPlayer && remotePlayer && remotePlayer.isConnected) {
                    let distance = mainPlayer.group.position.distanceTo(remotePlayer.group.position);
                    _this.distCoefTarget = Math.range(distance, .5, 5, 1, 0, !0)
                }
                if (_this.distCoef = Math.lerp(_this.distCoefTarget, _this.distCoef, .1),
                _layers && _layers.main_group) {
                    let {scale: scale, position: position, basePos: basePos, baseScale: baseScale} = _layers.main_group
                }
            }
            ,
            _this.ready = function() {
                return _this.wait("isReady")
            }
            ,
            _this.get("layout", (_=>_layout))
    }
));
let ID = 0;
Class((function OrbOutline() {
        Inherit(this, Object3D);
        var _shader, _this = this;
        function loop() {
            Utils3D.billboard(_this.batch.group),
            window.debug && console.log("ID", _this.id)
        }
        !function() {
            let batch = new MeshBatch;
            _this.add(batch.group),
                _this.id = ID,
                ID++;
            let geom = World.PLANE;
            _shader = new Shader("OrbOutline",{
                uDistCoef: {
                    value: 0
                },
                uColor: {
                    value: new Color
                },
                transparent: !0,
                blending: Shader.ADDITIVE_BLENDING,
                depthWrite: !1,
                depthTest: !1
            });
            for (var i = 0; i < 2; i++) {
                let mesh = new Mesh(geom,_shader);
                mesh.scale.x = mesh.scale.y = 1.2,
                    mesh.rotation.x = .1 * i,
                    mesh.position.z = Math.range(i, 0, 10, -.2, .2),
                    mesh.attributes = {
                        seed: .3 * i
                    },
                    batch.add(mesh)
            }
            batch.onMeshCreated = mesh=>{
                mesh.renderOrder = 100
            }
                ,
                _this.batch = batch,
                _this.startRender(loop)
        }(),
            this.setColor = function(color) {
                _shader.set("uColor", color)
            }
            ,
            this.animateIn = function() {}
    }
)),
    Class((function OrbShader(_mesh, _shader) {
            Inherit(this, Component);
            FX.BloomLayer.instance().add(_mesh),
                _shader.addUniforms({
                    uColor: {
                        value: new Color(16777215)
                    },
                    uSeed: {
                        value: new Vector3(Math.random(0, 1e3),Math.random(0, 1e3),Math.random(0, 1e3))
                    },
                    uNoiseAmp: {
                        value: .05
                    },
                    uNoiseSpeed: {
                        value: .8
                    },
                    uDistCoef: {
                        value: 0
                    },
                    uNoiseScale: {
                        value: .7
                    },
                    transparent: !0,
                    uVelocity: {
                        value: 0
                    }
                }),
                _mesh.setColor = function(color) {
                    _shader.set("uColor", color)
                }
        }
    ), (_=>{}
    )),
    Class((function CeilingScribble() {
            Inherit(this, Object3D);
            const _this = this;
            var _strokes = [];
            function loop() {}
            function randomLine() {
                _strokes.forEach((stroke=>{
                        stroke.pos.x = stroke.lastPos.x + Math.random(-1 * Math.range(stroke.lastPos.x, -1, 0, 0, .1, !0), 1 * Math.range(stroke.lastPos.x, 0, 1, .1, 0, !0), 4),
                            stroke.pos.y = stroke.lastPos.y + Math.random(-1 * Math.range(stroke.lastPos.y, -1, 0, 0, .1, !0), 1 * Math.range(stroke.lastPos.y, 0, 1, .1, 0, !0), 4),
                            stroke.pos.z = stroke.lastPos.z + Math.random(-1 * Math.range(stroke.lastPos.z, -1, 0, 0, .1, !0), 1 * Math.range(stroke.lastPos.z, 0, 1, .1, 0, !0), 4),
                            stroke.lastPos.copy(stroke.pos),
                            stroke.pos.multiplyScalar(22),
                            stroke.pos.y *= .12,
                            stroke.draw(stroke.pos)
                    }
                )),
                    clearTimeout(_this.autoDelay),
                    _this.autoDelay = _this.delayedCall(randomLine, Math.random(300, 1e3))
            }
            _this.velocity = 0,
            Tests.hasFloorScribble() && function initStroke() {
                let width = 1.7
                    , color = "#ffffff"
                    , length = 100
                    , count = 0;
                for (var i in Config.TRACKS)
                    Config.TRACKS[i].title && !Config.TRACKS[i].locked && count++;
                for (i = 0; i < count; i++) {
                    let stroke = new Line3D({
                        width: width,
                        color: color,
                        length: length,
                        opacity: .2
                    });
                    stroke.pos = new Vector3(.5 * Math.random(-1, 1, 3),-.2,.5 * Math.random(-1, 1, 3)),
                        stroke.lastPos = (new Vector3).copy(stroke.pos),
                        _this.add(stroke),
                        _strokes.push(stroke)
                }
            }(),
                this.start = function() {
                    Tests.hasFloorScribble() && (_this.startRender(loop),
                        randomLine())
                }
        }
    )),
    Class((function Scribble(_name) {
            Inherit(this, Object3D);
            const _this = this;
            var _stroke, _shader, _compass, _pos = new Vector3, _posTemp = new Vector3, _curlSeed = new Vector3, VEC_3 = new Vector3;
            function animateIn() {
                _shader.set("uOpacity", 0),
                    _this.delayedCall((_=>{
                            _this.animatedIn = !0,
                            _this.visible && (_compass && _compass.animateIn(4e3),
                                _shader.tween("uOpacity", 1, Utils.query("skip") ? 1 : 3e3, "easeInOutSine"))
                        }
                    ), Utils.query("skip") ? 1 : 5e3)
            }
            function transition(e) {
                _shader.set("uOpacity", 0),
                    _shader.tween("uOpacity", 1, e.time, "easeInOutSine")
            }
            _this.velocity = 0,
                _this.lastTime = 0,
                function initStrokes() {
                    _shader = _this.initClass(Shader, "ScribbleShader", {
                        transparent: !0,
                        blending: Shader.NORMAL_BLENDING,
                        side: Shader.DOUBLE_SIDE,
                        uAdmin: {
                            value: "main_player" == _name ? Multiplayer.PLAYER_ADMIN ? 1 : 0 : Multiplayer.REMOTE_ADMIN ? 1 : 0
                        }
                    }),
                        (_stroke = new Line3D({
                            width: Device.mobile.phone ? .4 : .6,
                            color: "main_player" == _name ? Multiplayer.PLAYER_COLOR : Multiplayer.REMOTE_COLOR,
                            length: 80
                        })).useShader(_shader),
                        _this.add(_stroke)
                }(),
            "main_player" == _name && function initCompass() {
                _compass = _this.initClass(Compass)
            }(),
                function addHandlers() {
                    _this.events.sub(GameControls.ANIMATE_IN, animateIn),
                        _this.events.sub(Scribble.ENTER_SCENE, transition)
                }(),
                this.show = function() {
                    _this.visible = !0,
                    _this.animatedIn && (_compass && _compass.animateIn(),
                        _shader.tween("uOpacity", 1, 2e3, "easeInOutSine"))
                }
                ,
                this.hide = function() {
                    _shader.tween("uOpacity", 0, 1e3, "easeOutSine").onComplete((()=>{
                            _this.visible = !1
                        }
                    ))
                }
                ,
                _this.reset = function(_pt) {
                    _pt ? VEC_3.copy(_pt) : VEC_3.set(0, 0, 0);
                    let seed = "main_player" == _this.name ? GameCenter.userData.arbitrary : 0;
                    for (let i = 0, l = 80; i < l; i++) {
                        let speed = 8e-4 * (Render.TIME + 16 * i) + seed + 100
                            , radius = .75 + .2 * Math.sin(3 * speed);
                        _posTemp.x = Math.sin(speed),
                            _posTemp.y = Math.cos(speed + .2),
                            _posTemp.z = Math.sin(.8 * speed - 1.2),
                            _posTemp.multiplyScalar(.4 * radius),
                            _pos.copy(VEC_3),
                            _pos.y += .5,
                            _pos.add(_posTemp),
                            _stroke.draw(_pos, 1, i < l - 1)
                    }
                }
                ,
                this.get("stroke", (_=>_stroke)),
                this.update = function(time, delta, velocity) {
                    if (!_this.name)
                        return;
                    let isMainPlayer = "main_player" == _this.name
                        , seed = isMainPlayer ? GameCenter.userData.arbitrary : 0
                        , vel = velocity.length();
                    vel > 10 && isMainPlayer && (_shader.set("uOpacity", 0),
                        _shader.tween("uOpacity", 1, 2e3, "easeInOutSine")),
                        _this.velocity = Math.lerp(vel, _this.velocity, .07);
                    let speed = 8e-4 * Render.TIME * Render.HZ_MULTIPLIER + seed;
                    Global.SPEED_MULTI && (speed *= Global.SPEED_MULTI);
                    let strength = Math.range(_this.velocity, 0, .15, 1, 0, !0)
                        , radius = .75 + .2 * Math.sin(3 * speed);
                    radius *= strength * _shader.uniforms.uOpacity.value,
                        _shader.set("uColor", "main_player" == _this.name ? Multiplayer.PLAYER_COLOR : Multiplayer.REMOTE_COLOR),
                        _shader.set("uAdmin", "main_player" == _this.name ? Multiplayer.PLAYER_ADMIN ? 1 : 0 : Multiplayer.REMOTE_ADMIN ? 1 : 0);
                    let player = "main_player" == _this.name ? PlayerController.mainPlayer : PlayerController.remotePlayer;
                    if (player && Math.abs(_this.lastTime - Render.TIME) > 10) {
                        _this.lastTime = Render.TIME,
                            _curlSeed.set(2 * speed + strength, 2 * speed + strength, speed + strength),
                            Curl.noise(_curlSeed, _posTemp),
                            _posTemp.multiplyScalar(.4 * radius),
                            _pos.copy(player.group.position);
                        let bounce = .06 * Math.sin(.011 * Render.TIME) + .1 * Math.sin(.006 * Render.TIME) + .1 * Math.sin(.004 * Render.TIME) + .1 * Math.sin(.0012 * Render.TIME);
                        _pos.y += .5 + bounce * (1 - strength) * .5,
                            _pos.add(_posTemp),
                            _stroke.draw(_pos)
                    }
                }
        }
    ), (_=>{
            Scribble.ENTER_SCENE = "enter_scene"
        }
    )),
    Class((function ScribbleGlow(_color) {
            Inherit(this, Object3D);
            const _this = this;
            _this.mesh = new Mesh(World.SPHERE,new Shader("ScribbleGlow",{
                uColor: {
                    value: new Color(_color)
                },
                blending: Shader.ADDITIVE_BLENDING,
                transparent: !0
            })),
                _this.mesh.scale.setScalar(.3)
        }
    )),
    Class((function SeatedView() {
            Inherit(this, Element);
            const $this = this.element;
            !function initHTML() {
                console.log("wut"),
                    $this.html('<div id=“seated-55fdf2c0” data-artist-id=“53564766-f2aa-4988-90cd-5e904fb44cb0" data-css-version=“2”></div><script src=“https://widget.seated.com/app.js”><\/script>')
            }()
        }
    )),
    Class((function Teaser() {
            Inherit(this, Element);
            let $this, $cover, $wrapper, $instruction, _video, _this = this;
            function playing() {
                _this.playing || (_this.playing = !0,
                    $wrapper.hit.hide(),
                    _this.events.unsub(Mouse.input, Interaction.CLICK, (_=>{
                            _video.div.play()
                        }
                    )),
                    $instruction.inner.tween({
                        opacity: 0
                    }, 400, "easeOutSine", (_=>{
                            $instruction.hide()
                        }
                    )),
                    $cover.tween({
                        opacity: 0
                    }, 500, "easeOutSine"),
                    _video.element.tween({
                        opacity: 1
                    }, 2e3, "easeInOutSine"))
            }
            function resizeHandlers() {
                clearTimeout(_this.timeout),
                    _this.timeout = _this.delayedCall(resize, 100)
            }
            function resize() {
                $instruction.css({
                    top: .85 * Stage.height
                });
                let width = Stage.width
                    , height = .5625 * width;
                height > Stage.height && (height = Stage.height,
                    width = height * (1280 / 720)),
                    $wrapper.size(width, height);
                let x = (Stage.width - width) / 2
                    , y = (Stage.height - height) / 2;
                $wrapper.transform({
                    x: x,
                    y: y
                })
            }
            !function initHTML() {
                $this = _this.element,
                    $this.size("100%").bg("#000"),
                    Stage.add($this),
                    $wrapper = $this.create(".wrapper"),
                    $wrapper.size("100%"),
                    $cover = $wrapper.create(".wrapper"),
                    $cover.size("100%").bg("assets/videos/teaser.jpg", "cover")
            }(),
                function initVideo() {
                    _video = _this.initClass(Video, {
                        src: Data.GLOBAL.placeholderVideo,
                        width: 1280,
                        height: 720,
                        loop: !0,
                        muted: !1,
                        events: ["playing", "progress"]
                    }),
                        _video.div.pause(),
                        $wrapper.add(_video.element),
                        _video.div.width = "100%",
                        _video.div.height = "100%",
                        _video.element.css({
                            opacity: 0,
                            width: "100%",
                            height: "100%"
                        }).mouseEnabled(!1)
                }(),
                function initInstruction() {
                    $instruction = $this.create(".bounce-fade"),
                        $instruction.size(200, 12).center(1, 0).css({
                            top: Stage.height - 100
                        }),
                        $instruction.inner = $instruction.create(".text"),
                        $instruction.inner.fontStyle(Config.FONTS.serif, 14, "#fff"),
                        $instruction.inner.css({
                            width: "100%",
                            letterSpacing: "0.3em",
                            textAlign: "center"
                        }),
                        $instruction.inner.text((Device.mobile ? "tap" : "click") + " to play")
                }(),
                function addHandlers() {
                    _this.events.sub(Events.RESIZE, resizeHandlers),
                        $wrapper.interact(null, (_=>{
                                _video.div.play()
                            }
                        )),
                        _this.events.sub(Mouse.input, Interaction.CLICK, (_=>{
                                _video.div.play()
                            }
                        )),
                        _this.events.sub(_video, Video.PLAYING, playing)
                }(),
                resize(),
                this.animateIn = function() {}
        }
    ), "singleton"),
    Class((function MobileControlsUI() {
            Inherit(this, Element);
            const _this = this
                , $this = this.element;
            var $joystickC, $joystickBorder, $joystickCursor, $jHitZone, $panZone, _isDown, _isPortrait, _size = new Vector2, _dir = new Vector2, _joystickCenter = new Vector2, _joystickCenterTarget = new Vector2, _joystickRestCenter = new Vector2, _borderScaleTarget = 1, _borderScale = 1, V2 = (Date.now(),
                new Vector2), _joystickZoneY = 0;
            function resize() {
                let isPortrait = Stage.width < Stage.height;
                Device.mobile && Device.mobile.phone;
                _size.set(isPortrait ? 80 : 100, isPortrait ? 80 : 100);
                let bottom = isPortrait ? 40 : 10
                    , top = Stage.height - bottom - _size.y;
                if ($joystickC.css({
                    position: "absolute",
                    width: _size.x,
                    height: _size.y,
                    marginTop: -_size.y / 2,
                    marginLeft: -_size.x / 2
                }),
                    _joystickRestCenter.set(80, top),
                    _joystickCenter.copy(_joystickRestCenter),
                    $joystickC.transform({
                        x: _joystickRestCenter.x,
                        y: _joystickRestCenter.y,
                        scale: .5
                    }),
                    $joystickC.css({
                        opacity: 1
                    }),
                    _this.forceTransform = !0,
                    isPortrait) {
                    let h = Device.mobile && Device.mobile.phone ? 300 : Stage.height / 2;
                    $jHitZone.css({
                        top: "",
                        bottom: 0,
                        left: 0,
                        width: "50%",
                        height: h
                    }),
                        _joystickZoneY = Stage.height - h,
                        $panZone.top.css({
                            width: "100%",
                            height: "100%",
                            left: "0%"
                        }),
                        $panZone.css({
                            width: "100%",
                            left: 0,
                            height: Device.mobile && Device.mobile.phone ? Stage.height : Stage.height / 2
                        })
                } else
                    _joystickZoneY = 0,
                        $jHitZone.css({
                            top: 0,
                            left: 0,
                            bottom: "",
                            width: "50%",
                            height: "100%"
                        }),
                        $panZone.css({
                            height: "100%",
                            left: "50%"
                        }),
                        $panZone.top.css({
                            width: "200%",
                            left: "-100%",
                            height: Device.mobile && Device.mobile.phone ? Stage.height - 280 : .5 * Stage.height
                        })
            }
            function loop() {
                _this.forceTransform = !1,
                    _borderScale += .08 * (_borderScaleTarget - _borderScale),
                Math.abs(_borderScale - _borderScaleTarget) > .01 && $joystickBorder.transform({
                    scale: _borderScale,
                    x: "-50%",
                    y: "-50%"
                })
            }
            function onTouchStart(ev) {
                if (AudioPlayer.playSilence(),
                    GameControls.instance().cameraAnimateIn)
                    return;
                let touch = ev.touches[0]
                    , {clientX: clientX, clientY: clientY} = touch;
                if (_isPortrait) {
                    if (touch.clientY < _joystickZoneY || touch.clientX > .5 * Stage.width)
                        return
                } else if (touch.clientX > .4 * Stage.width || touch.clientY < .4 * Stage.height)
                    return;
                Global.MOBILE_JOYSTICK_TOUCH = !0,
                    clientX = Math.max(45, clientX),
                    clientY = Math.min(Stage.height - 50, clientY),
                    _joystickCenterTarget.set(clientX, clientY),
                    $joystickC.tween({
                        x: clientX,
                        y: clientY,
                        scale: .7,
                        opacity: 1
                    }, 700, "easeOutExpo"),
                    $joystickCursor.tween({
                        opacity: 1
                    }, 400, "easeOutSine", 100),
                    _isDown = !0
            }
            function onTouchMove(ev) {
                if (GameControls.instance().cameraAnimateIn)
                    return;
                if (!_isDown)
                    return;
                let touch;
                for (let i = 0, l = ev.touches.length; i < l; i++)
                    if (_isPortrait) {
                        if (ev.touches[i].clientY > _joystickZoneY) {
                            touch = ev.touches[i];
                            break
                        }
                    } else if (ev.touches[i].clientX < .5 * Stage.width) {
                        touch = ev.touches[i];
                        break
                    }
                if (!touch)
                    return onTouchEnd();
                let {clientX: clientX, clientY: clientY} = touch
                    , x = clientX - _joystickCenterTarget.x
                    , y = clientY - _joystickCenterTarget.y;
                _dir.set(Math.range(x, -80, 80, -1, 1, !0), Math.range(y, -80, 80, -1, 1, !0));
                let angle = Math.atan2(y, x);
                _size.x;
                $joystickCursor.transform({
                    rotation: Math.degrees(angle + Math.PI / 2)
                });
                let dist = V2.set(clientX - _joystickCenterTarget.x, clientY - _joystickCenterTarget.y).length();
                _borderScaleTarget = 1 + .6 * Math.range(dist, 0, _size.x, 0, 1, !0)
            }
            function onTouchEnd(ev) {
                GameControls.instance().cameraAnimateIn || (Global.MOBILE_JOYSTICK_TOUCH = !1,
                    _isDown = !1,
                    _joystickCenterTarget.copy(_joystickRestCenter),
                    $joystickCursor.tween({
                        opacity: 0
                    }, 400, "easeOutSine"),
                    $joystickC.tween({
                        x: _joystickRestCenter.x,
                        y: _joystickRestCenter.y,
                        scale: .5,
                        opacity: 1
                    }, 600, "easeOutQuart"),
                    _borderScaleTarget = 1,
                    _dir.set(0, 0))
            }
            _isPortrait = Stage.width <= Stage.height,
                Stage.add($this),
                function initHTML() {
                    $this.css({
                        position: "fixed",
                        top: 0,
                        left: 0,
                        width: "100%",
                        height: "100%",
                        opacity: 0
                    }),
                        ($jHitZone = $this.create("MobileControlsUI-jHitZone")).css({
                            position: "absolute",
                            top: 0,
                            left: 0,
                            width: "50%",
                            height: "100%",
                            zIndex: 2
                        }),
                        ($panZone = $this.create("MobileControlsUI-panZone")).css({
                            position: "absolute",
                            top: 0,
                            left: "50%",
                            width: "50%",
                            height: "100%",
                            zIndex: 1
                        }),
                        $panZone.top = $panZone.create("MobileControlsUI-panZoneTop"),
                        $panZone.top.css({
                            position: "absolute",
                            top: 0,
                            left: "-100%",
                            width: "200%",
                            zIndex: 1
                        }),
                        $joystickC = $this.create("MobileControlsUI-joystickC"),
                        $joystickBorder = $joystickC.create("MobileControlsUI-joystickBorder"),
                        $joystickCursor = $joystickBorder.create("MobileControlsUI-joystickCursor"),
                        $joystickC.css({
                            position: "absolute",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center"
                        }),
                        $joystickBorder.css({
                            position: "absolute",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            width: "80%",
                            height: "80%",
                            border: "1px solid white",
                            borderRadius: "50%",
                            top: "50%",
                            left: "50%",
                            boxShadow: GPU.mobileLT(2) ? null : "0 0 5px #dedede"
                        }).transform({
                            x: "-50%",
                            y: "-50%"
                        }),
                        $joystickCursor.css({
                            position: "relative",
                            width: "calc(100% - 3px)",
                            height: "calc(100% - 3px)",
                            borderRadius: "50%",
                            border: "4px solid white",
                            opacity: 0,
                            borderColor: "white transparent transparent transparent"
                        })
                }(),
                function addListeners() {
                    _this.onResize(resize),
                        $jHitZone.bind("touchstart", onTouchStart),
                        $jHitZone.bind("touchmove", onTouchMove),
                        $jHitZone.bind("touchend", onTouchEnd),
                        _this.startRender(loop)
                }(),
                _this.animateIn = function animateIn(d=5e3) {
                    $this.tween({
                        opacity: 1
                    }, 1e3, "easeOutSine", d)
                }
                ,
                _this.animateOut = function(d=0) {
                    $this.tween({
                        opacity: 0
                    }, 1e3, "easeOutSine", d)
                }
                ,
                _this.get("isDown", (_=>_isDown)),
                _this.get("direction", (_=>_dir)),
                _this.get("$panZone", (_=>$panZone)),
                _this.get("joystickZoneY", (_=>_joystickZoneY))
        }
    )),
    Class((function LoaderView() {
            Inherit(this, Element);
            const _this = this
                , $this = this.element;
            var $lines, $bg, $footer, $top, $right, $bottom, $left;
            function loop() {
                $top.scaleY = $this.percent,
                    $top.transform(),
                    $right.scaleX = $this.percent,
                    $right.transform(),
                    $bottom.scaleY = $this.percent,
                    $bottom.transform(),
                    $left.scaleX = $this.percent,
                    $left.transform()
            }
            !function initHTML() {
                $this.size("100%").setZ(100),
                    $this.percent = 0,
                    Global.LOADER_VIEW = $this,
                    ($bg = $this.create(".bgg")).size("100%"),
                    $bg.bg("#000000"),
                    $this.create(".wrapper").size("100%")
            }(),
                function initLines() {
                    var size = Math.min(Stage.width * (Device.mobile ? .5 : .7), .45 * Stage.height);
                    ($lines = $this.create(".lines")).setZ(100),
                        $lines.size(size, size).center().transform({
                            y: 1
                        }),
                        Global.LINES = $lines,
                        ($top = $lines.create(".top")).css({
                            width: 1,
                            height: size / 2,
                            top: 0,
                            left: size / 2 - 1
                        }).bg("#fff").transformPoint("50%", "0%"),
                        ($right = $lines.create(".top")).css({
                            width: size / 2,
                            height: 1,
                            top: size / 2 - 1,
                            right: 0
                        }).bg("#fff").transformPoint("100%", "50%"),
                        ($bottom = $lines.create(".top")).css({
                            width: 1,
                            height: size / 2,
                            bottom: 0,
                            left: size / 2 - 1
                        }).bg("#fff").transformPoint("50%", "100%"),
                        ($left = $lines.create(".top")).css({
                            width: size / 2,
                            height: 1,
                            top: size / 2 - 1,
                            left: 0
                        }).bg("#fff").transformPoint("0%", "50%")
                }(),
            Stage.width < Stage.height && Device.mobile.phone && !Global.EP && !Global.IN_TOUR && !Global.LOAD_EUROPE && function initFooter() {
                ($footer = $this.create(".footer")).fontStyle(Config.FONTS.sansSerif, 9, "#777"),
                    $footer.size(200, 9).center(1, 0).css({
                        letterSpacing: "0.35em",
                        textAlign: "center",
                        textTransform: "uppercase",
                        bottom: "8%"
                    }).setZ(100),
                    $footer.text("Better in landscape"),
                    _this.events.sub(Events.RESIZE, (_=>{
                            Stage.width > Stage.height && $footer.hide()
                        }
                    ))
            }(),
                _this.startRender(loop),
                this.progress = function(e) {
                    tween($this, {
                        percent: .8 * e.percent
                    }, 4e3, "easeInOutSine")
                }
                ,
                this.complete = function() {}
                ,
                this.animateOut = async function(callback) {
                    Config.TEASER_PRE || Config.TEASER || Config.PREORDER || Config.GUITAR || await LevelController.ready(),
                        Utils.query("skip") ? callback() : (await _this.wait(300),
                            await tween($this, {
                                percent: 1
                            }, 400, "easeOutSine").promise(),
                            _this.stopRender(loop),
                        Config.TEASER_PRE || Config.TEASER || Config.PREORDER || Config.GUITAR || LevelController.animateIn(),
                            $lines.tween({
                                opacity: 0
                            }, 1e3, "easeInSine"),
                        $footer && $footer.tween({
                            opacity: 0
                        }, 1e3, "easeOutSine"),
                            $this.tween({
                                opacity: 0
                            }, 1500, "easeInOutSine").onComplete((()=>callback && callback())))
                }
        }
    )),
    Class((function LocationUI() {
            Inherit(this, Element);
            var $this, $text, $mouseX, $mouseY, $info, _this = this, _spaces = [], _size = Device.mobile.phone ? 8 : 10;
            function capitalize(s) {
                return "string" != typeof s ? "" : s.charAt(0).toUpperCase() + s.slice(1)
            }
            function move() {
                let x = Mouse.x
                    , y = Mouse.y;
                $mouseX && $mouseX.text(`X: ${parseInt(x, 10)}`),
                $mouseY && $mouseY.text(`Y: ${parseInt(y, 10)}`)
            }
            function resize() {
                $this.css({
                    top: Stage.height - Config.OFFSET - 15
                }),
                    Device.mobile ? _spaces.forEach(($space=>{
                            $space.css({
                                display: "inline-block"
                            })
                        }
                    )) : $this.css({
                        display: Stage.width < 800 ? "none" : "block"
                    })
            }
            !function initHTML() {
                ($this = _this.element).size(700, 15).css({
                    textAlign: "right",
                    bottom: Config.OFFSET - 6,
                    right: Config.OFFSET - 12,
                    opacity: .4,
                    whiteSpace: "nowrap"
                })
            }(),
                function initInfo() {
                    ($info = $this.create(".info")).fontStyle(Config.FONTS.serif, _size, "#fff"),
                        $info.css({
                            display: "inline-block",
                            letterSpacing: "0.08em",
                            margin: "0 " + (Device.mobile.phone,
                                "10px"),
                            position: "relative"
                        });
                    let text = "";
                    Device.mobile || (text += `System: <span style="font-style: italic; color: #fff">${capitalize(Device.system.os)}.</span> `),
                    Device.mobile || (text += `Browser:  <span style="font-style: italic; color: #fff">${capitalize(Device.system.browser)}.</span> `),
                        text += `Screen:  <span style="font-style: italic; color: #fff">${Stage.width}x${Stage.height}.</span> `,
                        $info.html(text)
                }(),
                Device.mobile,
            Device.mobile && Device.mobile.tablet || (function initSpace(end) {
                let $space = $this.create(".space");
                $space.css({
                    width: 1,
                    height: Device.mobile.phone ? 8 : 10,
                    margin: Device.mobile.phone ? "0 1px" : "0 4px",
                    display: "inline-block",
                    position: "relative"
                }),
                    $space.inner = $space.create(".inner");
                let height = Device.mobile.phone ? 20 : 26;
                $space.inner.bg("#fff").css({
                    opacity: .3,
                    width: 1,
                    height: height,
                    top: -(height - 10) / 2
                }),
                    _spaces.push($space)
            }(),
                function initText() {
                    ($text = $this.create(".text")).fontStyle(Config.FONTS.serif, _size, "#fff"),
                        $text.css({
                            textAlign: "left",
                            letterSpacing: "0.1em",
                            width: Device.mobile.phone ? 95 : 115,
                            margin: "0 0 0 " + (Device.mobile.phone ? "10px" : "15px"),
                            display: "inline-block",
                            position: "relative",
                            textTransform: "uppercase"
                        }),
                        $text.text(""),
                        Global.LOCATION_TEXT = $text
                }()),
                function addHandlers() {
                    _this.events.sub(Events.RESIZE, resize),
                        _this.events.sub(Mouse.input, Interaction.MOVE, move)
                }(),
                resize(),
                this.animateIn = function() {
                    $this.tween({
                        opacity: .7
                    }, 2e3, "easeInOutSine")
                }
                ,
                this.animateOut = function() {
                    $this.tween({
                        opacity: 0
                    }, 1e3, "easeOutSine")
                }
        }
    )),
    Class((function LogoUI(_config={}) {
            Inherit(this, Element);
            let $this, $text, _this = this;
            function hover(e) {
                switch (e.action) {
                    case "over":
                        $text.tween({
                            opacity: .6
                        }, 200, "easeOutSine");
                        break;
                    case "out":
                        $text.tween({
                            opacity: 1
                        }, 400, "easeOutSine")
                }
            }
            function click() {
                if (Config.TEASER)
                    return open("/", "_self");
                UIOverlay.instance().visible ? UIOverlay.instance().animateOut() : PlayerController.mainPlayer && PlayerController.mainPlayer.teleportToMainRoom()
            }
            function resize() {
                Stage.width < Stage.height && Device.mobile.phone ? ($this.css({
                    width: 100,
                    left: Config.OFFSET,
                    marginLeft: "",
                    textAlign: "left",
                    marginTop: 0
                }),
                    $text.css({
                        width: "",
                        textAlign: "",
                        top: -5
                    })) : ($this.css({
                    width: 200,
                    left: Config.OFFSET,
                    marginLeft: "",
                    textAlign: "left",
                    marginTop: 0
                }),
                    $text.css({
                        width: "",
                        textAlign: ""
                    }))
            }
            !async function() {
                await Data.ready(),
                    function initHTML() {
                        $this = _this.element,
                            $this.size(200, 18).css({
                                top: Config.OFFSET,
                                left: Config.OFFSET
                            }).setZ(50),
                        _config.fixed && $this.css({
                            position: "fixed"
                        })
                    }(),
                    function initText() {
                        $text = $this.create(".logo"),
                            $text.fontStyle(Config.FONTS.serif, Device.mobile.phone ? 10 : 12, "#fff"),
                            $text.css({
                                letterSpacing: "0.3em",
                                textTransform: "uppercase"
                            }),
                            $text.text(Data && Data.COPY && Data.COPY.title || "porter robinson"),
                        Config.TEASER && 3 == Config.TEASER_NUM && $text.css({
                            color: "#000"
                        })
                    }(),
                    function initAccess() {
                        $text.attr("role", "banner")
                    }(),
                    function addHandlers() {
                        $this.interact(hover, click),
                            _this.events.sub(Events.RESIZE, resize)
                    }(),
                    resize()
            }(),
                this.animateIn = function() {}
        }
    )),
    Class((function MultiplayerUI() {
            Inherit(this, Element);
            const _this = this
                , $this = this.element;
            var $text, $bg, $border, $circle;
            function hover(e) {
                if (!_this.toggled)
                    switch (e.action) {
                        case "over":
                            hoverOn();
                            break;
                        case "out":
                            hoverOff()
                    }
            }
            function hoverOn() {
                $text.tween({
                    color: "#000"
                }, 200, "easeOutSine"),
                    $bg.tween({
                        opacity: 1
                    }, 200, "easeOutSine")
            }
            function hoverOff() {
                $text.tween({
                    color: "#fff"
                }, 500, "easeOutSine"),
                    $bg.tween({
                        opacity: 0
                    }, 500, "easeOutSine")
            }
            function toggle({on: on}) {
                on ? (hoverOn(),
                    _this.toggled = !0) : (_this.toggled = !1,
                    hoverOff())
            }
            function click() {
                MultiplayerOverlay.instance().visible ? MultiplayerOverlay.instance().animateOut() : MultiplayerOverlay.instance().animateIn()
            }
            async function onConnection() {
                _this.connected = !0,
                    $this.tween({
                        opacity: 1
                    }, 1e3, "easeOutSine"),
                    $text.text("connected"),
                    $circle.css({
                        background: "#4f4"
                    }),
                    $border.css({
                        borderColor: "#4f4"
                    }),
                    Global.CONNECTED = !0,
                    await defer(),
                    _this.width = 45 + ($text.div.offsetWidth || 100),
                    $this.size(_this.width, _this.height),
                    $border.size(_this.width - 2 * _this.line, _this.height - 2 * _this.line),
                    $bg.size(_this.width, _this.height)
            }
            function resize() {
                $this.css({
                    left: Config.OFFSET - 4,
                    top: Stage.height - Config.OFFSET - _this.height + 8,
                    right: "",
                    bottom: ""
                })
            }
            async function onDisconect() {
                Global.CONNECTED = !1,
                    $this.tween({
                        opacity: 1
                    }, 1e3, "easeOutSine"),
                    $text.text("disconnected"),
                    $circle.css({
                        background: "#f44"
                    }),
                    $border.css({
                        borderColor: "#f44"
                    }),
                    await defer(),
                    _this.width = 45 + ($text.div.offsetWidth || 100),
                    $this.size(_this.width, _this.height),
                    $border.size(_this.width - 2 * _this.line, _this.height - 2 * _this.line),
                    $bg.size(_this.width, _this.height)
            }
            _this.width = 132,
                _this.height = 32,
                _this.line = 1,
                function initHTML() {
                    $this.size(_this.width, _this.height).setZ(10),
                        ($border = $this.create(".border")).size(_this.width - 2 * _this.line, _this.height - 2 * _this.line).css({
                            opacity: 1,
                            border: _this.line + "px solid #f44",
                            borderRadius: _this.height
                        }),
                        ($bg = $this.create(".bg")).size(_this.width, _this.height).bg("#fff").css({
                            opacity: 0,
                            borderRadius: _this.height
                        }),
                        ($circle = $this.create("MultiplayerUI-circle")).size(8, 8).bg("#f44").css({
                            top: _this.height / 2 - 4,
                            left: _this.height / 2 - 3,
                            borderRadius: "50%"
                        }),
                        ($text = $this.create("MultiplayerUI-text")).fontStyle(Config.FONTS.sansSerif, 8, "#fff"),
                        $text.css({
                            letterSpacing: "0.2em",
                            fontWeight: "bold",
                            top: _this.height / 2 - 5,
                            left: _this.height / 2 - 3 + 16,
                            textTransform: "uppercase"
                        }),
                        $text.text("disconnected")
                }(),
                function addHandlers() {
                    $this.interact(hover, click),
                        _this.events.sub(Events.RESIZE, resize),
                        _this.events.sub(MultiplayerUI.CONNECTED, onConnection),
                        _this.events.sub(MultiplayerUI.DISCONNECTED, onDisconect),
                        _this.events.sub(MultiplayerUI.TOGGLE, toggle)
                }(),
                resize(),
                this.animateIn = function(delay=0) {
                    Global.CONNECTED ? onConnection() : onDisconect(),
                        $this.tween({
                            opacity: 1
                        }, 2e3, "easeInOutSine", delay + 2e3)
                }
                ,
                this.animateOut = function() {
                    $this.tween({
                        opacity: 0
                    }, 1e3, "easeOutSine")
                }
        }
    ), (_=>{
            MultiplayerUI.CONNECTED = "multiplayerui_connected",
                MultiplayerUI.DISCONNECTED = "multiplayerui_diconnected",
                MultiplayerUI.TOGGLE = "multiplayerui_toggle"
        }
    )),
    Class((function MultiplayerOverlay() {
            Inherit(this, Element);
            var $this, $bg, _content, _this = this;
            !function initHTML() {
                ($this = _this.element).size("100%").hide().setZ(9),
                    Stage.add($this),
                    ($bg = $this.create(".bg")).size("100%").setZ(1)
            }(),
                function initContent() {
                    _content = _this.initClass(MultiplayerOverlayContent)
                }(),
                function addHandlers() {
                    $bg.interact(null, (_=>{
                            _this.animateOut()
                        }
                    ))
                }(),
                this.animateIn = function() {
                    _this.visible || (_this.visible = !0,
                        $this.show().clearAlpha(),
                        VFX.instance().toggleSketchOverlay(!0),
                        _this.events.fire(MultiplayerUI.TOGGLE, {
                            on: !0
                        }),
                        _content.animateIn())
                }
                ,
                this.animateOut = function() {
                    _this.visible && (_this.visible = !1,
                    UIOverlay.instance().visible || VFX.instance().toggleSketchOverlay(!1),
                        _this.events.fire(MultiplayerUI.TOGGLE, {
                            on: !1
                        }),
                        $this.tween({
                            opacity: 0
                        }, 500, "easeOutSine", (_=>{
                                $this.hide()
                            }
                        )))
                }
        }
    ), "singleton"),
    Class((function MultiplayerOverlayContent() {
            Inherit(this, Element);
            var $this, $line, $text, $connected, $location, $custom, $buttons, $url, $visit, $copy, _this = this, _elements = [], _url = URLUtil.addParam(URLUtil.removeParam(location.href, "r"), "r", URLUtil.randomHash());
            function resize() {
                Device.mobile.phone && Stage.width > Stage.height ? $line.hide() : $line.show()
            }
            function copy() {
                $url.div.select(),
                    document.execCommand("copy"),
                    $url.div.value = "copied!",
                    _this.delayedCall((_=>{
                            $url.div.value = _url
                        }
                    ), 1e3),
                    $url.css({
                        opacity: .7
                    }).tween({
                        opacity: 1
                    }, 1e3, "easeInOutSine")
            }
            function visit() {
                window.history.replaceState({}, document.title, _url),
                    Stage.tween({
                        opacity: 0
                    }, 400, "easeInSine", (_=>{
                            window.location.reload()
                        }
                    ))
            }
            !function initHTML() {
                ($this = _this.element).size(500, Device.mobile.phone ? 220 : 300).center().css({
                    textAlign: "center"
                }).setZ(2)
            }(),
                function initConnected() {
                    ($text = $this.create("text")).css({
                        display: "block",
                        position: "relative"
                    }),
                        ($connected = $text.create(".connected")).fontStyle(Config.FONTS.sansSerif, Device.mobile.phone ? 9 : 10, "#fff"),
                        $connected.css({
                            lineHeight: "2em",
                            position: "relative",
                            display: "block",
                            textTransform: "uppercase",
                            letterSpacing: "0.4em"
                        }),
                        _elements.push($connected),
                        ($location = $text.create(".connected")).fontStyle(Config.FONTS.serif, Device.mobile.phone ? 36 : 44, "#fff"),
                        $location.css({
                            position: "relative",
                            marginTop: 15,
                            lineHeight: "1.05em",
                            display: "block"
                        }),
                        _elements.push($location),
                        ($line = $this.create(".line")).size(50, 1).bg("#fff").css({
                            position: "relative",
                            display: "block",
                            margin: (Device.mobile.phone ? "25px" : "45px") + " auto"
                        })
                }(),
                function initCustom() {
                    ($custom = $this.create(".connected")).fontStyle(Config.FONTS.sansSerif, Device.mobile.phone ? 9 : 10, "#fff"),
                        $custom.css({
                            position: "relative",
                            display: "block",
                            marginTop: Device.mobile.phone ? 10 : 15,
                            textTransform: "uppercase",
                            letterSpacing: "0.4em"
                        }),
                        $custom.text("connect to a friend"),
                        _elements.push($custom),
                        ($url = $this.create(".url", "input")).fontStyle(Config.FONTS.serif, 16, "#000"),
                        $url.size(270, 16).css({
                            borderRadius: 50,
                            textAlign: "center",
                            padding: Device.mobile.phone ? 10 : 15,
                            fontStyle: "italic",
                            position: "relative",
                            display: "block",
                            margin: "0 auto",
                            outline: "none",
                            border: "none",
                            marginTop: 15
                        }),
                        $url.div.value = _url,
                        _elements.push($url);
                    let width = 100
                        , height = 36;
                    ($buttons = $this.create(".buttons")).css({
                        display: "block",
                        position: "relative",
                        height: height,
                        marginTop: 15
                    }),
                        ($copy = $buttons.create(".button")).size(width, height).center().css({
                            marginLeft: -width - 5,
                            border: "1px solid #fff"
                        }),
                        _elements.push($copy),
                        $copy.button = _this.initClass(UINavViewItem, {
                            custom: !0,
                            width: width - 40,
                            height: height,
                            fontSize: 9,
                            text: "COPY URL"
                        }, [$copy]),
                        ($visit = $buttons.create(".button")).size(width, height).center().css({
                            marginLeft: 5,
                            border: "1px solid #fff"
                        }),
                        _elements.push($visit),
                        $visit.button = _this.initClass(UINavViewItem, {
                            custom: !0,
                            width: width - 40,
                            height: height,
                            fontSize: 9,
                            text: "CONNECT"
                        }, [$visit])
                }(),
                function addHandlers() {
                    _this.events.sub($copy.button, Events.CLICK, copy),
                        _this.events.sub($visit.button, Events.CLICK, visit),
                        _this.events.sub(Events.RESIZE, resize)
                }(),
                resize(),
                this.animateIn = function() {
                    Multiplayer.REMOTE_ADMIN ? ($connected.html("connected to"),
                        $location.text("Porter Robinson")) : Global.CONNECTED ? ($connected.html("connected to someone in"),
                        $location.text(function titleCase(str) {
                            for (var splitStr = str.toLowerCase().split(" "), i = 0; i < splitStr.length; i++)
                                splitStr[i] = splitStr[i].charAt(0).toUpperCase() + splitStr[i].substring(1);
                            return splitStr.join(" ")
                        }(Multiplayer.REMOTE_LOCATION))) : ($location.text(""),
                        $connected.html(Device.mobile ? "not connected to anyone.<br/>try again another time." : "not connected to anyone.<br/>disable any ad blocker.<br/>try again another time.")),
                        $this.css({
                            opacity: 0
                        }).tween({
                            opacity: 1
                        }, 500, "easeOutSIne"),
                        $url.div.value = _url,
                        $line.transform({
                            scaleX: 0
                        }).tween({
                            scaleX: 1
                        }, 1500, "easeInOutQuart", 200);
                    let delay = 300;
                    _elements.forEach((($element,i)=>{
                            $element.transform({
                                y: 15
                            }).css({
                                opacity: 0
                            }).tween({
                                opacity: 1,
                                y: 0
                            }, 1400, "easeOutQuart", delay),
                                delay += 100,
                            1 == i && (delay += 200)
                        }
                    )),
                        _this.delayedCall($copy.button.animateIn, 800),
                        _this.delayedCall($visit.button.animateIn, 800)
                }
                ,
                this.animateOut = function() {
                    $this.tween({
                        opacity: 0
                    }, 500, "easeOutSIne")
                }
        }
    ), "singleton"),
    Class((function UINav() {
            Inherit(this, Element);
            const _this = this;
            let $this, _main;
            function resize() {
                $this.size(_main.width, _main.height),
                    !Device.mobile && Stage.width < 550 ? $this.transform({
                        scale: .7
                    }) : $this.transform({
                        scale: 1
                    }),
                    $this.css({
                        left: "",
                        marginLeft: ""
                    })
            }
            function hover(e) {
                "over" == e.action && e.main && _main.activate(e.text)
            }
            function move() {
                (Mouse.x < Stage.width - 600 || Mouse.y > 170) && _main.deactivate()
            }
            !function initHTML() {
                $this = _this.element,
                    $this.size(300, 50).css({
                        right: Config.OFFSET - 8,
                        top: Config.OFFSET - 8
                    }).invisible().setZ(20),
                    $this.css({
                        transformOrigin: "right"
                    })
            }(),
                function initElements() {
                    let data = [];
                    Data.NAVIGATION.forEach((({routeName: routeName, routeLink: routeLink, active: active})=>{
                            let text = routeName.toUpperCase()
                                , url = routeLink.includes("http") ? routeLink : "";
                            "MUSIC" == text && Config.TEASER && (active = !1),
                            text && active && data.push({
                                text: text,
                                url: url
                            })
                        }
                    )),
                        _main = _this.initClass(UINavView, data, !0),
                        _main.element.css({
                            top: 0
                        })
                }(),
                function addHandlers() {
                    _this.onResize(resize),
                        _main.events.sub(Events.HOVER, hover),
                        _this.events.sub(Mouse.input, Interaction.MOVE, move)
                }(),
                this.animateIn = async function(delay=200) {
                    await _this.wait(delay),
                        $this.visible(),
                        _main.animateIn(),
                        defer(resize)
                }
        }
    )),
    Class((function UINavView(_data, _main) {
            Inherit(this, Element);
            var $this, $outline, _items, _this = this;
            _this.width = 350,
                _this.height = Device.mobile.phone ? 28 : 34;
            function setActive(e) {
                _items.forEach((item=>{
                        item.type.toLowerCase() == e.text.toLowerCase() ? item.activate() : item.deactivate()
                    }
                ))
            }
            !function initHTML() {
                ($this = _this.element).size(_this.width, _this.height).invisible()
            }(),
                function initOutline() {
                    ($outline = $this.create(".outline")).size(_this.width - 2, _this.height - 2).css({
                        border: "1px solid #fff",
                        opacity: .3
                    }).setZ(1)
                }(),
                function initItems() {
                    _items = [];
                    for (var i = 0; i < _data.length; i++) {
                        _data[i].height = _this.height,
                            _data[i].main = _main;
                        var item = _this.initClass(UINavViewItem, _data[i]);
                        item.type = _data[i].text,
                            _items.push(item)
                    }
                }(),
                function addHandlers() {
                    _this.events.sub(UINavView.SET_ACTIVE, setActive)
                }(),
                this.activate = function(text) {}
                ,
                this.deactivate = function() {}
                ,
                this.animateIn = function() {
                    if (!_this.visible) {
                        _this.visible = !0,
                            function setWidths() {
                                _this.width = 0,
                                    $outline.html("");
                                for (var i = 0; i < _items.length; i++) {
                                    let width = _items[i].width || _items[i].text.width;
                                    _items[i].element.css({
                                        width: width,
                                        left: _this.width
                                    });
                                    let $line = $outline.create(".line");
                                    $line.css({
                                        width: 1,
                                        height: "100%",
                                        left: _this.width - 2,
                                        opacity: 1
                                    }).bg("#fff"),
                                        _items[i].line = $line,
                                        _this.width += width + 1
                                }
                                $this.size(_this.width, _this.height).css({
                                    right: 0
                                }),
                                    $outline.size(_this.width - 2, _this.height - 2)
                            }(),
                            $this.visible(),
                            $outline.clearTween().css({
                                opacity: 0
                            }).transform({
                                scaleY: 0
                            }).tween({
                                scaleY: 1,
                                opacity: .2
                            }, 600, "easeOutQuart");
                        for (var i = 0; i < _items.length; i++)
                            _items[i].animateIn(50 * i)
                    }
                }
                ,
                this.animateOut = function() {
                    if (_this.visible) {
                        _this.visible = !1;
                        for (var i = 0; i < _items.length; i++)
                            _items[i].animateOut(30 * i);
                        $outline.tween({
                            opacity: 0,
                            scaleY: 0
                        }, 400, "easeOutQuart", (function() {
                                $this.invisible()
                            }
                        ))
                    }
                }
        }
    ), (_=>{
            UINavView.SET_ACTIVE = "set_active"
        }
    )),
    Class((function UINavViewItem(_data) {
            Inherit(this, Element);
            var $this, $solid, $wrap, _text, _over, _this = this;
            function hover(e) {
                if ((!Device.mobile || e.forced) && (_this.events.fire(Events.HOVER, e),
                    !_this.isActive))
                    switch (e.action) {
                        case "over":
                            _over.hidden = !1,
                                _text.hidden = !0,
                                $solid.tween({
                                    y: _data.height,
                                    opacity: 1
                                }, 300, "easeOutQuart"),
                                _over.glitch(),
                                _over.element.tween({
                                    opacity: 1
                                }, 200, "easeOutSine");
                            break;
                        case "out":
                            _text.hidden = !1,
                                _over.hidden = !0,
                                $solid.tween({
                                    y: 2 * _data.height,
                                    opacity: 1
                                }, 400, "easeOutQuart"),
                                _over.element.tween({
                                    opacity: 0
                                }, 200, "easeOutSine")
                    }
            }
            function click() {
                UIOverlay.DEBOUNCE || (UIOverlay.DEBOUNCE = _this.delayedCall((()=>{
                        UIOverlay.DEBOUNCE = !1
                    }
                ), 1e3),
                    _data.custom ? _this.events.fire(Events.CLICK, _data) : _this.isActive ? UIOverlay.instance().animateOut() : _data.url ? (open(_data.url),
                        hover({
                            action: "out",
                            forced: !0
                        })) : UIOverlay.instance().animateIn(_data.text.toLowerCase()))
            }
            !function initHTML() {
                ($this = _this.element).size(_data.boxWidth || "100%", _data.height).setZ(10),
                    ($wrap = $this.create(".wrap")).size("100%").css({
                        overflow: "hidden"
                    })
            }(),
                function initText() {
                    _text = _this.initClass(UILinksItemText, _data, "#fff", [$wrap]),
                        _this.text = _text
                }(),
                function initOver() {
                    ($solid = $wrap.create(".solid")).size("100%").bg("#fff").css({
                        top: "-100%",
                        opacity: 1
                    }).transform({
                        y: 2 * _data.height
                    }),
                        (_over = _this.initClass(UILinksItemText, _data, "#000", [$wrap])).hidden = !0,
                        _over.element.css({
                            opacity: 0,
                            fontWeight: "bold"
                        })
                }(),
                function addListeners() {
                    $this.interact(hover, click, "#", _data.text),
                        $this.mouseEnabled(!0)
                }(),
                this.activate = function() {
                    _this.isActive || (hover({
                        action: "over",
                        forced: !0
                    }),
                        _this.isActive = !0)
                }
                ,
                this.deactivate = function() {
                    _this.isActive && (_this.isActive = !1,
                        hover({
                            action: "out",
                            forced: !0
                        }))
                }
                ,
                this.animateIn = function() {
                    $this.visible(),
                        _text.glitch(),
                        $this.css({
                            opacity: 0
                        }).tween({
                            opacity: 1
                        }, 300, "easeOutSine")
                }
                ,
                this.animateOut = function() {
                    $this.tween({
                        opacity: 0
                    }, 300, "easeOutSine", (function() {
                            $this.invisible()
                        }
                    ))
                }
        }
    )),
    Class((function UILinksItemText(_data, _color) {
            Inherit(this, Element);
            var $this, _letters, _timeout, _this = this, _chars = ":_-".split("");
            function loop(t) {
                if (_letters && !_this.hidden && _this.animating && !(t - _this.time < 60) && !_data.noGlitch) {
                    _this.time = t;
                    for (var i = 0; i < _letters.length; i++) {
                        var $letter = _letters[i];
                        if ($letter.canGlitch)
                            if (0 == Math.random(0, 1) && $letter.glitching) {
                                $letter.reset = !1;
                                var letter = _chars[Math.random(0, _chars.length - 1)];
                                _letters[i].html(letter)
                            } else
                                $letter.reset || ($letter.reset = !0,
                                    $letter.html($letter.base))
                    }
                }
            }
            !async function() {
                !function initHTML() {
                    ($this = _this.element).fontStyle(Config.FONTS.sansSerif, _data.fontSize ? _data.fontSize : Device.mobile.phone ? 8 : 9, _color),
                        $this.css({
                            textAlign: "center",
                            fontWeight: "bold",
                            letterSpacing: "0.22em",
                            lineHeight: 10,
                            top: "50%",
                            marginTop: -5,
                            whiteSpace: "nowrap"
                        }),
                        $this.text(_data.text)
                }(),
                    await _this.wait(200),
                    function setWidth() {
                        let width = _data.width || $this.div.offsetWidth || 48;
                        if (_this.width = width + (Device.mobile.phone ? 24 : _data.dropdown ? 55 : 34),
                            $this.css({
                                width: _this.width
                            }),
                            _data.noGlitch)
                            return;
                        _letters = SplitTextfield.split($this);
                        for (var i = 0; i < _letters.length; i++)
                            _letters[i].css({
                                position: "relative",
                                float: "",
                                cssFloat: "",
                                styleFloat: "",
                                display: "inline-block"
                            }),
                            "&nbsp;" == _letters[i].div.innerHTML && (_letters[i - 1].css({
                                paddingRight: 7
                            }),
                                _letters[i].div.innerHTML = " "),
                                _letters[i].base = _letters[i].div.innerHTML,
                                _letters[i].canGlitch = _letters[i].div.innerHTML.length < 2 && "-" !== _letters[i].div.innerHTML
                    }(),
                    _this.startRender(loop)
            }(),
                this.glitch = function() {
                    if (!_data.noGlitch && _letters) {
                        clearTimeout(_timeout),
                            _this.animating = !0;
                        for (var i = 0; i < _letters.length; i++)
                            _letters[i].canGlitch && glitchLetter(_letters[i], Math.random(0, 8));
                        _timeout = _this.delayedCall((function() {
                                _this.animating = !1;
                                for (var i = 0; i < _letters.length; i++) {
                                    var $letter = _letters[i];
                                    $letter.html($letter.base)
                                }
                            }
                        ), 600)
                    }
                    function glitchLetter($letter, amount) {
                        $letter.glitching = !0,
                            _this.delayedCall((function() {
                                    $letter.glitching = !1
                                }
                            ), 40 * amount)
                    }
                }
        }
    )),
    Class((function UIOverlay() {
            Inherit(this, Element);
            var $this, _view, _controls, _this = this;
            function resize() {
                _this.visible && CanvasDraw.instance().resize()
            }
            !function initHTML() {
                ($this = _this.element).size("100%").hide().setZ(10),
                    Stage.add($this)
            }(),
                function addHandlers() {
                    _this.events.sub(Events.RESIZE, resize)
                }(),
                this.animateIn = async function(type) {
                    if (!_this.visible || type != _this.visible) {
                        switch (_controls = GameControls.instance().controls,
                            _this.type = type,
                            _this.visible ? (CanvasDraw.instance().animateOut(),
                                await _this.wait(500)) : $this.show().css({
                                opacity: 0
                            }).tween({
                                opacity: 1
                            }, 500, "easeOutSine"),
                            Tests.showFallback() ? Fallback.instance().toggle(!1) : VFX.instance().toggleuUIOverlay(!0),
                            CanvasDraw.instance().animateIn(),
                            _this.events.fire(LevelController.CHANGE_SCENE, {
                                id: "overlay"
                            }),
                            _this.events.fire(UINavView.SET_ACTIVE, {
                                text: type
                            }),
                        _view && (await _view.animateOut(),
                            _view = _view.destroy()),
                            type) {
                            case "music":
                                _view = _this.initClass(UIOverlayMusic);
                                break;
                            case "tour":
                                _view = _this.initClass(UIOverlayTour)
                        }
                        Multiplayer.leave(),
                            _this.delayedCall(_view.animateIn, _this.visible ? 200 : 1e3),
                            _this.visible = !0,
                            _this.events.fire(UIOverlay.SHOWN),
                        MultiplayerOverlay.instance().visible && MultiplayerOverlay.instance().animateOut(),
                        _controls.animateOut && _controls.animateOut(500)
                    }
                }
                ,
                this.animateOut = function() {
                    _this.events.fire(UIOverlay.HIDDEN),
                        _this.visible = !1,
                    Container.SHOW_INSTRUCTIONS && Container.SHOW_INSTRUCTIONS.resolve(),
                        CanvasDraw.instance().animateOut(),
                        Tests.showFallback() ? Fallback.instance().toggle(!0) : VFX.instance().toggleuUIOverlay(!1),
                        _this.events.fire(LevelController.CHANGE_SCENE, {
                            reset: !0
                        }),
                        _this.events.fire(UINavView.SET_ACTIVE, {
                            text: "home"
                        }),
                    _controls.animateIn && _controls.animateIn(0),
                        $this.tween({
                            opacity: 0
                        }, 500, "easeOutSine", (_=>{
                                $this.hide(),
                                _view && (_view = _view.destroy())
                            }
                        )),
                        Multiplayer.join()
                }
        }
    ), "singleton", (_=>{
            UIOverlay.SHOWN = "ui_overlay_shown",
                UIOverlay.HIDDEN = "ui_overlay_hidden",
                UIOverlay.DEBOUNCE = null
        }
    )),
    Class((function UIOverlayEurope() {
            Inherit(this, Element);
            var $this, _this = this;
            !function initHTML() {
                ($this = _this.element).size("100%").css({
                    opacity: 0
                });
                let dates = $this.create("dates-container");
                dates.size("100%"),
                    dates.attr("id", "seated-55fdf2c0"),
                    dates.attr("data-artist-id", "53564766-f2aa-4988-90cd-5e904fb44cb0"),
                    dates.attr("data-css-version", "2");
                var tag = document.createElement("script");
                tag.src = "https://widget.seated.com/app.js";
                var firstScriptTag = document.getElementsByTagName("script")[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag)
            }(),
                this.animateIn = function() {
                    $this && $this.css && $this.css({
                        opacity: 0
                    }).tween({
                        opacity: 1
                    }, 1e3, "easeInOutSine")
                }
                ,
                this.animateOut = async function() {
                    $this && $this.tween && await $this.tween({
                        opacity: 0
                    }, 500, "easeInOutSine").promise()
                }
        }
    )),
    Class((function UIOverlayMusic() {
            Inherit(this, Element);
            let $this, $links, $wrapper, _frames, _buttons, _this = this;
            function resize() {
                let width = Math.clamp(Stage.width - 2 * Config.OFFSET, 0, 400);
                Math.clamp(Stage.height - 2 * Config.OFFSET, 0, 500);
                $wrapper.css({
                    width: width
                }),
                    _frames.forEach((frame=>{
                            frame.resize(width)
                        }
                    ))
            }
            function hover(e) {
                switch (clearTimeout(_this.hoverOut),
                    e.action) {
                    case "over":
                        _buttons.forEach((button=>{
                                button.text == e.text ? button.hover({
                                    action: "over"
                                }) : button.hover({
                                    action: "out"
                                })
                            }
                        ));
                        break;
                    case "out":
                        _this.hoverOut = _this.delayedCall((_=>{
                                _buttons.forEach((button=>{
                                        button.hover({
                                            action: "out"
                                        })
                                    }
                                ))
                            }
                        ), 200)
                }
            }
            !function initHTML() {
                $this = _this.element,
                    $this.size("100%").invisible(),
                    $this.overflowScroll({
                        y: 1
                    }),
                    $this.css({
                        display: "flex",
                        alignItems: "center"
                    })
            }(),
                function initFrames() {
                    $wrapper = $this.create(".wrapper"),
                        $wrapper.css({
                            display: "block",
                            position: "relative",
                            margin: "150px auto 80px auto"
                        }),
                        _frames = [];
                    let album = _this.initClass(UIOverlayMusicFrame, {
                        height: 520,
                        embed: "https://open.spotify.com/embed/album/4Hjqdhj5rh816i1dfcUEaM"
                    }, [$wrapper]);
                    _frames.push(album)
                }(),
                function initLinks() {
                    $links = $wrapper.create(".wrapper"),
                        $links.css({
                            height: 60,
                            display: "block",
                            position: "relative",
                            margin: "10px auto"
                        });
                    let icons = [{
                        text: "Youtube",
                        type: "yt",
                        url: "https://porterrobinson.co/youtube"
                    }, {
                        text: "Spotify",
                        type: "spot",
                        url: "https://porterrobinson.co/spotify"
                    }, {
                        text: "Apple Music",
                        type: "itu",
                        url: "https://porterrobinson.co/applemusic"
                    }, {
                        text: "Soundcloud",
                        type: "sound",
                        url: "https://porterrobinson.co/soundcloud"
                    }, {
                        text: "Amazon Music",
                        type: "amazon",
                        url: "https://porterrobinson.co/amazon"
                    }];
                    _buttons = [];
                    let gap = 56;
                    icons.forEach(((icon,i)=>{
                            let button = _this.initClass(EPLinksButton, icon, [$links]);
                            button.text = icon.text,
                                button.element.center(1, 0).css({
                                    marginLeft: .5 * -gap * icons.length + gap * i + .1 * gap,
                                    bottom: 0
                                }),
                                _buttons.push(button)
                        }
                    ))
                }(),
                function addHandlers() {
                    _this.events.sub(Events.RESIZE, resize),
                        _buttons.forEach((button=>{
                                _this.events.sub(button, Events.HOVER, hover)
                            }
                        ))
                }(),
                resize(),
                this.animateIn = function() {
                    $this && $this.visible && ($this.visible().css({
                        opacity: 0
                    }).tween({
                        opacity: 1
                    }, 1e3, "easeOutCubic"),
                        _frames.forEach(((frame,i)=>{
                                frame.animateIn(200 * i)
                            }
                        )),
                        _buttons.forEach(((button,i)=>{
                                button.element.transform({
                                    y: 20
                                }).css({
                                    opacity: 0
                                }).tween({
                                    y: 0,
                                    opacity: 1,
                                    math: !0
                                }, 1500, "easeOutQuart", 1e3 + 120 * i)
                            }
                        )))
                }
                ,
                this.animateOut = async function() {
                    $this && !$this.tween && await $this.tween({
                        opacity: 0
                    }, 500, "easeInOutSine").promise()
                }
        }
    )),
    Class((function UIOverlayMusicFrame(_data) {
            Inherit(this, Element);
            var $this, $frame, _this = this;
            function initFrame() {
                ($frame = $this.create(".frame", "iframe")).css({
                    position: "relative",
                    display: "block"
                }),
                    $frame.div.src = _data.embed,
                    $frame.height = _data.height
            }
            function onClick(ev) {
                console.log("click")
            }
            !function initHTML() {
                ($this = _this.element).size("100%").css({
                    position: "relative",
                    display: "block",
                    marginBottom: 20,
                    opacity: 0,
                    boxShadow: "0 10px 60px rgba(0,0,0,0.4)",
                    background: "black"
                })
            }(),
                initFrame(),
                function addListeners() {
                    $this.click(onClick)
                }(),
                this.reset = function() {
                    $frame.destroy(),
                        initFrame()
                }
                ,
                this.resize = function(width) {
                    $this.size(width, _data.height),
                        $frame.size(width, _data.height)
                }
                ,
                this.animateIn = function(delay=0) {
                    $this.css({
                        opacity: 0
                    }).transform({
                        y: 50
                    }).tween({
                        opacity: 1,
                        y: 0
                    }, 1e3, "easeOutCubic", delay)
                }
        }
    )),
    Class((function UIOverlayTour() {
            Inherit(this, Element);
            var $this, $items, _items, _this = this;
            !function initHTML() {
                ($this = _this.element).size("100%").css({
                    opacity: 0
                })
            }(),
                function initList() {
                    let sorted = Data.TOUR.sort(((a,b)=>new Date(a.date) - new Date(b.date)));
                    ($items = $this.create(".items")).size("100%"),
                        $items.overflowScroll({
                            y: 1
                        }),
                        $items.inner = $items.create("inner"),
                        $items.inner.css({
                            display: "block",
                            maxWidth: Device.mobile.phone ? 550 : 700,
                            padding: "0 " + Config.OFFSET + "px",
                            margin: "150px auto",
                            position: "relative"
                        }),
                    Device.mobile.phone && $items.inner.css({
                        marginTop: 200
                    }),
                        _items = [];
                    let now = new Date;
                    sorted.forEach(((d,i)=>{
                            let notPast = new Date(d.date) > now - 864e5;
                            if (d.active && notPast) {
                                d.index = i;
                                let item = _this.initClass(UIOverlayTourItem, d, [$items.inner]);
                                _items.push(item)
                            }
                        }
                    )),
                    0 == _items.length && ($items.inner.fontStyle(Config.FONTS.serif, Device.mobile.phone ? 30 : 52, "#fff"),
                        $items.inner.css({
                            textAlign: "center"
                        }),
                        $items.inner.text("no upcoming dates"))
                }(),
                this.animateIn = function() {
                    $this && $this.css && ($this.css({
                        opacity: 0
                    }).tween({
                        opacity: 1
                    }, 1e3, "easeInOutSine"),
                        Global.IS_TOUR = !0,
                        $items.inner.transform({
                            y: .3 * Stage.height
                        }).tween({
                            y: 0,
                            math: !0
                        }, 2e3, "easeOutQuart"),
                        _items.forEach(((item,i)=>{
                                _this.delayedCall(item.animateIn, 150 * i + 500)
                            }
                        )),
                        UIPreOrder.instance().animateIn(1e3, !0))
                }
                ,
                this.animateOut = async function() {
                    Global.IS_TOUR = !1,
                    $this && $this.tween && await $this.tween({
                        opacity: 0
                    }, 500, "easeInOutSine").promise()
                }
        }
    )),
    Class((function UIOverlayTourItem(_data) {
            Inherit(this, Element);
            var $this, $line, $wrapper, $title, $info, $button, _button, _this = this, _buttonWidth = Device.mobile.phone ? 130 : 150, _textSpacing = Device.mobile.phone ? 18 : 25;
            function hover(e) {
                switch (e.action) {
                    case "over":
                        $title.tween({
                            x: 10,
                            opacity: 1
                        }, 500, "easeOutCubic"),
                            $line.inner2.clearTween().transformPoint("100%", "50%").transform({
                                scaleX: 0
                            }).tween({
                                scaleX: 1
                            }, 500, "easeOutCubic");
                        break;
                    case "out":
                        $title.tween({
                            x: 0,
                            opacity: 1
                        }, 700, "easeOutCubic"),
                            $line.inner2.tween({
                                scaleX: 0
                            }, 1200, "easeInOutCubic")
                }
            }
            !function initHTML() {
                ($this = _this.element).size("100%", 100).css({
                    height: "auto",
                    position: "relative",
                    display: "block",
                    margin: Device.mobile.phone ? "50px 0" : "60px 0"
                }).invisible(),
                    ($wrapper = $this.create(".wrapper")).css({
                        display: "block",
                        position: "relative",
                        paddingRight: _buttonWidth
                    })
            }(),
                function initTitle() {
                    let size = Device.mobile.phone ? 30 : 50;
                    _data.headline || console.log(_data),
                        ($title = $wrapper.create(".title")).fontStyle(Config.FONTS.serif, size, "#fff"),
                        $title.css({
                            display: "block",
                            fontWeight: "light",
                            textTransform: "lowercase",
                            lineHeight: 1.15 * size,
                            letterSpacing: "0.02em",
                            position: "relative",
                            paddingRight: 10
                        }),
                        $title.text(_data.headline)
                }(),
                function initTickets() {
                    ($line = $wrapper.create(".line")).css({
                        display: "block",
                        position: "relative",
                        height: 1,
                        margin: "1px 0"
                    }),
                    Device.mobile.phone && $line.css({
                        marginTop: 6
                    }),
                        $line.inner = $line.create(".inner"),
                        $line.inner.size("100%").transformPoint("0%", "50%").transform({
                            scaleX: 0
                        }).css({
                            background: Device.mobile ? "rgba(255,255,255,0.6)" : "rgba(255,255,255,0.3)"
                        }),
                        $line.inner2 = $line.inner.create(".inner"),
                        $line.inner2.size("100%").bg("#fff").transformPoint("100%", "50%").transform({
                            scaleX: 0
                        }),
                        ($button = $wrapper.create(".button")).size(_buttonWidth, 40).css({
                            marginTop: -25,
                            right: 0,
                            border: "1px solid #fff"
                        }).bg("#000"),
                        _button = _this.initClass(UINavViewItem, {
                            url: _data.url,
                            width: Device.mobile.phone ? _buttonWidth - 20 : _buttonWidth - 40,
                            height: 40,
                            fontSize: Device.mobile.phone ? 10 : 11,
                            text: "BUY TICKETS"
                        }, [$button])
                }(),
                function initInfo() {
                    ($info = $wrapper.create(".info")).fontStyle(Config.FONTS.sansSerif, Device.mobile.phone ? 10 : 12, "#fff"),
                        $info.css({
                            display: "block",
                            textTransform: "uppercase",
                            letterSpacing: "0.1em",
                            position: "relative",
                            marginTop: 10
                        }),
                        $info.date = $info.create(".date"),
                        $info.date.css({
                            display: "inline-block",
                            fontWeight: "bold",
                            position: "relative",
                            marginRight: .4 * _textSpacing
                        });
                    let dateObj = new Date(_data.date)
                        , dateText = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][dateObj.getMonth()].slice(0, 3) + " - " + dateObj.getDate() + " - " + dateObj.getFullYear();
                    $info.date.text(dateText),
                        $info.day = $info.create(".date"),
                        $info.day.css({
                            display: "inline-block",
                            opacity: .7,
                            position: "relative",
                            marginRight: 1.2 * _textSpacing
                        });
                    let day = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dateObj.getDay()];
                    $info.day.text(day.slice(0, 3)),
                        $info.location = $info.create(".date"),
                        $info.location.css({
                            display: "inline-block",
                            position: "relative",
                            marginRight: _textSpacing
                        }),
                        $info.location.text(_data.location),
                        $info.info = $info.create(".date"),
                        $info.info.css({
                            display: "block",
                            position: "relative",
                            marginRight: _textSpacing
                        }),
                        $info.info.text(_data.info)
                }(),
                function addHandlers() {
                    _this.events.sub(_button, Events.HOVER, hover)
                }(),
                this.animateIn = function() {
                    $this.visible(),
                        $title.transform({
                            y: 10
                        }).css({
                            opacity: 0
                        }).tween({
                            y: 0,
                            opacity: 1
                        }, 800, "easeOutQuart"),
                        $line.inner.transform({
                            scaleX: 0
                        }).transformPoint("0%", "50%").tween({
                            scaleX: 1
                        }, 1e3, "easeOutQuart"),
                        $line.inner2.transform({
                            scaleX: 1
                        }).transformPoint("100%", "50%").tween({
                            scaleX: 0
                        }, 2e3, "easeInOutQuart"),
                        $info.date.transform({
                            x: 20
                        }).css({
                            opacity: 0
                        }).tween({
                            x: 0,
                            opacity: 1
                        }, 800, "easeOutQuart", 200),
                        $info.day.transform({
                            x: 20
                        }).css({
                            opacity: 0
                        }).tween({
                            x: 0,
                            opacity: .8
                        }, 800, "easeOutQuart", 300),
                        $info.location.transform({
                            x: 20
                        }).css({
                            opacity: 0
                        }).tween({
                            x: 0,
                            opacity: 1
                        }, 800, "easeOutQuart", 400),
                        $info.info.transform({
                            x: 20
                        }).css({
                            opacity: 0
                        }).tween({
                            x: 0,
                            opacity: 1
                        }, 800, "easeOutQuart", 500),
                        $button.transform({
                            x: 30
                        }).css({
                            opacity: 0
                        }).tween({
                            x: 0,
                            opacity: 1
                        }, 800, "easeOutQuart", 300),
                        _this.delayedCall(_button.animateIn, 700)
                }
        }
    )),
    Class((function UIClose(_data) {
            Inherit(this, Element);
            var $this, $solid, $wrap, _text, _over, _this = this;
            function hover(e) {
                if ((!Device.mobile || e.forced) && (_this.events.fire(Events.HOVER, e),
                    !_this.isActive))
                    switch (e.action) {
                        case "over":
                            _over.hidden = !1,
                                _text.hidden = !0,
                                $solid.tween({
                                    y: _data.height,
                                    opacity: 1
                                }, 300, "easeOutQuart"),
                                _over.glitch(),
                                _over.element.tween({
                                    opacity: 1
                                }, 200, "easeOutSine");
                            break;
                        case "out":
                            _text.hidden = !1,
                                _over.hidden = !0,
                                $solid.tween({
                                    y: 2 * _data.height,
                                    opacity: 1
                                }, 400, "easeOutQuart"),
                                _over.element.tween({
                                    opacity: 0
                                }, 200, "easeOutSine")
                    }
            }
            function click() {
                _this.events.fire(Events.CLICK, _data)
            }
            _data.noGlitch = !0,
                function initHTML() {
                    ($this = _this.element).size(_data.height, _data.height).setZ(10).css({
                        right: 0,
                        background: "rgba(0,0,0,0.7)"
                    }).invisible(),
                        ($wrap = $this.create(".wrap")).size("100%").css({
                            overflow: "hidden"
                        })
                }(),
                function initText() {
                    (_text = _this.initClass(UILinksItemText, _data, "#fff", [$wrap])).element.css({
                        left: -15
                    }),
                        _this.text = _text
                }(),
                function initOver() {
                    ($solid = $wrap.create(".solid")).size("100%").bg("#fff").css({
                        top: "-100%",
                        opacity: 1
                    }).transform({
                        y: 2 * _data.height
                    }),
                        (_over = _this.initClass(UILinksItemText, _data, "#000", [$wrap])).hidden = !0,
                        _over.element.css({
                            opacity: 0,
                            left: -15
                        })
                }(),
                function addListeners() {
                    $this.interact(hover, click, "#", _data.text)
                }(),
                this.animateIn = function() {
                    $this.visible(),
                        _text.glitch(),
                        $this.css({
                            opacity: 0
                        }).tween({
                            opacity: 1
                        }, 300, "easeOutSine")
                }
                ,
                this.animateOut = function() {
                    $this.tween({
                        opacity: 0
                    }, 300, "easeOutSine", (function() {
                            $this.invisible()
                        }
                    ))
                }
        }
    )),
    Class((function UIPreOrder() {
            Inherit(this, Element);
            const _this = this;
            var $this, $wrapper, $image, _close;
            function resize() {
                let wide = Device.mobile.phone;
                _this.wide = wide,
                    _this.width = wide ? 325.8 : 243,
                    _this.height = wide ? 99 : 327,
                    _this.width = Math.round(_this.width),
                    _this.height = Math.round(_this.height);
                let top = wide ? Stage.width > Stage.height ? 60 : 70 : Stage.height - _this.height - Config.OFFSET - (Global.IS_TOUR ? -10 : 40)
                    , left = wide ? Stage.width > Stage.height ? Stage.width - _this.width - Config.OFFSET : Stage.width / 2 - _this.width / 2 : Stage.width - _this.width - Config.OFFSET;
                wide ? (_this.width,
                    _this.height) : _this.width,
                    wide ? _this.height : (_this.height,
                        _this.width);
                $this.size(_this.width, _this.height).css({
                    top: top,
                    left: left
                }),
                    $image.size(_this.width, _this.height).bg(wide ? Data.GLOBAL.promoImageMobile : Data.GLOBAL.promoImage),
                    _close.element.css({
                        top: wide ? _this.height + 1 : -41
                    })
            }
            function hover(e) {
                switch (e.action) {
                    case "over":
                        $image.tween({
                            opacity: .8
                        }, 200, "easeOutSine");
                        break;
                    case "out":
                        $image.tween({
                            opacity: 1
                        }, 600, "easeOutSine")
                }
            }
            function click() {
                open(Data.GLOBAL.promoLink || "http://nurturelive.com/")
            }
            function close() {
                Storage.set("closedPreOrder", !0),
                    _this.animateOut()
            }
            function changeLevel() {
                !Global.LOAD_TOUR || Device.mobile.phone ? _this.animateOut() : Global.LOAD_TOUR = !1
            }
            !function initHTML() {
                ($this = _this.element).hide().setZ(1e3),
                    Stage.add($this),
                    ($wrapper = $this.create(".wrapper")).size("100%").css({
                        overflow: "hidden"
                    }),
                    $wrapper.inner = $wrapper.create(".wrapper"),
                    $wrapper.inner.size("100%").bg("#fff")
            }(),
                function initImage() {
                    ($image = $wrapper.inner.create(".image")).size("100%").bg().css({
                        boxShadow: "0 5px 20px rgba(0,0,0,0.3)"
                    })
                }(),
                function initClose() {
                    _close = _this.initClass(UIClose, {
                        text: "x",
                        width: 40,
                        height: 40,
                        fontSize: 18
                    })
                }(),
                function addHandlers() {
                    _this.events.sub(Events.RESIZE, resize),
                        _this.events.sub(_close, Events.CLICK, close),
                        _this.events.sub(LevelController.CHANGE_SCENE, changeLevel),
                        $image.interact(hover, click)
                }(),
                resize(),
            _this.isPlayground() && _this.delayedCall((_=>{
                    _this.animateIn()
                }
            ), 500),
                this.animateIn = async function(delay=0) {}
                ,
                this.animateOut = function() {
                    _this.isVisible && (_this.isVisible = !1,
                        _close.animateOut(),
                        $this.tween({
                            opacity: 0,
                            y: _this.wide ? -10 : 10
                        }, 600, "easeOutCubic", (_=>{
                                $this.hide()
                            }
                        )))
                }
        }
    ), "singleton"),
    Class((function UIPreOrderText({size: size, text: text, serif: serif, letterSpacing: letterSpacing}) {
            Inherit(this, Element);
            const _this = this;
            var $this, $text;
            !function initHTML() {
                ($this = _this.element).size("100%", size).css({
                    marginTop: 10,
                    width: "100%",
                    textAlign: "center",
                    display: "block",
                    position: "relative"
                }),
                    ($text = $this.create(".text")).fontStyle(serif ? Config.FONTS.serif : Config.FONTS.sansSerif, size, "#000"),
                    $text.css({
                        lineHeight: size,
                        width: "100%",
                        fontWeight: 300,
                        letterSpacing: letterSpacing,
                        textAlign: "center",
                        display: "block",
                        position: "relative"
                    }),
                    $text.text(text)
            }()
        }
    )),
    Class((function UITopGradient() {
            Inherit(this, Element);
            const _this = this
                , $this = this.element;
            function animateIn() {
                $this.tween({
                    opacity: 1
                }, 2e3, "easeOutSine", 4e3)
            }
            function animateOut(d=0) {
                $this.tween({
                    opacity: 0
                }, 300, "easeOutSine", 0)
            }
            function resize() {}
            Stage.add($this),
                function initHTML() {
                    $this.css({
                        position: "fixed",
                        top: 0,
                        left: 0,
                        width: "100%",
                        height: Device.mobile ? 100 : 150,
                        opacity: 0,
                        background: "linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.7) 50%)",
                        zIndex: 10,
                        pointerEvents: "none"
                    })
                }(),
                function addListeners() {
                    _this.onResize(resize),
                        _this.events.sub(UIOverlay.SHOWN, animateIn),
                        _this.events.sub(UIOverlay.HIDDEN, animateOut)
                }()
        }
    )),
    Class((function UITutorial() {
            Inherit(this, Element);
            const _this = this
                , $this = this.element;
            var $container, $keyboard, $grab, $jump, $joystick;
            function resize() {
                Device.mobile && ($this.css({
                    height: Stage.height
                }),
                    Stage.width > Stage.height ? $container.css({
                        bottom: 50
                    }) : $container.css({
                        bottom: 150
                    }))
            }
            !async function() {
                Stage.add($this),
                    await async function initHTML() {
                        $this.css({
                            display: "flex",
                            justifyContent: "center",
                            position: "fixed",
                            width: "100%",
                            height: "100vh",
                            zIndex: 10,
                            opacity: .9,
                            pointerEvents: "none",
                            color: "white"
                        }),
                            $this.hide(),
                            ($container = $this.create("UITutorial-container")).css({
                                display: "flex",
                                position: "absolute",
                                justifyContent: "center",
                                alignItems: "center",
                                width: "100%",
                                bottom: Config.OFFSET + 50
                            }),
                            _this.onResize(resize),
                            Device.mobile ? await async function initMobile() {
                                let step = {
                                    position: "relative"
                                }
                                    , icon = {
                                    position: "relative",
                                    display: "flex",
                                    justifyContent: "center",
                                    marginBottom: 20,
                                    opacity: 0
                                }
                                    , text = {
                                    position: "relative",
                                    color: "white",
                                    fontFamily: Config.FONTS.sansSerif,
                                    fontSize: 11,
                                    letterSpacing: "0.1em",
                                    textTransform: "uppercase",
                                    width: 200,
                                    textAlign: "center",
                                    lineHeight: "1.8",
                                    opacity: 0
                                };
                                ($joystick = $container.create("UITutorial-step")).container = $joystick.create("UITutorial-joystickC"),
                                    $joystick.border = $joystick.container.create("UITutorial-joystickBorder"),
                                    $joystick.cursor = $joystick.border.create("UITutorial-joystickCursor"),
                                    $joystick.container.css({
                                        position: "relative",
                                        width: 30,
                                        height: 30,
                                        margin: "0 auto 20px auto"
                                    }),
                                    $joystick.border.css({
                                        position: "absolute",
                                        display: "flex",
                                        alignItems: "center",
                                        justifyContent: "center",
                                        width: "80%",
                                        height: "80%",
                                        border: "1px solid white",
                                        borderRadius: "50%",
                                        top: "50%",
                                        left: "50%",
                                        boxShadow: "0 0 2px #dedede"
                                    }).transform({
                                        x: "-50%",
                                        y: "-50%"
                                    }),
                                    $joystick.cursor.css({
                                        position: "relative",
                                        width: "calc(100% - 2px)",
                                        height: "calc(100% - 2px)",
                                        borderRadius: "50%",
                                        border: "2px solid white",
                                        opacity: 0,
                                        borderColor: "white transparent transparent transparent"
                                    }),
                                    $joystick.text = $joystick.create("UITutorial-stepText"),
                                    $joystick.text.html("Drag the bottom left<br>joystick circle to move"),
                                    $joystick.css(step),
                                    $joystick.text.css(text),
                                    $joystick.hide(),
                                    ($grab = $container.create("UITutorial-step")).icon = $grab.create("UITutorial-stepIcon"),
                                    $grab.text = $grab.create("UITutorial-stepText"),
                                    $grab.text.html("Drag the screen<br>to look around");
                                let svgStr = await get("assets/images/icons/finger.svg");
                                $grab.icon.html(svgStr),
                                    $grab.svg = $($grab.div.querySelector("svg")),
                                    $grab.svg.css({
                                        position: "relative",
                                        height: 35,
                                        margin: "auto"
                                    }),
                                    $grab.css(step),
                                    $grab.icon.css(icon),
                                    $grab.icon.css({
                                        marginLeft: 50
                                    }),
                                    $grab.text.css(text),
                                    $grab.hide(),
                                    ($jump = $container.create("UITutorial-step")).icon = $jump.create("UITutorial-stepIcon"),
                                    $jump.text = $jump.create("UITutorial-stepText"),
                                    $jump.text.html("Double tap to jump"),
                                    svgStr = await get("assets/images/icons/finger.svg"),
                                    $jump.icon.html(svgStr),
                                    $jump.svg = $($jump.div.querySelector("svg")),
                                    $jump.svg.css({
                                        position: "relative",
                                        height: 35,
                                        margin: "auto"
                                    }),
                                    $jump.css(step),
                                    $jump.icon.css(icon),
                                    $jump.icon.css({
                                        marginLeft: 50
                                    }),
                                    $jump.text.css(text),
                                    $jump.hide(),
                                    resize()
                            }() : await async function initDesktop() {
                                let step = {
                                    position: "relative"
                                }
                                    , icon = {
                                    position: "relative",
                                    display: "flex",
                                    justifyContent: "center",
                                    marginBottom: 20,
                                    opacity: 0
                                }
                                    , text = {
                                    position: "relative",
                                    color: "white",
                                    fontFamily: Config.FONTS.sansSerif,
                                    fontSize: 9,
                                    letterSpacing: "0.2em",
                                    textTransform: "uppercase",
                                    width: 250,
                                    textAlign: "center",
                                    lineHeight: "1.8",
                                    opacity: 0
                                };
                                ($keyboard = $container.create("UITutorial-step")).icon = $keyboard.create("UITutorial-stepIcon"),
                                    $keyboard.text = $keyboard.create("UITutorial-stepText"),
                                    $keyboard.text.html("Use [WASD] or arrows on your keyboard to move around"),
                                    $keyboard.css(step),
                                    $keyboard.icon.css(icon),
                                    $keyboard.text.css(text),
                                    $keyboard.hide();
                                let svgStr = await get("assets/images/icons/keyboard.svg");
                                $keyboard.icon.html(svgStr),
                                    $keyboard.svg = $($keyboard.div.querySelector("svg")),
                                    $keyboard.svg.css({
                                        position: "relative",
                                        height: 75,
                                        margin: "auto"
                                    });
                                let g = $keyboard.svg.div.querySelectorAll("g");
                                $keyboard.keys = [];
                                for (let i = 0, l = g.length; i < l; i++)
                                    $keyboard.keys.push($(g[i]));
                                ($grab = $container.create("UITutorial-step")).icon = $grab.create("UITutorial-stepIcon"),
                                    $grab.text = $grab.create("UITutorial-stepText"),
                                    $grab.text.html("Drag with your mouse<br>to look around"),
                                    $grab.css(step),
                                    $grab.icon.css(icon),
                                    $grab.text.css(text),
                                    $grab.hide(),
                                    svgStr = await get("assets/images/icons/grab.svg"),
                                    $grab.icon.html(svgStr),
                                    $grab.svg = $($grab.div.querySelector("svg")),
                                    $grab.svg.css({
                                        position: "relative",
                                        height: 35,
                                        margin: "auto"
                                    }),
                                    ($jump = $container.create("UITutorial-step")).icon = $jump.create("UITutorial-stepIcon"),
                                    $jump.text = $jump.create("UITutorial-stepText"),
                                    $jump.text.html("Press space to jump"),
                                    $jump.css(step),
                                    $jump.icon.css(icon),
                                    $jump.icon.space = $jump.icon.create("UITutorial-space"),
                                    $jump.icon.space.css({
                                        position: "relative",
                                        width: 100,
                                        height: 20,
                                        borderRadius: 5,
                                        border: "1px solid white"
                                    }),
                                    $jump.text.css(text),
                                    $jump.hide()
                            }()
                    }(),
                    Container.SHOW_INSTRUCTIONS.then((_=>{
                            Device.mobile ? async function animateInMobile() {
                                Global.IN_TOUR || Global.LOAD_EUROPE || await _this.wait(3e3);
                                $this.show(),
                                    $joystick.show(),
                                    $joystick.container.transform({
                                        y: 20
                                    }).tween({
                                        y: 0,
                                        opacity: .4
                                    }, 1500, "easeOutCubic"),
                                    await $joystick.text.transform({
                                        y: 20
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1500, "easeOutCubic", 300).promise(),
                                    $joystick.cursor.tween({
                                        opacity: 1,
                                        rotation: -35
                                    }, 350, "easeOutExpo"),
                                    await $joystick.container.tween({
                                        opacity: .8,
                                        scale: 1.3,
                                        x: -30,
                                        y: -20
                                    }, 1e3, "easeOutCubic").promise(),
                                    $joystick.cursor.tween({
                                        opacity: 1,
                                        rotation: 135
                                    }, 350, "easeOutExpo"),
                                    await $joystick.container.tween({
                                        opacity: .8,
                                        scale: 1.3,
                                        x: 30,
                                        y: 5
                                    }, 1e3, "easeOutCubic").promise(),
                                    $joystick.cursor.tween({
                                        opacity: 1,
                                        rotation: -90
                                    }, 350, "easeOutExpo"),
                                    await $joystick.container.tween({
                                        opacity: .8,
                                        scale: 1.3,
                                        x: -35,
                                        y: 0
                                    }, 1e3, "easeOutCubic").promise(),
                                    $joystick.cursor.tween({
                                        opacity: 0
                                    }, 1e3, "easeOutCubic"),
                                    await $joystick.container.tween({
                                        opacity: .4,
                                        scale: 1,
                                        x: 0,
                                        y: 0,
                                        rotation: 0
                                    }, 1e3, "easeOutCubic").promise(),
                                    await $joystick.tween({
                                        opacity: 0
                                    }, 1e3, "easeOutCubic").promise(),
                                    $joystick.hide(),
                                    $grab.show(),
                                    $grab.icon.transform({
                                        y: 20
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1500, "easeOutCubic"),
                                    $grab.text.transform({
                                        y: 20
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1500, "easeOutCubic", 300),
                                    await _this.wait(2e3),
                                    $grab.icon.tween({
                                        x: 20,
                                        rotation: 10
                                    }, 500, "easeOutCubic"),
                                    await _this.wait(480),
                                    $grab.icon.tween({
                                        x: -20,
                                        rotation: -10
                                    }, 700, "easeOutCubic"),
                                    await _this.wait(700),
                                    $grab.icon.tween({
                                        x: 0,
                                        y: -10,
                                        rotation: 0
                                    }, 400, "easeOutCubic"),
                                    await _this.wait(400),
                                    $grab.icon.tween({
                                        x: 0,
                                        y: 0,
                                        rotation: 0,
                                        opacity: 0
                                    }, 400, "easeOutCubic"),
                                    await $grab.tween({
                                        opacity: 0
                                    }, 1e3, "easeOutCubic", 600).promise(),
                                    $grab.hide(),
                                    $jump.show(),
                                    $jump.icon.transform({
                                        y: 20
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1500, "easeOutCubic"),
                                    $jump.text.transform({
                                        y: 20
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1500, "easeOutCubic", 300),
                                    await _this.wait(2e3),
                                    await $jump.icon.tween({
                                        scale: .8,
                                        opacity: .8,
                                        rotation: -3
                                    }, 200, "easeOutCubic").promise(),
                                    await $jump.icon.tween({
                                        scale: 1,
                                        opacity: 1,
                                        rotation: 0
                                    }, 100, "easeOutCubic").promise(),
                                    await $jump.icon.tween({
                                        scale: .8,
                                        opacity: .8,
                                        rotation: -5
                                    }, 200, "easeOutCubic").promise(),
                                    await $jump.icon.tween({
                                        scale: 1,
                                        opacity: 1,
                                        rotation: 0
                                    }, 100, "easeOutCubic").promise(),
                                    await _this.wait(480),
                                    await $jump.icon.tween({
                                        scale: .8,
                                        opacity: .8,
                                        rotation: -2
                                    }, 200, "easeOutCubic").promise(),
                                    await $jump.icon.tween({
                                        scale: 1,
                                        opacity: 1,
                                        rotation: 0
                                    }, 100, "easeOutCubic").promise(),
                                    await $jump.icon.tween({
                                        scale: .8,
                                        opacity: .8,
                                        rotation: -4
                                    }, 200, "easeOutCubic").promise(),
                                    await $jump.icon.tween({
                                        scale: 1,
                                        opacity: 1,
                                        rotation: 0
                                    }, 100, "easeOutCubic").promise(),
                                    await _this.wait(1e3),
                                    await $jump.icon.tween({
                                        opacity: 0
                                    }, 600, "easeOutCubic"),
                                    await $jump.tween({
                                        opacity: 0
                                    }, 1e3, "easeOutCubic", 600).promise(),
                                    $jump.hide(),
                                    $this.hide()
                            }() : async function animateIn() {
                                Global.IN_TOUR || Global.LOAD_EUROPE || await _this.wait(4e3);
                                Storage.set("seen_tutorial", !0),
                                    VFX.instance().toggleInstructions(!0),
                                    $this.show(),
                                    $keyboard.show(),
                                    $keyboard.icon.transform({
                                        y: 40
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1200, "easeOutCubic"),
                                    $keyboard.text.transform({
                                        y: 40
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1200, "easeOutCubic", 300),
                                    await _this.wait(1e3),
                                    $keyboard.keys.forEach(((key,i)=>{
                                            key.tween({
                                                opacity: .3
                                            }, 800, "easeInOutCubic", 250 * i).onComplete((()=>{
                                                    key.tween({
                                                        opacity: 1
                                                    }, 800, "easeInOutCubic").onComplete((()=>{
                                                            key.tween({
                                                                opacity: .3
                                                            }, 800, "easeInOutCubic").onComplete((()=>{
                                                                    key.tween({
                                                                        opacity: 1
                                                                    }, 800, "easeInOutCubic")
                                                                }
                                                            ))
                                                        }
                                                    ))
                                                }
                                            ))
                                        }
                                    )),
                                    await _this.wait(4e3),
                                    await $keyboard.tween({
                                        opacity: 0
                                    }, 800, "easeOutSine").promise(),
                                    $keyboard.hide(),
                                    $grab.show(),
                                    $grab.icon.transform({
                                        y: 40
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1200, "easeOutCubic"),
                                    $grab.text.transform({
                                        y: 40
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1200, "easeOutCubic", 300),
                                    await _this.wait(1500),
                                    $grab.icon.tween({
                                        x: -80,
                                        rotation: -10
                                    }, 800, "easeInOutCubic"),
                                    await _this.wait(800),
                                    $grab.icon.tween({
                                        x: 80,
                                        rotation: 10
                                    }, 1100, "easeInOutCubic"),
                                    await _this.wait(1100),
                                    $grab.icon.tween({
                                        x: 0,
                                        y: -20,
                                        rotation: 0
                                    }, 400, "easeOutCubic"),
                                    await _this.wait(400),
                                    $grab.icon.tween({
                                        x: 0,
                                        y: 0,
                                        rotation: 0,
                                        opacity: 0
                                    }, 400, "easeOutCubic"),
                                    await _this.wait(400),
                                    VFX.instance().toggleInstructions(),
                                    await $grab.tween({
                                        opacity: 0
                                    }, 700, "easeOutSine").promise(),
                                    $grab.hide(),
                                    $jump.show(),
                                    $jump.icon.transform({
                                        y: 50
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1500, "easeOutCubic"),
                                    await $jump.text.transform({
                                        y: 50
                                    }).tween({
                                        y: 0,
                                        opacity: 1
                                    }, 1500, "easeOutCubic", 300).promise(),
                                    await $jump.icon.tween({
                                        scale: .9,
                                        opacity: .75
                                    }, 200, "easeOutSine").promise(),
                                    await $jump.icon.tween({
                                        scale: 1,
                                        opacity: 1
                                    }, 300, "easeOutSine").promise(),
                                    await $jump.icon.tween({
                                        scale: .9,
                                        opacity: .75
                                    }, 200, "easeOutSine", 500).promise(),
                                    await $jump.icon.tween({
                                        scale: 1,
                                        opacity: 1
                                    }, 300, "easeOutSine").promise(),
                                    await $jump.tween({
                                        opacity: 0
                                    }, 700, "easeOutSine").promise(),
                                    $jump.hide(),
                                    $this.hide()
                            }()
                        }
                    ))
            }()
        }
    )),
    Class((function Main() {
            Inherit(this, Component);
            var _this = this;
            function resize() {
                Device.mobile && (clearTimeout(_this.throttle),
                    _this.throttle = _this.delayedCall((()=>{
                            Date.now() - _this.last > 200 && forceStage(),
                                _this.last = Date.now(),
                                window.innerWidth < window.innerHeight ? (document.body.style.height = `${window.innerHeight}px`,
                                    Stage.css({
                                        height: window.innerHeight
                                    })) : (document.body.style.height = "100%",
                                    Stage.css({
                                        height: "100%"
                                    }))
                        }
                    ), 100))
            }
            !async function() {
                if (await Data.ready(),
                    Utils.query("performance"))
                    return Performance.displayResults();
                !function init() {
                    if (Config.TEASER_PRE)
                        return void Teaser.instance();
                    if (Config.TEASER)
                        return void EP.instance();
                    if (Config.GUITAR)
                        return void Guitar.instance();
                    if (Tests.showFallback())
                        return void Fallback.instance();
                    if (GLUI.init(),
                    window.location.search.includes("p=") && Hydra.LOCAL)
                        return Hydra.LOCAL = !0,
                            AssetLoader.loadAssets(Assets.list().filter(["data", "shaders"])).then((()=>{
                                    Playground.instance()
                                }
                            ));
                    Container.instance()
                }(),
                    _this.last = Date.now(),
                    _this.events.sub(Events.RESIZE, resize),
                    _this.events.sub(Events.FULLSCREEN, (_=>_this.delayedCall(resize, 500))),
                Device.mobile && ($("html").css({
                    overflow: "visible"
                }),
                    $("body").css({
                        overflow: "visible"
                    }),
                    Stage.css({
                        overflow: "visible"
                    }))
            }()
        }
    ));
window._MINIFIED_ = true;
window._BUILT_ = true;
